<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 20:41:34 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pp_wget__define.pro (OMINAS Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pp_wget__define.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
    <span class="comments">;+</span>
    <span class="comments">; :Author: Paulo Penteado (`http://www.ppenteado.net &lt;http://www.ppenteado.net>`)</span>
    <span class="comments">;-</span>
    <span class="comments">;+</span>
    <span class="comments">; :Description:</span>
    <span class="comments">; </span>
    <span class="comments">;    This class is used to provide functionality similar to the UNIX wget</span>
    <span class="comments">;    or IDL's wget (introduced in IDL 8.5). The main differences relative</span>
    <span class="comments">;    to IDL's wget is that timestamps of the downloaded files are set to match</span>
    <span class="comments">;    the timestamps informed by the server, and the optional arguments, to control</span>
    <span class="comments">;    things such as overwriting of existing files, recursivenes and regular expression</span>
    <span class="comments">;    matching. </span>
    <span class="comments">;    </span>
    <span class="comments">;</span>
    <span class="comments">; :Params:</span>
    <span class="comments">;    baseurl: in, required</span>
    <span class="comments">;    The root URL to be downloaded. If this is a directory (ends with /), all</span>
    <span class="comments">;    files found inside it will be downloaded. If it does not end with /, just</span>
    <span class="comments">;    that one file will be downloaded.</span>
    <span class="comments">;</span>
    <span class="comments">; :Keywords:</span>
    <span class="comments">;    clobber: in, optional, default=0</span>
    <span class="comments">;      If set to 0 (default), exisiting files with the same timestamp as that</span>
    <span class="comments">;      returned by the server will be skipped. If set to 1, files will be downloaded, </span>
    <span class="comments">;      even if overwriting existing local files. If set to 2, existing files will</span>
    <span class="comments">;      be skipped, without checking the timestamp. Setting this argument to 1</span>
    <span class="comments">;      is useful to resume an interrupted download of a directory.</span>
    <span class="comments">;    pattern: in, optional</span>
    <span class="comments">;      A string with a regular expression that file names in the server will be</span>
    <span class="comments">;      matched to. If provided, only those files matching this expression will be</span>
    <span class="comments">;      downloaded.</span>
    <span class="comments">;    recursive: in, optional, default=0</span>
    <span class="comments">;      If set and baseurl is a directory, all directories contained inside it</span>
    <span class="comments">;      will be recursively downloaded.</span>
    <span class="comments">;    localdir: in, optional, default='./'</span>
    <span class="comments">;      Local directory where the downloaded files are to be stored. Defaults to the</span>
    <span class="comments">;      current directory.</span>
    <span class="comments">;    debug: in, optional, default=0</span>
    <span class="comments">;    timestamps: in, optional</span>
    <span class="comments">;      If provided, a hash (empty or not) where the timestamps of the downloaded</span>
    <span class="comments">;      files will be stored. Such a hash is always created internally and can be</span>
    <span class="comments">;      retrieved as a property (called timestamps). The reason to provide a hash</span>
    <span class="comments">;      is to have the timestamps be appended to this hash, instead of having a new</span>
    <span class="comments">;      hash created. </span>
    <span class="comments">;    bdir: in, optional</span>
    <span class="comments">;      For internal use by recursive calls only.</span>
    <span class="comments">;    xpattern: in, optional</span>
    <span class="comments">;      A string with a regular expression that file names in the server will be</span>
    <span class="comments">;      matched to. If provided, only those files NOT matching this expression will be</span>
    <span class="comments">;      downloaded.</span>
    <span class="comments">;    absolute_paths: in, optional, default=0</span>
    <span class="comments">;      If set, the timestamps hash will contain absolute paths instead of relative paths. </span>
    <span class="comments">;</span>
    <span class="comments">; :Author: Paulo Penteado (`http://www.ppenteado.net &lt;http://www.ppenteado.net>`)</span>
    <span class="comments">;-</span>
<a id="pp_wget::init:source"></a>function pp_wget::init,baseurl,clobber=clobber,pattern=pattern,$
recursive=recursive,localdir=localdir,debug=debug,timestamps=timestamps,$
bdir=bdir,xpattern=xpattern,absolute_paths=absolute,_ref_extra=e,$
ssl_certificate_file=sslf,splitrows=splitrows,allow_slash=allow_slash,$
lm=lm,tz=tz,quiet=quiet,ftpw=ftpw,mdonly=mdonly
compile_opt idl2,logical_predicate,hidden

self.clobber=keyword_set(clobber)
self.localdir=n_elements(localdir) ? localdir : '.'
self.baseurl=baseurl
self.recursive=keyword_set(recursive)
self.timestamps=isa(timestamps,'hash') ? timestamps : hash()
ldir=file_expand_path(self.localdir)
self.debug=keyword_set(debug)
self.bdir=n_elements(bdir) ? bdir : ''
self.ldir=ldir+path_sep()
self.pattern=n_elements(pattern) ? pattern : ''
self.xpattern=n_elements(xpattern) ? xpattern : ''
self.absolute=keyword_set(absolute)
<span class="comments">;self.sslf=n_elements(sslf) ? file_search(sslf) : (file_search(filepath('',subdir='bin')+'*/ca-bundle.crt'))[0]</span>
if n_elements(sslf) then self.sslf=file_search(sslf) else begin
  if (!version.release ge '8.4') then self.sslf=(file_search(filepath('',subdir='bin')+'*/ca-bundle.crt'))[0] else begin
     ft=file_dirname((file_which('pp_wget__define.pro'))[0],/mark_directory)+'ca-bundle.crt'
     self.sslf=file_test(ft,/read) ? ft : (file_search(filepath('',subdir='bin')+'*/ca-bundle.crt'))[0]
   endelse
endelse
self.quiet=keyword_set(quiet)
if ~self.quiet then print,self.sslf
self.splitrows=keyword_set(splitrows)
self.allow_slash=keyword_set(allow_slash)
self.lm=keyword_set(lm)
self.tz=n_elements(tz) ? tz : 0d0
self.ftpw=n_elements(ftpw) ? ftpw :  (!version.release lt '8.4')
self.mdonly=n_elements(mdonly) ? mdonly : 0B
<span class="comments">;if n_elements(e) then self.extra=ptr_new(e)</span>

return,1
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Internal function, inteded to be used by pp_wget::geturl.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (`http://www.ppenteado.net &lt;http://www.ppenteado.net>`)</span>
<span class="comments">;-</span>
<a id="pp_wget_callback:source"></a>function pp_wget_callback,StatusInfo,ProgressInfo,CallbackData
compile_opt idl2,logical_predicate
if callbackdata.debug then print,statusinfo
w=where(stregex(statusinfo,'Verbose:[[:blank:]]+Header In:[[:blank:]]+Content-Length:',/bool),count)
if count then begin
  tmp=stregex(statusinfo[w[0]],'Content-Length:[[:blank:]]*([[:digit:]]+)',/subexpr,/extract)
  callbackdata.content_length=long64(tmp[1])
  if ~callbackdata.quiet then print,'Content Length: ',pp_readablesize(tmp[1],/string)
  if callbackdata.mdonly eq 1 then begin
    print,'Skipping download'
    callbackdata.mdata={size:long64(tmp[1])}
    return,0
  endif
endif
w=where(stregex(statusinfo,'Verbose:[[:blank:]]+Header In:[[:blank:]]+Last-Modified:',/bool),count)
if count then begin
  olm=callbackdata.last_modified
  sinfom=stregex(statusinfo[w[0]],'Last-Modified:[[:blank:]]+(.*)',/subexpr,/extract)
  callbackdata.last_modified=sinfom[1]
  if (~callbackdata.clobber) && callbackdata.local_file_exists then begin
    tml=callbackdata.local_file_tm
    tmr=sinfom[1]
    tmrj=pp_parse_date(tmr)
    tmlj=julday(1,1,1970)-0.5d0+tml/86400d0
    if olm then begin <span class="comments">;if server provided a timestamp with directory listing</span>
      tdiff=pp_parse_date(olm)-tmrj
      if (tdiff le 1d0) then begin
        tz=round(tdiff*1440d0) <span class="comments">;offset as integer minutes</span>
        tz=15*round(tz/15) <span class="comments">;offset in precision of 1/4h (the smallest time zone difference)</span>
        callbackdata.tz=tz/1440d0
        callbackdata.hlm=olm
      endif
    endif
    <span class="comments">;if (abs(tmrj-tmlj) lt 1d0/86400d0) then begin</span>
    if (abs(tmrj-tmlj) lt 1d0/1440d0) then begin
      print,'This file is already present locally with same timestamp. Skipping'
      return,0
    endif else print,'dif: ',tmrj-tmlj
  endif
endif
return,1
end

<a id="pp_wget::setproperty:source"></a>pro pp_wget::setproperty,last_modified=last_modified,content_length=content_length,$
  tz=tz,hlm=hlm,quiet=quiet,mdata=mdata
compile_opt idl2,logical_predicate
if n_elements(last_modified) then self.last_modified=last_modified
if n_elements(content_length) then self.content_length=content_length
if n_elements(tz) then self.tz=tz
if n_elements(hlm) then self.hlm=hlm
if n_elements(mdata) then self.mdata=ptr_new(mdata)
<span class="comments">;if n_elements(ex) then self.idlneturl::setproperty,_strict_extra=ex</span>
end

<a id="pp_wget::getproperty:source"></a>pro pp_wget::getproperty,local_file_tm=local_file_tm,clobber=clobber,$
  debug=debug,content_length=content_length,local_file_exists=local_file_exists,$
  timestamps=timestamps,last_modified=last_modified,tz=tz,hlm=hlm,quiet=quiet,$
  mdonly=mdonly,mdata=mdata
compile_opt idl2,logical_predicate
if arg_present(local_file_tm) then local_file_tm=self.local_file_tm
if arg_present(clobber) then clobber=self.clobber
if arg_present(debug) then debug=self.debug
if arg_present(local_file_exists) then local_file_exists=self.local_file_exists
if arg_present(timestamps) then timestamps=self.timestamps
if arg_present(last_modified) then last_modified=self.last_modified
if arg_present(tz) then tz=self.tz
if arg_present(hlm) then hlm=self.hlm
<span class="comments">;if n_elements(ex) then self.idlneturl::setproperty,_strict_extra=ex</span>
if arg_present(quiet) then quiet=self.quiet
if arg_present(mdonly) then mdonly=self.mdonly
if arg_present(mdata) then mdata=*self.mdata
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Starts the download of the URL set when the object was instantiated.</span>
<span class="comments">;    </span>
<span class="comments">; :Examples:</span>
<span class="comments">; </span>
<span class="comments">;    Download all files at ,skipping exisiting files, recursively::</span>
<span class="comments">;    </span>
<span class="comments">;      </span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (`http://www.ppenteado.net &lt;http://www.ppenteado.net>`)</span>
<span class="comments">;-</span>
<a id="pp_wget::geturl:source"></a>pro pp_wget::geturl,listonly=listonly
compile_opt idl2,logical_predicate

if ~file_test(self.ldir,/directory) then begin
  if file_test(self.ldir,/regular) then begin
    if ~self.quiet then print,'directory ',self.ldir,' exists as a file. Deleting the file to replace it with directory'
    file_delete,self.ldir,/verbose
  endif
  print,'Creating directory ',self.ldir
  file_mkdir,self.ldir
endif


pu=parse_url(self.baseurl)
if (strlowcase(pu.scheme) eq 'ftp') && (self.ftpw) then begin
 self.iu=pp_ftp(url=self.baseurl,verbose=~self.quiet,debug=self.debug,callback_data=self,$
 callback_function='pp_wget_callback')
endif else begin
 if ptr_valid(self.extra) then begin
  self.iu=idlneturl(url_host=pu.host,url_scheme=pu.scheme,url_port=pu.port,url_path=pu.path,$
    url_query=pu.query,/verbose,callback_function='pp_wget_callback',callback_data=self,$
    ftp_connection_mode=0,_strict_extra=*self.extra,ssl_certificate_file=self.sslf)
 endif else begin
  self.iu=idlneturl(url_host=pu.host,url_scheme=pu.scheme,url_port=pu.port,url_path=pu.path,$
    url_query=pu.query,/verbose,callback_function='pp_wget_callback',callback_data=self,$
    ftp_connection_mode=0,ssl_certificate_file=self.sslf)    
 endelse
endelse

if strmatch(self.baseurl,'*/') then begin <span class="comments">;if url is a directory</span>
  if strlowcase(pu.scheme) eq 'ftp' then begin
    <span class="comments">;ind=!version.release gt '8.3' ? self.iu.getftpdirlist() : pp_jget(self.baseurl)</span>
    ind=self.iu.getftpdirlist()
    inds=(strsplit(ind,/extract)).toarray()
    links=inds[*,-1]
    lm=inds[*,-4]+' '+inds[*,-3]+' '+inds[*,-2]
    if arg_present(listonly) then begin
      listonly=links
      return
    endif
    foreach link,links,il do begin
      self.retrieve,link,lm=lm[il],/skip_missing
    endforeach
  endif else begin
    ind=self.iu.get(/string_array)
    if self.splitrows then begin
      indtmp=strsplit(ind,'&lt;/tr>',/extract,/regex,count=count)
      foreach c,count,ic do if (c gt 0) then indtmp[ic]+='&lt;/tr>'
      indtmp=indtmp.toarray(dim=1)
      ind=indtmp
    endif
    indj=strjoin(ind,' ')
    tmp=strtrim(((stregex(indj,'&lt;title>(.+)&lt;/title>',/extract,/subexpr))[1]),2)
    if stregex(tmp,'^index of ',/fold_case,/bool) then begin
      <span class="comments">;w=where(stregex(ind,'&lt;a[[:blank:]]+href[[:blank:]]*="[^"]+"[^>]*>',/bool))</span>
      w=where(stregex(ind,'&lt;a[^>]*[[:blank:]]+href[[:blank:]]*="[^"]+"[^>]*>',/bool))
      indl=ind[w]<span class="comments">;lines with links</span>
      <span class="comments">;links=reform((stregex(indl,'&lt;a[[:blank:]]+href[[:blank:]]*="([^"]+)"[^>]*>',/extract,/subexpr))[1,*])</span>
<span class="comments">;      links=(stregex(indl,'&lt;a[^>]*[[:blank:]]+href[[:blank:]]*="([^"]+)"[^>]*>',/extract,/subexpr))</span>
      <span class="comments">;links=(stregex(indl,'&lt;a[^>]*[[:blank:]]+href[[:blank:]]*="([^"]+)"[^>]*>.*&lt;td[^>]*>[[:blank:]]*([[:alnum:] :-]{10,17})[[:blank:]]*&lt;/td>',/extract,/subexpr))     re1='&lt;a[^>]*[[:blank:]]+href[[:blank:]]*="([^"]+)"[^>]*>.*&lt;td[^>]*>[[:blank:]]*([[:alnum:] :-]{10,17})[[:blank:]]*&lt;/td>'</span>
      re1='&lt;a[^>]*[[:blank:]]+href[[:blank:]]*="([^"]+)"[^>]*>.*&lt;td[^>]*>[[:blank:]]*([[:alnum:] :-]{10,17})[[:blank:]]*&lt;/td>'
      links=stregex(indl,re1,/boolean)
      if total(links,/integer) eq 0 then begin
        re2='&lt;a[^>]*[[:blank:]]+href[[:blank:]]*="([^"]+)"[^>]*>.*&lt;td[^>]*>[[:blank:]]*([[:alnum:] :-]{10,19})[[:blank:]]*&lt;/td>'
        links=stregex(indl,re2,/extract,/subexpr)
        lms=reform(links[2,*])
        links=reform(links[1,*])
      endif else begin
        links=stregex(indl,re1,/extract,/subexpr)
        lms=reform(links[2,*])
        links=reform(links[1,*])
      endelse
      if total(strlen(strtrim(lms,2)),/integer) eq 0 then begin
        links=(stregex(indl,'\[(DIR)?[[:blank:]]*\][[:blank:]]*&lt;a[^>]*[[:blank:]]+href[[:blank:]]*="([^"]+)"[^>]*>([^&lt;]*)&lt;/a>(&lt;td[^>]*>)?[[:blank:]]*([[:alnum:] :-]{10,17})[[:blank:]]*(&lt;/td>)?',/extract,/subexpr))
        lms=reform(links[5,*])
        w=where(strtrim(links[1,*],2) eq 'DIR',wc)
        if wc then begin
          ww=where(~strmatch(links[3,*],'*/'),wwc)
        endif else wwc=0
        links=reform(links[3,*])
        if wwc then links[w[ww]]+='/'
      endif
      wla=where(stregex(links,'^(\/|\?)',/bool),/null,count,complement=wlac)
      if ~self.allow_slash then begin
        links=links[wlac]
        lms=lms[wlac]
      endif else begin
        w=wla
        if count then begin
          <span class="comments">;links[w]=strmid(links[w],1)</span>
          lw=stregex(links[w],'^/'+pu.path+'(.*)',/extract,/subexpr)
          links[w]=lw[1,*]
          <span class="comments">;print,count</span>
        endif
        wf=where(strlen(strtrim(links,2)),/null)
        links=links[wf]
        lms=lms[wf]
      endelse
      if arg_present(listonly) then begin
        listonly=links
        return
      endif
      foreach link,links,il do begin
        if self.lm then self.retrieve,link,/skip_missing,lm=lms[il] $
          else self.retrieve,link,/skip_missing
      endforeach
    endif
  endelse
endif else begin
  <span class="comments">;link=file_basename(pu.path)</span>
  <span class="comments">;self.iu.setproperty,url_path=(stregex(pu.path,'(.*)'+link+'$',/extract,/subexpr))[1]</span>
  self.retrieve,''
endelse

end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Internal function, inteded to be used by pp_wget::geturl.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (`http://www.ppenteado.net &lt;http://www.ppenteado.net>`)</span>
<span class="comments">;-</span>
<a id="pp_wget::retrieve:source"></a>pro pp_wget::retrieve,link,lm=lm,skip_missing=skip_missing
compile_opt idl2,logical_predicate,hidden
self.hlm=''
if ~strmatch(link,'*/') then begin <span class="comments">;if entry is not a directory</span>
  self.iu.getproperty,url_scheme=us,url_port=po,url_path=up
  pu=parse_url(self.baseurl)
  if (us eq 'https') && ~(stregex(self.baseurl,'https://[^/]+:[[:digit:]]+',/bool)) then po='443'
  <span class="comments">;if (pu.scheme eq 'https') && ~(stregex(self.baseurl,'https://[^/]+:[[:digit:]]+',/bool)) then pu.port='443'</span>
  <span class="comments">;self.iu.setproperty,url_path=up+link,url_port=po</span>
  self.iu.setproperty,url_path=pu.path+link,url_port=po
  if self.pattern && ~stregex(link,self.pattern,/bool) then begin
    if ~self.quiet then print,'skipping '+link+' because it does not match the specified pattern: '+self.pattern
    return
  endif
  if self.xpattern && stregex(link,self.xpattern,/bool) then begin
    if ~self.quiet then print,'skipping '+link+' because it matches the specified xpattern: '+self.xpattern
    return
  endif
  ds=((self.bdir ? (self.bdir+'/') : '')+link)
  if ~ds then ds=self.baseurl
  print,'downloading '+ds
  self.last_modified=n_elements(lm) ? lm : ''
  self.hlm=self.last_modified
  self.content_length=0LL
  fi=file_info(self.ldir+link)
  if (fi.exists && self.clobber eq 2) then begin
    print,'skipping '+link+' because it already exists.'
    return
  endif
  if ~self.clobber then begin
    if fi.exists then begin
      self.local_file_exists=1
      self.local_file_tm=fi.mtime
    endif else begin
      self.local_file_exists=0
      self.local_file_tm=0
    endelse
  endif
  setts=1
  
    catch,err
    if err then begin
      catch,/cancel
      if (err ne -1005) && (err ne -1006) && (~strmatch(!error_state.msg,'*Cancel request detected*',/fold_case)) then begin
        if keyword_set(skip_missing) && (strmatch(!error_state.msg,'*Failed to open file*',/fold_case) || (err eq -1052)) then begin
          return
        endif
        print,'error downloading file ',link,': ',err,' ',!error_state.msg
        return
      endif else setts=0
    endif else begin
      ng=0B
      if self.last_modified then begin
        if (~self.clobber) && self.local_file_exists then begin
          tml=self.local_file_tm
          tmrj=pp_parse_date(self.last_modified)
          if (self.last_modified eq self.hlm) then tmrj-=self.tz
          tmlj=julday(1,1,1970)-0.5d0+tml/86400d0
          <span class="comments">;if (abs(tmrj-tmlj) lt 1d0/86400d0) then begin</span>
          <span class="comments">;if (abs(tmrj-tmlj) lt 1d0/1440d0) then begin</span>
          <span class="comments">;for test from server directory listing, test must be more lax, as servers may not inform time zone, so their time might shift by 1h during the year</span>
          if (abs(tmrj-tmlj) le 1d0/24d0+1d0/1440d0) then begin
            if ~self.quiet then print,'This file is already present locally with same timestamp. Skipping.'
            setts=0B
            ng=1B
          endif <span class="comments">;else print,'diff: ',tmrj-tmlj</span>
        endif
      endif
      if ~ng then begin
        fn=link ? link : file_basename(pu.path)
        self.hlm=self.last_modified
        g=self.iu.get(filename=self.ldir+fn)
        nlm=self.last_modified
      endif
    endelse
  
  <span class="comments">;Set the timestamp</span>
  if self.last_modified then begin
    if n_elements(lm) then tm=self.last_modified else begin
      tm=stregex(self.last_modified,'Last-Modified:[[:blank:]]+(.*)',/subexpr,/extract)
      tm=tm[1]
    endelse
    if tm then begin
      tmrj=pp_parse_date(tm)
      if (self.last_modified eq self.hlm) then tmrj-=self.tz
      if setts then begin
        if ~strmatch(!version.os_family,'*win*',/fold) then begin <span class="comments">;linux-like systems</span>
          caldat,tmrj,mon,day,yr,h,m,s
          tmstr=string(yr,mon,day,h,m,s,format='(I04,I02,I02,I02,I02,".",I02)')
          smon=(['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'])[mon-1]
          tmstr=string(day,smon,yr,h,m,s,format='(I02," ",A3," ",I04," ",I02,":",I02,":",I02," GMT")')
          <span class="comments">;print, 'touch -d "'+tmstr+'" '+self.ldir+link</span>
          <span class="comments">;spawn,'touch -d "'+tmstr+'" '+self.ldir+link</span>
          tmstr=string(yr,mon,day,h,m,s,format='(I04,I02,I02,I02,I02,".",I02)')
          <span class="comments">;print, 'TZ=UTC touch -t "'+tmstr+'" '+self.ldir+link</span>
          spawn, 'TZ=UTC touch -t "'+tmstr+'" '+self.ldir+link
        endif else begin <span class="comments">;Windows systems</span>
          spawn,'powershell -WindowStyle Hidden "$(Get-Item '+self.ldir+link+').lastwritetime=$(Get-Date '+"'"+tm+"'"+')"',/noshell
        endelse
      endif
      tsf=self.absolute ? file_expand_path(self.ldir+link) : self.bdir+link
      (self.timestamps)[tsf]=tmrj
    endif
  endif
endif else begin
  if self.recursive then begin <span class="comments">; if entry is a directory</span>
    if ~self.quiet then print,'Entering directory ',link
    iw=pp_wget(self.baseurl+'/'+link,$
      timestamps=self.timestamps,clobber=self.clobber,pattern=self.pattern,$
      recursive=self.recursive,localdir=self.localdir+path_sep()+link+path_sep(),$
      bdir=self.bdir ? self.bdir+'/'+link : link,xpattern=self.xpattern,absolute=self.absolute,$
      ssl_certificate_file=self.sslf,splitrows=self.splitrows,allow_slash=self.allow_slash,$
      lm=self.lm,quiet=self.quiet,ftpw=self.ftpw,mdonly=self.mdonly)
    iw.geturl
    if ~self.quiet then print,'Done with directory ',link
  endif else if ~self.quiet then print,'Recursive mode not set, skipping directory ',link
endelse
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Type definition for pp_wget. See the documentation on `pp_wget::init`.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (`http://www.ppenteado.net &lt;http://www.ppenteado.net>`)</span>
<span class="comments">;-</span>
<a id="pp_wget__define:source"></a>pro pp_wget__define
compile_opt idl2,logical_predicate
!null={pp_wget, inherits idl_object, clobber:0,recursive:0,$
  ldir:'',pattern:'',localdir:'',last_modified:'',local_file_exists:0,local_file_tm:0LL,$
  baseurl:'',iu:obj_new(),timestamps:obj_new(),debug:0,content_length:0LL,bdir:'',$
  xpattern:'',absolute:0,extra:ptr_new(),sslf:'',splitrows:0B,allow_slash:0B,lm:0B,$
  tz:0d0,hlm:'',quiet:0B,ftpw:0B,mdonly:0B,mdata:ptr_new()}
end
</code>
    </div>
  </body>
</html>