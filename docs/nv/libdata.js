/* Index used for searching */
/*
   Fields used:
     url, name, type, filename, authors, routine name, comments, parameters,
     categories, and attributes
*/
title = "OMINAS Documentation";
subtitle = "Generated by IDLdoc";
libdata = new Array();
libdataItem = 0;



libdata[libdataItem++] = new Array("obj/bod/_bod_aberration_mask.html", "_bod_aberration_mask.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "_bod_aberration_mask.pro", "", "", " NAME: 	_bod_aberration_mask    PURPOSE: 	Returns a bitmask for an aberration.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	mask = _bod_aberration_mask(_bx, name)    ARGUMENTS:   INPUT: NONE 	name:	 Name of aberration.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Aberration mask associated with the given name for each given body 	structure.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/_bod_aberration_mask.html#_bod_aberration_mask", "_bod_aberration_mask", 'routine in <a href="obj/bod/_bod_aberration_mask.html">_bod_aberration_mask.pro</a>', "_bod_aberration_mask.pro", "", "_bod_aberration_mask", "", "name", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/_cor_gd.html", "_cor_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "_cor_gd.pro", "", "", " NAME: 	_cor_gd    PURPOSE: 	Retrieves the generic descriptor from a CORE structure.  The generic 	descriptor is stored in a protected structure that prevents its contents 	from being freed by nv_free, while still allowing its references to 	be copied by nv_clone.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	gd = _cor_gd(_crd)    ARGUMENTS:   INPUT: 	_crd:		CORE structure.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	_cor_set_gd     MODIFICATION HISTORY:  	Written by:	Spitale		3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/_cor_gd.html#_cor_gd", "_cor_gd", 'routine in <a href="obj/cor/_cor_gd.html">_cor_gd.pro</a>', "_cor_gd.pro", "", "_cor_gd", "", "_xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/_cor_set_gd.html", "_cor_set_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "_cor_set_gd.pro", "", "", " NAME: 	_cor_set_gd    PURPOSE: 	Sets the generic descriptor in a CORE structure.  The generic 	descriptor is stored in a protected structure that prevents its contents 	from being freed by nv_free, while still allowing its references to 	be copied by nv_clone.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	_cor_set_gd, _crd, gd    ARGUMENTS:   INPUT: 	_crd:		CORE structure.  	gd:		New gd.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	_cor_gd     MODIFICATION HISTORY:  	Written by:	Spitale		3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/_cor_set_gd.html#_cor_set_gd", "_cor_set_gd", 'routine in <a href="obj/cor/_cor_set_gd.html">_cor_set_gd.pro</a>', "_cor_set_gd.pro", "", "_cor_set_gd", "", "_xdgd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/_cor_test_udata.html", "_cor_test_udata.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "_cor_test_udata.pro", "", "", " NAME: 	_cor_test_udata    PURPOSE: 	Tests the existence of data stored in a structure under the 	specified name.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	data = _cor_test_udata(_crd, name)    ARGUMENTS:   INPUT: 	_crd:	 Any subclass of CORE.  Only one structure may be provided.  	name:	 Name associated with the data to test.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	True if the data is stored under the given name, false otherwise.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/_cor_test_udata.html#_cor_test_udata", "_cor_test_udata", 'routine in <a href="obj/cor/_cor_test_udata.html">_cor_test_udata.pro</a>', "_cor_test_udata.pro", "", "_cor_test_udata", "", "_crdname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/_dat_compress_data.html", "_dat_compress_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "_dat_compress_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/_dat_compress_data.html#_dat_compress_data", "_dat_compress_data", 'routine in <a href="obj/dat/_dat_compress_data.html">_dat_compress_data.pro</a>', "_dat_compress_data.pro", "", "_dat_compress_data", "", "cdatacabscissa_dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/_dat_compute_size.html", "_dat_compute_size.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "_dat_compute_size.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/_dat_compute_size.html#_dat_compute_size", "_dat_compute_size", 'routine in <a href="obj/dat/_dat_compute_size.html">_dat_compute_size.pro</a>', "_dat_compute_size.pro", "", "_dat_compute_size", "", "_ddsamples", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/_dat_uncompress_data.html", "_dat_uncompress_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "_dat_uncompress_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/_dat_uncompress_data.html#_dat_uncompress_data", "_dat_uncompress_data", 'routine in <a href="obj/dat/_dat_uncompress_data.html">_dat_uncompress_data.pro</a>', "_dat_uncompress_data.pro", "", "_dat_uncompress_data", "", "cdatacabscissa_dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/_glb_get_surface_normal_body.html", "_glb_get_surface_normal_body.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "_glb_get_surface_normal_body.pro", "", "", " NAME: 	_glb_get_surface_normal_body    PURPOSE: 	Computes the surface normals of a GLOBE object at the given 	body-frame positions.  This is an internal routine.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	n = _glb_get_surface_normalbody(_gbd, r)    ARGUMENTS:   INPUT: 	_gbd:	Array (nt) of GLOBE structures.  	r:	Array (nv,3) of surface positions in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: 	nonorm:	If set, the returned vectors are not normalized.    OUTPUT: NONE    RETURN: 	Array (nv, 3, nt) of surface unit normals in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/_glb_get_surface_normal_body.html#_glb_get_surface_normal_body", "_glb_get_surface_normal_body", 'routine in <a href="obj/glb/_glb_get_surface_normal_body.html">_glb_get_surface_normal_body.pro</a>', "_glb_get_surface_normal_body.pro", "", "_glb_get_surface_normal_body", "", "nonorm_gbdr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/_map_apply_pole.html", "_map_apply_pole.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "_map_apply_pole.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/_map_apply_pole.html#_map_apply_pole", "_map_apply_pole", 'routine in <a href="obj/map/_map_apply_pole.html">_map_apply_pole.pro</a>', "_map_apply_pole.pro", "", "_map_apply_pole", "", "inverse_mdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/_map_lookup_transformations.html", "_map_lookup_transformations.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "_map_lookup_transformations.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/_map_lookup_transformations.html#_map_lookup_transformations", "_map_lookup_transformations", 'routine in <a href="obj/map/_map_lookup_transformations.html">_map_lookup_transformations.pro</a>', "_map_lookup_transformations.pro", "", "_map_lookup_transformations", "", "_mdfn_map_to_imagefn_image_to_map", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/_map_valid_points.html", "_map_valid_points.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "_map_valid_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/_map_valid_points.html#_map_valid_points", "_map_valid_points", 'routine in <a href="obj/map/_map_valid_points.html">_map_valid_points.pro</a>', "_map_valid_points.pro", "", "_map_valid_points", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/_map_valid_points_mercator.html", "_map_valid_points_mercator.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "_map_valid_points_mercator.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/_map_valid_points_mercator.html#_map_valid_points_mercator", "_map_valid_points_mercator", 'routine in <a href="obj/map/_map_valid_points_mercator.html">_map_valid_points_mercator.pro</a>', "_map_valid_points_mercator.pro", "", "_map_valid_points_mercator", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/_map_valid_points_mollweide.html", "_map_valid_points_mollweide.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "_map_valid_points_mollweide.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/_map_valid_points_mollweide.html#_map_valid_points_mollweide", "_map_valid_points_mollweide", 'routine in <a href="obj/map/_map_valid_points_mollweide.html">_map_valid_points_mollweide.pro</a>', "_map_valid_points_mollweide.pro", "", "_map_valid_points_mollweide", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/_map_valid_points_orthographic.html", "_map_valid_points_orthographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "_map_valid_points_orthographic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/_map_valid_points_orthographic.html#_map_valid_points_orthographic", "_map_valid_points_orthographic", 'routine in <a href="obj/map/_map_valid_points_orthographic.html">_map_valid_points_orthographic.pro</a>', "_map_valid_points_orthographic.pro", "", "_map_valid_points_orthographic", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/_map_valid_points_orthographic_disk.html", "_map_valid_points_orthographic_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "_map_valid_points_orthographic_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/_map_valid_points_orthographic_disk.html#_map_valid_points_orthographic_disk", "_map_valid_points_orthographic_disk", 'routine in <a href="obj/map/_map_valid_points_orthographic_disk.html">_map_valid_points_orthographic_disk.pro</a>', "_map_valid_points_orthographic_disk.pro", "", "_map_valid_points_orthographic_disk", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/_map_valid_points_rectangular.html", "_map_valid_points_rectangular.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "_map_valid_points_rectangular.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/_map_valid_points_rectangular.html#_map_valid_points_rectangular", "_map_valid_points_rectangular", 'routine in <a href="obj/map/_map_valid_points_rectangular.html">_map_valid_points_rectangular.pro</a>', "_map_valid_points_rectangular.pro", "", "_map_valid_points_rectangular", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/_map_valid_points_rectangular_disk.html", "_map_valid_points_rectangular_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "_map_valid_points_rectangular_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/_map_valid_points_rectangular_disk.html#_map_valid_points_rectangular_disk", "_map_valid_points_rectangular_disk", 'routine in <a href="obj/map/_map_valid_points_rectangular_disk.html">_map_valid_points_rectangular_disk.pro</a>', "_map_valid_points_rectangular_disk.pro", "", "_map_valid_points_rectangular_disk", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/_map_valid_points_sinusoidal.html", "_map_valid_points_sinusoidal.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "_map_valid_points_sinusoidal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/_map_valid_points_sinusoidal.html#_map_valid_points_sinusoidal", "_map_valid_points_sinusoidal", 'routine in <a href="obj/map/_map_valid_points_sinusoidal.html">_map_valid_points_sinusoidal.pro</a>', "_map_valid_points_sinusoidal.pro", "", "_map_valid_points_sinusoidal", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/_map_valid_points_stereographic.html", "_map_valid_points_stereographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "_map_valid_points_stereographic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/_map_valid_points_stereographic.html#_map_valid_points_stereographic", "_map_valid_points_stereographic", 'routine in <a href="obj/map/_map_valid_points_stereographic.html">_map_valid_points_stereographic.pro</a>', "_map_valid_points_stereographic.pro", "", "_map_valid_points_stereographic", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/_map_wrap_points.html", "_map_wrap_points.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "_map_wrap_points.pro", "", "", " NAME: 	_map_wrap_points    PURPOSE: 	Forces all map image points to lie inside a specified map by wrapping 	longitudes.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	wrap_image_pts = map_wrap_points(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2,nv,nt) of wrapped map image points.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/_map_wrap_points.html#_map_wrap_points", "_map_wrap_points", 'routine in <a href="obj/map/_map_wrap_points.html">_map_wrap_points.pro</a>', "_map_wrap_points.pro", "", "_map_wrap_points", "", "_md_image_pts_map_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/_map_wrap_points.html#__map_wrap_points", "__map_wrap_points", 'routine in <a href="obj/map/_map_wrap_points.html">_map_wrap_points.pro</a>', "_map_wrap_points.pro", "", "__map_wrap_points", "", "_md_image_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/_map_wrap_points.html#_map_wrap_points", "_map_wrap_points", 'routine in <a href="obj/map/_map_wrap_points.html">_map_wrap_points.pro</a>', "_map_wrap_points.pro", "", "_map_wrap_points", "", "_md_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/_pnt_resize.html", "_pnt_resize.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "_pnt_resize.pro", "", "", " NAME: 	_pnt_resize    PURPOSE: 	Resizes a POINT structure.  Arrays are padded with zeroes or truncated 	as needed.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_resize, _ptd, nv=nv, nt=nt    ARGUMENTS:   INPUT: 	_ptd:		POINT struct.  Note this is an actual POINT structure 			rather than an object, as this routine is only 			meant to be called internally.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nv.nt:		New nv, nt.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete;    MODIFICATION HISTORY:  	Written by:	Spitale		12/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/_pnt_resize.html#_pnt_resize", "_pnt_resize", 'routine in <a href="obj/pnt/_pnt_resize.html">_pnt_resize.pro</a>', "_pnt_resize.pro", "", "_pnt_resize", "", "nvnt_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/abcorr.html", "abcorr.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "abcorr.pro", "", "", " NAME:        abcorr    PURPOSE: 	Performs stellar aberration and light-travel-time corrections.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        abcorr, obs_bx, targ_bx, c=c    ARGUMENTS:   INPUT: 	obs_bx:	  Any subclass of BODY describing the observer.  	targ_bx:  Array(nt) of any subclass of BODY describing the targets.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	c:		Speed of light.  	iterate:	If set, then the lt correction routine will iterate 			to refine its solution.  	epsilon:	Stopping criterion for the lt correction: maximum 			allowable timing error.  Default is 1d-7.    OUTPUT: NONE    RETURN: NONE     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/abcorr.html#abcorr", "abcorr", 'routine in <a href="obj/tools/abcorr.html">abcorr.pro</a>', "abcorr.pro", "", "abcorr", "", "citerateepsilonfastinvertobs_bxtarg_bx", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/abcorr.html#abcorr", "abcorr", 'routine in <a href="obj/tools/abcorr.html">abcorr.pro</a>', "abcorr.pro", "", "abcorr", "", "citerateepsilonfastobs_bxtarg_bx0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_assign.html", "arr_assign.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_assign.pro", "", "", " NAME: 	arr_assign    PURPOSE: 	Replaces fields in a ARRAY object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/ARR    CALLING SEQUENCE: 	arr_assign, ard, <keywords>=<values>    ARGUMENTS:   INPUT: 	ard:		ARRAY object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	ARRAY fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	arr_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_assign.html#arr_assign", "arr_assign", 'routine in <a href="obj/arr/arr_assign.html">arr_assign.pro</a>', "arr_assign.pro", "", "arr_assign", "", "noeventxd@arr__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_create_descriptors.html", "arr_create_descriptors.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_create_descriptors.pro", "", "", " NAME:        arr_create_descriptors    PURPOSE: 	Init method for the ARRAY class.    CATEGORY:        NV/LIB/arr    CALLING SEQUENCE:        ard = arr_create_descriptors(n)    ARGUMENTS:   INPUT:        n:      Number of array descriptors.    OUTPUT:        NONE    KEYWORDS:   INPUT: 	ard:	Station descriptor(s) to initialize, instead of creating new 		ones.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	primary:	Array (n) of primary strings.    OUTPUT: NONE   RETURN:        An array (n) of array descriptors.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_create_descriptors.html#arr_create_descriptors", "arr_create_descriptors", 'routine in <a href="obj/arr/arr_create_descriptors.html">arr_create_descriptors.pro</a>', "arr_create_descriptors.pro", "", "arr_create_descriptors", "", "crdardn@arr__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_primary.html", "arr_primary.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_primary.pro", "", "", " NAME: 	arr_primary    PURPOSE: 	Returns the primary descriptor for each given array descriptor.    CATEGORY: 	NV/LIB/arr    CALLING SEQUENCE: 	primary = arr_primary(ard)    ARGUMENTS:   INPUT: 	ard:	 Array (nt) of ARRAY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Primary descriptors associated with each given array descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_primary.html#arr_primary", "arr_primary", 'routine in <a href="obj/arr/arr_primary.html">arr_primary.pro</a>', "arr_primary.pro", "", "arr_primary", "", "noeventard", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_query.html", "arr_query.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_query.pro", "", "", " NAME: 	arr_query    PURPOSE: 	Returns the fields associated with a ARRAY object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/ARR    CALLING SEQUENCE: 	arr_query, ard, <keywords>=<values>    ARGUMENTS:   INPUT: 	ard:	ARRAY object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	ARRAY object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_query.html#arr_query", "arr_query", 'routine in <a href="obj/arr/arr_query.html">arr_query.pro</a>', "arr_query.pro", "", "arr_query", "", "conditioncatnoeventxd@arr__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_replicate.html", "arr_replicate.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_replicate.pro", "", "", " NAME: 	arr_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/arr    CALLING SEQUENCE: 	ards = str_replicate(ard, dim)    ARGUMENTS:   INPUT: 	ard:	 Station descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_replicate.html#arr_replicate", "arr_replicate", 'routine in <a href="obj/arr/arr_replicate.html">arr_replicate.pro</a>', "arr_replicate.pro", "", "arr_replicate", "", "arddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_set_primary.html", "arr_set_primary.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_set_primary.pro", "", "", " NAME: 	arr_set_primary    PURPOSE: 	Replaces the primary string in each given array descriptor.    CATEGORY: 	NV/LIB/arr    CALLING SEQUENCE: 	arr_set_primary, ard, primary    ARGUMENTS:   INPUT: 	ard:	Array (nt) of ARRAY descriptors.  	primary:	Array (nt) of primary descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_set_primary.html#arr_set_primary", "arr_set_primary", 'routine in <a href="obj/arr/arr_set_primary.html">arr_set_primary.pro</a>', "arr_set_primary.pro", "", "arr_set_primary", "", "noeventardprimary", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_set_surface_pts.html", "arr_set_surface_pts.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_set_surface_pts.pro", "", "", " NAME: 	arr_set_surface_pts    PURPOSE: 	Replaces the surface_pts vector in each given array descriptor.    CATEGORY: 	NV/LIB/arr    CALLING SEQUENCE: 	arr_set_surface_pts, ard, surface_pts    ARGUMENTS:   INPUT: 	ard:		Array (nt) of ARRAY descriptors.  	surface_pts:	Array (nv,3,nt) of surface_pts vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_set_surface_pts.html#arr_set_surface_pts", "arr_set_surface_pts", 'routine in <a href="obj/arr/arr_set_surface_pts.html">arr_set_surface_pts.pro</a>', "arr_set_surface_pts.pro", "", "arr_set_surface_pts", "", "noeventardsurface_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_surface_pts.html", "arr_surface_pts.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_surface_pts.pro", "", "", " NAME: 	arr_surface_pts    PURPOSE: 	Returns the surface_pts vector for each given array descriptor.    CATEGORY: 	NV/LIB/arr    CALLING SEQUENCE: 	surface_pts = arr_surface_pts(ard)    ARGUMENTS:   INPUT: 	ard:	 Array (nt) of ARRAY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of surface_pts vectors associated with each given 	array descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_surface_pts.html#arr_surface_pts", "arr_surface_pts", 'routine in <a href="obj/arr/arr_surface_pts.html">arr_surface_pts.pro</a>', "arr_surface_pts.pro", "", "arr_surface_pts", "", "noeventard", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/best_radial_scale_feat.html", "best_radial_scale_feat.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "best_radial_scale_feat.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/best_radial_scale_feat.html#best_radial_scale_feat", "best_radial_scale_feat", 'routine in <a href="obj/tools/best_radial_scale_feat.html">best_radial_scale_feat.pro</a>', "best_radial_scale_feat.pro", "", "best_radial_scale_feat", "", "radminradmaxlonminlonmaxpp_minpp_maxpp0resperpcdrdpd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_aberration.html", "bod_aberration.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_aberration.pro", "", "", " NAME: 	bod_aberration    PURPOSE: 	Returns the aberration flags for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	ab = bod_aberration(bx, name)    ARGUMENTS:   INPUT: NONE 	bx:	 Any subclass of BODY.  	name:	 Name of aberration to return.  If not given, the full 		 aberration value is returned.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Aberration flag associated with the given name for each given body 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_aberration.html#bod_aberration", "bod_aberration", 'routine in <a href="obj/bod/bod_aberration.html">bod_aberration.pro</a>', "bod_aberration.pro", "", "bod_aberration", "", "noeventbdname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_assign.html", "bod_assign.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_assign.pro", "", "", " NAME: 	bod_assign    PURPOSE: 	Replaces fields in a BODY object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/BOD    CALLING SEQUENCE: 	bod_assign, bd, <keywords>=<values>    ARGUMENTS:   INPUT: 	bd:		BODY object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	BODY fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	bod_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_assign.html#bod_assign", "bod_assign", 'routine in <a href="obj/bod/bod_assign.html">bod_assign.pro</a>', "bod_assign.pro", "", "bod_assign", "", "noeventxd@bod__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_avel.html", "bod_avel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_avel.pro", "", "", " NAME: 	bod_avel    PURPOSE: 	Returns the angular velocity for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	avel = bod_avel(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Angular velocity value associated with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_avel.html#bod_avel", "bod_avel", 'routine in <a href="obj/bod/bod_avel.html">bod_avel.pro</a>', "bod_avel.pro", "", "bod_avel", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial.html", "bod_body_to_inertial.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_inertial.pro", "", "", " NAME: 	bod_body_to_inertial    PURPOSE: 	Transforms the given column vectors from the body coordinate 	system to the inertial coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	inertial_pts = bod_body_to_inertial(bx, body_pts)    ARGUMENTS:   INPUT: 	bx:	 	Any subclass of BODY.  	body_pts:	Array (nv,3,nt) of column vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of column vectors in the bx inertial frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial.html#bod_body_to_inertial", "bod_body_to_inertial", 'routine in <a href="obj/bod/bod_body_to_inertial.html">bod_body_to_inertial.pro</a>', "bod_body_to_inertial.pro", "", "bod_body_to_inertial", "", "_subbdv", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial.html#bod_body_to_inertial", "bod_body_to_inertial", 'routine in <a href="obj/bod/bod_body_to_inertial.html">bod_body_to_inertial.pro</a>', "bod_body_to_inertial.pro", "", "bod_body_to_inertial", "", "_subbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_default.html", "bod_body_to_inertial_default.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_inertial_default.pro", "", "", " NAME: 	bod_body_to_inertial_default    PURPOSE: 	Transforms the given column vectors from the body coordinate 	system to the inertial coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	inertial_pts = bod_body_to_inertial_default(bx, body_pts)    ARGUMENTS:   INPUT: 	bx:	 	Any subclass of BODY.  	body_pts:	Array (nv,3,nt) of column vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of column vectors in the bx inertial frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_default.html#bod_body_to_inertial_default", "bod_body_to_inertial_default", 'routine in <a href="obj/bod/bod_body_to_inertial_default.html">bod_body_to_inertial_default.pro</a>', "bod_body_to_inertial_default.pro", "", "bod_body_to_inertial_default", "", "_subbdvp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_pos.html", "bod_body_to_inertial_pos.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_inertial_pos.pro", "", "", " NAME: 	bod_body_to_inertial_pos    PURPOSE:        Transforms the given column position vectors from the body        coordinate system to the inertial coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	inertial_pts = bod_body_to_inertial(bx, body_pts)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	body_pts:	Array (nv,3,nt) of column POSITION vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column position vectors in the inertial        frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_pos.html#bod_body_to_inertial_pos", "bod_body_to_inertial_pos", 'routine in <a href="obj/bod/bod_body_to_inertial_pos.html">bod_body_to_inertial_pos.pro</a>', "bod_body_to_inertial_pos.pro", "", "bod_body_to_inertial_pos", "", "bdv", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_pos.html#__bod_body_to_inertial_pos", "__bod_body_to_inertial_pos", 'routine in <a href="obj/bod/bod_body_to_inertial_pos.html">bod_body_to_inertial_pos.pro</a>', "bod_body_to_inertial_pos.pro", "", "__bod_body_to_inertial_pos", "", "bdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_vel.html", "bod_body_to_inertial_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_inertial_vel.pro", "", "", " NAME: 	bod_body_to_inertial_vel    PURPOSE:        Transforms the given column velocity vectors from the body        coordinate system to the inertial coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	inertial_vel = bod_body_to_inertial_vel(bx, body_vel)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	body_vel:	Array (nv,3,nt) of column velocity vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column velocity vectors in the inertial        frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_vel.html#bod_body_to_inertial_vel", "bod_body_to_inertial_vel", 'routine in <a href="obj/bod/bod_body_to_inertial_vel.html">bod_body_to_inertial_vel.pro</a>', "bod_body_to_inertial_vel.pro", "", "bod_body_to_inertial_vel", "", "bdv", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_vel.html#bod_body_to_inertial_vel", "bod_body_to_inertial_vel", 'routine in <a href="obj/bod/bod_body_to_inertial_vel.html">bod_body_to_inertial_vel.pro</a>', "bod_body_to_inertial_vel.pro", "", "bod_body_to_inertial_vel", "", "bdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_radec.html", "bod_body_to_radec.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_radec.pro", "", "", " NAME: 	bod_body_to_radec    PURPOSE:        Transforms the given column vectors from the body coordinate        system to the RA/DEC coordinate system associated to that        body.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	radec_pts = bod_body_to_radec(bx, body_pts)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the bx radec frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_radec.html#bod_body_to_radec", "bod_body_to_radec", 'routine in <a href="obj/bod/bod_body_to_radec.html">bod_body_to_radec.pro</a>', "bod_body_to_radec.pro", "", "bod_body_to_radec", "", "bdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_radec_vel.html", "bod_body_to_radec_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_radec_vel.pro", "", "", " NAME: 	bod_body_to_radec_vel    PURPOSE:        Transforms the given column velocity vectors from the body coordinate        system to the RA/DEC coordinate system associated with that body.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	radec_pts = bod_body_to_radec_vel(bx, body_pts)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the bx radec frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_radec_vel.html#bod_body_to_radec_vel", "bod_body_to_radec_vel", 'routine in <a href="obj/bod/bod_body_to_radec_vel.html">bod_body_to_radec_vel.pro</a>', "bod_body_to_radec_vel.pro", "", "bod_body_to_radec_vel", "", "bdrv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_create_descriptors.html", "bod_create_descriptors.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_create_descriptors.pro", "", "", " NAME: 	bod_create_descriptors    PURPOSE: 	Init method for the BODY class.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bd = bod_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	Number of descriptors to create.    OUTPUT: NONE    KEYWORDS (in addition to those accepted by all superclasses):   INPUT: 	bd:	Body descriptor(s) to initialize, instead of creating a new one.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	time:	Array (n) of times, at body position, at which each descriptor 		is valid.  	opaque:	Array (n) of flags describing whether each body is  easily 		visible .  	orient:	Array (3,3,n) of orientation matrices, transforming body to 		inertial for each body.  	avel:	Array (ndv,3,n) of angular velocity vectors for each body.  	pos:	Array (ndv,3,n) of position vectors for each body.  	vel:	Array (ndv,3,n) of velocity vectors for each body.  	libv:	Array (ndv,3,n) of libration vectors for each body.  	lib:	Array (ndv,n) of libration phases for each body.  	dlibdt:	Array (ndv,n) of libration frequencies for each body.     OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized body descriptors, depending 	on the presence of the bd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_create_descriptors.html#bod_create_descriptors", "bod_create_descriptors", 'routine in <a href="obj/bod/bod_create_descriptors.html">bod_create_descriptors.pro</a>', "bod_create_descriptors.pro", "", "bod_create_descriptors", "", "crdbdn@bod__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_dlibdt.html", "bod_dlibdt.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_dlibdt.pro", "", "", " NAME: 	bod_dlibdt    PURPOSE:        Returns the frequency of each libration vector for each given        body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	dlibdt = bod_dlibdt(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN:        Values of the frequency of each libration vector associated        with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_dlibdt.html#bod_dlibdt", "bod_dlibdt", 'routine in <a href="obj/bod/bod_dlibdt.html">bod_dlibdt.pro</a>', "bod_dlibdt.pro", "", "bod_dlibdt", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_evolve.html", "bod_evolve.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_evolve.pro", "", "", " NAME: 	bod_evolve    PURPOSE: 	Computes new body descriptors at the given time offsets from the 	given body descriptors using the taylor series expansion 	corresponding to the derivatives contained in the given body 	descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bdt = bod_evolve(bx, dt)    ARGUMENTS:   INPUT: 	bx:	 Any subclass of BODY.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	If set, derivatives will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN: 	Array (nbd,ndt) of newly allocated descriptors, of class BODY, 	evolved by time dt, where nbd is the number of bx, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_evolve.html#bod_evolve", "bod_evolve", 'routine in <a href="obj/bod/bod_evolve.html">bod_evolve.pro</a>', "bod_evolve.pro", "", "bod_evolve", "", "nodvcopybddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_get_radec_ranges.html", "bod_get_radec_ranges.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_get_radec_ranges.pro", "", "", " NAME: 	bod_get_radec_ranges    PURPOSE: 	Returns ranges of valid  radec coordinates for the given BODY object.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	ranges = bod_get_radec_ranges(bx)    ARGUMENTS:   INPUT: 	bx:	 Any subclass of BODY.  One descriptor only.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (2 x 3) giving the ranges in radius, RA and DEC.    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_get_radec_ranges.html#bod_get_radec_ranges", "bod_get_radec_ranges", 'routine in <a href="obj/bod/bod_get_radec_ranges.html">bod_get_radec_ranges.pro</a>', "bod_get_radec_ranges.pro", "", "bod_get_radec_ranges", "", "bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_ib_data.html", "bod_ib_data.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_ib_data.pro", "", "", " NAME: 	bod_ib_data    PURPOSE: 	Returns the function data for a body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	data = bod_ib_data(bd)    ARGUMENTS:   INPUT: NONE 	bd:	 Body descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Function data associated with the given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Adapted by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_ib_data.html#bod_ib_data", "bod_ib_data", 'routine in <a href="obj/bod/bod_ib_data.html">bod_ib_data.pro</a>', "bod_ib_data.pro", "", "bod_ib_data", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial.html", "bod_inertial.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial.pro", "", "", " NAME: 	bod_inertial    PURPOSE: 	Returns body descriptors defining te inertial coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bd = bod_inertial()    ARGUMENTS:   INPUT: 	nt : number of desriptors to return.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Body descriptor defining the inertial frame.  Note this descriptor is 	not allocated on the heap, so it should not be freed by the caller.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_inertial.html#bod_inertial", "bod_inertial", 'routine in <a href="obj/bod/bod_inertial.html">bod_inertial.pro</a>', "bod_inertial.pro", "", "bod_inertial", "", "nt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body.html", "bod_inertial_to_body.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial_to_body.pro", "", "", " NAME: 	bod_inertial_to_body    PURPOSE: 	Transforms the given column vectors from the inertial coordinate 	system to the body coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	body_pts = bod_inertial_to_body(bx, inertial_pts)    ARGUMENTS:   INPUT: 	bx:	 	Any subclass of BODY.  	inertial_pts:	Array (nv,3,nt) of column vectors in the inertial frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of column vectors in the bx body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body.html#bod_inertial_to_body", "bod_inertial_to_body", 'routine in <a href="obj/bod/bod_inertial_to_body.html">bod_inertial_to_body.pro</a>', "bod_inertial_to_body.pro", "", "bod_inertial_to_body", "", "_subbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_default.html", "bod_inertial_to_body_default.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial_to_body_default.pro", "", "", " NAME: 	bod_inertial_to_body_default    PURPOSE: 	Transforms the given column vectors from the inertial coordinate 	system to the body coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	body_pts = bod_inertial_to_body_default(bx, inertial_pts)    ARGUMENTS:   INPUT: 	bx:	 	Any subclass of BODY.  	inertial_pts:	Array (nv,3,nt) of column vectors in the inertial frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of column vectors in the bx body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_default.html#bod_inertial_to_body_default", "bod_inertial_to_body_default", 'routine in <a href="obj/bod/bod_inertial_to_body_default.html">bod_inertial_to_body_default.pro</a>', "bod_inertial_to_body_default.pro", "", "bod_inertial_to_body_default", "", "_subbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_pos.html", "bod_inertial_to_body_pos.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial_to_body_pos.pro", "", "", " NAME: 	bod_inertial_to_body_pos    PURPOSE:        Transforms the given column position vectors from the inertial        coordinate system to the body coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	body_pts = bod_inertial_to_body_pos(bx, inertial_pts)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	inertial_pts:	Array (nv,3,nt) of column POSITION vectors in the inertial frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column position vectors in the bx body        frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_pos.html#bod_inertial_to_body_pos", "bod_inertial_to_body_pos", 'routine in <a href="obj/bod/bod_inertial_to_body_pos.html">bod_inertial_to_body_pos.pro</a>', "bod_inertial_to_body_pos.pro", "", "bod_inertial_to_body_pos", "", "bdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_vel.html", "bod_inertial_to_body_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial_to_body_vel.pro", "", "", " NAME: 	bod_inertial_to_body_vel    PURPOSE:        Transforms the given column velocity vectors from the inertial        coordinate system to the body coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	body_vel = bod_inertial_to_body_vel(bx, inertial_vel)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	inertial_vel:	Array (nv,3,nt) of column velocity vectors in the inertial frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column velocity vectors in the bx body        frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_vel.html#bod_inertial_to_body_vel", "bod_inertial_to_body_vel", 'routine in <a href="obj/bod/bod_inertial_to_body_vel.html">bod_inertial_to_body_vel.pro</a>', "bod_inertial_to_body_vel.pro", "", "bod_inertial_to_body_vel", "", "bdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_lib.html", "bod_lib.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_lib.pro", "", "", " NAME: 	bod_lib    PURPOSE:        Returns the phase of the libration vector at body time for        each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	lib = bod_lib(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN:        Phase of the libraton vectors at body time associated with        each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_lib.html#bod_lib", "bod_lib", 'routine in <a href="obj/bod/bod_lib.html">bod_lib.pro</a>', "bod_lib.pro", "", "bod_lib", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_libv.html", "bod_libv.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_libv.pro", "", "", " NAME: 	bod_libv    PURPOSE: 	Returns the libration vector for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	libv = bod_libv(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Libration vector associated with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_libv.html#bod_libv", "bod_libv", 'routine in <a href="obj/bod/bod_libv.html">bod_libv.pro</a>', "bod_libv.pro", "", "bod_libv", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_ndv.html", "bod_ndv.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_ndv.pro", "", "", " NAME: 	bod_ndv    PURPOSE: 	Returns an integer indicating the maximum number of time derivatives 	allowed in the vel and avel fields of the body descriptor.  This number 	can be adjusted using the environment variable 'BOD_NDV'.  The default 	is 4.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	ndv = bod_ndv()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    ENVIRONMENT VARIABLES: 	BOD_NDV:	Sets the ndv value.    RETURN: 	Current ndv value.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_ndv.html#bod_ndv", "bod_ndv", 'routine in <a href="obj/bod/bod_ndv.html">bod_ndv.pro</a>', "bod_ndv.pro", "", "bod_ndv", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_opaque.html", "bod_opaque.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_opaque.pro", "", "", " NAME: 	bod_opaque    PURPOSE: 	Returns the opaque value for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	opaque = bod_opaque(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Opaque value associated with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_opaque.html#bod_opaque", "bod_opaque", 'routine in <a href="obj/bod/bod_opaque.html">bod_opaque.pro</a>', "bod_opaque.pro", "", "bod_opaque", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_orient.html", "bod_orient.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_orient.pro", "", "", " NAME: 	bod_orient    PURPOSE: 	Returns the orientation matrix for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	orient = bod_orient(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Orientation matrix associated with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_orient.html#bod_orient", "bod_orient", 'routine in <a href="obj/bod/bod_orient.html">bod_orient.pro</a>', "bod_orient.pro", "", "bod_orient", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_pos.html", "bod_pos.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_pos.pro", "", "", " NAME: 	bod_pos    PURPOSE:        Returns the position of body center (in the inertial frame)        for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	pos = bod_pos(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN:        Position of body center (in the inertial frame) associated        with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_pos.html#bod_pos", "bod_pos", 'routine in <a href="obj/bod/bod_pos.html">bod_pos.pro</a>', "bod_pos.pro", "", "bod_pos", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_query.html", "bod_query.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_query.pro", "", "", " NAME: 	bod_query    PURPOSE: 	Returns the fields associated with a BODY object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/BOD    CALLING SEQUENCE: 	bod_query, bd, <keywords>=<values>    ARGUMENTS:   INPUT: 	bd:	BODY object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	BODY object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_query.html#bod_query", "bod_query", 'routine in <a href="obj/bod/bod_query.html">bod_query.pro</a>', "bod_query.pro", "", "bod_query", "", "conditioncatnoeventxd@bod__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_radec_to_body.html", "bod_radec_to_body.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_radec_to_body.pro", "", "", " NAME: 	bod_radec_to_body    PURPOSE: 	Transforms the given column vectors from the RA/DEC coordinate        system associated to the body to the body coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	body_pts = bod_radec_to_body(bx, radec_pts)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	radec_pts:	Array (nv,3,nt) of column vectors in the bx radec frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of column vectors in the bx body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_radec_to_body.html#bod_radec_to_body", "bod_radec_to_body", 'routine in <a href="obj/bod/bod_radec_to_body.html">bod_radec_to_body.pro</a>', "bod_radec_to_body.pro", "", "bod_radec_to_body", "", "bdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_radec_to_body_vel.html", "bod_radec_to_body_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_radec_to_body_vel.pro", "", "", " NAME: 	bod_radec_to_body_vel    PURPOSE: 	Transforms the given column velocity vectors from the RA/DEC coordinate        system associated to the body to the body coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	body_pts = bod_radec_to_body_vel(bx, radec_pos, radec_vel)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	radec_pos:	Array (nv,3,nt) of column vectors in the bx radec frame.  	radec_vel:	Array (nv,3,nt) of column velocity vectors in the bx 			radec frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of column velocity vectors in the bx body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_radec_to_body_vel.html#bod_radec_to_body_vel", "bod_radec_to_body_vel", 'routine in <a href="obj/bod/bod_radec_to_body_vel.html">bod_radec_to_body_vel.pro</a>', "bod_radec_to_body_vel.pro", "", "bod_radec_to_body_vel", "", "bdrv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_recenter.html", "bod_recenter.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_recenter.pro", "", "", " NAME: 	bod_recenter    PURPOSE: 	Transforms a body descriptor into another body frame.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_recenter, bx, bx0    ARGUMENTS:   INPUT: 	bx:	Descriptor to transform, array (nt) of any subclass of BODY.  	bx0:	Frame to transform into, array (nt) of any subclass of BODY.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE   STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_recenter.html#bod_recenter", "bod_recenter", 'routine in <a href="obj/bod/bod_recenter.html">bod_recenter.pro</a>', "bod_recenter.pro", "", "bod_recenter", "", "bxbx0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_reorient.html", "bod_reorient.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_reorient.pro", "", "", " NAME: 	bod_reorient    PURPOSE: 	Rotates the orientation matrix of each body such that the specified 	axis vector is parallel to the given vector.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_reorient, bx, index, v    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY.  	index:	Integer giving the reference body axis: 0, 1, or 2.  	v:	Array (nv,3,nt) of column vectors to align with the 		each reference axis.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_reorient.html#bod_reorient", "bod_reorient", 'routine in <a href="obj/bod/bod_reorient.html">bod_reorient.pro</a>', "bod_reorient.pro", "", "bod_reorient", "", "bxii_v", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_replicate.html", "bod_replicate.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_replicate.pro", "", "", " NAME: 	bod_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	xd = bod_replicate(bx, dim)    ARGUMENTS:   INPUT: 	bx:	 Any superclass of BODY.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_replicate.html#bod_replicate", "bod_replicate", 'routine in <a href="obj/bod/bod_replicate.html">bod_replicate.pro</a>', "bod_replicate.pro", "", "bod_replicate", "", "bddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_rotate.html", "bod_rotate.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_rotate.pro", "", "", " NAME: 	bod_rotate    PURPOSE: 	Rotates a body about one its axes.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_rotate, bd, theta, axis=axis    ARGUMENTS:   INPUT: 	bx:	 	Any subclass of BODY (nt).  	theta:		Angle of rotation (nt).    OUTPUT: NONE    KEYWORDS:   INPUT: axis:		Body axis about which to rotate; default is 2.    OUTPUT: NONE    RETURN: 	NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2014  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_rotate.html#bod_rotate", "bod_rotate", 'routine in <a href="obj/bod/bod_rotate.html">bod_rotate.pro</a>', "bod_rotate.pro", "", "bod_rotate", "", "axisbx_theta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_aberration.html", "bod_set_aberration.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_aberration.pro", "", "", " NAME: 	bod_set_aberration    PURPOSE: 	Sets aberration flags for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_aberration, bx, name    ARGUMENTS:   INPUT: 	bx:	 Any subclass of BODY.  	name:	 Name of aberration to set.    OUTPUT: NONE    KEYWORDS:   INPUT: 	unset:	If set, the named flag is unset.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_aberration.html#bod_set_aberration", "bod_set_aberration", 'routine in <a href="obj/bod/bod_set_aberration.html">bod_set_aberration.pro</a>', "bod_set_aberration.pro", "", "bod_set_aberration", "", "unsetnoeventbdname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_avel.html", "bod_set_avel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_avel.pro", "", "", " NAME: 	bod_set_avel    PURPOSE: 	Replaces the angular velocity vector of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_avel, bx, avel    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	avel:	 Array (ndv,3,nt) of new angular velocity vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_avel.html#bod_set_avel", "bod_set_avel", 'routine in <a href="obj/bod/bod_set_avel.html">bod_set_avel.pro</a>', "bod_set_avel.pro", "", "bod_set_avel", "", "noeventbdavel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_dlibdt.html", "bod_set_dlibdt.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_dlibdt.pro", "", "", " NAME: 	bod_set_dlibdt    PURPOSE:        Replaces the frequency of each libration vector for each given        body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_dlibdt, bx, dlibdt    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	dlibdt:	 Array (ndv,nt) of new frequencies.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_dlibdt.html#bod_set_dlibdt", "bod_set_dlibdt", 'routine in <a href="obj/bod/bod_set_dlibdt.html">bod_set_dlibdt.pro</a>', "bod_set_dlibdt.pro", "", "bod_set_dlibdt", "", "noeventbddlibdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_ib_data.html", "bod_set_ib_data.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_ib_data.pro", "", "", " NAME: 	bod_set_ib_data    PURPOSE: 	Replaces the function data for a body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_ib_data, bd, data    ARGUMENTS:   INPUT: 	bd:	 Body descriptor.  	data:	 New function data.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Adapted by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_ib_data.html#bod_set_ib_data", "bod_set_ib_data", 'routine in <a href="obj/bod/bod_set_ib_data.html">bod_set_ib_data.pro</a>', "bod_set_ib_data.pro", "", "bod_set_ib_data", "", "noeventbddata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_lib.html", "bod_set_lib.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_lib.pro", "", "", " NAME: 	bod_set_lib    PURPOSE:        Replaces the phase of the libration vector at body time for        each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_lib, bx, lib    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	lib:	 Array (ndv,nt) of new phases of the libration vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_lib.html#bod_set_lib", "bod_set_lib", 'routine in <a href="obj/bod/bod_set_lib.html">bod_set_lib.pro</a>', "bod_set_lib.pro", "", "bod_set_lib", "", "noeventbdlib", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_libv.html", "bod_set_libv.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_libv.pro", "", "", " NAME: 	bod_set_libv    PURPOSE: 	Replaces the libration vector of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_libv, bx, libv    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	libv:	 Array (ndv,3,nt) of new libration vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_libv.html#bod_set_libv", "bod_set_libv", 'routine in <a href="obj/bod/bod_set_libv.html">bod_set_libv.pro</a>', "bod_set_libv.pro", "", "bod_set_libv", "", "noeventbdlibv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_opaque.html", "bod_set_opaque.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_opaque.pro", "", "", " NAME: 	bod_set_opaque    PURPOSE: 	Replaces the opaque flag of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_opaque, bx, opaque    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	avel:	 Array (nt) of new opaque values.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_opaque.html#bod_set_opaque", "bod_set_opaque", 'routine in <a href="obj/bod/bod_set_opaque.html">bod_set_opaque.pro</a>', "bod_set_opaque.pro", "", "bod_set_opaque", "", "noeventbdopaque", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_orient.html", "bod_set_orient.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_orient.pro", "", "", " NAME: 	bod_set_orient    PURPOSE: 	Replaces the orientation matrix of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_orient, bx, orient    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	orient:	 Array (3,3,nt) of new orientation matrices.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_orient.html#bod_set_orient", "bod_set_orient", 'routine in <a href="obj/bod/bod_set_orient.html">bod_set_orient.pro</a>', "bod_set_orient.pro", "", "bod_set_orient", "", "noeventbdorient", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_pos.html", "bod_set_pos.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_pos.pro", "", "", " NAME: 	bod_set_pos    PURPOSE:        Replaces the position of body center (in the inertial frame)        of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_pos, bx, pos    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	pos:	 Array (1,3,nt) of new position vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_pos.html#bod_set_pos", "bod_set_pos", 'routine in <a href="obj/bod/bod_set_pos.html">bod_set_pos.pro</a>', "bod_set_pos.pro", "", "bod_set_pos", "", "noeventbdpos", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_time.html", "bod_set_time.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_time.pro", "", "", " NAME: 	bod_set_time    PURPOSE: 	Replaces the time of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_time, bx, time    ARGUMENTS:   INPUT: 	bx:	 Any subclass of BODY.  	time:	 New time value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_time.html#bod_set_time", "bod_set_time", 'routine in <a href="obj/bod/bod_set_time.html">bod_set_time.pro</a>', "bod_set_time.pro", "", "bod_set_time", "", "noeventbdtime", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_vel.html", "bod_set_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_vel.pro", "", "", " NAME: 	bod_set_vel    PURPOSE:        Replaces the velocity vector (of body center in the inertial        frame) of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_vel, bx, vel    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	vel:	 Array (ndv,3,nt) of new velocity vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_vel.html#bod_set_vel", "bod_set_vel", 'routine in <a href="obj/bod/bod_set_vel.html">bod_set_vel.pro</a>', "bod_set_vel.pro", "", "bod_set_vel", "", "noeventbdvel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_time.html", "bod_time.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_time.pro", "", "", " NAME: 	bod_time    PURPOSE: 	Returns the time for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	time = bod_time(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Any subclass of BODY.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Time value associated with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_time.html#bod_time", "bod_time", 'routine in <a href="obj/bod/bod_time.html">bod_time.pro</a>', "bod_time.pro", "", "bod_time", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_vel.html", "bod_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_vel.pro", "", "", " NAME: 	bod_vel    PURPOSE:        Returns the velocity of body center (in the inertial frame)        for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	vel = bod_vel(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN:        Velocity of body center (in the inertial frame) associated        with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_vel.html#bod_vel", "bod_vel", 'routine in <a href="obj/bod/bod_vel.html">bod_vel.pro</a>', "bod_vel.pro", "", "bod_vel", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/body_radius.html", "body_radius.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "body_radius.pro", "", "", " NAME:        body_radius    PURPOSE: 	Returns the sizes of the given bodies.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        body_radius(bx)    ARGUMENTS:   INPUT: 	bx:      Globe or Disk descriptor; nt.     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	nt-element array giving the size of each body.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/body_radius.html#body_radius", "body_radius", 'routine in <a href="obj/tools/composite/body_radius.html">body_radius.pro</a>', "body_radius.pro", "", "body_radius", "", "bx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/body_to_image_pos.html", "body_to_image_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "body_to_image_pos.pro", "", "", " NAME:        body_to_image_pos    PURPOSE:        Transforms vectors in body coordinates to image coordinates    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = body_to_image_pos(cd, bx, v, inertial=inertial)    ARGUMENTS:   INPUT:              cd:       Array of nt camera or map descriptors.               bx:       Array of nt object descriptors, subclass of BODY.                v:       Array (nv x 3 x nt) of position vectors.    OUTPUT: 	NONE   KEYWORDS:   INPUT: 	NONE    OUTPUT:        inertial:       Array (nv x 3 x nt) of Vectors in inertial coordinates.  	valid:	Indices of valid output points.    RETURN:        An array (2 x nv x nt) of points in image coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/body_to_image_pos.html#body_to_image_pos", "body_to_image_pos", 'routine in <a href="obj/tools/composite/body_to_image_pos.html">body_to_image_pos.pro</a>', "body_to_image_pos.pro", "", "body_to_image_pos", "", "inertialvalidcdbxv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/body_to_surface.html", "body_to_surface.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "body_to_surface.pro", "", "", " NAME:        body_to_surface    PURPOSE:        Transforms points in body coordinates to surface coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = body_to_surface(bx, body_pts)    ARGUMENTS:   INPUT: 	bx:      Array of nt object descriptors (subclass of BODY).  	body_pts:       Array (nv x 3 x nt) of body points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of surface coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/body_to_surface.html#body_to_surface", "body_to_surface", 'routine in <a href="obj/tools/composite/body_to_surface.html">body_to_surface.pro</a>', "body_to_surface.pro", "", "body_to_surface", "", "bxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/brim.html", "brim.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "brim.pro", "", "", " NAME: 	brim    PURPOSE: 	Image browser.    CATEGORY: 	NV/GR    CALLING SEQUENCE: 	brim, files    ARGUMENTS:   INPUT: 	files:	List of filenames and file specifications.  Only files whose 		filetypes can be detected are loaded.  If this argument is not 		given, the user is prompted for a list of files.  An array of 		data descriptors may also be specified.    OUTPUT: NONE    KEYWORDS:   INPUT: 	thumbsize:	Size of the thumbnal images.  Default is 100 pixels. 			Thumbnail images are alwasy square.  	labels:		Labels to use for each thumbnail.  If none given, the 			filename is used, is one exists.  	ids:		Array to identify each thumbnail.  If none given, the 			labels are used, if they exist.  	select_ids:	Ids of Initial thumbnail(s) to appear selected.  	left_fn:	Name of a procedure to call when the left mouse button 			is clicked on a thumbnail.  Default procedure selects 			that image and opens it in a new grim window.  The 			user procedure is called as follows:  				left_fn, fn_data, i, id, status=status  			fn_data is supplied by the caller through the fn_data 			keyword, i is the index of the thumbnail, id is the 			thumbnail id as given by the ids keyword, 			and status should return 0 if successful and nonzero 			otherwise.  	middle_fn:	Name of a procedure to call when the middle mouse button 			is clicked on a thumbnail.  There is no default.  	right_fn:	Name of a procedure to call when the right mouse button 			is clicked on a thumbnail.  There is no default.  	fn_data:	Data to be supplied to the above user procedures.  	exclusive_selection: 			If set, only one image may be selected at once. 			(Currently multiple image selection is not supported.)  	path:		Initial path to use for the file selection widget, 			which appears only if the file argument is not given.  	modal:		If set, only the brim widget may be used until it 			is closed.  	title:		Title to use for the brim widget instead of 'brim'.  	order:		Display order for thumbnails.  Default is 0.  	filter:		Initial filter to use when loading files.    OUTPUT: 	get_path:	Final path selected in the file selection widget.  	select_ids:	On return, select_ids contains the ids of the selected 			images.  If there are no selections, its value will be 			the null string: ''.    RETURN: 	NONE    PROCEDURE: 	brim may be run standalone or from within grim.  If no files or data 	descriptors are given, brim first prompts the user to select a list of 	files.  brim then displays thumbnails of all valid files.  Files may be 	selected by clicking with the left mouse button.  By default, the image 	is opened in a new grim window.  Alternate actions may be defined 	through procedures supplied by the caller.    EXAMPLES: 	To load files into brim using a file-selection widget:  	 IDL> brim   	To load all recognizeable images in the current directory into brim:  	 IDL> brim, '*'   	To browse a set of data descriptors:  	 IDL> dd = dat_read('*') 	 IDL> brim, dd    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/brim.html#brim_display_image", "brim_display_image", 'routine in <a href="grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_display_image", "", "brim_data_iimage", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/brim.html#brim_resolve_ids", "brim_resolve_ids", 'routine in <a href="grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_resolve_ids", "", "brim_dataids", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/brim.html#brim_load", "brim_load", 'routine in <a href="grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_load", "", "displaybrim_datafiles", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/brim.html#brim_configure", "brim_configure", 'routine in <a href="grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_configure", "", "filesbasethumbsizelabelsselect_idsleft_fnright_fnmiddle_fnfn_dataexclusive_selectionpathget_pathmodaltitleidsorderfilterenable_selectionbrim_datan", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/brim.html#brim_select", "brim_select", 'routine in <a href="grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_select", "", "idddbrim_data_i", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/brim.html#brim_fn_grim", "brim_fn_grim", 'routine in <a href="grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_fn_grim", "", "statusbrim_datailabel", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/brim.html#brim_event", "brim_event", 'routine in <a href="grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/brim.html#brim_draw_event", "brim_draw_event", 'routine in <a href="grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_draw_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/brim.html#brim", "brim", 'routine in <a href="grim/brim.html">brim.pro</a>', "brim.pro", "", "brim", "", "thumbsizelabelsselect_idsleft_fnright_fnmiddle_fnfn_dataexclusive_selectionpathget_pathmodaltitleidsorderfilterenable_selectionbasefiles", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_assign.html", "cam_assign.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_assign.pro", "", "", " NAME: 	cam_assign    PURPOSE: 	Replaces fields in a CAMERA object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	cam_assign, cd, <keywords>=<values>    ARGUMENTS:   INPUT: 	cd:		CAMERA object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	CAMERA fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	cam_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_assign.html#cam_assign", "cam_assign", 'routine in <a href="obj/cam/cam_assign.html">cam_assign.pro</a>', "cam_assign.pro", "", "cam_assign", "", "noeventxd@cam__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_body_to_focal.html", "cam_body_to_focal.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_body_to_focal.pro", "", "", " NAME: 	cam_body_to_focal    PURPOSE:        Transforms the given column vectors from the body coordinate        system to the camera focal plane coordinate system.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	focal_pts = cam_body_to_focal(cd, body_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the camera focal plane frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_body_to_focal.html#cam_body_to_focal", "cam_body_to_focal", 'routine in <a href="obj/cam/cam_body_to_focal.html">cam_body_to_focal.pro</a>', "cam_body_to_focal.pro", "", "cam_body_to_focal", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_create_descriptors.html", "cam_create_descriptors.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_create_descriptors.pro", "", "", " NAME: 	cam_create_descriptors    PURPOSE: 	Init method for the CAMERA class.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cd = cam_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	Number of descriptors to create.    OUTPUT: NONE    KEYWORDS (in addition to those accepted by all superclasses):   INPUT: 	cd:	Camera descriptor(s) to initialize, instead of creating a new 		one.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	scale:	Array (2,n) of scales for each camera.  	oaxis:	Array (2,n) of optic axis values for each camera.  	exposure:	Array (n) of exposure times for each camera.  	size:	Array (2,n) of sizes for each camera.  	filters:	Array (nfilt,n) of filter names for each camera.  	fn_focal_to_image:	Array (n) of focal-to-image function names 				for each camera.  	fn_image_to_focal:	Array (n) of image-to-focal function names 				for each camera.  	fn_psf:	Array (n) of point-spread function names for each camera.     OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized camera descriptors, depending 	on the presence of the cd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_create_descriptors.html#cam_create_descriptors", "cam_create_descriptors", 'routine in <a href="obj/cam/cam_create_descriptors.html">cam_create_descriptors.pro</a>', "cam_create_descriptors.pro", "", "cam_create_descriptors", "", "crdbdcdn@cam__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_evolve.html", "cam_evolve.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_evolve.pro", "", "", " NAME: 	cam_evolve    PURPOSE:        Computes new camera descriptors at the given time offsets from        the given camera descriptors using the taylor series expansion        corresponding to the derivatives contained in the given camera        descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cdt = cam_evolve(cd, dt)    ARGUMENTS:   INPUT: 	cd:	 Array (ncd) of CAMERA descriptors.  	dt:	 Array (ndt) of time offsets.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, velocities will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN:        Array (ncd,ndt) of newly allocated camera descriptors evolved        by time dt, where ncd is the number of cd, and ndt is the        number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_evolve.html#cam_evolve", "cam_evolve", 'routine in <a href="obj/cam/cam_evolve.html">cam_evolve.pro</a>', "cam_evolve.pro", "", "cam_evolve", "", "nodvcopycddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_exposure.html", "cam_exposure.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_exposure.pro", "", "", " NAME: 	cam_exposure    PURPOSE:        Returns the exposure duration of each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	exposure = cam_exposure(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Exposure duration associated with each given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_exposure.html#cam_exposure", "cam_exposure", 'routine in <a href="obj/cam/cam_exposure.html">cam_exposure.pro</a>', "cam_exposure.pro", "", "cam_exposure", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_fi_data.html", "cam_fi_data.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_fi_data.pro", "", "", " NAME: 	cam_fi_data    PURPOSE: 	Returns the focal/image function data for a camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	data = cam_fi_data(cd)    ARGUMENTS:   INPUT: NONE 	cd:	 Camera descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Function data associated with the given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Adapted by:	Spitale, 7/2016; adapted from cam_fi_data_p   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_fi_data.html#cam_fi_data", "cam_fi_data", 'routine in <a href="obj/cam/cam_fi_data.html">cam_fi_data.pro</a>', "cam_fi_data.pro", "", "cam_fi_data", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_filters.html", "cam_filters.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_filters.pro", "", "", " NAME: 	cam_filters    PURPOSE: 	Returns the filter name(s) for a given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	filters = cam_filers(cd, index)    ARGUMENTS:   INPUT: 	cd:	 Camera descriptor.  	index:	 Index of filter to return.  If not given, all are returned.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Names of requested filters.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_filters.html#cam_filters", "cam_filters", 'routine in <a href="obj/cam/cam_filters.html">cam_filters.pro</a>', "cam_filters.pro", "", "cam_filters", "", "noeventcdi", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_fn_focal_to_image.html", "cam_fn_focal_to_image.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_fn_focal_to_image.pro", "", "", " NAME: 	cam_fn_focal_to_image    PURPOSE:        Returns the name of the user-defined focal --> image        transformation function for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	fn = cam_fn_focal_to_image(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Focal --> image transformation function associated with each        given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_fn_focal_to_image.html#cam_fn_focal_to_image", "cam_fn_focal_to_image", 'routine in <a href="obj/cam/cam_fn_focal_to_image.html">cam_fn_focal_to_image.pro</a>', "cam_fn_focal_to_image.pro", "", "cam_fn_focal_to_image", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_fn_image_to_focal.html", "cam_fn_image_to_focal.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_fn_image_to_focal.pro", "", "", " NAME: 	cam_fn_image_to_focal    PURPOSE:        Returns the name of the user-defined image --> focal        transformation function for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	fn = cam_fn_image_to_focal(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Image --> focal transformation function associated with each        given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_fn_image_to_focal.html#cam_fn_image_to_focal", "cam_fn_image_to_focal", 'routine in <a href="obj/cam/cam_fn_image_to_focal.html">cam_fn_image_to_focal.pro</a>', "cam_fn_image_to_focal.pro", "", "cam_fn_image_to_focal", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_fn_psf.html", "cam_fn_psf.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_fn_psf.pro", "", "", " NAME: 	cam_fn_psf    PURPOSE: 	Returns the user-defined psf function for the given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	fn = cam_fn_psf(cd)    ARGUMENTS:   INPUT: NONE 	cd:	 Camera descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	PSF function associated with each given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_fn_psf.html#cam_fn_psf", "cam_fn_psf", 'routine in <a href="obj/cam/cam_fn_psf.html">cam_fn_psf.pro</a>', "cam_fn_psf.pro", "", "cam_fn_psf", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_body.html", "cam_focal_to_body.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_body.pro", "", "", " NAME: 	cam_focal_to_body    PURPOSE:        Transforms the given array of points from the camera focal        plane coordinate system to the body coordinate system.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	body_pts = cam_focal_to_body(cd, focal_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	focal_pts:	Array (2,nv,nt) of points in the camera focal plane frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_body.html#cam_focal_to_body", "cam_focal_to_body", 'routine in <a href="obj/cam/cam_focal_to_body.html">cam_focal_to_body.pro</a>', "cam_focal_to_body.pro", "", "cam_focal_to_body", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image.html", "cam_focal_to_image.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_image.pro", "", "", " NAME: 	cam_focal_to_image    PURPOSE: 	Transforms the given array of points in the focal plane        coordinate system to an array of points in the image        coordinate system using the fn_focal_to_image function of the        camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	image_pts = cam_focal_to_image(cd, focal_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	focal_pts:	Array (2,nv,nt) of points in the camera focal frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the image coordinate system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image.html#cam_focal_to_image", "cam_focal_to_image", 'routine in <a href="obj/cam/cam_focal_to_image.html">cam_focal_to_image.pro</a>', "cam_focal_to_image.pro", "", "cam_focal_to_image", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_linear.html", "cam_focal_to_image_linear.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_image_linear.pro", "", "", " NAME: 	cam_focal_to_image_linear    PURPOSE:        Transforms the given array of points in the focal plane        coordinate system to an array of points in the image        coordinate system using a linear model that assumes that        distances in the image are proportional to angles in the focal        plane.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	image_pts = cam_focal_to_image_linear(cd, focal_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	focal_pts:	Array (2,nv,nt) of points in the camera focal frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the image coordinate system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_linear.html#cam_focal_to_image_linear", "cam_focal_to_image_linear", 'routine in <a href="obj/cam/cam_focal_to_image_linear.html">cam_focal_to_image_linear.pro</a>', "cam_focal_to_image_linear.pro", "", "cam_focal_to_image_linear", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_poly.html", "cam_focal_to_image_poly.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_image_poly.pro", "", "", " NAME: 	cam_focal_to_image_poly    PURPOSE:        Transforms the given array of points in the focal plane        coordinate system to an array of points in the image        coordinate system using a polynomial distortion model.   CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	image_pts = cam_focal_to_image_poly(cd, focal_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	focal_pts:	Array (2,nv,nt) of points in the camera focal frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the image coordinate system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_poly.html#cam_focal_to_image_poly", "cam_focal_to_image_poly", 'routine in <a href="obj/cam/cam_focal_to_image_poly.html">cam_focal_to_image_poly.pro</a>', "cam_focal_to_image_poly.pro", "", "cam_focal_to_image_poly", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_radial.html", "cam_focal_to_image_radial.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_image_radial.pro", "", "", " NAME: 	cam_focal_to_image_radial    PURPOSE:        Transforms the given array of points in the focal plane        coordinate system to an array of points in the image        coordinate system using a radial distortion model.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	image_pts = cam_focal_to_image_radial(cd, focal_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	focal_pts:	Array (2,nv,nt) of points in the camera focal frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the image coordinate system.    STATUS: 	**Incomplete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_radial.html#cam_focal_to_image_radial", "cam_focal_to_image_radial", 'routine in <a href="obj/cam/cam_focal_to_image_radial.html">cam_focal_to_image_radial.pro</a>', "cam_focal_to_image_radial.pro", "", "cam_focal_to_image_radial", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_get_poly_matrices.html", "cam_get_poly_matrices.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_get_poly_matrices.pro", "", "", " NAME: 	cam_get_poly_matrices    PURPOSE:        Obtains the camera function data for the polynomial distortion model.   CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_get_poly_matrices, cd, XX, YY, PP, QQ    ARGUMENTS:   INPUT: 	cd:	Array (nt) of and subclass of CAMERA.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT:         XX:     Polynominal distortion coefficients in x.         YY:     Polynominal distortion coefficients in y.         PP:     Inverse polynominal distortion coefficients in x.         QQ:     Inverse polynominal distortion coefficients in y.    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_get_poly_matrices.html#cam_get_poly_matrices", "cam_get_poly_matrices", 'routine in <a href="obj/cam/cam_get_poly_matrices.html">cam_get_poly_matrices.pro</a>', "cam_get_poly_matrices.pro", "", "cam_get_poly_matrices", "", "cdXXYYPPQQ", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_get_radec_twist.html", "cam_get_radec_twist.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_get_radec_twist.pro", "", "", " NAME: 	cam_get_radec_twist    PURPOSE:        Computes camera Euler angles relative to the inertial frame.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_get_radec_twist, cd, ra=ra, dec=dec, twist=twist    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	ra:	Array (nt) of RA angles.  	dec:	Array (nt) of DEC angles.  	twist:	Array (nt) of TWIST angles.    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_get_radec_twist.html#cam_get_radec_twist", "cam_get_radec_twist", 'routine in <a href="obj/cam/cam_get_radec_twist.html">cam_get_radec_twist.pro</a>', "cam_get_radec_twist.pro", "", "cam_get_radec_twist", "", "radectwistcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal.html", "cam_image_to_focal.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_image_to_focal.pro", "", "", " NAME: 	cam_image_to_focal    PURPOSE:        Transforms the given array of points in the image coordinate        system to an array of points in the camera focal plane        coordinate system using the fn_image_to_focal function of the        camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	focal_pts = cam_image_to_focal(cd, image_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	image_pts:	Array (2,nv,nt) of points in the image coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the camera focal frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal.html#cam_image_to_focal", "cam_image_to_focal", 'routine in <a href="obj/cam/cam_image_to_focal.html">cam_image_to_focal.pro</a>', "cam_image_to_focal.pro", "", "cam_image_to_focal", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_linear.html", "cam_image_to_focal_linear.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_image_to_focal_linear.pro", "", "", " NAME: 	cam_image_to_focal_linear    PURPOSE:        Transforms the given array of points in the image coordinate        system to an array of points in the camera focal plane        coordinate system using a linear model that assumes that        distances in the image are proportional to angles in the focal        plane.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	focal_pts = cam_image_to_focal_linear(cd, image_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	image_pts:	Array (2,nv,nt) of points in the image coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the camera focal frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_linear.html#cam_image_to_focal_linear", "cam_image_to_focal_linear", 'routine in <a href="obj/cam/cam_image_to_focal_linear.html">cam_image_to_focal_linear.pro</a>', "cam_image_to_focal_linear.pro", "", "cam_image_to_focal_linear", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_poly.html", "cam_image_to_focal_poly.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_image_to_focal_poly.pro", "", "", " NAME: 	cam_image_to_focal_poly    PURPOSE:        Transforms the given array of points in the image coordinate        system to an array of points in the camera focal plane        coordinate system using a polynomial distortion model.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	focal_pts = cam_image_to_focal_poly(cd, image_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	image_pts:	Array (2,nv,nt) of points in the image coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the camera focal frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_poly.html#cam_image_to_focal_poly", "cam_image_to_focal_poly", 'routine in <a href="obj/cam/cam_image_to_focal_poly.html">cam_image_to_focal_poly.pro</a>', "cam_image_to_focal_poly.pro", "", "cam_image_to_focal_poly", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_radial.html", "cam_image_to_focal_radial.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_image_to_focal_radial.pro", "", "", " NAME: 	cam_image_to_focal_radial    PURPOSE:        Transforms the given array of points in the image coordinate        system to an array of points in the camera focal plane        coordinate system using a radial distortion model.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	focal_pts = cam_image_to_focal_radial(cd, image_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	image_pts:	Array (2,nv,nt) of points in the image coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the camera focal frame.    STATUS: 	**Incomplete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_radial.html#cam_image_to_focal_radial", "cam_image_to_focal_radial", 'routine in <a href="obj/cam/cam_image_to_focal_radial.html">cam_image_to_focal_radial.pro</a>', "cam_image_to_focal_radial.pro", "", "cam_image_to_focal_radial", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_nfilters.html", "cam_nfilters.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_nfilters.pro", "", "", " NAME: 	cam_nfilters    PURPOSE: 	Returns an integer indicating the maximum number of filters allowed 	in the 'filters' fields of the camera descriptor.  This number can 	be adjusted using the environment variable 'CAM_NFILTERS'.  The default 	is 4.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	nfilters = cam_nfilters()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    ENVIRONMENT VARIABLES: 	CAM_NFILTERS:	Sets the maximum number of filters.    RETURN: 	Current nfilters value.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_nfilters.html#cam_nfilters", "cam_nfilters", 'routine in <a href="obj/cam/cam_nfilters.html">cam_nfilters.pro</a>', "cam_nfilters.pro", "", "cam_nfilters", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_oaxis.html", "cam_oaxis.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_oaxis.pro", "", "", " NAME: 	cam_oaxis    PURPOSE:        Returns the 2-element array giving the image coordinates (in        pixels) corresponding to the camera optic axis for each given        camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	oaxis = cam_oaxis(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Oaxis array associated with each given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_oaxis.html#cam_oaxis", "cam_oaxis", 'routine in <a href="obj/cam/cam_oaxis.html">cam_oaxis.pro</a>', "cam_oaxis.pro", "", "cam_oaxis", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_origin.html", "cam_origin.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_origin.pro", "", "", " NAME: 	cam_origin    PURPOSE:        Returns the 2-element array giving the image coordinates (in        pixels) corresponding to the camera optic axis for each given        camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	origin = cam_origin(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	origin array associated with each given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_origin.html#cam_origin", "cam_origin", 'routine in <a href="obj/cam/cam_origin.html">cam_origin.pro</a>', "cam_origin.pro", "", "cam_origin", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_psf.html", "cam_psf.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_psf.pro", "", "", " NAME: 	cam_psf    PURPOSE: 	Computes a point-spread function.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	psf = cam_psf(cd, x, y)    ARGUMENTS:   INPUT: 	cd:	 Camera descriptor.  	x:	 Array of x coordinates relative to the center of the PSF, 		 or a width in the x direction.  	y:	 Array of y coordinates relative to the center of the PSF, 		 or a width in the y direction.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Point-spread function values at each point specified by the x and y 	arguments.    PROCEDURE: 	The function indicated by the fn_psf field of the camera descriptor 	is called and its return value is passed through to the caller of 	cam_psf.  If x and y widths are given instead of arrays, the PSF 	will be centered, and the grid spacing will be one pixel.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_psf.html#cam_psf", "cam_psf", 'routine in <a href="obj/cam/cam_psf.html">cam_psf.pro</a>', "cam_psf.pro", "", "cam_psf", "", "noeventcd_x_y", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_psf_attrib.html", "cam_psf_attrib.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_psf_attrib.pro", "", "", " NAME: 	cam_psf_attrib    PURPOSE: 	Computes attributes of a point-spread function.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_psf_attrib, cd, <attribute keywords...>    ARGUMENTS:   INPUT: 	cd:	 Camera descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: 	fwhm:	Full-width at half maximum of the point-spread function.    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_psf_attrib.html#cam_psf_attrib", "cam_psf_attrib", 'routine in <a href="obj/cam/cam_psf_attrib.html">cam_psf_attrib.pro</a>', "cam_psf_attrib.pro", "", "cam_psf_attrib", "", "fwhmcd", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/cam/cam_psf_attrib.html#__cam_psf_attrib", "__cam_psf_attrib", 'routine in <a href="obj/cam/cam_psf_attrib.html">cam_psf_attrib.pro</a>', "cam_psf_attrib.pro", "", "__cam_psf_attrib", "", "fwhmcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_query.html", "cam_query.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_query.pro", "", "", " NAME: 	cam_query    PURPOSE: 	Returns the fields associated with a CAMERA object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	cam_query, cd, <keywords>=<values>    ARGUMENTS:   INPUT: 	cd:	CAMERA object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	CAMERA object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_query.html#cam_query", "cam_query", 'routine in <a href="obj/cam/cam_query.html">cam_query.pro</a>', "cam_query.pro", "", "cam_query", "", "conditioncatnoeventxd@cam__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_rebin.html", "cam_rebin.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_rebin.pro", "", "", " NAME: 	cam_rebin    PURPOSE:        Modifies the camera parameters to reflect a re-binning of the pixels.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_rebin, cd, bin    ARGUMENTS:   INPUT: 	cd:	    Array (nt) of CAMERA descriptors.         bin:        Binning factor, can be non-integer.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_rebin.html#cam_rebin", "cam_rebin", 'routine in <a href="obj/cam/cam_rebin.html">cam_rebin.pro</a>', "cam_rebin.pro", "", "cam_rebin", "", "noeventcdbin", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_reorient.html", "cam_reorient.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_reorient.pro", "", "", " NAME: 	cam_reorient    PURPOSE:        Repoints the camera orientiation matrix based on x,y, and theta 	image offsets.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_reorient, cd, image_axis, dxy, dtheta    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors.  	image_axis:	Array (2,1,nt) of image points corresponding to the 			rotation axis for each descriptor.  	dxy:	Array (2,1,nt) of image offsets in x and y.  	dheta:	Array (1,1,nt) of rotation angles.    OUTPUT: NONE    KEYWORDS:   INPUT: 	absolute: If set, the dxy argument represents and abosolute image 		  position rather than an offset.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_reorient.html#cam_reorient", "cam_reorient", 'routine in <a href="obj/cam/cam_reorient.html">cam_reorient.pro</a>', "cam_reorient.pro", "", "cam_reorient", "", "absolutensin_anglecos_anglecd0image_axisdxydtheta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_replicate.html", "cam_replicate.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_replicate.pro", "", "", " NAME: 	cam_replicate    PURPOSE: 	Replicates the given camera descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	new_cd = cam_replicate(cd, dim)    ARGUMENTS:   INPUT: 	cd:	 One CAMERA descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_replicate.html#cam_replicate", "cam_replicate", 'routine in <a href="obj/cam/cam_replicate.html">cam_replicate.pro</a>', "cam_replicate.pro", "", "cam_replicate", "", "cddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_rescale.html", "cam_rescale.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_rescale.pro", "", "", " NAME: 	cam_rescale    PURPOSE:        Produces a new camera descriptor describing an image of the same 	angluar dimensions, but with a new scale, specified by camera scale.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_rescale, cd, scale    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors to modify.  	scale:	Array (2,1,nt) of new camera scales.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_rescale.html#cam_rescale", "cam_rescale", 'routine in <a href="obj/cam/cam_rescale.html">cam_rescale.pro</a>', "cam_rescale.pro", "", "cam_rescale", "", "noeventcdscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_resize.html", "cam_resize.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_resize.pro", "", "", " NAME: 	cam_resize    PURPOSE:        Produces a new camera descriptor describing an image of the same 	angluar dimensions, but with a new scale, specified by image size.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_resize, cd, size    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors to modify.  	size:	Array (2,1,nt) of new image sizes.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_resize.html#cam_resize", "cam_resize", 'routine in <a href="obj/cam/cam_resize.html">cam_resize.pro</a>', "cam_resize.pro", "", "cam_resize", "", "noeventcdsize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_scale.html", "cam_scale.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_scale.pro", "", "", " NAME: 	cam_scale    PURPOSE:        Returns the 2-element array giving the camera scale        (radians/pixel) in each direction for each given camera        descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	scale = cam_scale(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Scale array associated with each given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_scale.html#cam_scale", "cam_scale", 'routine in <a href="obj/cam/cam_scale.html">cam_scale.pro</a>', "cam_scale.pro", "", "cam_scale", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_exposure.html", "cam_set_exposure.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_exposure.pro", "", "", " NAME: 	cam_set_exposure    PURPOSE:        Replaces the exposure duration for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_exposure,cd,exposure    ARGUMENTS:   INPUT: 	cd:	     Array (nt) of CAMERA descriptors.         exposure:    Array (nt) of new exposure values.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_exposure.html#cam_set_exposure", "cam_set_exposure", 'routine in <a href="obj/cam/cam_set_exposure.html">cam_set_exposure.pro</a>', "cam_set_exposure.pro", "", "cam_set_exposure", "", "noeventcdexposure", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_fi_data.html", "cam_set_fi_data.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_fi_data.pro", "", "", " NAME: 	cam_set_fi_data    PURPOSE: 	Replaces the focal/image function data for a camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_fi_data, cd, data    ARGUMENTS:   INPUT: 	cd:	 Camera descriptor.  	data:	 New function data.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Adapted by:	Spitale, 7/2016; adapted from cam_set_fi_data_p   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_fi_data.html#cam_set_fi_data", "cam_set_fi_data", 'routine in <a href="obj/cam/cam_set_fi_data.html">cam_set_fi_data.pro</a>', "cam_set_fi_data.pro", "", "cam_set_fi_data", "", "noeventcddata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_filters.html", "cam_set_filters.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_filters.pro", "", "", " NAME: 	cam_set_filters    PURPOSE: 	Sets the filter name(s) for a given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_filters, cd, filters, i    ARGUMENTS:   INPUT: 	cd:	 Camera descriptor.  	filters:	Name(s) of filters.  	index:	 Index of filter to set.  If not given, all are set.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE   STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_filters.html#cam_set_filters", "cam_set_filters", 'routine in <a href="obj/cam/cam_set_filters.html">cam_set_filters.pro</a>', "cam_set_filters.pro", "", "cam_set_filters", "", "noeventcdfilteri", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_focal_to_image.html", "cam_set_fn_focal_to_image.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_fn_focal_to_image.pro", "", "", " NAME: 	cam_set_fn_focal_to_image    PURPOSE:        Sets the user-defined focal --> image transformation function        for the given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_fn_focal_to_image, cd, fn    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.  	fn:	 Array (nt) of user-defined focal --> image functions.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_focal_to_image.html#cam_set_fn_focal_to_image", "cam_set_fn_focal_to_image", 'routine in <a href="obj/cam/cam_set_fn_focal_to_image.html">cam_set_fn_focal_to_image.pro</a>', "cam_set_fn_focal_to_image.pro", "", "cam_set_fn_focal_to_image", "", "noeventcdfn_focal_to_image", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_image_to_focal.html", "cam_set_fn_image_to_focal.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_fn_image_to_focal.pro", "", "", " NAME: 	cam_set_fn_image_to_focal    PURPOSE:        Sets the user-defined image --> focal transformation function        for the given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_fn_image_to_focal, cd, fn    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.  	fn:	 Array (nt) of user-defined image --> focal functions.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_image_to_focal.html#cam_set_fn_image_to_focal", "cam_set_fn_image_to_focal", 'routine in <a href="obj/cam/cam_set_fn_image_to_focal.html">cam_set_fn_image_to_focal.pro</a>', "cam_set_fn_image_to_focal.pro", "", "cam_set_fn_image_to_focal", "", "noeventcdfn_image_to_focal", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_psf.html", "cam_set_fn_psf.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_fn_psf.pro", "", "", " NAME: 	cam_set_fn_psf    PURPOSE: 	Sets the user-defined PSF function for the given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_fn_psf, cd, fn    ARGUMENTS:   INPUT: 	cd:	 Camera descriptor.  	fn:	 Name of user-defined PSF function.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_psf.html#cam_set_fn_psf", "cam_set_fn_psf", 'routine in <a href="obj/cam/cam_set_fn_psf.html">cam_set_fn_psf.pro</a>', "cam_set_fn_psf.pro", "", "cam_set_fn_psf", "", "noeventcdpsf", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_oaxis.html", "cam_set_oaxis.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_oaxis.pro", "", "", " NAME: 	cam_set_oaxis    PURPOSE:        Replaces the oaxis array for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_oaxis, cd, oaxis    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors.         oaxis:	Array (2,nt) of new oaxis values.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_oaxis.html#cam_set_oaxis", "cam_set_oaxis", 'routine in <a href="obj/cam/cam_set_oaxis.html">cam_set_oaxis.pro</a>', "cam_set_oaxis.pro", "", "cam_set_oaxis", "", "noeventcdoaxis", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_origin.html", "cam_set_origin.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_origin.pro", "", "", " NAME: 	cam_set_origin    PURPOSE:        Replaces the origin array for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_origin, cd, origin    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors.         origin:	Array (2,nt) of new origin values.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_origin.html#cam_set_origin", "cam_set_origin", 'routine in <a href="obj/cam/cam_set_origin.html">cam_set_origin.pro</a>', "cam_set_origin.pro", "", "cam_set_origin", "", "noeventcdorigin", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_poly_matrices.html", "cam_set_poly_matrices.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_poly_matrices.pro", "", "", " NAME: 	cam_set_poly_matrices    PURPOSE:        Sets up the camera function data for the polynomial distortion model.   CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_poly_matrices, cd, XX, YY, PP, QQ    ARGUMENTS:   INPUT: 	cd:	Array (nt) of and subclass of CAMERA.         XX:     Polynominal distortion coefficients in x.         YY:     Polynominal distortion coefficients in y.         PP:     Inverse polynominal distortion coefficients in x.         QQ:     Inverse polynominal distortion coefficients in y.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_poly_matrices.html#cam_set_poly_matrices", "cam_set_poly_matrices", 'routine in <a href="obj/cam/cam_set_poly_matrices.html">cam_set_poly_matrices.pro</a>', "cam_set_poly_matrices.pro", "", "cam_set_poly_matrices", "", "noeventcdXXYYPPQQ", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_scale.html", "cam_set_scale.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_scale.pro", "", "", " NAME: 	cam_set_scale    PURPOSE:        Replaces the scale array for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_scale, cd, scale    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors.  	scale:	Array (2,nt) of new scale values.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_scale.html#cam_set_scale", "cam_set_scale", 'routine in <a href="obj/cam/cam_set_scale.html">cam_set_scale.pro</a>', "cam_set_scale.pro", "", "cam_set_scale", "", "noeventcdscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_size.html", "cam_set_size.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_size.pro", "", "", " NAME: 	cam_set_size    PURPOSE:        Replaces the size array for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_size, cd, size    ARGUMENTS:   INPUT: 	cd:	     Array (nt) of CAMERA descriptors.         size:        Array (2,nt) of new size values.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_size.html#cam_set_size", "cam_set_size", 'routine in <a href="obj/cam/cam_set_size.html">cam_set_size.pro</a>', "cam_set_size.pro", "", "cam_set_size", "", "noeventcdsize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_size.html", "cam_size.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_size.pro", "", "", " NAME: 	cam_size    PURPOSE: 	Returns the image size (in pixels) for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	size = cam_size(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Size array associated with each given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_size.html#cam_size", "cam_size", 'routine in <a href="obj/cam/cam_size.html">cam_size.pro</a>', "cam_size.pro", "", "cam_size", "", "noeventnxnycd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_subimage.html", "cam_subimage.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_subimage.pro", "", "", " NAME: 	cam_subimage    PURPOSE:        Produces a new camera descriptor corresponding to dividing the 	associated image as specified.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_subimage, cd, p0, nxy    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors to modify.  	p0:	Starting corner of subimage.  	size:	Array (2,1,nt) of image sizes.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 4/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_subimage.html#cam_subimage", "cam_subimage", 'routine in <a href="obj/cam/cam_subimage.html">cam_subimage.pro</a>', "cam_subimage.pro", "", "cam_subimage", "", "noeventcdp0size", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/cd_to_radec_twist.html", "cd_to_radec_twist.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "cd_to_radec_twist.pro", "", "", " NAME:        cd_to_radec_twist    PURPOSE:        Computes Euler angles representing the orientation of a given 	camera descriptor.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        cd_to_radec_twist, cd, ra=ra, dec=dec, twist=twist    ARGUMENTS:   INPUT:             cd:       Array (nv,3,nt) of camera descriptors.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT:        ra:	Right ascension relative to the inertial frame.  	dec:	Declination relative to the inertial frame.  	twist:	Twist angle relative to the inertial frame.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/cd_to_radec_twist.html#cd_to_radec_twist", "cd_to_radec_twist", 'routine in <a href="obj/tools/cd_to_radec_twist.html">cd_to_radec_twist.pro</a>', "cd_to_radec_twist.pro", "", "cd_to_radec_twist", "", "radectwistcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/util/clget.html", "clget.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "clget.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/clget.html#clget", "clget", 'routine in <a href="sys/util/clget.html">clget.pro</a>', "clget.pro", "", "clget", "", "foundodptag_name", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/util/clset.html", "clset.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "clset.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/clset.html#clset", "clset", 'routine in <a href="sys/util/clset.html">clset.pro</a>', "clset.pro", "", "clset", "", "foundodptag_namevalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html", "construct_mosaic.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "construct_mosaic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html#cm_combine_edge1", "cm_combine_edge1", 'routine in <a href="obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_edge1", "", "mapsdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html#cm_combine_edge", "cm_combine_edge", 'routine in <a href="obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_edge", "", "mapsdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html#cm_combine_emm", "cm_combine_emm", 'routine in <a href="obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_emm", "", "mapsdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html#cm_combine_emm5", "cm_combine_emm5", 'routine in <a href="obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_emm5", "", "mapsdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html#cm_wt_edge1", "cm_wt_edge1", 'routine in <a href="obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_wt_edge1", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html#cm_wt_edge", "cm_wt_edge", 'routine in <a href="obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_wt_edge", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html#cm_combine_median", "cm_combine_median", 'routine in <a href="obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_median", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html#cm_combine_sum", "cm_combine_sum", 'routine in <a href="obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_sum", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html#cm_combine_mean", "cm_combine_mean", 'routine in <a href="obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_mean", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html#cm_combine_overlay", "cm_combine_overlay", 'routine in <a href="obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_overlay", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html#cm_wt_rescale", "cm_wt_rescale", 'routine in <a href="obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_wt_rescale", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html#cm_wt_emm", "cm_wt_emm", 'routine in <a href="obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_wt_emm", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/construct_mosaic.html#construct_mosaic", "construct_mosaic", 'routine in <a href="obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "construct_mosaic", "", "combine_fnwt_fnsdataauxmaps", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_abbrev.html", "cor_abbrev.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_abbrev.pro", "", "", " NAME: 	cor_abbrev    PURPOSE: 	Returns the abbrieviation for the given object class.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	abbrev = cor_abbrev(xd)    ARGUMENTS:   INPUT: 	xd:	 Descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	String giving the standard abbreviation for the given class, 	e.g., 'BOD'.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_abbrev.html#cor_abbrev", "cor_abbrev", 'routine in <a href="obj/cor/cor_abbrev.html">cor_abbrev.pro</a>', "cor_abbrev.pro", "", "cor_abbrev", "", "noeventcrd", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/cor/cor_abbrev.html#_cor_abbrev", "_cor_abbrev", 'routine in <a href="obj/cor/cor_abbrev.html">cor_abbrev.pro</a>', "cor_abbrev.pro", "", "_cor_abbrev", "", "xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_add_task.html", "cor_add_task.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_add_task.pro", "", "", " NAME: 	cor_add_task    PURPOSE: 	Adds a task to the descriptor task list.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	cor_add_task, crx, task    ARGUMENTS:   INPUT: 	crx:	 Any subclass of CORE.  Only one descriptor may be provided.  	task:	 String giving the name of a program that modified the 		 descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_add_task.html#cor_add_task", "cor_add_task", 'routine in <a href="obj/cor/cor_add_task.html">cor_add_task.pro</a>', "cor_add_task.pro", "", "cor_add_task", "", "noeventcrdtask", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_assign.html", "cor_assign.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_assign.pro", "", "", " NAME: 	cor_assign    PURPOSE: 	Replaces fields in a POINT object.  This is a fast way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	cor_assign, xd, <keywords>=<values>    ARGUMENTS:   INPUT: 	xd:		CORE object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	CORE fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	cor_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		1/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_assign.html#cor_assign", "cor_assign", 'routine in <a href="obj/cor/cor_assign.html">cor_assign.pro</a>', "cor_assign.pro", "", "cor_assign", "", "noeventxd@cor__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_cat_gd.html", "cor_cat_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_cat_gd.pro", "", "", " NAME: 	cor_cat_gd    PURPOSE: 	Produces an array of object descriptors from a generic descriptor.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	xds = cor_cat_gd(gd)    ARGUMENTS:   INPUT: 	gd:	Generic descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array of object descriptors taken from the given generic descriptors.     MODIFICATION HISTORY:  	Written by:	Spitale 	Moved to CORE	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_cat_gd.html#cor_cat_gd", "cor_cat_gd", 'routine in <a href="obj/cor/cor_cat_gd.html">cor_cat_gd.pro</a>', "cor_cat_gd.pro", "", "cor_cat_gd", "", "gd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_class.html", "cor_class.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_class.pro", "", "", " NAME: 	cor_class    PURPOSE: 	Returns the class name for the given object class.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	class = cor_class(xd)    ARGUMENTS:   INPUT: 	xd:	 Descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	String giving the class name for the given class, without the OMINAS_ 	prefix.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale		4/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_class.html#cor_class", "cor_class", 'routine in <a href="obj/cor/cor_class.html">cor_class.pro</a>', "cor_class.pro", "", "cor_class", "", "xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_class_info.html", "cor_class_info.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_class_info.pro", "", "", " NAME: 	cor_class_info    PURPOSE: 	Returns information about OMINAS object classes.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	cor_class_info, classes=classes, abbrev=abbrev, tags=tags    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	classes:	String array giving the names of all OMINAS classes.  	abbrev:		String array giving the abbreviations of OMINAS classes.  	tags:		String array giving the tag names of OMINAS classes.     RETURN: NONE      MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_class_info.html#cor_class_info", "cor_class_info", 'routine in <a href="obj/cor/cor_class_info.html">cor_class_info.pro</a>', "cor_class_info.pro", "", "cor_class_info", "", "classesabbrevtags", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_count_descriptors.html", "cor_count_descriptors.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_count_descriptors.pro", "", "", " NAME: 	cor_count_descriptors    PURPOSE: 	Determines dimensions of an array of input descriptors.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	cor_count_descriptors, xds, nd=nd, nt=nt    ARGUMENTS:   INPUT: 	xds:		Array (nd,nt) of descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	nd:	First dimension, number of objects, default is 1.  	nt:	Second dimension, number of 'timesteps', default is 1.    RETURN: NONE     MODIFICATION HISTORY:  	Written by:	Spitale 	Copied to cor/:	Spitale 	2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_count_descriptors.html#cor_count_descriptors", "cor_count_descriptors", 'routine in <a href="obj/cor/cor_count_descriptors.html">cor_count_descriptors.pro</a>', "cor_count_descriptors.pro", "", "cor_count_descriptors", "", "ndntxds", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_create_descriptors.html", "cor_create_descriptors.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_create_descriptors.pro", "", "", " NAME: 	cor_create_descriptors    PURPOSE: 	Init method for the CORE class.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	crd = cor_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	 Number of descriptors to create.    OUTPUT: NONE    KEYWORDS:   INPUT: 	crd:	Core descriptor(s) to initialize, instead of creating a new one.  	name:	 String giving the name of the descriptor.  	user:	 String giving the username for the descriptor.  	tasks:	 String array giving the initial task list.    OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized core descriptors depending 	on the presence of the crd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_create_descriptors.html#cor_create_descriptors", "cor_create_descriptors", 'routine in <a href="obj/cor/cor_create_descriptors.html">cor_create_descriptors.pro</a>', "cor_create_descriptors.pro", "", "cor_create_descriptors", "", "crdn@cor__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_create_gd.html", "cor_create_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_create_gd.pro", "", "", " NAME: 	cor_create_gd    PURPOSE: 	Creates a generic descriptor from a set of given descriptors.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	new_gd = cor_create_gd(xds, gd=gd, <descriptor output keywords>    ARGUMENTS:   INPUT: 	xds:	Array of descriptors.  If given, any generic descriptors 		contained within these descriptors are also included (unless 		/explicit).  A generic descriptor may also be given as the 		argument to this function.    OUTPUT: NONE    KEYWORDS:   INPUT: 	gd:	Generic descriptor.  Fields from this descriptor will be 		included in the output.  	<x>d:	Input keyword for each descriptor type to include in 		new generic descriptor.  	explicit: 		If set, generic descriptors contained in input descriptors 		are not included in the output.    OUTPUT: NONE    RETURN: 	Generic descriptor containing all of the input fields, and any 	descripors contained in gd.  Any invalid objects are culled out.     MODIFICATION HISTORY:  	Written by:	Spitale 	Moved to CORE	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_create_gd.html#cor_create_gd", "cor_create_gd", 'routine in <a href="obj/cor/cor_create_gd.html">cor_create_gd.pro</a>', "cor_create_gd.pro", "", "cor_create_gd", "", "gdexplicit_extra_xds", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/cor/cor_create_gd.html#___cor_create_gd", "___cor_create_gd", 'routine in <a href="obj/cor/cor_create_gd.html">cor_create_gd.pro</a>', "cor_create_gd.pro", "", "___cor_create_gd", "", "gdexplicit_extra_xds", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_cull.html", "cor_cull.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_cull.pro", "", "", " NAME: 	cor_cull    PURPOSE: 	Removes null objects from an array.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	new_ptd = cor_cull(ptd)    ARGUMENTS:   INPUT: 	ptd:	Array of objects.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array objects, or !null if all were empty.     MODIFICATION HISTORY:   Spitale, 3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_cull.html#cor_cull", "cor_cull", 'routine in <a href="obj/cor/cor_cull.html">cor_cull.pro</a>', "cor_cull.pro", "", "cor_cull", "", "crd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_dereference.html", "cor_dereference.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_dereference.pro", "", "", " NAME: 	cor_dereference    PURPOSE: 	Turns an array of objects into an array of structures.    CATEGORY: 	NV/SYS/COR    CALLING SEQUENCE: 	result = cor_dereference(xd)    ARGUMENTS:   INPUT: 	xd:	Array of objects.  Objects may have different classes, but only 		their common fields are dereferenced.    OUTPUT: 	NONE    KEYWORDS: NONE    RETURN: 	Array of structures.    STATUS: 	Complete    SEE ALSO: 	cor_rereference    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2002  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_dereference.html#cor_dereference", "cor_dereference", 'routine in <a href="obj/cor/cor_dereference.html">cor_dereference.pro</a>', "cor_dereference.pro", "", "cor_dereference", "", "xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_dereference_gd.html", "cor_dereference_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_dereference_gd.pro", "", "", " NAME: 	cor_dereference_gd    PURPOSE: 	Dereferences a generic descriptor.    CATEGORY: 	NV/PGS    CALLING SEQUENCE: 	xds = cor_dereference_gd(gd, <descriptor output keywords>)    ARGUMENTS:   INPUT: 	gd:	Generic descriptor.  	name:	If given, only descriptors whose names appear in this array 		will be returned.  If no descriptor keywords are 		speciied (see below), then all fields are searched for 		descriptors with these names.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<x>d:	Standard descriptor keywords.  Setting a keyword causes the 		corresponding field of the generic descriptor to be returned.    OUTPUT: NONE    RETURN: 	Array of descriptors or zero if no fields found.     MODIFICATION HISTORY: 	Moved to CORE	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_dereference_gd.html#cor_dereference_gd", "cor_dereference_gd", 'routine in <a href="obj/cor/cor_dereference_gd.html">cor_dereference_gd.pro</a>', "cor_dereference_gd.pro", "", "cor_dereference_gd", "", "name_ref_extragd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_evolve.html", "cor_evolve.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_evolve.pro", "", "", " NAME: 	cor_evolve    PURPOSE: 	Calls the 'evolve' method appropriate for the given descriptor.    CATEGORY: 	NV/SYS/COR    CALLING SEQUENCE: 	xdt = cor_evolve(xd, dt)    ARGUMENTS:   INPUT: 	xd:	 Any subclass of BODY.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, velocities will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.    OUTPUT: NONE    RETURN: 	Array (nxd,ndt) of newly allocated descriptors, of the same class 	as xd, evolved by time dt, where nxd is the number of xd, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_evolve.html#cor_evolve", "cor_evolve", 'routine in <a href="obj/cor/cor_evolve.html">cor_evolve.pro</a>', "cor_evolve.pro", "", "cor_evolve", "", "nodvcopyxddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_gd.html", "cor_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_gd.pro", "", "", " NAME: 	cor_gd    PURPOSE: 	Returns the generic descriptor for a CORE object.    CATEGORY: 	NV/PGS    CALLING SEQUENCE: 	gd = cor_gd(crd)    ARGUMENTS:   INPUT: 	crd:	Subclass of CORE.  Multiple descriptors may be given, 		but an error will result if their generic descriptors 		are incompatible.  	name:	If given, only descriptors whose names appear in this aray 		will be returned.  If no descriptor keywords are 		specified (see below), then all fields are searched for 		descriptors with these names.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<x>d:	Standard descriptor keywords.  Setting a keyword causes 		the corresponding field of the generic descriptor to be 		returned instead of the generic descriptor.  	noevent: 		If set, no event is generated.    OUTPUT: NONE     RETURN: 	Generic descriptor.     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_gd.html#cor_gd", "cor_gd", 'routine in <a href="obj/cor/cor_gd.html">cor_gd.pro</a>', "cor_gd.pro", "", "cor_gd", "", "namenoevent_ref_extracrd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_init_state.html", "cor_init_state.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_init_state.pro", "", "", " NAME: 	cor_init_state    PURPOSE: 	Initializes the CORE state structure.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	state = cor_init_state()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	New core state structure.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale		5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_init_state.html#cor_init_state", "cor_init_state", 'routine in <a href="obj/cor/cor_init_state.html">cor_init_state.pro</a>', "cor_init_state.pro", "", "cor_init_state", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_isa.html", "cor_isa.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_isa.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_isa.html#cor_isa", "cor_isa", 'routine in <a href="obj/cor/cor_isa.html">cor_isa.pro</a>', "cor_isa.pro", "", "cor_isa", "", "odclass", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_match_gd.html", "cor_match_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_match_gd.pro", "", "", " NAME: 	cor_match_gd    PURPOSE: 	Compares generic descriptors.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	status = cor_match_gd(gd1, gd2)    ARGUMENTS:   INPUT: 	gd1, gd2:	Generic descriptors to compare, or object descriptors 			containing generic descriptors to compare.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	True if the generic descriptors match, false otherwise.  The 	fields in each structure do not have to be in the same order.     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_match_gd.html#cmgd_compare", "cmgd_compare", 'routine in <a href="obj/cor/cor_match_gd.html">cor_match_gd.pro</a>', "cor_match_gd.pro", "", "cmgd_compare", "", "gd1gd2", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/cor/cor_match_gd.html#cor_match_gd", "cor_match_gd", 'routine in <a href="obj/cor/cor_match_gd.html">cor_match_gd.pro</a>', "cor_match_gd.pro", "", "cor_match_gd", "", "_gd1_gd2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_name.html", "cor_name.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_name.pro", "", "", " NAME: 	cor_name    PURPOSE: 	Returns the name for each given core descriptor.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	name = cor_name(crd)    ARGUMENTS:   INPUT: NONE 	crd:	 Any subclass of CORE.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Name associated with each given core descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 4/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_name.html#cor_name", "cor_name", 'routine in <a href="obj/cor/cor_name.html">cor_name.pro</a>', "cor_name.pro", "", "cor_name", "", "noeventcrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_query.html", "cor_query.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_query.pro", "", "", " NAME: 	cor_query    PURPOSE: 	Returns fields associated with a CORE object.  This is a 	fast way of retrieving multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	cor_query, xd, <keywords>=<values>    ARGUMENTS:   INPUT: 	xd:	CORE object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	POINT object fields to retrieve.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 1/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_query.html#cor_query", "cor_query", 'routine in <a href="obj/cor/cor_query.html">cor_query.pro</a>', "cor_query.pro", "", "cor_query", "", "noeventxd@cor__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_replicate.html", "cor_replicate.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_replicate.pro", "", "", " NAME: 	cor_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	xd = cor_replicate(crx, dim)    ARGUMENTS:   INPUT: 	crx:	 Any subclass of CORE.  Only one descriptor may be provided.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_replicate.html#cor_replicate", "cor_replicate", 'routine in <a href="obj/cor/cor_replicate.html">cor_replicate.pro</a>', "cor_replicate.pro", "", "cor_replicate", "", "crddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_rereference.html", "cor_rereference.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_rereference.pro", "", "", " NAME: 	cor_rereference    PURPOSE: 	Copies an array of structures into an array of objects.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	cor_rereference, xd, _xd    ARGUMENTS:   INPUT: 	xd:	Array of objects.  	_xd:	Array of structures.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	new:	If set, new pointers will be allocated in xd.    OUTPUT: NONE    RETURN: 	NONE    STATUS: 	Complete    SEE ALSO: 	cor_dereference    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2002  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_rereference.html#cor_rereference", "cor_rereference", 'routine in <a href="obj/cor/cor_rereference.html">cor_rereference.pro</a>', "cor_rereference.pro", "", "cor_rereference", "", "newxd_xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_select.html", "cor_select.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_select.pro", "", "", " NAME: 	cor_select    PURPOSE: 	Selects descriptors based on given criteria.    CATEGORY: 	NV/SYS/COR    CALLING SEQUENCE: 	xd = cor_select(crx, key)    ARGUMENTS:   INPUT: 	crx:	 Array of descriptors of any subclass of CORE.  	key:	 Array of key to select.    OUTPUT: NONE    KEYWORDS:   INPUT: 	name:	Match by descriptor name.  	class:	Match by descriptor class.  	rm:	If set, the selected descriptors are removed from the 	        input array.     OUTPUT: NONE    RETURN: 	All descriptors in crx whose parameters match the given key. 	0 if no matches found.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Rewritten by:	Spitale, 4/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_select.html#cor_select", "cor_select", 'routine in <a href="obj/cor/cor_select.html">cor_select.pro</a>', "cor_select.pro", "", "cor_select", "", "indicesrmnoeventnameclasscrxkey", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_set_field.html", "cor_set_field.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_set_field.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_set_field.html#cor_set_field", "cor_set_field", 'routine in <a href="obj/cor/cor_set_field.html">cor_set_field.pro</a>', "cor_set_field.pro", "", "cor_set_field", "", "foundnoeventodptag_namevalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_set_gd.html", "cor_set_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_set_gd.pro", "", "", " NAME: 	cor_set_gd    PURPOSE: 	Sets the generic descriptor in a CORE object.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	cor_set_gd, crd, gd    ARGUMENTS:   INPUT: 	crd:		CORE object.  The fields from any existing generic 			descriptor in this object are retained in the new one. 			Only one object allowed.  	gd:		New gd.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<x>d:		Input keyword for each descriptor type.  	xds:		Array of objects to put in generic descriptor.  Generic 			descriptors in these objects are considered as well.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	cor_gd     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_set_gd.html#cor_set_gd", "cor_set_gd", 'routine in <a href="obj/cor/cor_set_gd.html">cor_set_gd.pro</a>', "cor_set_gd.pro", "", "cor_set_gd", "", "xdsnoeventdirect_ref_extracrd0gd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_set_name.html", "cor_set_name.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_set_name.pro", "", "", " NAME: 	cor_set_name    PURPOSE: 	Replaces the name for each given core descriptor.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	cor_set_name, crx, name    ARGUMENTS:   INPUT: NONE 	crx:	 Any subclass of CORE.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_set_name.html#cor_set_name", "cor_set_name", 'routine in <a href="obj/cor/cor_set_name.html">cor_set_name.pro</a>', "cor_set_name.pro", "", "cor_set_name", "", "noeventcrdname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_set_udata.html", "cor_set_udata.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_set_udata.pro", "", "", " NAME: 	cor_set_udata    PURPOSE: 	Stores user data in a descriptor and associates it with the 	specified name. If multiple descriptors, then the trailing dimension 	must match the number of descriptors.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	cor_set_udata, crx, name, data    ARGUMENTS:   INPUT: 	crx:	 Any subclass of CORE.  Only one descriptor may be provided.  	name:	 Name to associate with the data.  If the name already exists, 		 then the data is overwritten.  	data:	 Data to store.  If multiple crx supplied, then the trailing 		 dimension must match the number of descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_set_udata.html#cor_set_udata", "cor_set_udata", 'routine in <a href="obj/cor/cor_set_udata.html">cor_set_udata.pro</a>', "cor_set_udata.pro", "", "cor_set_udata", "", "noeventcrdnameudata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_state.html", "cor_state.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_state.pro", "", "", " NAME: 	cor_state    PURPOSE: 	Builds a class tree for the given descriptor.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	cor_state, <options>    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	trace:	New value for the trace flag.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale		5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_state.html#cor_state", "cor_state", 'routine in <a href="obj/cor/cor_state.html">cor_state.pro</a>', "cor_state.pro", "", "cor_state", "", "trace", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_tag.html", "cor_tag.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_tag.pro", "", "", " NAME: 	cor_tag    PURPOSE: 	Returns the tag name for the given object class.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	tag = cor_tag(xd)    ARGUMENTS:   INPUT: 	xd:	 Descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	x:	If set, the generic form is returned, e.g, 'CRX'.    OUTPUT: NONE    RETURN: 	String giving the standard tag for the given class, e.g., 'CRD'.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_tag.html#cor_tag", "cor_tag", 'routine in <a href="obj/cor/cor_tag.html">cor_tag.pro</a>', "cor_tag.pro", "", "cor_tag", "", "xnoeventcrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_tasks.html", "cor_tasks.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_tasks.pro", "", "", " NAME: 	cor_tasks    PURPOSE: 	Returns the descriptor task list.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	tasks = cor_tasks(crx)    ARGUMENTS:   INPUT: 	crx:	 Any subclass of CORE.  Only one descriptor may be provided.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	String array containing the list of all programs that have modified 	the given descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_tasks.html#cor_tasks", "cor_tasks", 'routine in <a href="obj/cor/cor_tasks.html">cor_tasks.pro</a>', "cor_tasks.pro", "", "cor_tasks", "", "noeventcrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_test.html", "cor_test.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_test.pro", "", "", " NAME: 	cor_test    PURPOSE: 	Tests whether the input is an OMINAS object or object structure.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	data = cor_test(xd)    ARGUMENTS:   INPUT: 	xd:	 Any subclass of CORE.  Only one descriptor may be provided.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	True if xd is an OMINAS object or object structure, false otherwise.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_test.html#cor_test", "cor_test", 'routine in <a href="obj/cor/cor_test.html">cor_test.pro</a>', "cor_test.pro", "", "cor_test", "", "noeventxd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_test_gd.html", "cor_test_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_test_gd.pro", "", "", " NAME: 	cor_test_gd    PURPOSE: 	Tests whether a generic descriptor field exists and contains a 	descriptor.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	data = cor_test_gd(gd, tag)    ARGUMENTS:   INPUT: 	gd:	 Generic descriptor.  	tag:	 Name of field to test.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	True if gd contains the tag and it is a valid descriptor, false otherwise.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_test_gd.html#cor_test_gd", "cor_test_gd", 'routine in <a href="obj/cor/cor_test_gd.html">cor_test_gd.pro</a>', "cor_test_gd.pro", "", "cor_test_gd", "", "gdtag", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_test_udata.html", "cor_test_udata.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_test_udata.pro", "", "", " NAME: 	cor_test_udata    PURPOSE: 	Tests the existence of data stored in a descriptor under the 	specified name.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	data = cor_test_udata(crx, name)    ARGUMENTS:   INPUT: 	crx:	 Any subclass of CORE.  Only one descriptor may be provided.  	name:	 Name associated with the data to test.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	True if the data is stored under the given name, false otherwise.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_test_udata.html#cor_test_udata", "cor_test_udata", 'routine in <a href="obj/cor/cor_test_udata.html">cor_test_udata.pro</a>', "cor_test_udata.pro", "", "cor_test_udata", "", "noeventcrdname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_tree.html", "cor_tree.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_tree.pro", "", "", " NAME: 	cor_tree    PURPOSE: 	Builds a class tree for the given descriptor.    CATEGORY: 	NV/SYS/COR    CALLING SEQUENCE: 	classes = cor_tree(od)    ARGUMENTS:   INPUT: 	od:	 Descriptor of any class.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	String array giving the names of all classes in od, in descending order.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_tree.html#cor_tree", "cor_tree", 'routine in <a href="obj/cor/cor_tree.html">cor_tree.pro</a>', "cor_tree.pro", "", "cor_tree", "", "od", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_udata.html", "cor_udata.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_udata.pro", "", "", " NAME: 	cor_udata    PURPOSE: 	Retrieves user data stored in a descriptor under the specified name.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	data = cor_udata(crx, name)    ARGUMENTS:   INPUT: 	crx:	 Any subclass of CORE.  If multiple crx are provided, then 		 the trailing dimension represents each each descriptor.  	name:	 Name associated with the data.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Data associated with the given name.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_udata.html#cor_udata", "cor_udata", 'routine in <a href="obj/cor/cor_udata.html">cor_udata.pro</a>', "cor_udata.pro", "", "cor_udata", "", "noeventcrdname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_user.html", "cor_user.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_user.pro", "", "", " NAME: 	cor_user    PURPOSE: 	Returns the username for each given core descriptor.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	user = cor_user(crx)    ARGUMENTS:   INPUT: NONE 	crx:	 Any subclass of CORE.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Username associated with each given core descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_user.html#cor_user", "cor_user", 'routine in <a href="obj/cor/cor_user.html">cor_user.pro</a>', "cor_user.pro", "", "cor_user", "", "noeventcrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/core_state_struct__define.html", "core_state_struct__define.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "core_state_struct__define.pro", "", "", " NAME: 	core_state_struct__define    PURPOSE: 	Structure defining the CORE state.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	N/A    FIELDS: 	trace:		Specifies whether trace information is printed 			or object routines.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/core_state_struct__define.html#core_state_struct__define", "core_state_struct__define", 'routine in <a href="obj/cor/core_state_struct__define.html">core_state_struct__define.pro</a>', "core_state_struct__define.pro", "", "core_state_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/corot_to_disk.html", "corot_to_disk.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "corot_to_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/corot_to_disk.html#corot_to_disk", "corot_to_disk", 'routine in <a href="obj/tools/corot_to_disk.html">corot_to_disk.pro</a>', "corot_to_disk.pro", "", "corot_to_disk", "", "cddkxgbxt0dmldttimescorot_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/corot_to_disk_lon.html", "corot_to_disk_lon.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "corot_to_disk_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/corot_to_disk_lon.html#corot_to_disk_lon", "corot_to_disk_lon", 'routine in <a href="obj/tools/corot_to_disk_lon.html">corot_to_disk_lon.pro</a>', "corot_to_disk_lon.pro", "", "corot_to_disk_lon", "", "cddkxgbxt0dmldttimescorot_lons", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_add_transient_keyvals.html", "dat_add_transient_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_add_transient_keyvals.pro", "", "", " NAME: 	dat_add_transient_keyvals    PURPOSE: 	Records keyword/value pairs from a transient argument string.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_add_transient_keyvals, dd, trs    ARGUMENTS:   INPUT: 	dd:	Data descriptor in which to record transient keyvals.  	trs:	Transient argument string.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_add_transient_keyvals.html#dat_add_transient_keyvals", "dat_add_transient_keyvals", 'routine in <a href="obj/dat/dat_add_transient_keyvals.html">dat_add_transient_keyvals.pro</a>', "dat_add_transient_keyvals.pro", "", "dat_add_transient_keyvals", "", "_ddtrs", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_assign.html", "dat_assign.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_assign.pro", "", "", " NAME: 	dat_assign    PURPOSE: 	Replaces fields in a CAMERA object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	dat_assign, cd, <keywords>=<values>    ARGUMENTS:   INPUT: 	cd:		CAMERA object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	CAMERA fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dat_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_assign.html#dat_assign", "dat_assign", 'routine in <a href="obj/dat/dat_assign.html">dat_assign.pro</a>', "dat_assign.pro", "", "dat_assign", "", "noeventxd@dat__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_cache.html", "dat_cache.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_cache.pro", "", "", " NAME: 	dat_cache    PURPOSE: 	Returns a long integer indicating the maximum size of a data array. 	This value may be adjusted using the environment variable 'DAT_CACHE'. 	-1 is returned if it cannot be determined.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	cache = dat_cache()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    ENVIRONMENT VARIABLES: 	DAT_CACHE:	Sets the size of the cache.    RETURN: 	Current cache value.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_cache.html#dat_cache", "dat_cache", 'routine in <a href="obj/dat/dat_cache.html">dat_cache.pro</a>', "dat_cache.pro", "", "dat_cache", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_compress.html", "dat_compress.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_compress.pro", "", "", " NAME: 	dat_compress    PURPOSE: 	Returns the compression function suffix associated with a data 	descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	suffix = dat_compress(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	String giving the compression suffix.  The full name 	of the compression function is dat_compress_data_<suffix>.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_compress.html#dat_compress", "dat_compress", 'routine in <a href="obj/dat/dat_compress.html">dat_compress.pro</a>', "dat_compress.pro", "", "dat_compress", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_compress_data_mask.html", "dat_compress_data_mask.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_compress_data_mask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_compress_data_mask.html#dat_compress_data_mask", "dat_compress_data_mask", 'routine in <a href="obj/dat/dat_compress_data_mask.html">dat_compress_data_mask.pro</a>', "dat_compress_data_mask.pro", "", "dat_compress_data_mask", "", "_dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_create_descriptors.html", "dat_create_descriptors.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_create_descriptors.pro", "", "", " NAME: 	dat_create_descriptors    PURPOSE: 	Creates and initializes a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dd = dat_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	 Number of descriptors to create.    OUTPUT: NONE    KEYWORDS:   INPUT: 	filename:	Name of data file.  	dim:		Array giving the dimensions of the data array.  	typecode:	Integer giving the type code of the data array.  	data:		Data array.  	nhist:		Number of past version of the data array to archive. 			If not given, the environment variable NV_NHIST is 			used.  If that is not set, then nhist defaults to 1.  	header:		Header array.  	filetype:	Filetype identifier string.  If not given 			an attempt is made to detect it.  	input_fn:	Name of function to read data file.  	output_fn:	Name of function to write data file.  	keyword_fn:	Name of function to read/write header keywords.  	instrument:	Instrument string.  If not given an 			attempt is made to detect it.  	input_transforms:	String array giving the names of the 				input transforms.  	output_transforms:	String array giving the names of the 				output transforms.  	maintain:	Data maintenance mode.  	compress:	Compression suffix.     OUTPUT: NONE 	input_translators:	String array giving the names of the 				input translators.  	output_translators:	String array giving the names of the 				output translators.     RETURN: 	Newly created and initialized data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_create_descriptors.html#dat_create_descriptors", "dat_create_descriptors", 'routine in <a href="obj/dat/dat_create_descriptors.html">dat_create_descriptors.pro</a>', "dat_create_descriptors.pro", "", "dat_create_descriptors", "", "crdddn@dat__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_data.html", "dat_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_data.pro", "", "", " NAME: 	dat_data    PURPOSE: 	Returns the data array associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_data(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	samples:  Sampling indices.  If set, only these data elements are 		  returned.  May be 1D or the same number of dimensions as 		  the data array.  	slice:	  Slice coordinates.  	current:  If set, the current loaded samples are returned.  In this 		  case, the sample indices are returned in the  samples  		  keyword.  	nd:       If set, the samples input is taken to be an ND coordinate 	          rather than a 1D subscript.  dat_data can normally tell 	          the difference automatically, but there is an ambiguity 	          if a single ND point is requested.  In that case, dat_data 	          interprets that as an array of 1D subscripts, unless /nd 	          is set.  	true:     If set, the actual data array is returned, even if there is 	          a sampling function.    OUTPUT: 	abscissa: The abscissa is returned in this array.  	samples:  Output sample indices for /current.    RETURN: 	The data array associated with the data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_set_data    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_data.html#dat_data", "dat_data", 'routine in <a href="obj/dat/dat_data.html">dat_data.pro</a>', "dat_data.pro", "", "dat_data", "", "samplescurrentslicendtruenoeventabscissadd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_detect_filetype.html", "dat_detect_filetype.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_detect_filetype.pro", "", "", " NAME: 	dat_detect_filetype    PURPOSE: 	Attempts to detect the type of the given file by calling the 	detectors in the filetype detectors table.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	filetype = dat_detect_filetype(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing filename to test.    OUTPUT: NONE    KEYWORDS:   INPUT: 	default:	If set, the 'default' filetype is returned. 			The default filetype is the first item in the table 			whose action is not 'IGNORE'.  	all:	If set, all filetypes in the table are returned.    OUTPUT: NONE    RETURN: 	String giving the filetype, or null string if none detected.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_detect_filetype.html#dat_detect_filetype", "dat_detect_filetype", 'routine in <a href="obj/dat/dat_detect_filetype.html">dat_detect_filetype.pro</a>', "dat_detect_filetype.pro", "", "dat_detect_filetype", "", "defaultallactiondd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_detect_instrument.html", "dat_detect_instrument.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_detect_instrument.pro", "", "", " NAME: 	dat_detect_instrument    PURPOSE: 	Attempts to detect the instrument for a data set by calling the 	detectors in the instrument detectors table.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	instrument = dat_detect_instrument(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing header an filetype.  	filetype:	Filetype from dat_detect_filetype.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	String giving the instrument, or 'DEFAULT' if none detected.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_detect_instrument.html#dat_detect_instrument", "dat_detect_instrument", 'routine in <a href="obj/dat/dat_detect_instrument.html">dat_detect_instrument.pro</a>', "dat_detect_instrument.pro", "", "dat_detect_instrument", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_dh.html", "dat_dh.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_dh.pro", "", "", " NAME: 	dat_dh    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_dh(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_dh.html#dat_dh", "dat_dh", 'routine in <a href="obj/dat/dat_dh.html">dat_dh.pro</a>', "dat_dh.pro", "", "dat_dh", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_dim.html", "dat_dim.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_dim.pro", "", "", " NAME: 	dat_dim    PURPOSE: 	Returns the dimensions of the data array in the given data 	descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dim = dat_dim(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	true:	If set, the dimension function is not called and the true 	 	dimensions of the dat are returned.    OUTPUT: NONE    RETURN: 	Array giving the dimensions of the data in the data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_dim.html#dat_dim", "dat_dim", 'routine in <a href="obj/dat/dat_dim.html">dat_dim.pro</a>', "dat_dim.pro", "", "dat_dim", "", "truenoeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_dim_data.html", "dat_dim_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_dim_data.pro", "", "", " NAME: 	dat_dim_data    PURPOSE: 	Returns the dimension function associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dim_data = dat_dim_data(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The dim_data associated with the data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_set_dim_data    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_dim_data.html#dat_dim_data", "dat_dim_data", 'routine in <a href="obj/dat/dat_dim_data.html">dat_dim_data.pro</a>', "dat_dim_data.pro", "", "dat_dim_data", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_dim_fn.html", "dat_dim_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_dim_fn.pro", "", "", " NAME: 	dat_dim_fn    PURPOSE: 	Returns the dimension function associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dim_fn = dat_dim_fn(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The dim_fn associated with the data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_set_dim_fn    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_dim_fn.html#dat_dim_fn", "dat_dim_fn", 'routine in <a href="obj/dat/dat_dim_fn.html">dat_dim_fn.pro</a>', "dat_dim_fn.pro", "", "dat_dim_fn", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_filename.html", "dat_filename.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_filename.pro", "", "", " NAME: 	dat_filename    PURPOSE: 	Returns the file name associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	filename = dat_filename(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	String giving the filename.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 12/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_filename.html#dat_filename", "dat_filename", 'routine in <a href="obj/dat/dat_filename.html">dat_filename.pro</a>', "dat_filename.pro", "", "dat_filename", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_filetype.html", "dat_filetype.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_filetype.pro", "", "", " NAME: 	dat_filetype    PURPOSE: 	Returns the filetype associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	filetype = dat_filetype(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	String giving the filetype.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_filetype.html#dat_filetype", "dat_filetype", 'routine in <a href="obj/dat/dat_filetype.html">dat_filetype.pro</a>', "dat_filetype.pro", "", "dat_filetype", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_gd.html", "dat_gd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_gd.pro", "", "", " NAME: 	dat_gd    PURPOSE: 	Dereferences a given generic descriptor, or the generic descriptor 	contained in a data descriptor.  Similar to cor_gd, but data 	descriptors are handled specially.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	xd = dat_gd(gd, <descriptor keywords>)    ARGUMENTS:   INPUT: 	gd:	Generic descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	dd:	Data descriptor.  If gd is undefined, the generic descriptor 		contained in this data descriptor is used instead.  If this 		keyword is set (i.e., /dd), then it is treated like the 		other descriptor keywords and a data desctipro is returned 		if one exists in the generic descriptor.  	<x>d:	Standard descriptor keywords.  Setting a keyword causes the 		corresponding field of the generic descriptor to be returned 		in the output array.    OUTPUT: NONE    RETURN: Array of descriptors corresponding to the selected keywords.     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_gd.html#dat_gd", "dat_gd", 'routine in <a href="obj/dat/dat_gd.html">dat_gd.pro</a>', "dat_gd.pro", "", "dat_gd", "", "dd_ref_extra_gd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_get_value.html", "dat_get_value.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_get_value.pro", "", "", " NAME: 	dat_get_value    PURPOSE: 	Calls input translators, supplying the given keyword, and builds 	a list of returned descriptors.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	xds = dat_get_value(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptors.  Must all have the same instrument 			string.  	keyword:	Keyword to pass to translators, describing the 			requested quantity.    OUTPUT: NONE    KEYWORDS:   INPUT: 	trs:		Transient argument string.  	tr_disable:	If set, dat_get_value returns without performing 			any action.  	tr_override:	Comma-delimited list of translators to use instead 			of those stored in dd.  	tr_first:	If set, dat_get_value returns after the first 			successful translator.  	tr_nosort:	By default, output descriptors are sorted to remove 			those with duplicate names, retaining only the first 			descriptor of a given name for each input data 			descriptor.  /tr_nosort disables this action.  	tr_order:	If set (and tr_nosort not set), dat_get_value selects 			the latest of any duplicately named output descriptors 			instead of the earliest.     OUTPUT: 	status:		0 if at least one translator call was successful, 			-1 otherwise.    RETURN: 	Array of descriptors returned from all successful translator calls. 	Descriptors are returned in the same order that the corresponding 	translators were called.  Each translator may produce multiple 	descriptors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_get_value.html#dat_get_value", "dat_get_value", 'routine in <a href="obj/dat/dat_get_value.html">dat_get_value.pro</a>', "dat_get_value.pro", "", "dat_get_value", "", "statustrsddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_gff.html", "dat_gff.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_gff.pro", "", "", " NAME: 	dat_gff    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_gff(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_gff.html#dat_gff", "dat_gff", 'routine in <a href="obj/dat/dat_gff.html">dat_gff.pro</a>', "dat_gff.pro", "", "dat_gff", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_header.html", "dat_header.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_header.pro", "", "", " NAME: 	dat_header    PURPOSE: 	Returns the header array associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	header = dat_header(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The header array associated with the data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_set_header    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_header.html#dat_header", "dat_header", 'routine in <a href="obj/dat/dat_header.html">dat_header.pro</a>', "dat_header.pro", "", "dat_header", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_header_value.html", "dat_header_value.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_header_value.pro", "", "", " NAME: 	dat_header_value    PURPOSE: 	Reads and write header keyword values.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_header_value, dd, keyword, get=get, set=set    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the keyword to get or set.    OUTPUT: NONE    KEYWORDS:   INPUT: 	set:	New value to write to the specified keyword.     OUTPUT: NONE 	get:	Value of the specified keyword read from the header.     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_header_value.html#dat_header_value", "dat_header_value", 'routine in <a href="obj/dat/dat_header_value.html">dat_header_value.pro</a>', "dat_header_value.pro", "", "dat_header_value", "", "getsetnoeventddkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_input_fn.html", "dat_input_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_input_fn.pro", "", "", " NAME: 	dat_input_fn    PURPOSE: 	Returns the input_fn value associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_input_fn(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The input_fn value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_input_fn.html#dat_input_fn", "dat_input_fn", 'routine in <a href="obj/dat/dat_input_fn.html">dat_input_fn.pro</a>', "dat_input_fn.pro", "", "dat_input_fn", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_input_keyvals.html", "dat_input_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_input_keyvals.pro", "", "", " NAME: 	dat_input_keyvals    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_input_keyvals(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_input_keyvals.html#dat_input_keyvals", "dat_input_keyvals", 'routine in <a href="obj/dat/dat_input_keyvals.html">dat_input_keyvals.pro</a>', "dat_input_keyvals.pro", "", "dat_input_keyvals", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_input_transforms.html", "dat_input_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_input_transforms.pro", "", "", " NAME: 	dat_input_transforms    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_input_transforms(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_input_transforms.html#dat_input_transforms", "dat_input_transforms", 'routine in <a href="obj/dat/dat_input_transforms.html">dat_input_transforms.pro</a>', "dat_input_transforms.pro", "", "dat_input_transforms", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_input_translators.html", "dat_input_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_input_translators.pro", "", "", " NAME: 	dat_input_translators    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_input_translators(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_input_translators.html#dat_input_translators", "dat_input_translators", 'routine in <a href="obj/dat/dat_input_translators.html">dat_input_translators.pro</a>', "dat_input_translators.pro", "", "dat_input_translators", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_instrument.html", "dat_instrument.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_instrument.pro", "", "", " NAME: 	dat_instrument    PURPOSE: 	Returns the instrument string associated with a data descriptor.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	instrument = dat_instrument(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The instrument string associated with the data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2001  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_instrument.html#dat_instrument", "dat_instrument", 'routine in <a href="obj/dat/dat_instrument.html">dat_instrument.pro</a>', "dat_instrument.pro", "", "dat_instrument", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_keyword_fn.html", "dat_keyword_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_keyword_fn.pro", "", "", " NAME: 	dat_keyword_fn    PURPOSE: 	Returns the keyword_fn value associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_keyword_fn(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The keyword_fn value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_keyword_fn.html#dat_keyword_fn", "dat_keyword_fn", 'routine in <a href="obj/dat/dat_keyword_fn.html">dat_keyword_fn.pro</a>', "dat_keyword_fn.pro", "", "dat_keyword_fn", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_load_data.html", "dat_load_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_load_data.pro", "", "", " NAME: 	dat_load_data    PURPOSE: 	Loads the data array for a given data descriptor.  Adds to 	NV state maintained list if maintain == 1.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_load_data(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor to test.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Loaded data array.    KNOWN BUGS: 	Subsampling (ie. caching) is unreliable.  Lines or other anomalies 	often appear in subsampled images.  This does not seem to happen 	with integer sampling (e.g. integer zooms in tvim or grim), so it 	may be related to rounding or truncating of indices.  It may also be 	a problem with the set arithmetic.  Caching is currently disabled 	(see (*_dd.dd0p).cache = -1 below) until it can be fixed.    STATUS: 	Some bugs.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_load_data.html#dat_load_data", "dat_load_data", 'routine in <a href="obj/dat/dat_load_data.html">dat_load_data.pro</a>', "dat_load_data.pro", "", "dat_load_data", "", "sampledatadd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_lookup_io.html", "dat_lookup_io.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_lookup_io.pro", "", "", " NAME: 	dat_lookup_io    PURPOSE: 	Looks up the names of the data input and output functions in 	the I/O table.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_lookup_io, filetype, input_fn, output_fn    ARGUMENTS:   INPUT: 	filetype:	Filetype string from dat_detect_filetype.    OUTPUT: 	input_fn:	Name of the input function.  	output_fn:	Name of the output function.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_lookup_io.html#dat_lookup_io", "dat_lookup_io", 'routine in <a href="obj/dat/dat_lookup_io.html">dat_lookup_io.pro</a>', "dat_lookup_io.pro", "", "dat_lookup_io", "", "filetypeinput_fnoutput_fnkeyword_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_lookup_transforms.html", "dat_lookup_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_lookup_transforms.pro", "", "", " NAME: 	dat_lookup_transforms    PURPOSE: 	Looks up the names of the data input and output functions in 	the I/O table.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_lookup_transforms, instrument, input_transforms, output_transforms    ARGUMENTS:   INPUT: 	instrument:	Instrument string from dat_detect_instrument.    OUTPUT: 	input_transforms:	Array giving the names of the input transform 				functions.  	output_transforms:	Array giving the names of the output transform 				functions.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_lookup_transforms.html#dat_lookup_transforms", "dat_lookup_transforms", 'routine in <a href="obj/dat/dat_lookup_transforms.html">dat_lookup_transforms.pro</a>', "dat_lookup_transforms.pro", "", "dat_lookup_transforms", "", "tab_transformsinstrumentinput_transformsoutput_transforms", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_lookup_translators.html", "dat_lookup_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_lookup_translators.pro", "", "", " NAME: 	dat_lookup_translators    PURPOSE: 	Looks up the names of the data input and output tranlators in 	the translators table.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_lookup_translators, instrument, input_translators, output_translators    ARGUMENTS:   INPUT: 	instrument:	Instrument string from dat_detect_instrument.    OUTPUT: 	input_translators:	Array giving the names of the input translator 				functions.  	output_translators:	Array giving the names of the output translator 				functions.  	input_keyvals:	Array giving the keyword/value pairs the from the 			translators table, for each input translator.  	output_keyvals:	Array giving the keyword/value pairs the from the 			translators table, for each output translator.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_lookup_translators.html#dltr_extract", "dltr_extract", 'routine in <a href="obj/dat/dat_lookup_translators.html">dat_lookup_translators.pro</a>', "dat_lookup_translators.pro", "", "dltr_extract", "", "tableinstrumentinput_translatorsoutput_translatorsinput_keyvalsoutput_keyvals", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dat/dat_lookup_translators.html#dat_lookup_translators", "dat_lookup_translators", 'routine in <a href="obj/dat/dat_lookup_translators.html">dat_lookup_translators.pro</a>', "dat_lookup_translators.pro", "", "dat_lookup_translators", "", "tab_translatorsinstrumentinput_translatorsoutput_translatorsinput_keyvalsoutput_keyvals", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_maintain.html", "dat_maintain.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_maintain.pro", "", "", " NAME: 	dat_maintain    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_maintain(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_maintain.html#dat_maintain", "dat_maintain", 'routine in <a href="obj/dat/dat_maintain.html">dat_maintain.pro</a>', "dat_maintain.pro", "", "dat_maintain", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_manage_dd.html", "dat_manage_dd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_manage_dd.pro", "", "", " NAME: 	dat_manage_dd    PURPOSE: 	Adds a data descriptor to the NV state maintained list.  If the list 	is full, the oldest descriptor is unloaded and removed.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_manage_dd, dd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_manage_dd.html#dat_manage_dd", "dat_manage_dd", 'routine in <a href="obj/dat/dat_manage_dd.html">dat_manage_dd.pro</a>', "dat_manage_dd.pro", "", "dat_manage_dd", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_max.html", "dat_max.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_max.pro", "", "", " NAME: 	dat_max    PURPOSE: 	Returns the max value associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_max(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The max value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_max.html#dat_max", "dat_max", 'routine in <a href="obj/dat/dat_max.html">dat_max.pro</a>', "dat_max.pro", "", "dat_max", "", "noeventabscissadd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_min.html", "dat_min.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_min.pro", "", "", " NAME: 	dat_min    PURPOSE: 	Returns the min value associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_min(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The min value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_min.html#dat_min", "dat_min", 'routine in <a href="obj/dat/dat_min.html">dat_min.pro</a>', "dat_min.pro", "", "dat_min", "", "noeventabscissadd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_n.html", "dat_n.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_n.pro", "", "", " NAME: 	dat_n    PURPOSE: 	Returns the number of elements in the data array in the given data 	descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dim = dat_n(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	true:	If set, the dimension function is not called and the true 	 	length of the data is returned.    OUTPUT: NONE    RETURN: 	Number of elements in the data in the data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_n.html#dat_n", "dat_n", 'routine in <a href="obj/dat/dat_n.html">dat_n.pro</a>', "dat_n.pro", "", "dat_n", "", "truenoeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_ndd.html", "dat_ndd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_ndd.pro", "", "", " NAME: 	dat_ndd    PURPOSE: 	Returns the global maintenance ndd value.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_ndd(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The global maintenance ndd value.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_ndd.html#dat_ndd", "dat_ndd", 'routine in <a href="obj/dat/dat_ndd.html">dat_ndd.pro</a>', "dat_ndd.pro", "", "dat_ndd", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_nhist.html", "dat_nhist.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_nhist.pro", "", "", " NAME: 	dat_nhist    PURPOSE: 	Returns the number of archived data states.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nhist = dat_nhist(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Integer giving the number of past data states archived 	in the data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_nhist.html#dat_nhist", "dat_nhist", 'routine in <a href="obj/dat/dat_nhist.html">dat_nhist.pro</a>', "dat_nhist.pro", "", "dat_nhist", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_output_fn.html", "dat_output_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_output_fn.pro", "", "", " NAME: 	dat_output_fn    PURPOSE: 	Returns the output_fn value associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_output_fn(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The output_fn value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_output_fn.html#dat_output_fn", "dat_output_fn", 'routine in <a href="obj/dat/dat_output_fn.html">dat_output_fn.pro</a>', "dat_output_fn.pro", "", "dat_output_fn", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_output_keyvals.html", "dat_output_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_output_keyvals.pro", "", "", " NAME: 	dat_output_keyvals    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_output_keyvals(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_output_keyvals.html#dat_output_keyvals", "dat_output_keyvals", 'routine in <a href="obj/dat/dat_output_keyvals.html">dat_output_keyvals.pro</a>', "dat_output_keyvals.pro", "", "dat_output_keyvals", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_output_transforms.html", "dat_output_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_output_transforms.pro", "", "", " NAME: 	dat_output_transforms    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_output_transforms(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_output_transforms.html#dat_output_transforms", "dat_output_transforms", 'routine in <a href="obj/dat/dat_output_transforms.html">dat_output_transforms.pro</a>', "dat_output_transforms.pro", "", "dat_output_transforms", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_output_translators.html", "dat_output_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_output_translators.pro", "", "", " NAME: 	dat_output_translators    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_output_translators(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_output_translators.html#dat_output_translators", "dat_output_translators", 'routine in <a href="obj/dat/dat_output_translators.html">dat_output_translators.pro</a>', "dat_output_translators.pro", "", "dat_output_translators", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_parse_keyval.html", "dat_parse_keyval.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_parse_keyval.pro", "", "", " NAME: 	dat_parse_keyval    PURPOSE: 	Parses a string containing a keyword=value pair.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_parse_keyval, keyval, keyword, value    ARGUMENTS:   INPUT: 	keyval:		String of the form <keyword>=<value>.    OUTPUT: 	keyword:	String giving the keyword.  	value:		String giving the value.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_parse_keyval.html#dat_parse_keyval", "dat_parse_keyval", 'routine in <a href="obj/dat/dat_parse_keyval.html">dat_parse_keyval.pro</a>', "dat_parse_keyval.pro", "", "dat_parse_keyval", "", "_keyvalkeywordvalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_parse_keyvals.html", "dat_parse_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_parse_keyvals.pro", "", "", " NAME: 	dat_parse_keyvals    PURPOSE: 	Parses an array strings containing keyword=value pairs.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	kv = dat_parse_keyvals(keyvals)    ARGUMENTS:   INPUT: 	keyvals:	Array of strings of the form <keyword>=<value>.    OUTPUT:    KEYWORDS:   INPUT: NONE    OUTPUT: 	keywords:	Array of keywords.    RETURN: 	Array of type keyval_struct containing the parsed keywords 	and values.  One element per input array element.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_parse_keyvals.html#dat_parse_keyvals", "dat_parse_keyvals", 'routine in <a href="obj/dat/dat_parse_keyvals.html">dat_parse_keyvals.pro</a>', "dat_parse_keyvals.pro", "", "dat_parse_keyvals", "", "keywordskeyvals", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_parse_transient_keyvals.html", "dat_parse_transient_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_parse_transient_keyvals.pro", "", "", " NAME: 	dat_parse_transient_keyvals    PURPOSE: 	Parses a comma-delimited transient argument string into an of array 	of strings containing keyword=value pairs.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	keyvals = dat_parse_transient_keyvals(trs)    ARGUMENTS:   INPUT: 	trs:	Transient argument string.    OUTPUT:    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array of strings containing keyword=value pairs.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_parse_transient_keyvals.html#dat_parse_transient_keyvals", "dat_parse_transient_keyvals", 'routine in <a href="obj/dat/dat_parse_transient_keyvals.html">dat_parse_transient_keyvals.pro</a>', "dat_parse_transient_keyvals.pro", "", "dat_parse_transient_keyvals", "", "trs", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_put_value.html", "dat_put_value.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_put_value.pro", "", "", " NAME: 	dat_put_value    PURPOSE: 	Calls output translators, supplying the given keyword and value.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_put_value, dd, keyword, value    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	Keyword to pass to translators, describing the 			requested quantity.  	value:		Value to write through the translators.    OUTPUT: NONE    KEYWORDS:   INPUT: 	trs:		Transient argument string.  	tr_disable:	If set, dat_get_value returns without performing 			any action.  	tr_override:	Comma-delimited list of translators to use instead 			of those stored in dd.    OUTPUT: 	status:		0 if at least one translator call was successful, 			-1 otherwise.    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_put_value.html#dat_put_value", "dat_put_value", 'routine in <a href="obj/dat/dat_put_value.html">dat_put_value.pro</a>', "dat_put_value.pro", "", "dat_put_value", "", "trsstatusddkeywordvalue@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_query.html", "dat_query.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_query.pro", "", "", " NAME: 	dat_query    PURPOSE: 	Returns the fields associated with a CAMERA object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	dat_query, cd, <keywords>=<values>    ARGUMENTS:   INPUT: 	cd:	CAMERA object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	CAMERA object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_query.html#dat_query", "dat_query", 'routine in <a href="obj/dat/dat_query.html">dat_query.pro</a>', "dat_query.pro", "", "dat_query", "", "conditioncatnoeventxd@dat__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_read.html", "dat_read.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_read.pro", "", "", " NAME: 	dat_read    PURPOSE: 	Reads a data file of arbitrary format and produces a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dd = dat_read(filespec [, data, header])    ARGUMENTS:   INPUT: 	filespec:	Array of strings giving file specifications for 			file to read.    OUTPUT: 	data:		Data array from the last file read.  This is provided 			as a convenience when reading single files so that 			it is not necessary to call dat_data to get the array.  	header:		Header array from the last file read.  This is provided 			as a convenience when reading single files so that 			it is not necessary to call dat_header to get the array.    KEYWORDS:   INPUT: 	filetype:	Overrides automatic filetype detection.  	input_fn:	Overrides input function lookup.  	output_fn:	Overrides output function lookup.  	tab_translators:	Name of translators table to use instead of 				that given by the environment variable 				NV_TRANSLATORS.  If no path is given, then the 				file is assumed to reside in the same directory 				as the translator named by the NV_TRANSLATORS 				environment variable.  	input_translator:	Use this input translator name instead of 				looking it up in the table.  	output_translator:	Use this output translator name instead of 				looking it up in the table.  	instrument:	Use this instrument name instead of attempting to 			detect it.  	sample:		Vector giving the sampling indices in the input data 			file.  This parameter is passed through to the input 			function, which may choose to ignore it.  	extensions:	If given, these extensions are attempted for each file. 			If a file with the extension is not found, then the next 			extension is tried until no extensions are left to try. 			If no extensions work, then the raw filename is attemtped.     OUTPUT: NONE     ENVIRONMENT VARIABLES: 	NV_TRANSLATORS:		Name(s) of the translators table(s) to use unless 				overridden by the tab_translators keyword. 				Multiple table names are delimited with ':'.  	NV_FTP_DETECT:		Name(s) of the filetype detectors table(s). 				Multiple table names are delimited with ':'.  	NV_IO:			Name(s) of the I/O table(s). 				Multiple table names are delimited with ':'.  	NV_INS_DETECT:		Name(s) of the instrument detectors table(s). 				Multiple table names are delimited with ':'.    RETURN: 	Array of data descriptors - one for each file resulting from the 	expansion of the given file specifications.    PROCEDURE: 	dat_read expands all file specifications and then attempts to detect 	the filetype for each resulting filename using the filetype detectors 	table.  If a filetype is detected, dat_read looks up the I/O functions 	and calls the input function to read the file.  Finally, it calls 	nv_init_descriptor to obtain a data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_write    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_read.html#drd_read", "drd_read", 'routine in <a href="obj/dat/dat_read.html">dat_read.pro</a>', "dat_read.pro", "", "drd_read", "", "filetypeinput_fnoutput_fnkeyword_fninstrumentinput_translatorsoutput_translatorsinput_transformsoutput_transformstab_translatorsmaintaincompresssamplenodatanamenhistextensions_filenamedataheader", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dat/dat_read.html#dat_read", "dat_read", 'routine in <a href="obj/dat/dat_read.html">dat_read.pro</a>', "dat_read.pro", "", "dat_read", "", "filetypeinput_fnoutput_fnkeyword_fninstrumentinput_translatorsoutput_translatorsinput_transformsoutput_transformstab_translatorsmaintaincompresssamplenodatanamenhistextensionsfilespecdataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_read_config.html", "dat_read_config.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_read_config.pro", "", "", " NAME: 	dat_read_config    PURPOSE: 	Reads an NV configuration table.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_read_config, env, table_p, filenames_p    ARGUMENTS:   INPUT: 	env:	Name of an environment variable giving the names of the 		configuration files to read, delimited by ':'.    OUTPUT: 	table_p:	Pointer to the configuration table contructed by 			concatenating the contents of each file.  	filenames_p:	List of configuration filenames that were read.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_read_config.html#dat_read_config", "dat_read_config", 'routine in <a href="obj/dat/dat_read_config.html">dat_read_config.pro</a>', "dat_read_config.pro", "", "dat_read_config", "", "continuestatusenvtable_pfilenames_p", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_redo.html", "dat_redo.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_redo.pro", "", "", " NAME: 	dat_redo    PURPOSE: 	Decrements the data archive index in the data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	dat_redo, dd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_redo.html#dat_redo", "dat_redo", 'routine in <a href="obj/dat/dat_redo.html">dat_redo.pro</a>', "dat_redo.pro", "", "dat_redo", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_replicate.html", "dat_replicate.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_replicate.pro", "", "", " NAME: 	dat_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	dds = dat_replicate(dd, dim)    ARGUMENTS:   INPUT: 	dd:	 Data deccriptor to replicate.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT: 	fn:	Name of the cloning function.  Default is nv_clone.    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_replicate.html#dat_replicate", "dat_replicate", 'routine in <a href="obj/dat/dat_replicate.html">dat_replicate.pro</a>', "dat_replicate.pro", "", "dat_replicate", "", "fndddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_sampling_data.html", "dat_sampling_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_sampling_data.pro", "", "", " NAME: 	dat_sampling_data    PURPOSE: 	Returns the sampling function associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	sampling_data = dat_sampling_data(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The sampling_data associated with the data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_set_sampling_data    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_sampling_data.html#dat_sampling_data", "dat_sampling_data", 'routine in <a href="obj/dat/dat_sampling_data.html">dat_sampling_data.pro</a>', "dat_sampling_data.pro", "", "dat_sampling_data", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_sampling_fn.html", "dat_sampling_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_sampling_fn.pro", "", "", " NAME: 	dat_sampling_fn    PURPOSE: 	Returns the sampling function associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	sampling_fn = dat_sampling_fn(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The sampling_fn associated with the data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_set_sampling_fn    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_sampling_fn.html#dat_sampling_fn", "dat_sampling_fn", 'routine in <a href="obj/dat/dat_sampling_fn.html">dat_sampling_fn.pro</a>', "dat_sampling_fn.pro", "", "dat_sampling_fn", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_compress.html", "dat_set_compress.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_compress.pro", "", "", " NAME: 	dat_set_compress    PURPOSE: 	Replaces the name of the compression function in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_compress, dd, compress    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	compress:	String giving the name of a new compression function.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_compress.html#dat_set_compress", "dat_set_compress", 'routine in <a href="obj/dat/dat_set_compress.html">dat_set_compress.pro</a>', "dat_set_compress.pro", "", "dat_set_compress", "", "ddcompress", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_data.html", "dat_set_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_data.pro", "", "", " NAME: 	dat_set_data    PURPOSE: 	Replaces the data array associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_data, dd, data    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	data:	New data array.    OUTPUT: 	dd:	Modified data descriptor.    KEYWORDS:   INPUT: 	abscissa: If set, the given array is taken as the abscissa.  	update:	Update mode flag.  If not given, it will be taken from dd.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Does not yet support sampling.    SEE ALSO: 	dat_data    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_data.html#dat_set_data", "dat_set_data", 'routine in <a href="obj/dat/dat_set_data.html">dat_set_data.pro</a>', "dat_set_data.pro", "", "dat_set_data", "", "updatenoeventabscissasampledd_data", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_dh.html", "dat_set_dh.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_dh.pro", "", "", " NAME: 	dat_set_dh    PURPOSE: 	Replaces the dh value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_dh, dd, dh    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	dh:	New dh value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_dh.html#dat_set_dh", "dat_set_dh", 'routine in <a href="obj/dat/dat_set_dh.html">dat_set_dh.pro</a>', "dat_set_dh.pro", "", "dat_set_dh", "", "noeventdddh", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_dim.html", "dat_set_dim.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_dim.pro", "", "", " NAME: 	dat_set_dim    PURPOSE: 	Replaces the dimensions in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_dim, dd, dim    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	dim:	New dimensions.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_dim.html#dat_set_dim", "dat_set_dim", 'routine in <a href="obj/dat/dat_set_dim.html">dat_set_dim.pro</a>', "dat_set_dim.pro", "", "dat_set_dim", "", "noeventdddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_dim_data.html", "dat_set_dim_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_dim_data.pro", "", "", " NAME: 	dat_set_dim_data    PURPOSE: 	Replaces the dimension function data associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_dim_data, dd, dim_data    ARGUMENTS:   INPUT: 	dd:			Data descriptor.  	dim_data:	New sampling function data.    OUTPUT: 	dd:	Modified data descriptor.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dat_dim_data    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_dim_data.html#dat_set_dim_data", "dat_set_dim_data", 'routine in <a href="obj/dat/dat_set_dim_data.html">dat_set_dim_data.pro</a>', "dat_set_dim_data.pro", "", "dat_set_dim_data", "", "noeventdddata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_dim_fn.html", "dat_set_dim_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_dim_fn.pro", "", "", " NAME: 	dat_set_dim_fn    PURPOSE: 	Replaces the dimension function associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_dim_fn, dd, dim_fn    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	dim_fn:	New sampling function.    OUTPUT: 	dd:	Modified data descriptor.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dat_dim_fn    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_dim_fn.html#dat_set_dim_fn", "dat_set_dim_fn", 'routine in <a href="obj/dat/dat_set_dim_fn.html">dat_set_dim_fn.pro</a>', "dat_set_dim_fn.pro", "", "dat_set_dim_fn", "", "noeventdddim_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_filename.html", "dat_set_filename.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_filename.pro", "", "", " NAME: 	dat_set_filename    PURPOSE: 	Changes the file name associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_filename, dd, filename    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	filename:	New file name.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_filename.html#dat_set_filename", "dat_set_filename", 'routine in <a href="obj/dat/dat_set_filename.html">dat_set_filename.pro</a>', "dat_set_filename.pro", "", "dat_set_filename", "", "noeventddfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_filetype.html", "dat_set_filetype.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_filetype.pro", "", "", " NAME: 	dat_set_filetype    PURPOSE: 	Changes the file name associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_filetype, dd, filetype    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	filetype:	New file name.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_filetype.html#dat_set_filetype", "dat_set_filetype", 'routine in <a href="obj/dat/dat_set_filetype.html">dat_set_filetype.pro</a>', "dat_set_filetype.pro", "", "dat_set_filetype", "", "noeventddfiletype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_gd.html", "dat_set_gd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_gd.pro", "", "", " NAME: 	dat_set_gd    PURPOSE: 	Updates a generic descriptor contained in an object.  Similar to 	cor_set_gd, except descriptor inputs are sorted according to the 	data descriptors contained in their generic descriptors.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dat_set_gd, xd, gd, <descriptor keywords>    ARGUMENTS:   INPUT: 	xd:	Objects to modify.  The fields from any existing generic 		descriptors in these objects are retained in the new ones.  	gd:	New generic descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<x>d:	Input keyword for each descriptor type.  These are sorted 		according to associated data descriptors.     OUTPUT: NONE    RETURN: NONE     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_gd.html#dat_set_gd", "dat_set_gd", 'routine in <a href="obj/dat/dat_set_gd.html">dat_set_gd.pro</a>', "dat_set_gd.pro", "", "dat_set_gd", "", "_extraxdgd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_gff.html", "dat_set_gff.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_gff.pro", "", "", " NAME: 	dat_set_gff    PURPOSE: 	Replaces the gff value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_gff, dd, gff    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	gff:	New gff value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_gff.html#dat_set_gff", "dat_set_gff", 'routine in <a href="obj/dat/dat_set_gff.html">dat_set_gff.pro</a>', "dat_set_gff.pro", "", "dat_set_gff", "", "noeventddgff", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_header.html", "dat_set_header.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_header.pro", "", "", " NAME: 	dat_set_header    PURPOSE: 	Replaces the header array associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_header, dd, header    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	header:	New header array.    OUTPUT: 	dd:	Modified data descriptor.    KEYWORDS:   INPUT: 	update:	Update mode flag.  If not given, it will be taken from dd.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dat_header    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_header.html#dat_set_header", "dat_set_header", 'routine in <a href="obj/dat/dat_set_header.html">dat_set_header.pro</a>', "dat_set_header.pro", "", "dat_set_header", "", "updatenoeventddheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_input_fn.html", "dat_set_input_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_input_fn.pro", "", "", " NAME: 	dat_set_input_fn    PURPOSE: 	Replaces the input_fn value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_input_fn, dd, input_fn    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	input_fn:	New input_fn value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_input_fn.html#dat_set_input_fn", "dat_set_input_fn", 'routine in <a href="obj/dat/dat_set_input_fn.html">dat_set_input_fn.pro</a>', "dat_set_input_fn.pro", "", "dat_set_input_fn", "", "noeventddinput_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_input_keyvals.html", "dat_set_input_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_input_keyvals.pro", "", "", " NAME: 	dat_set_input_keyvals    PURPOSE: 	Replaces the input_keyvals value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_input_keyvals, dd, input_keyvals    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	input_keyvals:	New input_keyvals value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_input_keyvals.html#dat_set_input_keyvals", "dat_set_input_keyvals", 'routine in <a href="obj/dat/dat_set_input_keyvals.html">dat_set_input_keyvals.pro</a>', "dat_set_input_keyvals.pro", "", "dat_set_input_keyvals", "", "noeventddinput_keyvals", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_input_transforms.html", "dat_set_input_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_input_transforms.pro", "", "", " NAME: 	dat_set_input_transforms    PURPOSE: 	Replaces the input_transforms value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_input_transforms, dd, input_transforms    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	input_transforms:	New input_transforms value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_input_transforms.html#dat_set_input_transforms", "dat_set_input_transforms", 'routine in <a href="obj/dat/dat_set_input_transforms.html">dat_set_input_transforms.pro</a>', "dat_set_input_transforms.pro", "", "dat_set_input_transforms", "", "noeventddinput_transforms", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_input_translators.html", "dat_set_input_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_input_translators.pro", "", "", " NAME: 	dat_set_input_translators    PURPOSE: 	Replaces the input_translators value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_input_translators, dd, input_translators    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	input_translators:	New input_translators value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_input_translators.html#dat_set_input_translators", "dat_set_input_translators", 'routine in <a href="obj/dat/dat_set_input_translators.html">dat_set_input_translators.pro</a>', "dat_set_input_translators.pro", "", "dat_set_input_translators", "", "noeventddinput_translators", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_instrument.html", "dat_set_instrument.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_instrument.pro", "", "", " NAME: 	dat_set_instrument    PURPOSE: 	Changes the file name associated with a data descriptor.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	dat_set_instrument, dd, instrument    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	instrument:	New instrument name.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_instrument.html#dat_set_instrument", "dat_set_instrument", 'routine in <a href="obj/dat/dat_set_instrument.html">dat_set_instrument.pro</a>', "dat_set_instrument.pro", "", "dat_set_instrument", "", "noeventddinstrument", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_keyword_fn.html", "dat_set_keyword_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_keyword_fn.pro", "", "", " NAME: 	dat_set_keyword_fn    PURPOSE: 	Replaces the keyword_fn value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_keyword_fn, dd, keyword_fn    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword_fn:	New keyword_fn value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_keyword_fn.html#dat_set_keyword_fn", "dat_set_keyword_fn", 'routine in <a href="obj/dat/dat_set_keyword_fn.html">dat_set_keyword_fn.pro</a>', "dat_set_keyword_fn.pro", "", "dat_set_keyword_fn", "", "noeventddkeyword_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_maintain.html", "dat_set_maintain.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_maintain.pro", "", "", " NAME: 	dat_set_maintain    PURPOSE: 	Replaces the maintain flag in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_maintain, dd, maintain    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	maintain:	New maintain flag.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_maintain.html#dat_set_maintain", "dat_set_maintain", 'routine in <a href="obj/dat/dat_set_maintain.html">dat_set_maintain.pro</a>', "dat_set_maintain.pro", "", "dat_set_maintain", "", "noeventddmaintain", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_max.html", "dat_set_max.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_max.pro", "", "", " NAME: 	dat_set_max    PURPOSE: 	Replaces the max value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_max, dd, max    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	max:	New max value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_max.html#dat_set_max", "dat_set_max", 'routine in <a href="obj/dat/dat_set_max.html">dat_set_max.pro</a>', "dat_set_max.pro", "", "dat_set_max", "", "noeventabscissaddmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_min.html", "dat_set_min.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_min.pro", "", "", " NAME: 	dat_set_min    PURPOSE: 	Replaces the min value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_min, dd, min    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	min:	New min value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_min.html#dat_set_min", "dat_set_min", 'routine in <a href="obj/dat/dat_set_min.html">dat_set_min.pro</a>', "dat_set_min.pro", "", "dat_set_min", "", "noeventabscissaddmin", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_ndd.html", "dat_set_ndd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_ndd.pro", "", "", " NAME: 	dat_set_ndd    PURPOSE: 	Sets a new ndd value in the NV state structure.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_ndd, ndd    ARGUMENTS:   INPUT: 	ndd:	New ndd value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_ndd.html#dat_set_ndd", "dat_set_ndd", 'routine in <a href="obj/dat/dat_set_ndd.html">dat_set_ndd.pro</a>', "dat_set_ndd.pro", "", "dat_set_ndd", "", "ndd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_nhist.html", "dat_set_nhist.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_nhist.pro", "", "", " NAME: 	dat_set_nhist    PURPOSE: 	Changes the number of past states archived in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_nhist, dd, nhist    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	nhist:	New nhist value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_nhist.html#dat_set_nhist", "dat_set_nhist", 'routine in <a href="obj/dat/dat_set_nhist.html">dat_set_nhist.pro</a>', "dat_set_nhist.pro", "", "dat_set_nhist", "", "noeventddnhist", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_output_fn.html", "dat_set_output_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_output_fn.pro", "", "", " NAME: 	dat_set_output_fn    PURPOSE: 	Replaces the output_fn value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_output_fn, dd, output_fn    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	output_fn:	New output_fn value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_output_fn.html#dat_set_output_fn", "dat_set_output_fn", 'routine in <a href="obj/dat/dat_set_output_fn.html">dat_set_output_fn.pro</a>', "dat_set_output_fn.pro", "", "dat_set_output_fn", "", "noeventddoutput_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_output_keyvals.html", "dat_set_output_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_output_keyvals.pro", "", "", " NAME: 	dat_set_output_keyvals    PURPOSE: 	Replaces the output_keyvals value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_output_keyvals, dd, output_keyvals    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	output_keyvals:	New output_keyvals value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_output_keyvals.html#dat_set_output_keyvals", "dat_set_output_keyvals", 'routine in <a href="obj/dat/dat_set_output_keyvals.html">dat_set_output_keyvals.pro</a>', "dat_set_output_keyvals.pro", "", "dat_set_output_keyvals", "", "noeventddoutput_keyvals", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_output_transforms.html", "dat_set_output_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_output_transforms.pro", "", "", " NAME: 	dat_set_output_transforms    PURPOSE: 	Replaces the output_transforms value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_output_transforms, dd, output_transforms    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	output_transforms:	New output_transforms value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_output_transforms.html#dat_set_output_transforms", "dat_set_output_transforms", 'routine in <a href="obj/dat/dat_set_output_transforms.html">dat_set_output_transforms.pro</a>', "dat_set_output_transforms.pro", "", "dat_set_output_transforms", "", "noeventddoutput_transforms", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_output_translators.html", "dat_set_output_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_output_translators.pro", "", "", " NAME: 	dat_set_output_translators    PURPOSE: 	Replaces the output_translators value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_output_translators, dd, output_translators    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	output_translators:	New output_translators value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_output_translators.html#dat_set_output_translators", "dat_set_output_translators", 'routine in <a href="obj/dat/dat_set_output_translators.html">dat_set_output_translators.pro</a>', "dat_set_output_translators.pro", "", "dat_set_output_translators", "", "noeventddoutput_translators", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_sampling_data.html", "dat_set_sampling_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_sampling_data.pro", "", "", " NAME: 	dat_set_sampling_data    PURPOSE: 	Replaces the sampling function data associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_sampling_data, dd, sampling_data    ARGUMENTS:   INPUT: 	dd:			Data descriptor.  	sampling_data:	New sampling function data.    OUTPUT: 	dd:	Modified data descriptor.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dat_sampling_data    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_sampling_data.html#dat_set_sampling_data", "dat_set_sampling_data", 'routine in <a href="obj/dat/dat_set_sampling_data.html">dat_set_sampling_data.pro</a>', "dat_set_sampling_data.pro", "", "dat_set_sampling_data", "", "noeventdddata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_sampling_fn.html", "dat_set_sampling_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_sampling_fn.pro", "", "", " NAME: 	dat_set_sampling_fn    PURPOSE: 	Replaces the sampling function associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_sampling_fn, dd, sampling_fn    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	sampling_fn:	New sampling function.    OUTPUT: 	dd:	Modified data descriptor.    KEYWORDS:   INPUT: 	data 	Data to be sent to the sampling function.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dat_sampling_fn    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_sampling_fn.html#dat_set_sampling_fn", "dat_set_sampling_fn", 'routine in <a href="obj/dat/dat_set_sampling_fn.html">dat_set_sampling_fn.pro</a>', "dat_set_sampling_fn.pro", "", "dat_set_sampling_fn", "", "datanoeventddsampling_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_sibling.html", "dat_set_sibling.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_sibling.pro", "", "", " NAME: 	dat_set_sibling    PURPOSE: 	Changes the sibling in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_sibling, dd, dd_sibling    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	dd_sibling:	Data descriptor of new sibling.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_sibling.html#dat_set_sibling", "dat_set_sibling", 'routine in <a href="obj/dat/dat_set_sibling.html">dat_set_sibling.pro</a>', "dat_set_sibling.pro", "", "dat_set_sibling", "", "noeventdddd_sibling", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_slice.html", "dat_set_slice.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_slice.pro", "", "", " NAME: 	dat_set_slice    PURPOSE: 	Sets slice coordinates in a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	dat_set_slice, dd, dd0, slice    ARGUMENTS:   INPUT: 	dd:	Data descriptorin which to set the slice coordinates.  	dd0:	Data descriptorin describing the source data array.  	slice:	Array giving the slice coordinates.    OUTPUT: NONE    KEYWORDS:   INPUT: 	new:	If set, a new slice pointer is allocated instead of overwriting 		the exiting data.    OUTPUT: NONE    RETURN: NONE    MODIFICATION HISTORY:  	Written by:	Spitale		6/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_slice.html#dat_set_slice", "dat_set_slice", 'routine in <a href="obj/dat/dat_set_slice.html">dat_set_slice.pro</a>', "dat_set_slice.pro", "", "dat_set_slice", "", "newdddd0slice", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_typecode.html", "dat_set_typecode.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_typecode.pro", "", "", " NAME: 	dat_set_typecode    PURPOSE: 	Replaces the typecode value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_typecode, dd, typecode    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	typecode:	New typecode value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_typecode.html#dat_set_typecode", "dat_set_typecode", 'routine in <a href="obj/dat/dat_set_typecode.html">dat_set_typecode.pro</a>', "dat_set_typecode.pro", "", "dat_set_typecode", "", "noeventddtypecode", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_update.html", "dat_set_update.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_update.pro", "", "", " NAME: 	dat_set_update    PURPOSE: 	Changes the update flag in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_update, dd, update    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	update:	New update flag.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_update.html#dat_set_update", "dat_set_update", 'routine in <a href="obj/dat/dat_set_update.html">dat_set_update.pro</a>', "dat_set_update.pro", "", "dat_set_update", "", "noeventddupdate", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_sibling.html", "dat_sibling.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_sibling.pro", "", "", " NAME: 	dat_sibling    PURPOSE: 	Returns the sibling data descriptor associated with a data 	descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	sibling_dd = dat_sibling(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Data descriptor of the sibling.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_sibling.html#dat_sibling", "dat_sibling", 'routine in <a href="obj/dat/dat_sibling.html">dat_sibling.pro</a>', "dat_sibling.pro", "", "dat_sibling", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_slice.html", "dat_slice.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_slice.pro", "", "", " NAME: 	dat_slice    PURPOSE: 	Returns the slice coordinates for the given data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dim = dat_slice(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array giving the slice coordinates for the data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_slice.html#dat_slice", "dat_slice", 'routine in <a href="obj/dat/dat_slice.html">dat_slice.pro</a>', "dat_slice.pro", "", "dat_slice", "", "dd0noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_slice__define.html", "dat_slice__define.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_slice__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_slice__define.html#dat_slice__define", "dat_slice__define", 'routine in <a href="obj/dat/dat_slice__define.html">dat_slice__define.pro</a>', "dat_slice__define.pro", "", "dat_slice__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_slice_offset.html", "dat_slice_offset.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_slice_offset.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_slice_offset.html#dat_slice_offset", "dat_slice_offset", 'routine in <a href="obj/dat/dat_slice_offset.html">dat_slice_offset.pro</a>', "dat_slice_offset.pro", "", "dat_slice_offset", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_slices.html", "dat_slices.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_slices.pro", "", "", " NAME: 	dat_slices    PURPOSE: 	Creates new data descriptors that point to a subarray slices in a given 	data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	new_dd = dat_slices(dd, h, q)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing N-dimensional data array.  	slice:	m x n array giving coordinates of n m-dimensional arrays to 		select. If not given, the original data array is sliced into 		arrays of one dimension smaller, i.e., a cube is sliced 		into its constituent images, and an image is sliced into its 		constituent lines etc.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	New data descriptors for the selected data arrays.  Dimensions are N - m. 	Note that new data arrays are not allocated.  Instead, the returned 	descriptors point to the subarray within the data array of the input 	data descriptor.    EXAMPLE: 	1) Extract the ith image of a 3-dimensional data cube:  		new_dd = dat_slices(dd, i)  	2) Extract the ith cube of a 4-dimensional data array:  		new_dd = dat_slices(dd, i)  	3) Extract the ith image in the jth cube of a 4-dimensional data array:  		new_dd = dat_slices(dd, [i,j])     MODIFICATION HISTORY:  	Written by:	Spitale		6/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_slices.html#dat_slices", "dat_slices", 'routine in <a href="obj/dat/dat_slices.html">dat_slices.pro</a>', "dat_slices.pro", "", "dat_slices", "", "dd0slice", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_test_dd.html", "dat_test_dd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_test_dd.pro", "", "", " NAME: 	dat_test_dd    PURPOSE: 	Determines whether the argument is a valid data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	test = dat_test_dd(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor to test.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	True if the argument is present, is a valid pointer, and 	points to a data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_test_dd.html#dat_test_dd", "dat_test_dd", 'routine in <a href="obj/dat/dat_test_dd.html">dat_test_dd.pro</a>', "dat_test_dd.pro", "", "dat_test_dd", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_transform_input.html", "dat_transform_input.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_transform_input.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_transform_input.html#dat_transform_input", "dat_transform_input", 'routine in <a href="obj/dat/dat_transform_input.html">dat_transform_input.pro</a>', "dat_transform_input.pro", "", "dat_transform_input", "", "_dddataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_transform_output.html", "dat_transform_output.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_transform_output.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_transform_output.html#dat_transform_output", "dat_transform_output", 'routine in <a href="obj/dat/dat_transform_output.html">dat_transform_output.pro</a>', "dat_transform_output.pro", "", "dat_transform_output", "", "_dddataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_typecode.html", "dat_typecode.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_typecode.pro", "", "", " NAME: 	dat_typecode    PURPOSE: 	Returns the type code associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	typecode = dat_typecode(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Integer giving the typecode.    STATUS: Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_typecode.html#dat_typecode", "dat_typecode", 'routine in <a href="obj/dat/dat_typecode.html">dat_typecode.pro</a>', "dat_typecode.pro", "", "dat_typecode", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_uncompress_data_mask.html", "dat_uncompress_data_mask.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_uncompress_data_mask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_uncompress_data_mask.html#dat_uncompress_data_mask", "dat_uncompress_data_mask", 'routine in <a href="obj/dat/dat_uncompress_data_mask.html">dat_uncompress_data_mask.pro</a>', "dat_uncompress_data_mask.pro", "", "dat_uncompress_data_mask", "", "_dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_undo.html", "dat_undo.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_undo.pro", "", "", " NAME: 	dat_undo    PURPOSE: 	Increments the data archive index in the data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_undo, dd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_undo.html#dat_undo", "dat_undo", 'routine in <a href="obj/dat/dat_undo.html">dat_undo.pro</a>', "dat_undo.pro", "", "dat_undo", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_unload_data.html", "dat_unload_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_unload_data.pro", "", "", " NAME: 	dat_unload_data    PURPOSE: 	Unloads the dat descriptor data array and removes dd from the NV 	state maintained list if present.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_unload_data, dd    ARGUMENTS:   INPUT: 	dd:	Data descriptor to test.    OUTPUT: NONE    KEYWORDS:   INPUT: 	all:	If set, all maintained data descriptors are unloaded.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_unload_data.html#dat_unload_data", "dat_unload_data", 'routine in <a href="obj/dat/dat_unload_data.html">dat_unload_data.pro</a>', "dat_unload_data.pro", "", "dat_unload_data", "", "alldd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_update.html", "dat_update.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_update.pro", "", "", " NAME: 	dat_update    PURPOSE: 	Returns the update flag associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	update = dat_update(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Data descriptor update flag.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_update.html#dat_update", "dat_update", 'routine in <a href="obj/dat/dat_update.html">dat_update.pro</a>', "dat_update.pro", "", "dat_update", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_valid_descriptor.html", "dat_valid_descriptor.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_valid_descriptor.pro", "", "", " NAME: 	dat_valid_descriptor    PURPOSE: 	Determines whether the argument is a valid data descriptor, 	or data descriptor structure.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	test = dat_valid_descriptor(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor to test.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	True if the argument is a data descriptor structure or a 	pointer to one.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_valid_descriptor.html#dat_valid_descriptor", "dat_valid_descriptor", 'routine in <a href="obj/dat/dat_valid_descriptor.html">dat_valid_descriptor.pro</a>', "dat_valid_descriptor.pro", "", "dat_valid_descriptor", "", "ddp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_write.html", "dat_write.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_write.pro", "", "", " NAME: 	dat_write    PURPOSE: 	Writes a data file of arbitrary format.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_write, filespec, dd 	dat_write, dd    ARGUMENTS:   INPUT: 	filespec:	Array of strings giving file specifications for 			file to write.  Data descriptor filespec is 			updated unless /override.  	dd:		Array of data descriptors.  dd can also be given as the 			first argument, in which case, the file specifications 			are taken from the filename field of dd.    OUTPUT: NONE    KEYWORDS:   INPUT: 	filetype:	Overrides data descriptor filetype (and thus the 			output function).  Data descriptor filetype is 			updated unless /override.  	output_fn:	Overrides data descriptor output function.  Data 			descriptor output_fn is updated unless /override.  	override:	If set, filespec, filetype, and output_fn inputs 			are used for this call, but not updated in the data 			descriptor.     OUTPUT: NONE    RETURN: NONE    PROCEDURE: 	dat_write expands all file specifications and attempts to write a 	file corresponding to each given data descriptor.  An error results 	if the filespec expands to a different number of files than the number 	of given data descriptors.    STATUS: 	Complete    SEE ALSO: 	dat_read    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_write.html#dat_write", "dat_write", 'routine in <a href="obj/dat/dat_write.html">dat_write.pro</a>', "dat_write.pro", "", "dat_write", "", "nodatafiletypeoutput_fnoverridearg1arg2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/detect_dh.html", "detect_dh.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "detect_dh.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/detect_dh.html#detect_dh", "detect_dh", 'routine in <a href="obj/dat/dh/util/detect_dh.html">detect_dh.pro</a>', "detect_dh.pro", "", "detect_dh", "", "ddudata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_create.html", "dh_create.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_create.pro", "", "", " NAME: 	dh_create    PURPOSE: 	Creates a minimal detached header.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	result = dh_create()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	String array in which each element is a line of the detached header.    PROCEDURE: 	dh_create creates a detached header containing a history line and 	the '<updates>' separator.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_create.html#dh_create", "dh_create", 'routine in <a href="obj/dat/dh/util/dh_create.html">dh_create.pro</a>', "dh_create.pro", "", "dh_create", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_create_section.html", "dh_create_section.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_create_section.pro", "", "", " NAME: 	dh_create_section    PURPOSE: 	Creates a minimal detached header section.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	result = dh_create_section(section)    ARGUMENTS:   INPUT: 	section:	Name of section to create.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	String array in which each element is a line of the new section.     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_create_section.html#dh_create_section", "dh_create_section", 'routine in <a href="obj/dat/dh/util/dh_create_section.html">dh_create_section.pro</a>', "dh_create_section.pro", "", "dh_create_section", "", "section", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_field_name.html", "dh_field_name.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_field_name.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_field_name.html#dh_field_name", "dh_field_name", 'routine in <a href="obj/dat/dh/util/dh_field_name.html">dh_field_name.pro</a>', "dh_field_name.pro", "", "dh_field_name", "", "fieldprefix", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_fname.html", "dh_fname.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_fname.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_fname.html#dhfn_findfile", "dhfn_findfile", 'routine in <a href="obj/dat/dh/util/dh_fname.html">dh_fname.pro</a>', "dh_fname.pro", "", "dhfn_findfile", "", "dirnameext", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_fname.html#dh_fname", "dh_fname", 'routine in <a href="obj/dat/dh/util/dh_fname.html">dh_fname.pro</a>', "dh_fname.pro", "", "dh_fname", "", "writefilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/dh_format_comment.html", "dh_format_comment.pro", '.pro file in <a href="obj/dat/dh/dir-overview.html">obj/dat/dh/ directory</a>', "dh_format_comment.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/dh_format_comment.html#dh_format_comment", "dh_format_comment", 'routine in <a href="obj/dat/dh/dh_format_comment.html">dh_format_comment.pro</a>', "dh_format_comment.pro", "", "dh_format_comment", "", "formatvalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/dh_from_ominas.html", "dh_from_ominas.pro", '.pro file in <a href="obj/dat/dh/dir-overview.html">obj/dat/dh/ directory</a>', "dh_from_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/dh_from_ominas.html#dh_from_ominas", "dh_from_ominas", 'routine in <a href="obj/dat/dh/dh_from_ominas.html">dh_from_ominas.pro</a>', "dh_from_ominas.pro", "", "dh_from_ominas", "", "formatvalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_get_string.html", "dh_get_string.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_get_string.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_get_string.html#dh_get_string", "dh_get_string", 'routine in <a href="obj/dat/dh/util/dh_get_string.html">dh_get_string.pro</a>', "dh_get_string.pro", "", "dh_get_string", "", "history_indexn_objdimstatussectiondhkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_get_value.html", "dh_get_value.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_get_value.pro", "", "", " NAME: 	dh_get_value    PURPOSE: 	Gets the value of a specified keyword.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	result = dh_get_value(dh, keyword)    ARGUMENTS:   INPUT: 	dh:		String giving the detached header.  	keyword:	String giving the keyword whose value is to be obtained.    OUTPUT: NONE    KEYWORDS:   INPUT: 	n_match:	Maximum number of matches to return.  If not given, 			all matches are returned.  	all_match:	If set, match all occurrences.  	all_object:	If set, match all object indices.  If not set, then 			match only object index 0.  	all_history:	If set, match all history indices.  If not set, then 			only the highest history index is matched.  	object_index:	If given, then match only this object index.  	history_index:	If given, then match only this history index.  	prefix:		If set, then match any keyword that begins with the 			given keyword string instead of requiring an exact 			match.  	section:	Name of detached header section from which to read the 			data.  If not specified, the data is read from the 			'updates' section.     OUTPUT: 	count:		Integer giving the numebr of keywords matched.  	match_keys:	String array giving the names of the keywords that were 			matched.  	match_objects:	Array giving the object index for each keyword returned 			in match_keywords.  	match_hist:	Array giving the history index for each keyword returned 			in match_keywords.    RETURN: 	Array giving values for all matching keywords.  The type of array is 	determined by the value found in the detached header.  Strings are 	returned as strings, numeric values are converted to double.    STATUS: 	Complete    SEE ALSO: 	dh_put_value, dh_rm_value    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998 	Added 'section' keyword: Spitale; 11/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_get_value.html#dhgv_convert_value", "dhgv_convert_value", 'routine in <a href="obj/dat/dh/util/dh_get_value.html">dh_get_value.pro</a>', "dh_get_value.pro", "", "dhgv_convert_value", "", "val", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_get_value.html#dh_get_value", "dh_get_value", 'routine in <a href="obj/dat/dh/util/dh_get_value.html">dh_get_value.pro</a>', "dh_get_value.pro", "", "dh_get_value", "", "n_matchall_matchall_objectall_historymatch_keyscountmatch_objectsmatch_historiesobject_indexhistory_indexprefixsection_dhkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_put_value.html", "dh_put_value.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_put_value.pro", "", "", " NAME: 	dh_put_value    PURPOSE: 	Sets the value of a specified keyword.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	dh_put_value, dh, keyword, value, $                          object_index=object_index, comment=comment    ARGUMENTS:   INPUT: 	dh:		String array giving the detached header.  If undefined, 			a minimal detached header is first created.  	keyword:	String giving the keyword whose value is to be updated.  	value:		Value to associate with this keyword.    OUTPUT: 	dh:		The dh argument is modified on return.    KEYWORDS:   INPUT: 	object_index:	Object index to use for this update.  Default is 0.  	comment:	String giving optional comment.  	section:	Section in which to place the data.  If not specified, 			the data is placed in the 'updates' section.  If 			the specified section does not exist, it is created.     OUTPUT: NONE    RETURN: NONE    SIDE EFFECTS: 	See procedure below; 'utime' and 'history' keywords are modified.    PROCEDURE: 	The data is appended to the top of the specified section of the detached 	header using the given object index and a history index that is one 	greater than the current value found in the detached header for this 	keyword.  The value of the 'utime' keyword corresponding to this history 	index is modified to reflect the current time.  If this history index is 	greater than that given by the 'history' keyword, then that value is 	modified as well.  	If 'value' is an array, then each element is written on a different line 	using the keyword with the same object index, history index, and 	comment, but whose element indices reflect the order that the data 	appear in the array.  	If 'value' is of string type, then each entry is enclosed in quotes.    EXAMPLE: 	The following commands:  		IDL> val=[7,6,5,4,3] 		IDL> dh_put_value, dh, 'test_key', val  	produce the following detached header:  	 history = -1 / Current history value 	 <updates> 	 utime = 2451022.404086 / Julian day of update - Mon Jul 27 9:41:53 1998 	 test_key(0) = 7 	 test_key(1) = 6 	 test_key(2) = 5 	 test_key(3) = 4 	 test_key(4) = 3     STATUS: 	Complete    SEE ALSO: 	dh_get_value, dh_rm_value    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998 	Added 'section' keyword: Spitale; 11/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_put_value.html#dhpv_put", "dhpv_put", 'routine in <a href="obj/dat/dh/util/dh_put_value.html">dh_put_value.pro</a>', "dh_put_value.pro", "", "dhpv_put", "", "commentarrayformatdhlinekeywordvalueelemobjhist", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_put_value.html#dh_put_value", "dh_put_value", 'routine in <a href="obj/dat/dh/util/dh_put_value.html">dh_put_value.pro</a>', "dh_put_value.pro", "", "dh_put_value", "", "object_indexcommentsectiondhkeywordvalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_read.html", "dh_read.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_read.pro", "", "", " NAME: 	dh_read    PURPOSE: 	Reads a detached header file.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	result = dh_read(filename)    ARGUMENTS:   INPUT: 	filename:	Name of file to be read.    OUTPUT: NONE    KEYWORDS:   INPUT: 	buflen:		Number of lines to allocate at a time.  Default is 1000. 			The routine is faster with larger values of buflen, but 			less memory efficient.    OUTPUT: NONE    RETURN: 	String array in which each line is a line of the detached header. 	a blank detached header is created and returned if the file is 	not found.    STATUS: 	Complete    SEE ALSO: 	dh_write    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_read.html#dh_read", "dh_read", 'routine in <a href="obj/dat/dh/util/dh_read.html">dh_read.pro</a>', "dh_read.pro", "", "dh_read", "", "buflenfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_rm_value.html", "dh_rm_value.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_rm_value.pro", "", "", " NAME: 	dh_rm_value    PURPOSE: 	Deletes a specified keyword/value pair.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	dh_rm_value, dh, keyword    ARGUMENTS:   INPUT: 	dh:		String giving the detached header.  	keyword:	String giving the keyword to be deleted.    OUTPUT: 	dh:		dh is modified on return.     KEYWORDS:   INPUT: 	n_match:	Maximum number of matches to return.  If not given, 			all matches are returned.  	all_match:	If set, match all occurrences.  	all_object:	If set, match all object indices.  If not set, then 			match only object index 0.  	all_history:	If set, match all history indices.  If not set, 			then only the highest history index is matched.  	object_index:	If given, then match only this object index.  	history_index:	If given, then match only this history index.  	prefix:		If set, then match any keyword which begins with the 			given keyword string instead of requiring an exact 			match.    OUTPUT: 	count:		Integer giving the numebr of keywords matched.    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dh_get_value, dh_put_value    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_rm_value.html#dh_rm_value", "dh_rm_value", 'routine in <a href="obj/dat/dh/util/dh_rm_value.html">dh_rm_value.pro</a>', "dh_rm_value.pro", "", "dh_rm_value", "", "n_matchall_matchall_objectall_historycountobject_indexhistory_indexprefixdhkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_set.html", "dh_set.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_set.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_set.html#dh_set", "dh_set", 'routine in <a href="obj/dat/dh/util/dh_set.html">dh_set.pro</a>', "dh_set.pro", "", "dh_set", "", "dddh", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/dh_std_input.html", "dh_std_input.pro", '.pro file in <a href="obj/dat/dh/dir-overview.html">obj/dat/dh/ directory</a>', "dh_std_input.pro", "", "", " NAME: 	dh_std_input    PURPOSE: 	Input translator for detached header    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE(only to be called by dat_get_value): 	result = dh_std_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity to 			read.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	status:		Zero if valid data is returned     TRANSLATOR KEYWORDS: 	history:	History index to use in matching the keyword.  If not 			specified, the keyowrd with the highest history index 			is matched.    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    SEE ALSO: 	dh_std_output    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/dh_std_input.html#dhsi_associate_object", "dhsi_associate_object", 'routine in <a href="obj/dat/dh/dh_std_input.html">dh_std_input.pro</a>', "dh_std_input.pro", "", "dhsi_associate_object", "", "nameddall_xds", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dat/dh/dh_std_input.html#dhsi_get", "dhsi_get", 'routine in <a href="obj/dat/dh/dh_std_input.html">dh_std_input.pro</a>', "dh_std_input.pro", "", "dhsi_get", "", "objhidhprefixddall_xds", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dat/dh/dh_std_input.html#dh_std_input", "dh_std_input", 'routine in <a href="obj/dat/dh/dh_std_input.html">dh_std_input.pro</a>', "dh_std_input.pro", "", "dh_std_input", "", "valuesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/dh_std_output.html", "dh_std_output.pro", '.pro file in <a href="obj/dat/dh/dir-overview.html">obj/dat/dh/ directory</a>', "dh_std_output.pro", "", "", " NAME: 	dh_std_output    PURPOSE: 	Output translator for detached headers.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE(only to be called by dat_put_value): 	dh_std_output, dd, keyword, value    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity to 			write.  	value:		The data to write.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	status:		Zero unless a problem occurs.     TRANSLATOR KEYWORDS: 	format:		String giving the name of the output representation. 			Default is OMINAS internal representation.  The null 			string, '', indicates the default.    SIDE EFFECTS: 	The detached header in the data descriptor is modified.    STATUS: 	Complete    SEE ALSO: 	dh_std_input    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/dh_std_output.html#dhso_put", "dhso_put", 'routine in <a href="obj/dat/dh/dh_std_output.html">dh_std_output.pro</a>', "dh_std_output.pro", "", "dhso_put", "", "objdddh_odprefix", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dat/dh/dh_std_output.html#dh_std_output", "dh_std_output", 'routine in <a href="obj/dat/dh/dh_std_output.html">dh_std_output.pro</a>', "dh_std_output.pro", "", "dh_std_output", "", "statusddkeywordvalue@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/dh_to_ominas.html", "dh_to_ominas.pro", '.pro file in <a href="obj/dat/dh/dir-overview.html">obj/dat/dh/ directory</a>', "dh_to_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/dh_to_ominas.html#dh_to_ominas", "dh_to_ominas", 'routine in <a href="obj/dat/dh/dh_to_ominas.html">dh_to_ominas.pro</a>', "dh_to_ominas.pro", "", "dh_to_ominas", "", "formatvalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_write.html", "dh_write.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_write.pro", "", "", " NAME: 	dh_write    PURPOSE: 	Writes a detached header file.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	dh_write, filename, dh    ARGUMENTS:   INPUT: 	filename:	Name of file to be written.  	dh:		String array giving the detached header to write.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dh_read    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_write.html#dh_write", "dh_write", 'routine in <a href="obj/dat/dh/util/dh_write.html">dh_write.pro</a>', "dh_write.pro", "", "dh_write", "", "filenamedh", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dhh_extract.html", "dhh_extract.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dhh_extract.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dhh_extract.html#dhh_extract", "dhh_extract", 'routine in <a href="obj/dat/dh/util/dhh_extract.html">dhh_extract.pro</a>', "dhh_extract.pro", "", "dhh_extract", "", "dh_historydhsection", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dhh_insert.html", "dhh_insert.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dhh_insert.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dhh_insert.html#dhh_insert", "dhh_insert", 'routine in <a href="obj/dat/dh/util/dhh_insert.html">dhh_insert.pro</a>', "dhh_insert.pro", "", "dhh_insert", "", "dh_historydhdh_section", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dhh_parse_keyword.html", "dhh_parse_keyword.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dhh_parse_keyword.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dhh_parse_keyword.html#dhh_parse_keyword", "dhh_parse_keyword", 'routine in <a href="obj/dat/dh/util/dhh_parse_keyword.html">dhh_parse_keyword.pro</a>', "dhh_parse_keyword.pro", "", "dhh_parse_keyword", "", "rkwkwelm_indexobj_indexhist_index", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dhh_parse_line.html", "dhh_parse_line.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dhh_parse_line.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dhh_parse_line.html#dhh_parse_line", "dhh_parse_line", 'routine in <a href="obj/dat/dh/util/dhh_parse_line.html">dhh_parse_line.pro</a>', "dhh_parse_line.pro", "", "dhh_parse_line", "", "linerkwval", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dhh_search.html", "dhh_search.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dhh_search.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dhh_search.html#dhh_search", "dhh_search", 'routine in <a href="obj/dat/dh/util/dhh_search.html">dhh_search.pro</a>', "dhh_search.pro", "", "dhh_search", "", "linesdhkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dhh_separate.html", "dhh_separate.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dhh_separate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dhh_separate.html#dhh_separate", "dhh_separate", 'routine in <a href="obj/dat/dh/util/dhh_separate.html">dhh_separate.pro</a>', "dhh_separate.pro", "", "dhh_separate", "", "dh_sectionsdhdh_history", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/disk_to_corot.html", "disk_to_corot.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "disk_to_corot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/disk_to_corot.html#disk_to_corot", "disk_to_corot", 'routine in <a href="obj/tools/disk_to_corot.html">disk_to_corot.pro</a>', "disk_to_corot.pro", "", "disk_to_corot", "", "cddkxgbxt0dmldttimesdisk_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_image.html", "disk_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "disk_to_image.pro", "", "", " NAME:        disk_to_image    PURPOSE:        Transforms points in disk coordinates to image coordinates    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = disk_to_image(cd, dkx, p)    ARGUMENTS:   INPUT: 	cd:       Array of nt camera or map descriptors.  	dkx:      Array of nt object descriptors (subclass of DISK).  	p:       Array (nv x 3 x nt) of image points.    OUTPUT:        NONE   KEYWORDS:    INPUT: 	sund:	If given, longitudes are assumed to be referenced to the 		sun direction.     OUTPUT: 	valid:	Indices of valid output points.  	body_pts:	Body coordinates of output points.    RETURN:        Array (nv x 3 x nt) of image coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 9/2002  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_image.html#disk_to_image", "disk_to_image", 'routine in <a href="obj/tools/composite/disk_to_image.html">disk_to_image.pro</a>', "disk_to_image.pro", "", "disk_to_image", "", "body_ptsvalidcddkxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_inertial_pos.html", "disk_to_inertial_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "disk_to_inertial_pos.pro", "", "", " NAME:        disk_to_inertial_pos    PURPOSE:        Transforms position vectors in disk coordinates to inertial 	coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = disk_to_inertial_pos(dkx, v)    ARGUMENTS:   INPUT: 	dkx:	Array of nt descriptors, subclass of DISK.  	v:	Array (nv x 3 x nt) of disk points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of inertial points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_inertial_pos.html#disk_to_inertial_pos", "disk_to_inertial_pos", 'routine in <a href="obj/tools/composite/disk_to_inertial_pos.html">disk_to_inertial_pos.pro</a>', "disk_to_inertial_pos.pro", "", "disk_to_inertial_pos", "", "rdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_map.html", "disk_to_map.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "disk_to_map.pro", "", "", " NAME:        disk_to_map    PURPOSE:        Transforms points in disk coordinates to map coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = disk_to_map(md, dkx, disk_pts)    ARGUMENTS:   INPUT: 	md:      Array of nt map descriptors.  	dkx:     Array of nt disk descriptors.  	disk_pts:       Array (nv x 3 x nt) of disk points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (2 x nv x nt) of map coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_map.html#disk_to_map", "disk_to_map", 'routine in <a href="obj/tools/composite/disk_to_map.html">disk_to_map.pro</a>', "disk_to_map.pro", "", "disk_to_map", "", "mddkddisk_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/dred/dred.html", "dred.pro", '.pro file in <a href="grim/dred/dir-overview.html">grim/dred/ directory</a>', "dred.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/dred/dred.html#dred_update_form", "dred_update_form", 'routine in <a href="grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_update_form", "", "dataclass", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/dred/dred.html#dred_update_form", "dred_update_form", 'routine in <a href="grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_update_form", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/dred/dred.html#dred_configure_xd", "dred_configure_xd", 'routine in <a href="grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_configure_xd", "", "basexd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/dred/dred.html#dred_switch_class", "dred_switch_class", 'routine in <a href="grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_switch_class", "", "dataclass", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/dred/dred.html#dred_switch_xd", "dred_switch_xd", 'routine in <a href="grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_switch_xd", "", "datasii", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/dred/dred.html#dred_resize", "dred_resize", 'routine in <a href="grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_resize", "", "datas", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/dred/dred.html#dred_event", "dred_event", 'routine in <a href="grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/dred/dred.html#dred_cleanup", "dred_cleanup", 'routine in <a href="grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/dred/dred.html#dred", "dred", 'routine in <a href="grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred", "", "xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_apply_scale.html", "dsk_apply_scale.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_apply_scale.pro", "", "", " NAME: 	dsk_apply_scale    PURPOSE: 	Computes scaled radii.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	scaled_radii = dsk_apply_scale(dkd, radii)    ARGUMENTS:   INPUT: 	dkd:	 A single disk descriptors.  	radii:	 Array of radii to convert.    OUTPUT: NONE    KEYWORDS:   INPUT: 	inverse:	If set, the operation is performed in reverse.    OUTPUT: NONE    RETURN: 	Scaled radii based onthe scale parameters in the disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_apply_scale.html#dsk_apply_scale", "dsk_apply_scale", 'routine in <a href="obj/dsk/dsk_apply_scale.html">dsk_apply_scale.pro</a>', "dsk_apply_scale.pro", "", "dsk_apply_scale", "", "inversenoeventdkdradii", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_assign.html", "dsk_assign.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_assign.pro", "", "", " NAME: 	dsk_assign    PURPOSE: 	Replaces fields in a DISK object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/DSK    CALLING SEQUENCE: 	dsk_assign, dkd, <keywords>=<values>    ARGUMENTS:   INPUT: 	dkd:		DISK object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	DISK fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dsk_assign_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_assign.html#dsk_assign", "dsk_assign", 'routine in <a href="obj/dsk/dsk_assign.html">dsk_assign.pro</a>', "dsk_assign.pro", "", "dsk_assign", "", "noeventxd@dsk__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_body_to_disk.html", "dsk_body_to_disk.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_body_to_disk.pro", "", "", " NAME: 	dsk_body_to_disk    PURPOSE: 	Transforms vectors from the body coordinate system to the disk 	coordinate system.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	v_disk = dsk_body_to_disk(dkd, v_body)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	v_body:	 Array (nv x 3 x nt) of column vectors in the body 		 coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv x 3 x nt) of column vectors in the disk coordinate system.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_body_to_disk.html#dsk_body_to_disk", "dsk_body_to_disk", 'routine in <a href="obj/dsk/dsk_body_to_disk.html">dsk_body_to_disk.pro</a>', "dsk_body_to_disk.pro", "", "dsk_body_to_disk", "", "dkdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_cat.html", "dsk_cat.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_cat.pro", "", "", " NAME:        dsk_cat    PURPOSE: 	Concatenates the given disk descriptors into one descriptor encompassing 	the entire system.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        dkx_cat = dsk_cat(dkx)    ARGUMENTS:   INPUT: 	dkx:	Array (nt) of any subclass of DISK.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	A descriptor of the same class as dkx whose semimajor axes 	encompass the all of the input disks.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_cat.html#dsk_cat", "dsk_cat", 'routine in <a href="obj/tools/dsk_cat.html">dsk_cat.pro</a>', "dsk_cat.pro", "", "dsk_cat", "", "dkxs", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_cat_by_name.html", "dsk_cat_by_name.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_cat_by_name.pro", "", "", " NAME:        dsk_cat_by_name    PURPOSE: 	Concatenates the given disk descriptors into one descriptor 	encompassing all of the named descriptors.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        dkx_cat = dsk_cat_by_name(dkx, names)    ARGUMENTS:   INPUT: 	dkx:	Array (nt) of any subclass of DISK.  	names:	Array of names of disks to concatenate.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	A descriptor of the same class as dkx whose semimajor axes 	encompass the all of the named input disks.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_cat_by_name.html#dsk_cat_by_name", "dsk_cat_by_name", 'routine in <a href="obj/tools/dsk_cat_by_name.html">dsk_cat_by_name.pro</a>', "dsk_cat_by_name.pro", "", "dsk_cat_by_name", "", "dkxsnames", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_create_descriptors.html", "dsk_create_descriptors.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_create_descriptors.pro", "", "", " NAME: 	dsk_create_descriptors    PURPOSE: 	Init method for the DISK class.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dkd = dsk_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	Number of descriptors to create.    OUTPUT: NONE    KEYWORDS (in addition to those accepted by all superclasses):   INPUT: 	dkd:	Disk descriptor(s) to initialize, instead of creating a new one.  	sld:	Solid descriptor(s) instead of using sld_create_descriptors.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	sma:	Array (ndv+1 x 2 x n) giving the semimajor axes and derivatives 		for each edge.  	ecc:	Array (ndv+1 x 2 x n) giving the eccentricities and derivatives 		for each edge.  	scale:	Array (2 x n) giving radial scale coefficients.  	nm:	Integer giving the number of radial harmonics in the ring 		shape.  	m:	Array (nm x 2 x n) giving the m value for each harmonic, for 		each edge.  	em:	Array (nm x 2 x n) giving the eccentricity for each harmonic, for 		each edge.  	tapm:	Array (nm x 2 x n) giving the true anomaly of periapse for each 		harmonic, for each edge.  	dtapmdt:Array (nm x 2 x n) giving the tapm rate for each 		harmonic, for each edge.  	libam:	Array (nm x 2 x n) giving the libration amplitude for each 		harmonic, for each edge.  	libm:	Array (nm x 2 x n) giving the libration phase for each 		harmonic, for each edge.  	dlibmdt:	Array (nm x 2 x n) giving the libration frequency for each 			harmonic, for each edge.  	nl:	Integer giving the number of radial harmonics in the ring 		shape.  	_l:	Array (nl x 2 x n) giving the l value for each harmonic, for 		each edge.  The leading underscore is needed to avoid 		conflict with other keywords.  	il:	Array (l x 2 x n) giving the inclination for each harmonic, for 		each edge.  	taanl:	Array (nl x 2 x n) giving the true anomaly of periapse for each 		harmonic, for each edge.  	dtaanldt:	Array (nl x 2 x n) giving the taanl rate for each 			harmonic, for each edge.  	libal:	Array (nl x 2 x n) giving the libration amplitude for each 		harmonic, for each edge.  	libl:	Array (nl x 2 x n) giving the libration phase for each 		harmonic, for each edge.  	dlibldt:	Array (nl x 2 x n) giving the libration frequency for each 			harmonic, for each edge.    OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized disk descriptors, depending 	on the presence of the dkd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_create_descriptors.html#dsk_create_descriptors", "dsk_create_descriptors", 'routine in <a href="obj/dsk/dsk_create_descriptors.html">dsk_create_descriptors.pro</a>', "dsk_create_descriptors.pro", "", "dsk_create_descriptors", "", "crdbdslddkdn@dsk__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dap.html", "dsk_dap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dap.pro", "", "", " NAME: 	dsk_dap    PURPOSE: 	Returns dap for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dap = dsk_dap(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dap value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_dap.html#dsk_dap", "dsk_dap", 'routine in <a href="obj/dsk/dsk_dap.html">dsk_dap.pro</a>', "dsk_dap.pro", "", "dsk_dap", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_disk_to_body.html", "dsk_disk_to_body.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_disk_to_body.pro", "", "", " NAME: 	dsk_disk_to_body    PURPOSE: 	Transforms vectors from the disk coordinate system to the body 	coordinate system.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	v_body = dsk_disk_to_body(dkd, v_dsk)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	v_disk:	 Array (nv x 3 x nt) of column vectors in the disk 		 coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv x 3 x nt) of column vectors in the body coordinate system.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_disk_to_body.html#dsk_disk_to_body", "dsk_disk_to_body", 'routine in <a href="obj/dsk/dsk_disk_to_body.html">dsk_disk_to_body.pro</a>', "dsk_disk_to_body.pro", "", "dsk_disk_to_body", "", "dkdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dlibldt.html", "dsk_dlibldt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dlibldt.pro", "", "", " NAME: 	dsk_dlibldt    PURPOSE: 	Returns dlibldt for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dlibldt = dsk_dlibldt(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dlibldt value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_dlibldt.html#dsk_dlibldt", "dsk_dlibldt", 'routine in <a href="obj/dsk/dsk_dlibldt.html">dsk_dlibldt.pro</a>', "dsk_dlibldt.pro", "", "dsk_dlibldt", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dlibmdt.html", "dsk_dlibmdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dlibmdt.pro", "", "", " NAME: 	dsk_dlibmdt    PURPOSE: 	Returns dlibmdt for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dlibmdt = dsk_dlibmdt(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dlibmdt value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_dlibmdt.html#dsk_dlibmdt", "dsk_dlibmdt", 'routine in <a href="obj/dsk/dsk_dlibmdt.html">dsk_dlibmdt.pro</a>', "dsk_dlibmdt.pro", "", "dsk_dlibmdt", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dtaanldt.html", "dsk_dtaanldt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dtaanldt.pro", "", "", " NAME: 	dsk_dtaanldt    PURPOSE: 	Returns dtaanldt for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dtaanldt = dsk_dtaanldt(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dtaanldt value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_dtaanldt.html#dsk_dtaanldt", "dsk_dtaanldt", 'routine in <a href="obj/dsk/dsk_dtaanldt.html">dsk_dtaanldt.pro</a>', "dsk_dtaanldt.pro", "", "dsk_dtaanldt", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dtapmdt.html", "dsk_dtapmdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dtapmdt.pro", "", "", " NAME: 	dsk_dtapmdt    PURPOSE: 	Returns dtapmdt for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dtapmdt = dsk_dtapmdt(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dtapmdt value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_dtapmdt.html#dsk_dtapmdt", "dsk_dtapmdt", 'routine in <a href="obj/dsk/dsk_dtapmdt.html">dsk_dtapmdt.pro</a>', "dsk_dtapmdt.pro", "", "dsk_dtapmdt", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_ecc.html", "dsk_ecc.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_ecc.pro", "", "", " NAME: 	dsk_ecc    PURPOSE: 	Returns ecc for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	ecc = dsk_ecc(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	ecc value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_ecc.html#dsk_ecc", "dsk_ecc", 'routine in <a href="obj/dsk/dsk_ecc.html">dsk_ecc.pro</a>', "dsk_ecc.pro", "", "dsk_ecc", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_em.html", "dsk_em.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_em.pro", "", "", " NAME: 	dsk_em    PURPOSE: 	Returns em for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	em = dsk_em(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	em value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_em.html#dsk_em", "dsk_em", 'routine in <a href="obj/dsk/dsk_em.html">dsk_em.pro</a>', "dsk_em.pro", "", "dsk_em", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_evolve.html", "dsk_evolve.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_evolve.pro", "", "", " NAME: 	dsk_evolve    PURPOSE: 	Computes new disk descriptors at the given time offsets from the 	given disk descriptors using the taylor series expansion 	corresponding to the derivatives contained in the given disk 	descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	dkdt = dsk_evolve(dkd, dt)    ARGUMENTS:   INPUT: 	dkd:	 Any subclass of DISK.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, derivatives will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN: 	Array (ndkd,ndt) of newly allocated descriptors, of class DISK, 	evolved by time dt, where ndkd is the number of dkd, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_evolve.html#dsk_evolve", "dsk_evolve", 'routine in <a href="obj/dsk/dsk_evolve.html">dsk_evolve.pro</a>', "dsk_evolve.pro", "", "dsk_evolve", "", "nodvcopydkddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_ansa.html", "dsk_get_ansa.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_ansa.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_ansa.html#dsk_get_ansa", "dsk_get_ansa", 'routine in <a href="obj/dsk/dsk_get_ansa.html">dsk_get_ansa.pro</a>', "dsk_get_ansa.pro", "", "dsk_get_ansa", "", "ndkdr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_ap.html", "dsk_get_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_ap.pro", "", "", " NAME: 	dsk_get_ap    PURPOSE: 	Determines ap for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	ap = dsk_ap(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	ap value associated with each given disk descriptor.  One for each dkd.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_ap.html#dsk_get_ap", "dsk_get_ap", 'routine in <a href="obj/dsk/dsk_get_ap.html">dsk_get_ap.pro</a>', "dsk_get_ap.pro", "", "dsk_get_ap", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dapdt.html", "dsk_get_dapdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_dapdt.pro", "", "", " NAME: 	dsk_get_dapdt    PURPOSE: 	Determines dapdt for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dapdt = dsk_dapdt(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dapdt value associated with each given disk descriptor.  One for each dkd.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dapdt.html#dsk_get_dapdt", "dsk_get_dapdt", 'routine in <a href="obj/dsk/dsk_get_dapdt.html">dsk_get_dapdt.pro</a>', "dsk_get_dapdt.pro", "", "dsk_get_dapdt", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_disk_points.html", "dsk_get_disk_points.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_disk_points.pro", "", "", " NAME: 	dsk_get_disk_points    PURPOSE: 	Computes points on the inner and outer edges of a disk.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	disk_pts = dsk_get_disk_points(dkd, np)    ARGUMENTS:   INPUT: 	dkd:	 Any single subclass of DISK.  	np:	 Number of points on each edge.    OUTPUT: NONE    KEYWORDS:   INPUT: 	dta:		Azimuthal spacing for the points, instead of specifying 			the np argument.    OUTPUT: NONE    RETURN: 	Array (np x 3 x 2) of points on the inner and outer edges of the 	disk, in disk body coordinates.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_disk_points.html#_dsk_get_disk_points", "_dsk_get_disk_points", 'routine in <a href="obj/dsk/dsk_get_disk_points.html">dsk_get_disk_points.pro</a>', "dsk_get_disk_points.pro", "", "_dsk_get_disk_points", "", "dkdn_points", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_disk_points.html#dsk_get_disk_points", "dsk_get_disk_points", 'routine in <a href="obj/dsk/dsk_get_disk_points.html">dsk_get_disk_points.pro</a>', "dsk_get_disk_points.pro", "", "dsk_get_disk_points", "", "dtadkdn_points", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlandt.html", "dsk_get_dlandt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_dlandt.pro", "", "", " NAME: 	dsk_get_dlandt    PURPOSE: 	Determines dlandt for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dlandt = dsk_dlandt(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dlandt value associated with each given disk descriptor.  One for each dkd.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlandt.html#dsk_get_dlandt", "dsk_get_dlandt", 'routine in <a href="obj/dsk/dsk_get_dlandt.html">dsk_get_dlandt.pro</a>', "dsk_get_dlandt.pro", "", "dsk_get_dlandt", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlibdt_ap.html", "dsk_get_dlibdt_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_dlibdt_ap.pro", "", "", " NAME: 	dsk_get_dlibdt_ap    PURPOSE: 	Determines dlibdt_ap for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dlibdt_ap = dsk_dlibdt_ap(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dlibdt_ap value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlibdt_ap.html#dsk_get_dlibdt_ap", "dsk_get_dlibdt_ap", 'routine in <a href="obj/dsk/dsk_get_dlibdt_ap.html">dsk_get_dlibdt_ap.pro</a>', "dsk_get_dlibdt_ap.pro", "", "dsk_get_dlibdt_ap", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlibdt_lan.html", "dsk_get_dlibdt_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_dlibdt_lan.pro", "", "", " NAME: 	dsk_get_dlibdt_lan    PURPOSE: 	Determines dlibdt_lan for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dlibdt_lan = dsk_dlibdt_lan(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dlibdt_lan value associated with each given disk descriptor.  One for each dkd.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlibdt_lan.html#dsk_get_dlibdt_lan", "dsk_get_dlibdt_lan", 'routine in <a href="obj/dsk/dsk_get_dlibdt_lan.html">dsk_get_dlibdt_lan.pro</a>', "dsk_get_dlibdt_lan.pro", "", "dsk_get_dlibdt_lan", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_edge_elevation.html", "dsk_get_edge_elevation.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_edge_elevation.pro", "", "", " NAME: 	dsk_get_edge_elevation    PURPOSE: 	Computes elevations along the edge of a disk.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	z = dsk_get_edge_elevation(dkd, ta)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	ta:	 Array (nta) of true anomalies at which to compute elevations.     OUTPUT: NONE    KEYWORDS:   INPUT: 	inner:	If set, the inner edge is used.  	outer:	If set, the outer edge is used.    OUTPUT: NONE    RETURN: 	Array (nt x nta) of elevations computed at each true anomaly on each 	disk.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_edge_elevation.html#dsk_get_edge_elevation", "dsk_get_edge_elevation", 'routine in <a href="obj/dsk/dsk_get_edge_elevation.html">dsk_get_edge_elevation.pro</a>', "dsk_get_edge_elevation.pro", "", "dsk_get_edge_elevation", "", "innerouterone_to_onenoeventdkdta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_edge_radius.html", "dsk_get_edge_radius.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_edge_radius.pro", "", "", " NAME: 	dsk_get_edge_radius    PURPOSE: 	Computes radii along the edge of a disk.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	r = dsk_get_edge_radius(dkd, ta, frame_bd)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	ta:	 Array (nv x nt) of true anomalies at which to compute radii.  	time:	 Array (nt) of epochs to use instead of that of dkd.     OUTPUT: NONE    KEYWORDS:   INPUT: 	inner:	If set, the inner edge is used.  	outer:	If set, the outer edge is used.    OUTPUT: NONE    RETURN: 	Array (nv x nt) of radii computed at each true anomaly on each 	disk.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_edge_radius.html#dsk_get_edge_radius", "dsk_get_edge_radius", 'routine in <a href="obj/dsk/dsk_get_edge_radius.html">dsk_get_edge_radius.pro</a>', "dsk_get_edge_radius.pro", "", "dsk_get_edge_radius", "", "inneroutertimenoeventdkdta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_inc.html", "dsk_get_inc.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_inc.pro", "", "", " NAME: 	dsk_get_inc    PURPOSE: 	Determines inc for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	inc = dsk_inc(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	inc value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_inc.html#dsk_get_inc", "dsk_get_inc", 'routine in <a href="obj/dsk/dsk_get_inc.html">dsk_get_inc.pro</a>', "dsk_get_inc.pro", "", "dsk_get_inc", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_inner_disk_points.html", "dsk_get_inner_disk_points.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_inner_disk_points.pro", "", "", " NAME: 	dsk_get_inner_disk_points    PURPOSE: 	Computes points on the inner edge of a disk.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	disk_pts = dsk_get_inner_disk_points(dkd, np)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	np:	 Number of points on the edge.    OUTPUT: NONE    KEYWORDS:   INPUT: 	ta:	True anomalies for the points.  Default is the full circle.    OUTPUT: NONE    RETURN: 	Array (np x 3 x nt) of points on the outer edge of each disk, 	in disk body coordinates.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_inner_disk_points.html#dsk_get_inner_disk_points", "dsk_get_inner_disk_points", 'routine in <a href="obj/dsk/dsk_get_inner_disk_points.html">dsk_get_inner_disk_points.pro</a>', "dsk_get_inner_disk_points.pro", "", "dsk_get_inner_disk_points", "", "tadisk_ptsdkdn_points", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lan.html", "dsk_get_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_lan.pro", "", "", " NAME: 	dsk_get_lan    PURPOSE: 	Determines lan for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	lan = dsk_lan(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	lan value associated with each given disk descriptor.  One for each dkd.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lan.html#dsk_get_lan", "dsk_get_lan", 'routine in <a href="obj/dsk/dsk_get_lan.html">dsk_get_lan.pro</a>', "dsk_get_lan.pro", "", "dsk_get_lan", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lib_ap.html", "dsk_get_lib_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_lib_ap.pro", "", "", " NAME: 	dsk_get_lib_ap    PURPOSE: 	Determines lib_ap for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	lib_ap = dsk_lib_ap(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	lib_ap value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lib_ap.html#dsk_get_lib_ap", "dsk_get_lib_ap", 'routine in <a href="obj/dsk/dsk_get_lib_ap.html">dsk_get_lib_ap.pro</a>', "dsk_get_lib_ap.pro", "", "dsk_get_lib_ap", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lib_lan.html", "dsk_get_lib_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_lib_lan.pro", "", "", " NAME: 	dsk_get_lib_lan    PURPOSE: 	Determines lib_lan for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	lib_lan = dsk_lib_lan(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	lib_lan value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lib_lan.html#dsk_get_lib_lan", "dsk_get_lib_lan", 'routine in <a href="obj/dsk/dsk_get_lib_lan.html">dsk_get_lib_lan.pro</a>', "dsk_get_lib_lan.pro", "", "dsk_get_lib_lan", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_liba_ap.html", "dsk_get_liba_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_liba_ap.pro", "", "", " NAME: 	dsk_get_liba_ap    PURPOSE: 	Determines liba_ap for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	liba_ap = dsk_liba_ap(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	liba_ap value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_liba_ap.html#dsk_get_liba_ap", "dsk_get_liba_ap", 'routine in <a href="obj/dsk/dsk_get_liba_ap.html">dsk_get_liba_ap.pro</a>', "dsk_get_liba_ap.pro", "", "dsk_get_liba_ap", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_liba_lan.html", "dsk_get_liba_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_liba_lan.pro", "", "", " NAME: 	dsk_get_liba_lan    PURPOSE: 	Determines liba_lan for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	liba_lan = dsk_liba_lan(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	liba_lan value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_liba_lan.html#dsk_get_liba_lan", "dsk_get_liba_lan", 'routine in <a href="obj/dsk/dsk_get_liba_lan.html">dsk_get_liba_lan.pro</a>', "dsk_get_liba_lan.pro", "", "dsk_get_liba_lan", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_nl.html", "dsk_get_nl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_nl.pro", "", "", " NAME: 	dsk_get_nl    PURPOSE: 	Obtains the nl (number of vertical harmonics) value from the enironment.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	nm = dsk_get_nm()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    ENVIRONMENT VARIABLES: 	DSK_NL:		Sets the nl value.    RETURN: 	Value for nl obtained from the DSK_NL environmet variable.  Default 	is 4.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_nl.html#dsk_get_nl", "dsk_get_nl", 'routine in <a href="obj/dsk/dsk_get_nl.html">dsk_get_nl.pro</a>', "dsk_get_nl.pro", "", "dsk_get_nl", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_nm.html", "dsk_get_nm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_nm.pro", "", "", " NAME: 	dsk_get_nm    PURPOSE: 	Obtains the nm (number of radial harmonics) value from the enironment.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	nm = dsk_get_nm()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    ENVIRONMENT VARIABLES: 	DSK_NM:		Sets the nm value.    RETURN: 	Value for nm obtained from the DSK_NM environmet variable.  Default 	is 4.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_nm.html#dsk_get_nm", "dsk_get_nm", 'routine in <a href="obj/dsk/dsk_get_nm.html">dsk_get_nm.pro</a>', "dsk_get_nm.pro", "", "dsk_get_nm", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_node.html", "dsk_get_node.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_node.pro", "", "", " NAME: 	dsk_get_node    PURPOSE: 	Computes the ascending node of the given disk wrt the given frame 	body descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	node = dsk_get_node(dkd, frame_bd)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	One unit vector for each input descriptor pointng along the 	ascending node of each given disk on each given frame 	body descriptor.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_node.html#dsk_get_node", "dsk_get_node", 'routine in <a href="obj/dsk/dsk_get_node.html">dsk_get_node.pro</a>', "dsk_get_node.pro", "", "dsk_get_node", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_outer_disk_points.html", "dsk_get_outer_disk_points.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_outer_disk_points.pro", "", "", " NAME: 	dsk_get_outer_disk_points    PURPOSE: 	Computes points on the outer edge of a disk.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	disk_pts = dsk_get_outer_disk_points(dkd, np)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	np:	 Number of points on the edge.    OUTPUT: NONE    KEYWORDS:   INPUT: 	ta:	True anomalies for the points.  Default is the full circle.    OUTPUT: NONE    RETURN: 	Array (np x 3 x nt) of points on the outer edge of each disk, 	in disk body coordinates.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_outer_disk_points.html#dsk_get_outer_disk_points", "dsk_get_outer_disk_points", 'routine in <a href="obj/dsk/dsk_get_outer_disk_points.html">dsk_get_outer_disk_points.pro</a>', "dsk_get_outer_disk_points.pro", "", "dsk_get_outer_disk_points", "", "tadisk_ptsdkdn_points", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_get_perp.html", "dsk_get_perp.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_get_perp.pro", "", "", " NAME:        dsk_get_perp    PURPOSE: 	Computes vectors in the direction perpendicular to the azimuthal 	direction at a point on a disk.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        dir = dsk_get_perp(cd, dkx, p)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	dkx:	Any subclass of DISK.  	p:	Point on the disk n inertial coordinates.    OUTPUT:  NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3) of inertial direction vectors.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_get_perp.html#dsk_get_perp", "dsk_get_perp", 'routine in <a href="obj/tools/dsk_get_perp.html">dsk_get_perp.pro</a>', "dsk_get_perp.pro", "", "dsk_get_perp", "", "uucddkdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_radius.html", "dsk_get_radius.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_radius.pro", "", "", " NAME: 	dsk_get_radius    PURPOSE: 	Computes radii along the inner and outer edges of a disk.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	r = dsk_get_radius(dkd, ta, frame_bd)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	ta:	 Array (nv x nt) of true anomalies at which to compute radii.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv x 2 x nt) of radii computed at each true anomaly on each 	disk.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_radius.html#dsk_get_radius", "dsk_get_radius", 'routine in <a href="obj/dsk/dsk_get_radius.html">dsk_get_radius.pro</a>', "dsk_get_radius.pro", "", "dsk_get_radius", "", "one_to_onedkdta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_ranges.html", "dsk_get_ranges.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_ranges.pro", "", "", " NAME: 	dsk_get_ranges    PURPOSE: 	Returns ranges of valid coordinates for the given DISK object.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	ranges = dsk_get_ranges(dkd)    ARGUMENTS:   INPUT: 	dkd:	 Any subclass of DISK.  One descriptor only.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (2 x 3) giving the ranges in radius, true anomaly and altitude.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_ranges.html#dsk_get_ranges", "dsk_get_ranges", 'routine in <a href="obj/dsk/dsk_get_ranges.html">dsk_get_ranges.pro</a>', "dsk_get_ranges.pro", "", "dsk_get_ranges", "", "dkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_hide_points.html", "dsk_hide_points.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_hide_points.pro", "", "", " NAME: 	dsk_hide_points    PURPOSE: 	Hides points wrt a DISK object.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	sub = dsk_hide_points(dkd, r, points)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	r:	 Column vector giving the position of the viewer in the disk 		 body frame.  	points:	 Array (nv x 3 x nt) of points to test, given in the disk 		 body frame    OUTPUT: NONE    KEYWORDS:   INPUT: 	rm:	If set, points are flagged for being in front of or behind 		the disk, rather then just behind it.  	epsilon: 		Distance in front of the disk for a point to be 		considered  in front of  the disk.  Default is 1.     OUTPUT: NONE    RETURN: 	Array Subscripts of all input vectors (points argument) that are hidden 	from the viewer at r by the given disk.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_hide_points.html#dsk_hide_points", "dsk_hide_points", 'routine in <a href="obj/dsk/dsk_hide_points.html">dsk_hide_points.pro</a>', "dsk_hide_points.pro", "", "dsk_hide_points", "", "rmepsilondkdrpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_hide_points.html#_dsk_hide_points", "_dsk_hide_points", 'routine in <a href="obj/dsk/dsk_hide_points.html">dsk_hide_points.pro</a>', "dsk_hide_points.pro", "", "_dsk_hide_points", "", "epsiloninvertdkdrpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_il.html", "dsk_il.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_il.pro", "", "", " NAME: 	dsk_il    PURPOSE: 	Returns il for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	il = dsk_il(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	il value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_il.html#dsk_il", "dsk_il", 'routine in <a href="obj/dsk/dsk_il.html">dsk_il.pro</a>', "dsk_il.pro", "", "dsk_il", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_image_bounds.html", "dsk_image_bounds.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_image_bounds.pro", "", "", " NAME:        dsk_image_bounds    PURPOSE: 	Determines disk coordinate ranges visible in an image described 	by a given camera descriptor.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        dsk_image_bounds, cd, dkx, $ 	        radmin=radmin, radmax=radmax, lonmin=lonmin, lonmax=lonmax    ARGUMENTS:   INPUT: 	cd:	Camera descripor.  	dkx:	Any subclass of DISK.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	np:	Number of border points to compute.  	slop:	Number of pixels by which to expand the image in each 		direction.  	plane:	If set, the sma field in dkx is ignored, so an infinite 		disk is considered.     OUTPUT: 	radmin:	Minimum disk radius in image.  	radmax:	Maximum disk radius in image.  	lonmin:	Minimum disk longitude in image.  	lonmax:	Maximum disk longitude in image.  	border_pts_im:	Array (2,np) of points along the edge of the image.  	status:	-1 if no disk in the image, 0 otherwise.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_image_bounds.html#dsk_image_bounds", "dsk_image_bounds", 'routine in <a href="obj/tools/dsk_image_bounds.html">dsk_image_bounds.pro</a>', "dsk_image_bounds.pro", "", "dsk_image_bounds", "", "slopborder_pts_imradminradmaxlonminlonmaxnpplanestatuscropcddkx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_intersect.html", "dsk_intersect.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_intersect.pro", "", "", " NAME: 	dsk_intersect    PURPOSE: 	Computes ray intersections with a DISK object.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	v_int = dsk_intersect(dkd, v, r)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	v:	 Array (nv x 3 x nt) of column vectors giving the origins 		 of the rays in the body frame.  	r:	 Array (nv x 3 x nt) of column vectors giving the directions 		 of the rays in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	t:	Array(nv x 3 x nt) giving the distances to each intersection. 		Values down each column are identical, i.e., this array 		is a stack of three identical (nv x 1 x nt) arrays.  	hit: 	Array giving the subscripts of the input rays that actually 	 	intersect the disk.    RETURN: 	Array (nv x 3 x nt) of column vectors giving the ray/disk 	intersections in the body frame.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_intersect.html#dsk_intersect", "dsk_intersect", 'routine in <a href="obj/dsk/dsk_intersect.html">dsk_intersect.pro</a>', "dsk_intersect.pro", "", "dsk_intersect", "", "thitnearfaralldkdvr", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_intersect.html#_dsk_intersect", "_dsk_intersect", 'routine in <a href="obj/dsk/dsk_intersect.html">dsk_intersect.pro</a>', "dsk_intersect.pro", "", "_dsk_intersect", "", "thitdkdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_intersect_inertial.html", "dsk_intersect_inertial.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_intersect_inertial.pro", "", "", " NAME: 	dsk_intersect_inertial    PURPOSE: 	Computes ray intersections with a DISK object, in inertial coordinates.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	v_int = dsk_intersect_inertial(dkd, v, r)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	v:	 Array (nv x 3 x nt) of column vectors giving the origins 		 of the rays in the inertial frame.  	r:	 Array (nv x 3 x nt) of column vectors giving the directions 		 of the rays in the inertial frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	t:	Array(nv x 3 x nt) giving the distances to each intersection. 		Values down each column are identical, i.e., this array 		is a stack of three identical (nv x 1 x nt) arrays.  	hit: 	Array giving the subscripts of the input rays that actually 	 	intersect the disk.    RETURN: 	Array (nv x 3 x nt) of column vectors giving the ray/disk 	intersections in the inertial frame.  Note this if inertial 	results are needed, this routine is slightly faster than 	dsk_intersect.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_intersect_inertial.html#dsk_intersect_inertial", "dsk_intersect_inertial", 'routine in <a href="obj/dsk/dsk_intersect_inertial.html">dsk_intersect_inertial.pro</a>', "dsk_intersect_inertial.pro", "", "dsk_intersect_inertial", "", "thitnoeventdkdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_l.html", "dsk_l.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_l.pro", "", "", " NAME: 	dsk_l    PURPOSE: 	Returns l for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	l = dsk_l(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	l value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_l.html#dsk_l", "dsk_l", 'routine in <a href="obj/dsk/dsk_l.html">dsk_l.pro</a>', "dsk_l.pro", "", "dsk_l", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_libal.html", "dsk_libal.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_libal.pro", "", "", " NAME: 	dsk_libal    PURPOSE: 	Returns libal for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	libal = dsk_libal(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	libal value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_libal.html#dsk_libal", "dsk_libal", 'routine in <a href="obj/dsk/dsk_libal.html">dsk_libal.pro</a>', "dsk_libal.pro", "", "dsk_libal", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_libam.html", "dsk_libam.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_libam.pro", "", "", " NAME: 	dsk_libam    PURPOSE: 	Returns libam for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	libam = dsk_libam(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	libam value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_libam.html#dsk_libam", "dsk_libam", 'routine in <a href="obj/dsk/dsk_libam.html">dsk_libam.pro</a>', "dsk_libam.pro", "", "dsk_libam", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_libl.html", "dsk_libl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_libl.pro", "", "", " NAME: 	dsk_libl    PURPOSE: 	Returns libl for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	libl = dsk_libl(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	libl value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_libl.html#dsk_libl", "dsk_libl", 'routine in <a href="obj/dsk/dsk_libl.html">dsk_libl.pro</a>', "dsk_libl.pro", "", "dsk_libl", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_libm.html", "dsk_libm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_libm.pro", "", "", " NAME: 	dsk_libm    PURPOSE: 	Returns libm for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	libm = dsk_libm(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	libm value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_libm.html#dsk_libm", "dsk_libm", 'routine in <a href="obj/dsk/dsk_libm.html">dsk_libm.pro</a>', "dsk_libm.pro", "", "dsk_libm", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_m.html", "dsk_m.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_m.pro", "", "", " NAME: 	dsk_m    PURPOSE: 	Returns m for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	m = dsk_m(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	m value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_m.html#dsk_m", "dsk_m", 'routine in <a href="obj/dsk/dsk_m.html">dsk_m.pro</a>', "dsk_m.pro", "", "dsk_m", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_nl.html", "dsk_nl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_nl.pro", "", "", " NAME: 	dsk_nl    PURPOSE: 	Returns nl for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	nl = dsk_nl(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	nl value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_nl.html#dsk_nl", "dsk_nl", 'routine in <a href="obj/dsk/dsk_nl.html">dsk_nl.pro</a>', "dsk_nl.pro", "", "dsk_nl", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_nm.html", "dsk_nm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_nm.pro", "", "", " NAME: 	dsk_nm    PURPOSE: 	Returns nm for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	nm = dsk_nm(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	nm value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_nm.html#dsk_nm", "dsk_nm", 'routine in <a href="obj/dsk/dsk_nm.html">dsk_nm.pro</a>', "dsk_nm.pro", "", "dsk_nm", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_projected_resolution.html", "dsk_projected_resolution.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_projected_resolution.pro", "", "", " NAME:        dsk_projected_resolution    PURPOSE: 	Computes the resolution (actually scale) components at a point on a 	disk in a given camera.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        res = dsk_projected_resolution(dkx, cd, p, scale)    ARGUMENTS:   INPUT: 	dkx:	Any subclass of DISK.  	cd:	Camera descriptor.  	p:	Point on the dkx in inertial coordinates.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	rad:	Pixel scale in the radial direction.  	lon:	Pixel scale in the longitude direction.  	perp:	Pixel scale in the direction perpendicular to the 		projected longitude direction.  	rr:	Intercept radius.    RETURN: 	Radial resolution on dkx at r, computed as the length of a 	segment bisecting the intersection ellipse in the radial direction.    MODIFICATION HISTORY:        Written by:     Spitale, usning an approach suggested by M. Tiscareno   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_projected_resolution.html#dsk_projected_resolution", "dsk_projected_resolution", 'routine in <a href="obj/tools/dsk_projected_resolution.html">dsk_projected_resolution.pro</a>', "dsk_projected_resolution.pro", "", "dsk_projected_resolution", "", "radlonperprrdkdcdpscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_query.html", "dsk_query.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_query.pro", "", "", " NAME: 	dsk_query    PURPOSE: 	Returns the fields associated with a DISK object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/DSK    CALLING SEQUENCE: 	dsk_query, dkd, <keywords>=<values>    ARGUMENTS:   INPUT: 	dkd:	DISK object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	DISK object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_query.html#dsk_query", "dsk_query", 'routine in <a href="obj/dsk/dsk_query.html">dsk_query.pro</a>', "dsk_query.pro", "", "dsk_query", "", "conditioncatnoeventxd@dsk__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_radial_resolution.html", "dsk_radial_resolution.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_radial_resolution.pro", "", "", " NAME:        dsk_radial_resolution    PURPOSE: 	Computes the radial resolution at a point on a disk in a 	given camera.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        res = dsk_radial_resolution(dkx, cd, r, scale)    ARGUMENTS:   INPUT: 	dkx:	Any subclass of DISK.  	cd:	Camera descriptor.  	r:	Point on the dkx in inertial coordinates.    OUTPUT:  NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Radial resolution on dkx at r, computed as the length of a 	segment bisecting the intersection ellipse in the radial direction.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_radial_resolution.html#dsk_radial_resolution", "dsk_radial_resolution", 'routine in <a href="obj/tools/dsk_radial_resolution.html">dsk_radial_resolution.pro</a>', "dsk_radial_resolution.pro", "", "dsk_radial_resolution", "", "dkdcdrscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_reflect.html", "dsk_reflect.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_reflect.pro", "", "", " NAME: 	dsk_reflect    PURPOSE: 	Computes ray reflections with a DISK object.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	v_int = dsk_reflect(dkd, v, r)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	v:	 Array (nv x 3 x nt) of column vectors giving the observer 		 position in the body frame.  	r:	 Array (nv x 3 x nt) of column vectors giving the source 		 position in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	hit: 	Array giving the subscripts of the input rays that actually 	 	reflect on the disk.    RETURN: 	Array (nv x 3 x nt) of column vectors giving the ray/disk 	reflections in the body frame.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_reflect.html#dsk_reflect", "dsk_reflect", 'routine in <a href="obj/dsk/dsk_reflect.html">dsk_reflect.pro</a>', "dsk_reflect.pro", "", "dsk_reflect", "", "hitdkdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_replicate.html", "dsk_replicate.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_replicate.pro", "", "", " NAME: 	dsk_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	xd = dsk_replicate(dkd, dim)    ARGUMENTS:   INPUT: 	dkd:	 Any superclass of DISK.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_replicate.html#dsk_replicate", "dsk_replicate", 'routine in <a href="obj/dsk/dsk_replicate.html">dsk_replicate.pro</a>', "dsk_replicate.pro", "", "dsk_replicate", "", "dkddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_scale.html", "dsk_scale.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_scale.pro", "", "", " NAME: 	dsk_scale    PURPOSE: 	Returns scale for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	scale = dsk_scale(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	scale value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_scale.html#dsk_scale", "dsk_scale", 'routine in <a href="obj/dsk/dsk_scale.html">dsk_scale.pro</a>', "dsk_scale.pro", "", "dsk_scale", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_ap.html", "dsk_set_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_ap.pro", "", "", " NAME: 	dsk_set_ap    PURPOSE: 	Replaces ap in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_ap, bx, ap    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	ap:	 New ap value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_ap.html#dsk_set_ap", "dsk_set_ap", 'routine in <a href="obj/dsk/dsk_set_ap.html">dsk_set_ap.pro</a>', "dsk_set_ap.pro", "", "dsk_set_ap", "", "dkdapframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dap.html", "dsk_set_dap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dap.pro", "", "", " NAME: 	dsk_set_dap    PURPOSE: 	Replaces the apsidal shift in each given disk descriptor.  Half of the 	shift is applied to each edge, so as to not affect the mean periapse 	direction.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dap, bx, dap    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dap:	 New dap value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dap.html#dsk_set_dap", "dsk_set_dap", 'routine in <a href="obj/dsk/dsk_set_dap.html">dsk_set_dap.pro</a>', "dsk_set_dap.pro", "", "dsk_set_dap", "", "noeventdkddap", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dapdt.html", "dsk_set_dapdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dapdt.pro", "", "", " NAME: 	dsk_set_dapdt    PURPOSE: 	Replaces dapdt in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dapdt, bx, dapdt    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dapdt:	 New dapdt value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dapdt.html#dsk_set_dapdt", "dsk_set_dapdt", 'routine in <a href="obj/dsk/dsk_set_dapdt.html">dsk_set_dapdt.pro</a>', "dsk_set_dapdt.pro", "", "dsk_set_dapdt", "", "dkddapdtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlandt.html", "dsk_set_dlandt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlandt.pro", "", "", " NAME: 	dsk_set_dlandt    PURPOSE: 	Replaces dlandt in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dlandt, bx, dlandt    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dlandt:	 New dlandt value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlandt.html#dsk_set_dlandt", "dsk_set_dlandt", 'routine in <a href="obj/dsk/dsk_set_dlandt.html">dsk_set_dlandt.pro</a>', "dsk_set_dlandt.pro", "", "dsk_set_dlandt", "", "dkddlandtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibdt_ap.html", "dsk_set_dlibdt_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlibdt_ap.pro", "", "", " NAME: 	dsk_set_dlibdt_ap    PURPOSE: 	Sets dlibdt_ap in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dlibdt_ap, bx, dlibdt_ap, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dlibdt_ap:	 New dlibdt_ap value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibdt_ap.html#dsk_set_dlibdt_ap", "dsk_set_dlibdt_ap", 'routine in <a href="obj/dsk/dsk_set_dlibdt_ap.html">dsk_set_dlibdt_ap.pro</a>', "dsk_set_dlibdt_ap.pro", "", "dsk_set_dlibdt_ap", "", "dkddlibdt_apframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibdt_lan.html", "dsk_set_dlibdt_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlibdt_lan.pro", "", "", " NAME: 	dsk_set_dlibdt_lan    PURPOSE: 	Sets dlibdt_lan in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dlibdt_lan, bx, dlibdt_lan, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dlibdt_lan:	 New dlibdt_lan value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibdt_lan.html#dsk_set_dlibdt_lan", "dsk_set_dlibdt_lan", 'routine in <a href="obj/dsk/dsk_set_dlibdt_lan.html">dsk_set_dlibdt_lan.pro</a>', "dsk_set_dlibdt_lan.pro", "", "dsk_set_dlibdt_lan", "", "dkddlibdt_lanframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibldt.html", "dsk_set_dlibldt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlibldt.pro", "", "", " NAME: 	dsk_set_dlibldt    PURPOSE: 	Replaces dlibldt in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dlibldt, bx, dlibldt    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dlibldt:	 New dlibldt value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibldt.html#dsk_set_dlibldt", "dsk_set_dlibldt", 'routine in <a href="obj/dsk/dsk_set_dlibldt.html">dsk_set_dlibldt.pro</a>', "dsk_set_dlibldt.pro", "", "dsk_set_dlibldt", "", "noeventdkddlibldt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibmdt.html", "dsk_set_dlibmdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlibmdt.pro", "", "", " NAME: 	dsk_set_dlibmdt    PURPOSE: 	Replaces dlibmdt in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dlibmdt, bx, dlibmdt    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dlibmdt:	 New dlibmdt value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibmdt.html#dsk_set_dlibmdt", "dsk_set_dlibmdt", 'routine in <a href="obj/dsk/dsk_set_dlibmdt.html">dsk_set_dlibmdt.pro</a>', "dsk_set_dlibmdt.pro", "", "dsk_set_dlibmdt", "", "noeventdkddlibmdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlpmdt.html", "dsk_set_dlpmdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlpmdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlpmdt.html#dsk_set_dlpmdt", "dsk_set_dlpmdt", 'routine in <a href="obj/dsk/dsk_set_dlpmdt.html">dsk_set_dlpmdt.pro</a>', "dsk_set_dlpmdt.pro", "", "dsk_set_dlpmdt", "", "bxdlpmdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dtaanldt.html", "dsk_set_dtaanldt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dtaanldt.pro", "", "", " NAME: 	dsk_set_dtaanldt    PURPOSE: 	Replaces dtaanldt in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dtaanldt, bx, dtaanldt    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dtaanldt:	 New dtaanldt value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dtaanldt.html#dsk_set_dtaanldt", "dsk_set_dtaanldt", 'routine in <a href="obj/dsk/dsk_set_dtaanldt.html">dsk_set_dtaanldt.pro</a>', "dsk_set_dtaanldt.pro", "", "dsk_set_dtaanldt", "", "noeventdkddtaanldt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dtapmdt.html", "dsk_set_dtapmdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dtapmdt.pro", "", "", " NAME: 	dsk_set_dtapmdt    PURPOSE: 	Replaces dtapmdt in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dtapmdt, bx, dtapmdt    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dtapmdt:	 New dtapmdt value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dtapmdt.html#dsk_set_dtapmdt", "dsk_set_dtapmdt", 'routine in <a href="obj/dsk/dsk_set_dtapmdt.html">dsk_set_dtapmdt.pro</a>', "dsk_set_dtapmdt.pro", "", "dsk_set_dtapmdt", "", "noeventdkddtapmdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_ecc.html", "dsk_set_ecc.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_ecc.pro", "", "", " NAME: 	dsk_set_ecc    PURPOSE: 	Replaces ecc in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_ecc, bx, ecc    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	ecc:	 New ecc value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_ecc.html#dsk_set_ecc", "dsk_set_ecc", 'routine in <a href="obj/dsk/dsk_set_ecc.html">dsk_set_ecc.pro</a>', "dsk_set_ecc.pro", "", "dsk_set_ecc", "", "noeventdkdecc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_em.html", "dsk_set_em.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_em.pro", "", "", " NAME: 	dsk_set_em    PURPOSE: 	Replaces em in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_em, bx, em    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	em:	 New em value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_em.html#dsk_set_em", "dsk_set_em", 'routine in <a href="obj/dsk/dsk_set_em.html">dsk_set_em.pro</a>', "dsk_set_em.pro", "", "dsk_set_em", "", "noeventdkdem", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_il.html", "dsk_set_il.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_il.pro", "", "", " NAME: 	dsk_set_il    PURPOSE: 	Replaces il in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_il, bx, il    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	il:	 New il value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_il.html#dsk_set_il", "dsk_set_il", 'routine in <a href="obj/dsk/dsk_set_il.html">dsk_set_il.pro</a>', "dsk_set_il.pro", "", "dsk_set_il", "", "noeventdkdil", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_inc.html", "dsk_set_inc.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_inc.pro", "", "", " NAME: 	dsk_set_inc    PURPOSE: 	Sets inc in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_inc, bx, inc, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	inc:	 New inc value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_inc.html#dsk_set_inc", "dsk_set_inc", 'routine in <a href="obj/dsk/dsk_set_inc.html">dsk_set_inc.pro</a>', "dsk_set_inc.pro", "", "dsk_set_inc", "", "dkdincframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_l.html", "dsk_set_l.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_l.pro", "", "", " NAME: 	dsk_set_l    PURPOSE: 	Replaces l in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_l, bx, l    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	l:	 New l value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_l.html#dsk_set_l", "dsk_set_l", 'routine in <a href="obj/dsk/dsk_set_l.html">dsk_set_l.pro</a>', "dsk_set_l.pro", "", "dsk_set_l", "", "noeventdkdl", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lan.html", "dsk_set_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_lan.pro", "", "", " NAME: 	dsk_set_lan    PURPOSE: 	Sets lan in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_lan, bx, lan, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	lan:	 New lan value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lan.html#dsk_set_lan", "dsk_set_lan", 'routine in <a href="obj/dsk/dsk_set_lan.html">dsk_set_lan.pro</a>', "dsk_set_lan.pro", "", "dsk_set_lan", "", "dkdlanframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lib_ap.html", "dsk_set_lib_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_lib_ap.pro", "", "", " NAME: 	dsk_set_lib_ap    PURPOSE: 	Sets lib_ap in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_lib_ap, bx, lib_ap, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	lib_ap:	 New lib_ap value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lib_ap.html#dsk_set_lib_ap", "dsk_set_lib_ap", 'routine in <a href="obj/dsk/dsk_set_lib_ap.html">dsk_set_lib_ap.pro</a>', "dsk_set_lib_ap.pro", "", "dsk_set_lib_ap", "", "dkdlib_apframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lib_lan.html", "dsk_set_lib_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_lib_lan.pro", "", "", " NAME: 	dsk_set_lib_lan    PURPOSE: 	Sets lib_lan in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_lib_lan, bx, lib_lan, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	lib_lan:	 New lib_lan value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lib_lan.html#dsk_set_lib_lan", "dsk_set_lib_lan", 'routine in <a href="obj/dsk/dsk_set_lib_lan.html">dsk_set_lib_lan.pro</a>', "dsk_set_lib_lan.pro", "", "dsk_set_lib_lan", "", "dkdlib_lanframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_liba_ap.html", "dsk_set_liba_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_liba_ap.pro", "", "", " NAME: 	dsk_set_liba_ap    PURPOSE: 	Sets liba_ap in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_liba_ap, bx, liba_ap, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	liba_ap:	 New liba_ap value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_liba_ap.html#dsk_set_liba_ap", "dsk_set_liba_ap", 'routine in <a href="obj/dsk/dsk_set_liba_ap.html">dsk_set_liba_ap.pro</a>', "dsk_set_liba_ap.pro", "", "dsk_set_liba_ap", "", "dkdliba_apframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_liba_lan.html", "dsk_set_liba_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_liba_lan.pro", "", "", " NAME: 	dsk_set_liba_lan    PURPOSE: 	Sets liba_lan in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_liba_lan, bx, liba_lan, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	liba_lan:	 New liba_lan value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_liba_lan.html#dsk_set_liba_lan", "dsk_set_liba_lan", 'routine in <a href="obj/dsk/dsk_set_liba_lan.html">dsk_set_liba_lan.pro</a>', "dsk_set_liba_lan.pro", "", "dsk_set_liba_lan", "", "dkdliba_lanframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libal.html", "dsk_set_libal.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_libal.pro", "", "", " NAME: 	dsk_set_libal    PURPOSE: 	Replaces libal in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_libal, bx, libal    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	libal:	 New libal value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libal.html#dsk_set_libal", "dsk_set_libal", 'routine in <a href="obj/dsk/dsk_set_libal.html">dsk_set_libal.pro</a>', "dsk_set_libal.pro", "", "dsk_set_libal", "", "noeventdkdlibal", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libam.html", "dsk_set_libam.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_libam.pro", "", "", " NAME: 	dsk_set_libam    PURPOSE: 	Replaces libam in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_libam, bx, libam    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	libam:	 New libam value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libam.html#dsk_set_libam", "dsk_set_libam", 'routine in <a href="obj/dsk/dsk_set_libam.html">dsk_set_libam.pro</a>', "dsk_set_libam.pro", "", "dsk_set_libam", "", "noeventdkdlibam", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libl.html", "dsk_set_libl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_libl.pro", "", "", " NAME: 	dsk_set_libl    PURPOSE: 	Replaces libl in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_libl, bx, libl    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	libl:	 New libl value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libl.html#dsk_set_libl", "dsk_set_libl", 'routine in <a href="obj/dsk/dsk_set_libl.html">dsk_set_libl.pro</a>', "dsk_set_libl.pro", "", "dsk_set_libl", "", "noeventdkdlibl", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libm.html", "dsk_set_libm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_libm.pro", "", "", " NAME: 	dsk_set_libm    PURPOSE: 	Replaces libm in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_libm, bx, libm    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	libm:	 New libm value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libm.html#dsk_set_libm", "dsk_set_libm", 'routine in <a href="obj/dsk/dsk_set_libm.html">dsk_set_libm.pro</a>', "dsk_set_libm.pro", "", "dsk_set_libm", "", "noeventdkdlibm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lpm.html", "dsk_set_lpm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_lpm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lpm.html#dsk_set_lpm", "dsk_set_lpm", 'routine in <a href="obj/dsk/dsk_set_lpm.html">dsk_set_lpm.pro</a>', "dsk_set_lpm.pro", "", "dsk_set_lpm", "", "bxlpm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_m.html", "dsk_set_m.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_m.pro", "", "", " NAME: 	dsk_set_m    PURPOSE: 	Replaces m in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_m, bx, m    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	m:	 New m value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_m.html#dsk_set_m", "dsk_set_m", 'routine in <a href="obj/dsk/dsk_set_m.html">dsk_set_m.pro</a>', "dsk_set_m.pro", "", "dsk_set_m", "", "noeventdkdm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_nl.html", "dsk_set_nl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_nl.pro", "", "", " NAME: 	dsk_set_nl    PURPOSE: 	Replaces nl in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_nl, bx, nl    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	nl:	 New nl value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_nl.html#dsk_set_nl", "dsk_set_nl", 'routine in <a href="obj/dsk/dsk_set_nl.html">dsk_set_nl.pro</a>', "dsk_set_nl.pro", "", "dsk_set_nl", "", "noeventdkdnl", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_nm.html", "dsk_set_nm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_nm.pro", "", "", " NAME: 	dsk_set_nm    PURPOSE: 	Replaces nm in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_nm, bx, nm    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	nm:	 New nm value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_nm.html#dsk_set_nm", "dsk_set_nm", 'routine in <a href="obj/dsk/dsk_set_nm.html">dsk_set_nm.pro</a>', "dsk_set_nm.pro", "", "dsk_set_nm", "", "noeventdkdnm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_phase_fn.html", "dsk_set_phase_fn.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_phase_fn.pro", "", "", " NAME: 	dsk_set_phase_fn    PURPOSE:        Replaces the phase function for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_phase_fn, dkd, phase_fn    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK descriptors.  	phase_fn: Array (nt) of new phase functions.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_phase_fn.html#dsk_set_phase_fn", "dsk_set_phase_fn", 'routine in <a href="obj/dsk/dsk_set_phase_fn.html">dsk_set_phase_fn.pro</a>', "dsk_set_phase_fn.pro", "", "dsk_set_phase_fn", "", "noeventdkdphase_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_refl_fn.html", "dsk_set_refl_fn.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_refl_fn.pro", "", "", " NAME: 	dsk_set_refl_fn    PURPOSE:        Replaces the reflection function for each given disk descriptor.    CATEGORY: 	NV/LIB/dsk    CALLING SEQUENCE: 	dsk_set_refl_fn, dkd, refl_fn    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK descriptors.  	refl_fn: Array (nt) of new reflection functions.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_refl_fn.html#dsk_set_refl_fn", "dsk_set_refl_fn", 'routine in <a href="obj/dsk/dsk_set_refl_fn.html">dsk_set_refl_fn.pro</a>', "dsk_set_refl_fn.pro", "", "dsk_set_refl_fn", "", "noeventdkdrefl_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_scale.html", "dsk_set_scale.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_scale.pro", "", "", " NAME: 	dsk_set_scale    PURPOSE: 	Replaces the scale in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_scale, bx, scale    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	scale:	 New scale value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_scale.html#dsk_set_scale", "dsk_set_scale", 'routine in <a href="obj/dsk/dsk_set_scale.html">dsk_set_scale.pro</a>', "dsk_set_scale.pro", "", "dsk_set_scale", "", "noeventdkdscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_sma.html", "dsk_set_sma.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_sma.pro", "", "", " NAME: 	dsk_set_sma    PURPOSE: 	Replaces the sma in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_sma, bx, sma    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	sma:	 New sma value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_sma.html#dsk_set_sma", "dsk_set_sma", 'routine in <a href="obj/dsk/dsk_set_sma.html">dsk_set_sma.pro</a>', "dsk_set_sma.pro", "", "dsk_set_sma", "", "noeventdkdsma", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_taanl.html", "dsk_set_taanl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_taanl.pro", "", "", " NAME: 	dsk_set_taanl    PURPOSE: 	Replaces taanl in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_taanl, bx, taanl    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	taanl:	 New taanl value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_taanl.html#dsk_set_taanl", "dsk_set_taanl", 'routine in <a href="obj/dsk/dsk_set_taanl.html">dsk_set_taanl.pro</a>', "dsk_set_taanl.pro", "", "dsk_set_taanl", "", "noeventdkdtaanl", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_tanl.html", "dsk_set_tanl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_tanl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_tanl.html#dsk_set_tanl", "dsk_set_tanl", 'routine in <a href="obj/dsk/dsk_set_tanl.html">dsk_set_tanl.pro</a>', "dsk_set_tanl.pro", "", "dsk_set_tanl", "", "bxtanl", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_tapm.html", "dsk_set_tapm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_tapm.pro", "", "", " NAME: 	dsk_set_tapm    PURPOSE: 	Replaces tapm in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_tapm, bx, tapm    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	tapm:	 New tapm value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_tapm.html#dsk_set_tapm", "dsk_set_tapm", 'routine in <a href="obj/dsk/dsk_set_tapm.html">dsk_set_tapm.pro</a>', "dsk_set_tapm.pro", "", "dsk_set_tapm", "", "noeventdkdtapm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_shape_radial.html", "dsk_shape_radial.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_shape_radial.pro", "", "", " NAME: 	dsk_shape_radial    PURPOSE: 	Computes radii along the edge of a disk using disk elements.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	z = dsk_shape_radial(a, e, dap, ta, m, em, tapm)    ARGUMENTS:   INPUT: 	a:	 Array (nt) of semimajor axis values.  	e:	 Array (nt) of eccentricity values.  	dap:	 Array (nt) of apsidal shift values.  	ta:	 Array (nv x nt) of true anomalies at which to compute radii.  	m:	 Array (nt x nm) of radial wavenumbers.  	em:	 Array (nt x nm) of eccentricities for each m.  	tapm:	 Array (nt x nm) of true anomalies of periapse for each m.     OUTPUT: NONE    KEYWORDS:   INPUT: 	mm:	If set, only the radius component for this wavenumber 		is returned.  	mii:	If set, only the radius component with this index 		is returned.    OUTPUT: NONE    RETURN: 	Array (nv x nt) of radii computed at each true anomaly on each 	disk.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_shape_radial.html#dsk_shape_radial", "dsk_shape_radial", 'routine in <a href="obj/dsk/dsk_shape_radial.html">dsk_shape_radial.pro</a>', "dsk_shape_radial.pro", "", "dsk_shape_radial", "", "mmmii_a_e_dapta_m_em_tapm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_shape_vertical.html", "dsk_shape_vertical.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_shape_vertical.pro", "", "", " NAME: 	dsk_shape_vertical    PURPOSE: 	Computes elevations along the edge of a disk using disk elements.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	z = dsk_shape_vertical(dkd, a, ta, l, il, taanl)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	a:	 Array (nt) of semimajor axis values.  	ta:	 Array (nta) of true anomalies at which to compute elevations.  	l:	 Array (nt) of vertical wavenumbers.  	il:	 Array (nt) of inclinations for each l.  	taanl:	 Array (nt) of true anomalies of ascending node for each l.     OUTPUT: NONE    KEYWORDS:   INPUT: 	ll:	If set, only the elevation component for this wavenumber 		is returned.  	lii:	If set, only the elevation component with this index 		is returned.    OUTPUT: NONE    RETURN: 	Array (nt x nta) of elevations computed at each true anomaly on each 	disk.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_shape_vertical.html#dsk_shape_vertical", "dsk_shape_vertical", 'routine in <a href="obj/dsk/dsk_shape_vertical.html">dsk_shape_vertical.pro</a>', "dsk_shape_vertical.pro", "", "dsk_shape_vertical", "", "dkdllliiataliltaanl", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_sma.html", "dsk_sma.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_sma.pro", "", "", " NAME: 	dsk_sma    PURPOSE: 	Returns sma for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	sma = dsk_sma(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	sma value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_sma.html#dsk_sma", "dsk_sma", 'routine in <a href="obj/dsk/dsk_sma.html">dsk_sma.pro</a>', "dsk_sma.pro", "", "dsk_sma", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_surface_normal.html", "dsk_surface_normal.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_surface_normal.pro", "", "", " NAME: 	dsk_surface_normal    PURPOSE: 	Computes the surface normal for a DISK object at the given 	body-frame positions.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	n = dsk_surface_normal(dkd, r)    ARGUMENTS:   INPUT: 	dkd:	Array (nt) of any subclass of DISK descriptors.  	v:	Array (nv,3) of observer positions in the BODY frame.  	r:	Array (nv,3) of surface positions in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: 	north:     If set, the retruned normals will be pointed north. 	           Otherwise, they point toward the observer's hemisphere.     OUTPUT: NONE    RETURN: 	Array (nv, 3, nt) of surface unit normals in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_surface_normal.html#dsk_surface_normal", "dsk_surface_normal", 'routine in <a href="obj/dsk/dsk_surface_normal.html">dsk_surface_normal.pro</a>', "dsk_surface_normal.pro", "", "dsk_surface_normal", "", "noeventnorthdkdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_swap.html", "dsk_swap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_swap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_swap.html#dsk_swap", "dsk_swap", 'routine in <a href="obj/dsk/dsk_swap.html">dsk_swap.pro</a>', "dsk_swap.pro", "", "dsk_swap", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_taanl.html", "dsk_taanl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_taanl.pro", "", "", " NAME: 	dsk_taanl    PURPOSE: 	Returns taanl for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	taanl = dsk_taanl(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	taanl value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_taanl.html#dsk_taanl", "dsk_taanl", 'routine in <a href="obj/dsk/dsk_taanl.html">dsk_taanl.pro</a>', "dsk_taanl.pro", "", "dsk_taanl", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_tapm.html", "dsk_tapm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_tapm.pro", "", "", " NAME: 	dsk_tapm    PURPOSE: 	Returns tapm for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	tapm = dsk_tapm(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	tapm value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_tapm.html#dsk_tapm", "dsk_tapm", 'routine in <a href="obj/dsk/dsk_tapm.html">dsk_tapm.pro</a>', "dsk_tapm.pro", "", "dsk_tapm", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_valid_edges.html", "dsk_valid_edges.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_valid_edges.pro", "", "", " NAME: 	dsk_valid_edges    PURPOSE: 	Determines which edges (i.e., inner/outer) in the input DISK objects 	are valid.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	sub = dsk_valid_edges(dkd, </inner|/outer|/all>)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT: 	inner:	If set, only the inner edges are tested.  	outer:	If set, only the outer edges are tested.  	all:	If set, the inner and outer edges are tested, and must 		both be valid to be selected.    OUTPUT: NONE    RETURN: 	Array of subscripts of the descriptors whose edges meet the criteria 	defined by the input keyowrds.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_valid_edges.html#dsk_valid_edges", "dsk_valid_edges", 'routine in <a href="obj/dsk/dsk_valid_edges.html">dsk_valid_edges.pro</a>', "dsk_valid_edges.pro", "", "dsk_valid_edges", "", "innerouterallnoeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_widen.html", "dsk_widen.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_widen.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_widen.html#dsk_widen", "dsk_widen", 'routine in <a href="obj/dsk/dsk_widen.html">dsk_widen.pro</a>', "dsk_widen.pro", "", "dsk_widen", "", "noeventdkdwidth", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_atan.html", "edge_model_atan.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_atan.pro", "", "", " NAME:        edge_model_atan    PURPOSE: 	Calculates an arctan edge model for use in curve fitting.   CATEGORY:        NV/LIB/TOOLS/ICV    CALLING SEQUENCE:        result = edge_model_atan(n, w)    ARGUMENTS:   INPUT: 	    n:	Size of the model in samples  	    a:	Scaling factor: larger values give a sharper edge.    OUTPUT: 	 zero:  The array element corresponding to the physical edge.  	delta:	The number of pixels represented by each element 		Currently = 1.0  	cd:	Not used.    RETURN: 	An array containing the model.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_atan.html#edge_model_atan", "edge_model_atan", 'routine in <a href="obj/tools/icv/edge_model_atan.html">edge_model_atan.pro</a>', "edge_model_atan.pro", "", "edge_model_atan", "", "zerodeltacdna", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_gauss.html", "edge_model_gauss.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_gauss.pro", "", "", " NAME:        edge_model_gauss    PURPOSE: 	Calculates a gaussian edge model for use in curve fitting.   CATEGORY:        NV/LIB/TOOLS/ICV    CALLING SEQUENCE:        result = edge_model_gauss(n, w)    ARGUMENTS:   INPUT: 	    n:	Size of the model in samples  	    w:	Width of the gaussian (sigma)    OUTPUT: 	 zero:  The array element corresponding to the phyiscal edge.  	delta:	The number of pixels represented by each element 		Currently = 1.0  	cd:	Not used.    RETURN: 	An array containing the model.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_gauss.html#edge_model_gauss", "edge_model_gauss", 'routine in <a href="obj/tools/icv/edge_model_gauss.html">edge_model_gauss.pro</a>', "edge_model_gauss.pro", "", "edge_model_gauss", "", "zerodeltacdnw", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_nav_limb.html", "edge_model_nav_limb.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_nav_limb.pro", "", "", " NAME:        edge_model_nav_limb    PURPOSE: 	Returns the edge model used by the VICAR program NAV for limb fits.   CATEGORY:        NV/LIB/TOOLS/ICV    CALLING SEQUENCE:        result = edge_model_nav_limb()    ARGUMENTS:   INPUT: 	    NONE    OUTPUT: 	 zero:  The array element corresponding to the phyiscal edge.  	delta:	The number of pixels represented by each element 		Currently = 1.0  	cd:	Not used.    RETURN: 	An array containing the model.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_nav_limb.html#edge_model_nav_limb", "edge_model_nav_limb", 'routine in <a href="obj/tools/icv/edge_model_nav_limb.html">edge_model_nav_limb.pro</a>', "edge_model_nav_limb.pro", "", "edge_model_nav_limb", "", "zerodeltacd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_nav_ring.html", "edge_model_nav_ring.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_nav_ring.pro", "", "", " NAME:        edge_model_nav_ring    PURPOSE: 	Returns the edge model used by the VICAR program NAV for ring fits.   CATEGORY:        NV/LIB/TOOLS/ICV    CALLING SEQUENCE:        result = edge_model_nav_ring()    KEYWORDS:   INPUT: NONE    OUTPUT: 	 zero:  The array element corresponding to the phyiscal edge.  	delta:	The number of pixels represented by each element 		Currently = 1.0  	cd:	Not used.    RETURN: 	An array containing the model.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_nav_ring.html#edge_model_nav_ring", "edge_model_nav_ring", 'routine in <a href="obj/tools/icv/edge_model_nav_ring.html">edge_model_nav_ring.pro</a>', "edge_model_nav_ring.pro", "", "edge_model_nav_ring", "", "zerodeltacd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_psf_ring.html", "edge_model_psf_ring.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_psf_ring.pro", "", "", " NAME:        edge_model_psf_ring    PURPOSE: 	Returns an edge model produced by convolving a sharp edge with 	a point-spread function.   CATEGORY:        NV/LIB/TOOLS/ICV    CALLING SEQUENCE:        result = edge_model_psf_ring()    KEYWORDS:   INPUT: NONE    OUTPUT: 	 zero:  The array element corresponding to the phyiscal edge.  	delta:	The number of pixels represented by each element 		Currently = 1.0  	cd:	Camera descriptor fromwhich to obtain the PSF.    RETURN: 	An array containing the model.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_psf_ring.html#edge_model_psf_ring", "edge_model_psf_ring", 'routine in <a href="obj/tools/icv/edge_model_psf_ring.html">edge_model_psf_ring.pro</a>', "edge_model_psf_ring.pro", "", "edge_model_psf_ring", "", "cdzerodelta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/epoch_radec.html", "epoch_radec.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "epoch_radec.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/epoch_radec.html#epoch_radec", "epoch_radec", 'routine in <a href="obj/tools/epoch_radec.html">epoch_radec.pro</a>', "epoch_radec.pro", "", "epoch_radec", "", "odbxepoch", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/fill_ring.html", "fill_ring.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "fill_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/fill_ring.html#fill_ring", "fill_ring", 'routine in <a href="obj/tools/fill_ring.html">fill_ring.pro</a>', "fill_ring.pro", "", "fill_ring", "", "cdrdimagesub", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/footprint.html", "footprint.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "footprint.pro", "", "", " NAME:        footprint    PURPOSE: 	Computes the footprint of a camera on a given body.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        surface_pts = footprint(cd, bx)    ARGUMENTS:   INPUT: 	cd:		Camera descripor.  Only one allowed.  	bx:		Body descriptors.    OUTPUT:  NONE    KEYWORDS:   INPUT: 	corners:	Array(2,2) giving corers of image region to consider.  	slop:		Number of pixels by which to expand the image in each 			direction.  	image_pts:	Array (2,np) of points along the edge of the image.  	sample:		Sampling rate; default is 1 pixel.     OUTPUT: 	image_pts:	Footprint points in the image frame.  	body_p:		Array (nhit) of pointers to body footprint points for 			each body hit.  	hit_indices:	Array (nhit) of bx indices.   RETURN: 	Array (nhit) of pointers to inertial footprint points for each body hit. 	Zero is returned if no bodies are hit.    MODIFICATION HISTORY:        Written by:     Spitale		5/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/footprint.html#footprint", "footprint", 'routine in <a href="obj/tools/footprint.html">footprint.pro</a>', "footprint.pro", "", "footprint", "", "slopcornershit_indicesimage_ptsbody_psamplecdbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_disk_ref.html", "get_disk_ref.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_disk_ref.pro", "", "", " NAME:        get_disk_ref    PURPOSE: 	Produces inertial unit vectors corresponding to the projection 	of the given body 2-axis direction into the given disk plane.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        dkx_cat = get_disk_ref(dkx, bx)    ARGUMENTS:   INPUT: 	dkx:	Array (nt) of any subclass of DISK.  	bx:	Array (nt) of any subclass of BODY.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (1,3,nt) of inertial unit vectors.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_disk_ref.html#get_disk_ref", "get_disk_ref", 'routine in <a href="obj/tools/get_disk_ref.html">get_disk_ref.pro</a>', "get_disk_ref.pro", "", "get_disk_ref", "", "dkxbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_edge_points.html", "get_edge_points.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_edge_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_edge_points.html#get_edge_points", "get_edge_points", 'routine in <a href="obj/tools/get_edge_points.html">get_edge_points.pro</a>', "get_edge_points.pro", "", "get_edge_points", "", "cdbxgbxdkx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_image_border_pts.html", "get_image_border_pts.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_image_border_pts.pro", "", "", " NAME:        get_image_border_pts    PURPOSE: 	Computes points around the edge of an image.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        border_pts_im = get_image_border_pts(cd)    ARGUMENTS:   INPUT: 	cd:	Camera descripor.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	corners:	Array(2,2) giving corners of image region to border  	center:		Array (2) giving the center of the image to use 			instead of the optic axis.  	crop:		Number of pixels by which to shrink the image border in 			each direction.  	sample:		Sampling rate; default is 1 pixel.  	aperture:	If set, a circular aperture with a diameter equal to the 			logest dimension of the image is used.  (not complete)     OUTPUT: NONE    RETURN: 	Array (2,np) of image points on the image border.  np is computed 	such that points are spaced by one pixel.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_image_border_pts.html#get_image_border_pts", "get_image_border_pts", 'routine in <a href="obj/tools/get_image_border_pts.html">get_image_border_pts.pro</a>', "get_image_border_pts.pro", "", "get_image_border_pts", "", "cornerscentercropsampleaperturecd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_image_profile.html", "get_image_profile.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_image_profile.pro", "", "", " NAME:        get_image_profile    PURPOSE: 	Extracts a profile from a rectangular, but not necessarily axis-aligned, 	image region using interpolation.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        profile = get_image_profile(image, cd, p, nl, nw, sample)    ARGUMENTS:   INPUT: 	image:	Image array.  	cd:	Camera descriptor.  	p:	Array (2,2) of image points giving the start and end points 		for the scan.  	nl:	Number of samples along the scan.  	nw:	Number of samples across the scan.     OUTPUT:  NONE    KEYWORDS:   INPUT: 	interp:		Type of interpolation, see image_interp_cam.  	arg_interp:	Interpolation argument, see image_interp_cam.    OUTPUT: 	image_pts:	Array (2,nl) of image points along the center of 			the scan.  	distance:	Array (nl) giving the distance along the scan.  	sigma:		Standard deviation across the profile at each sample 			along the profile.    RETURN: 	Array (nl) containing the profile.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_image_profile.html#get_image_profile", "get_image_profile", 'routine in <a href="obj/tools/get_image_profile.html">get_image_profile.pro</a>', "get_image_profile.pro", "", "get_image_profile", "", "distanceinterparg_interpsigmaimage_ptsimcdpnlnwsample", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_image_profile_outline.html", "get_image_profile_outline.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_image_profile_outline.pro", "", "", " NAME:        get_image_profile_outline    PURPOSE: 	Generates an outline of an oblique rectangular image region.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        profile = get_image_profile_outline(points, point, nw=nw, nl=nl)    ARGUMENTS:   INPUT: 	points:	Array (2,2) of image points defining corners at opposite ends 		on one side of the sector.  	point:	Image point defining and third corner.     OUTPUT:  NONE    KEYWORDS:   INPUT: 	nl:	Number of samples along the scan.  	nw:	Number of samples across the scan.    OUTPUT: NONE    RETURN:        Array of image points defining the outline of the sector.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_image_profile_outline.html#get_image_profile_outline", "get_image_profile_outline", 'routine in <a href="obj/tools/get_image_profile_outline.html">get_image_profile_outline.pro</a>', "get_image_profile_outline.pro", "", "get_image_profile_outline", "", "nwnlsamplepointspoint", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_image_vector.html", "get_image_vector.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_image_vector.pro", "", "", " NAME:        get_image_vector    PURPOSE: 	Projects inertial vectors into an image.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        p = get_image_vector(cd, v)    ARGUMENTS:   INPUT: 	cd:	Array (nt) of camera descriptors.  	v:	Array (nv,3,nt) of vectors in the inertial frame.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2,nv,nt) of image vectors.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_image_vector.html#get_image_vector", "get_image_vector", 'routine in <a href="obj/tools/get_image_vector.html">get_image_vector.pro</a>', "get_image_vector.pro", "", "get_image_vector", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline.html", "get_limb_profile_outline.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_limb_profile_outline.pro", "", "", " NAME:        get_limb_profile_outline    PURPOSE:        Generates an outline of a limb sector.   CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE: 	result = get_limb_profile_outline(cd, gbx, points)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptor.  	points:	Array (2,2) of image points defining opposite corners 		of the sector.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	inertial:	Inertial vectors corresponding to the limb sector 			outline points.  	dkd:	Disk descriptor corresponding to the skyplane.    RETURN:        Array of image points defining the outline of the sector.    MODIFICATION HISTORY:        Written by:     Spitale, 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline.html#get_limb_profile_outline", "get_limb_profile_outline", 'routine in <a href="obj/tools/get_limb_profile_outline.html">get_limb_profile_outline.pro</a>', "get_limb_profile_outline.pro", "", "get_limb_profile_outline", "", "altaznaltnazinertialdkdsave_azsscan_altscan_azlimb_pts_bodygraphiccdgbxpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline_linear.html", "get_limb_profile_outline_linear.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_limb_profile_outline_linear.pro", "", "", " NAME:        get_limb_profile_outline_linear    PURPOSE:        Generates an outline of a rectangular limb sector.   CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE: 	result = get_limb_profile_outline_linear(cd, gbx, points)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptor.  	points:	Array (2,2) of image points defining opposite corners 		of the sector.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	inertial:	Inertial vectors corresponding to the limb sector 			outline points.    RETURN:        Array of image points defining the outline of the sector.    MODIFICATION HISTORY:        Written by:     Spitale, 1/2009   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline_linear.html#get_limb_profile_outline_linear", "get_limb_profile_outline_linear", 'routine in <a href="obj/tools/get_limb_profile_outline_linear.html">get_limb_profile_outline_linear.pro</a>', "get_limb_profile_outline_linear.pro", "", "get_limb_profile_outline_linear", "", "altaz0rimpointsnaltnriminertialsave_rimsscan_altscan_rimlimb_pts_bodygraphiccdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline_oblique.html", "get_limb_profile_outline_oblique.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_limb_profile_outline_oblique.pro", "", "", " NAME:        get_limb_profile_outline_oblique.  **incomplete**    PURPOSE:        Generates an outline of an oblique limb sector.   CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE: 	result = get_limb_profile_outline_oblique(cd, gbx, points)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptor.  	points:	Array (2,2) of image points defining opposite corners 		of the sector.  	point:    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	inertial:	Inertial vectors corresponding to the limb sector 			outline points.    RETURN:        Array of image points defining the outline of the sector.    MODIFICATION HISTORY:        Written by:     Spitale, 1/2009   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline_oblique.html#get_limb_profile_outline_oblique", "get_limb_profile_outline_oblique", 'routine in <a href="obj/tools/get_limb_profile_outline_oblique.html">get_limb_profile_outline_oblique.pro</a>', "get_limb_profile_outline_oblique.pro", "", "get_limb_profile_outline_oblique", "", "naltnazdkdcdgbxpointspoint", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_lonperp.html", "get_lonperp.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_lonperp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_lonperp.html#get_lonperp", "get_lonperp", 'routine in <a href="obj/tools/get_lonperp.html">get_lonperp.pro</a>', "get_lonperp.pro", "", "get_lonperp", "", "cdrdp0p1", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_object_by_name.html", "get_object_by_name.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_object_by_name.pro", "", "", " NAME:        get_object_by_name    PURPOSE: 	Selects from a list of descriptors based on their name.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        xd = get_object_by_name(xds, name)    ARGUMENTS:   INPUT: 	xds:	Array of any subclass of CORE.  	name:	Name to select.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array descriptors whose CORE name field matches the given name. 	If no matches are found, 0 is returned.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_object_by_name.html#get_object_by_name", "get_object_by_name", 'routine in <a href="obj/tools/get_object_by_name.html">get_object_by_name.pro</a>', "get_object_by_name.pro", "", "get_object_by_name", "", "xdsname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_primary.html", "get_primary.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_primary.pro", "", "", " NAME:        get_primary    PURPOSE: 	Attempts to determine the primary planet from a list of descriptors 	based on their names and proximity to the observer.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        gbx0 = get_primary(bx, gbx)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY, describing the observer.  	gbx:	Array (nd,nt) of any subclass of GLOBE, specifying a 		system of globe objects.    OUTPUT:        NONE    KEYOWRDS:   INPUT: 	rx:	Any subclass of RING.  	planets:	Array of names of objects to consider as planets. 			Default is the planets of the Solar System, or the 			primary planet of rx, if provided.    OUTPUT: NONE    RETURN: 	GLOBE descriptor for the selected primary.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_primary.html#get_primary", "get_primary", 'routine in <a href="obj/tools/get_primary.html">get_primary.pro</a>', "get_primary.pro", "", "get_primary", "", "planetsrxodgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_radperp.html", "get_radperp.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_radperp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_radperp.html#get_radperp", "get_radperp", 'routine in <a href="obj/tools/get_radperp.html">get_radperp.pro</a>', "get_radperp.pro", "", "get_radperp", "", "cddkxp0p1dsk_pt0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile.html", "get_ring_profile.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile.pro", "", "", " NAME:        get_ring_profile    PURPOSE:        Generates a ring profile in radius or longitude.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = get_ring_profile(image, cd, dkd, lon, rad)   ARGUMENTS:   INPUT:            image:      The image to scan                cd:      Camera descriptor               dkd:      Disk descriptor               lon:      Array of longitudes at which to sample image               rad:      Array of radii at which to sample image    OUTPUT:        NONE    KEYWORDS:   INPUT:        azimuthal:      If set, a longitudinal scan is done instead.    OUTPUT:        NONE    RETURN:        An array of averaged dn values that match the given rad or        match the given lon if /azimuthal selected.    PROCEDURE:        The profile is calculated by applying a grid of (radius, longitude)        given by rad and lon on a ring sector, interpolating the dn in        the image, and averaging along a direction to give a radius profile,        or a longitudinal profile.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile.html#get_ring_profile", "get_ring_profile", 'routine in <a href="obj/tools/get_ring_profile.html">get_ring_profile.pro</a>', "get_ring_profile.pro", "", "get_ring_profile", "", "azimuthalinterpim_ptsdxdsk_ptssigmawidthnnarg_interpimagecddkdlon_ptsrad_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_bin.html", "get_ring_profile_bin.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_bin.pro", "", "", " NAME:        get_ring_profile_bin    PURPOSE:        Generates a ring profile in radius or longitude using binning.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = get_ring_profile_bin(image, cd, dkd, dlon, rad)   ARGUMENTS:   INPUT:            image:      The image to scan                cd:      Camera descriptor               dkd:      Disk descriptor              dlon:      Array of disk longitudes of which to sample image               rad:      Array of disk radii of which to sample image    OUTPUT:        NONE    KEYWORDS:   INPUT:        azimuthal:      If set, a longitudinal scan is done instead.    OUTPUT:        NONE    RETURN:        An array of averaged dn values that match the given rad or        match the given dlon if /azimuthal selected.    PROCEDURE:        A ring sector polygon is calculated from the given dlon and rad        arrays.  All the pixels of the image within this polygon are        binned in an equally-spaced histogram in radius or longitude.   RESTRICTIONS:        The dlon and rad arrays are treated as equally spaced, that is,        the binsize is calculated by dividing the spacing in radius by        number of points minus one.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_bin.html#get_ring_profile_bin", "get_ring_profile_bin", 'routine in <a href="obj/tools/get_ring_profile_bin.html">get_ring_profile_bin.pro</a>', "get_ring_profile_bin.pro", "", "get_ring_profile_bin", "", "slopeazimuthalimagecddkdlon_ptsrad_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_n.html", "get_ring_profile_n.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_n.pro", "", "", " NAME:        get_ring_profile_n    PURPOSE:        Calculate the number of points in radius and longitude for        a ring profile.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = get_ring_profile_n(outline_pts, cd, dkd, lon, rad)    ARGUMENTS:   INPUT:        outline_pts:    Outline sector image points which are the result                        of calling get_ring_profile_outline()                  cd:    Camera descriptor                 dkd:    Disk descriptor                lon:    Equally spaced longitude array                 rad:    Equally spaced radius array    OUTPUT:        NONE    KEYWORDS:   INPUT:           oversamp:    Oversample factor compared to regular calculation of                        radius and longitude spacing which would put maximum                        spacing at 1 pixel.    OUTPUT:        NONE    RETURN:        Array containg n_rad and n_lon to be used by get_ring_profile() or        get_ring_profile_bin().    PROCEDURE:        Routine goes along the radial and longitudinal edges of a ring        profile sector and calculates the minimum spacing between the        points in image space, then derives the n_rad and n_lon points        to make the minimum spacing 1 pixel.  If the oversamp parameter        is given, the numbers are multiplied by this factor.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_n.html#get_ring_profile_n", "get_ring_profile_n", 'routine in <a href="obj/tools/get_ring_profile_n.html">get_ring_profile_n.pro</a>', "get_ring_profile_n.pro", "", "get_ring_profile_n", "", "oversampoutline_ptscddkdlonrad", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline.html", "get_ring_profile_outline.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_outline.pro", "", "", " NAME:        get_profile_ring_outline    PURPOSE:        Generates an outline of a ring sector.   CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:     result = get_profile_ring_outline(cd, dkd, lon, rad, inertial=inertial)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	dkx:	Disk descriptor.  	points:	Array (2,2) of image points defining corners of the sector.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	lon:	Array of disk longitudes for sector  	rad:	Array of disk radii for sector  	nrad:	Number of points in the radial direction.  	nlon:	Number of points in the longitudinal direction.    OUTPUT: 	inertial:	Inertial vectors corresponding to the ring sector 			outline points.    RETURN:        Output is set of image points (x,y) defining the outline of the        ring sector.   MODIFICATION HISTORY:        Written by:     Vance Haemmerle & Joe Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline.html#get_ring_profile_outline", "get_ring_profile_outline", 'routine in <a href="obj/tools/get_ring_profile_outline.html">get_ring_profile_outline.pro</a>', "get_ring_profile_outline.pro", "", "get_ring_profile_outline", "", "radlonxlondirnradnlonslopeinertialcddkdpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline_oblique.html", "get_ring_profile_outline_oblique.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_outline_oblique.pro", "", "", " NAME:        get_ring_profile_outline_oblique    PURPOSE:        Generates an outline of an oblique ring sector.   CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE: 	result = get_ring_profile_outline_oblique(cd, dkx, points, point)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptor.  	points:	Array (2,2) of image points defining corners at opposite ends 		on one side of the sector.  	point:	Image point defining and third corner.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	nrad:	Number of points in the radial direction.  	nlon:	Number of points in the longitudinal direction.    OUTPUT: NONE    RETURN:        Array of image points defining the outline of the sector.    MODIFICATION HISTORY:        Written by:     Spitale, 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline_oblique.html#get_ring_profile_outline_oblique", "get_ring_profile_outline_oblique", 'routine in <a href="obj/tools/get_ring_profile_outline_oblique.html">get_ring_profile_outline_oblique.pro</a>', "get_ring_profile_outline_oblique.pro", "", "get_ring_profile_outline_oblique", "", "dirnradnloncddkxpointspoint", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline_perp.html", "get_ring_profile_outline_perp.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_outline_perp.pro", "", "", " NAME:        get_ring_profile_outline_perp    PURPOSE:        Generates an outline of a ring sector perpendicular to the 	image-projected radial direction.   CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE: 	result = get_ring_profile_outline_perp(cd, dkx, points)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptor.  	points:	Array (2,2) of image points defining corners of the sector.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	nrad:	Number of points in the radial direction.  	nlon:	Number of points in the longitudinal direction.    OUTPUT: NONE    RETURN:        Array of image points defining the outline of the sector.    MODIFICATION HISTORY:        Written by:     Spitale, 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline_perp.html#get_ring_profile_outline_perp", "get_ring_profile_outline_perp", 'routine in <a href="obj/tools/get_ring_profile_outline_perp.html">get_ring_profile_outline_perp.pro</a>', "get_ring_profile_outline_perp.pro", "", "get_ring_profile_outline_perp", "", "dirnradnloncddkxpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_solar_ref.html", "get_solar_ref.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_solar_ref.pro", "", "", " NAME:        get_solar_ref    PURPOSE: 	Produces inertial unit vectors corresponding to the projection 	of the sun direction into the given disk plane.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        v = get_solar_ref(dkx, sund)    ARGUMENTS:   INPUT: 	dkx:	Array (nt) of any subclass of DISK.  	sund:	Array (nt) of any subclass of STAR representing the sun.    OUTPUT:  NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (1,3,nt) of inertial vectors.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_solar_ref.html#get_solar_ref", "get_solar_ref", 'routine in <a href="obj/tools/get_solar_ref.html">get_solar_ref.pro</a>', "get_solar_ref.pro", "", "get_solar_ref", "", "dkxsund", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/get_surface_ranges.html", "get_surface_ranges.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "get_surface_ranges.pro", "", "", " NAME:        get_surface_ranges    PURPOSE: 	Determines full ranges of valid surface coordinate system.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        points = get_surface_ranges(cd, bx)    ARGUMENTS:   INPUT: 	cd:      Camera or map descriptor  	bx:      Object descriptor (subclass of BODY)     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	Array of 2 points representng the minimum and maximum values of the 	relevant coordinate system.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/get_surface_ranges.html#get_surface_ranges", "get_surface_ranges", 'routine in <a href="obj/tools/composite/get_surface_ranges.html">get_surface_ranges.pro</a>', "get_surface_ranges.pro", "", "get_surface_ranges", "", "odbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_altaz_to_local.html", "glb_altaz_to_local.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_altaz_to_local.pro", "", "", " NAME: 	glb_altaz_to_local    PURPOSE:        Converts the given column vectors from the altaz coordinate        system to the local coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	local_dir = glb_altaz_to_local(gbd, surf_pts, altaz_dir)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	surf_pts:	Array (nv,3,nt) of column vectors in the body                        frame (representing points on the surface of                        the globe).         altaz_dir:      Array (3,nt) of column vectors in the altaz                        system, giving the direction from each surface point.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the local system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_altaz_to_local.html#glb_altaz_to_local", "glb_altaz_to_local", 'routine in <a href="obj/glb/glb_altaz_to_local.html">glb_altaz_to_local.pro</a>', "glb_altaz_to_local.pro", "", "glb_altaz_to_local", "", "gbdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_assign.html", "glb_assign.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_assign.pro", "", "", " NAME: 	glb_assign    PURPOSE: 	Replaces fields in a GLOBE object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/GLB    CALLING SEQUENCE: 	glb_assign, gbd, <keywords>=<values>    ARGUMENTS:   INPUT: 	gbd:		GLOBE object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	GLOBE fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	glb_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_assign.html#glb_assign", "glb_assign", 'routine in <a href="obj/glb/glb_assign.html">glb_assign.pro</a>', "glb_assign.pro", "", "glb_assign", "", "noeventxd@glb__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_body_to_globe.html", "glb_body_to_globe.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_body_to_globe.pro", "", "", " NAME: 	glb_body_to_globe    PURPOSE:        Transforms the given column vectors from the body coordinate        system to the globe coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	globe_pts = glb_body_to_globe(gbd, body_pts)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the globe frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_body_to_globe.html#glb_body_to_globe", "glb_body_to_globe", 'routine in <a href="obj/glb/glb_body_to_globe.html">glb_body_to_globe.pro</a>', "glb_body_to_globe.pro", "", "glb_body_to_globe", "", "gbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_body_to_local.html", "glb_body_to_local.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_body_to_local.pro", "", "", " NAME: 	glb_body_to_local    PURPOSE:        Converts the given column vectors from the body coordinate        system to the local coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	local_dir = glb_body_to_local(gbd, body_pts, body_dir)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body                        frame (representing points on the surface of                        the globe).         body_dir:       Array (3,nt) of column vectors in the body                        frame, giving the direction from each surface point.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the local system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_body_to_local.html#glb_body_to_local", "glb_body_to_local", 'routine in <a href="obj/glb/glb_body_to_local.html">glb_body_to_local.pro</a>', "glb_body_to_local.pro", "", "glb_body_to_local", "", "gbdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_create_descriptors.html", "glb_create_descriptors.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_create_descriptors.pro", "", "", " NAME: 	glb_create_descriptors    PURPOSE: 	Init method for the GLOBE class.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	gbd = glb_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	Number of descriptors to create.    OUTPUT: NONE    KEYWORDS (in addition to those accepted by all superclasses):   INPUT: 	gbd:	Globe descriptor(s) to initialize, instead of creating a new one.  	sld:	Solid descriptor(s) instead of using sld_create_descriptors.  	bd:	Body descriptor(s) instead of using bod_create_descriptors.  	crd:	Core descriptor(s) instead of using cor_create_descriptors.  	type:	Array (n) of type strings.  	lref:	Array (n) of longitude reference notes.  	radii:	Array (3,n) of ellipsoid radii.  	lora:	Array (n) giving longitudes  first ellipsoid radius.  	rref:	Array (n) of reference radii.  	J:	Array (n,nj) of zonal harmonics.  	GM:	Array (n) of masses x gravitiational constant.  	mass:	Array (n) of masses.  	phase_fn: Array (n) of phase function names.  	phase_parm:	Array (npht,n) of phase function parameters.  	refl_fn: Array (n) of reflection function names.  	refl_parm:	Array (npht,n) of reflection function parameters.  	albedo:	Array (n) of bond albedos.     OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized globe descriptors, depending 	on the presence of the bd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_create_descriptors.html#glb_create_descriptors", "glb_create_descriptors", 'routine in <a href="obj/glb/glb_create_descriptors.html">glb_create_descriptors.pro</a>', "glb_create_descriptors.pro", "", "glb_create_descriptors", "", "crdbdsldgbdn@glb__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_evolve.html", "glb_evolve.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_evolve.pro", "", "", " NAME: 	glb_evolve    PURPOSE:        Computes new globe descriptors at the given time offsets from        the given globe descriptors using the taylor series expansion        corresponding to the derivatives contained in the given globe        descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	gbdt = glb_evolve(gbd, dt)    ARGUMENTS:   INPUT: 	gbd:	 Array (ngd) of any subclass of GLOBE descriptors.  	dt:	 Array (ndt) of time offsets.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, velocities will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN:        Array (ngd,ndt) of newly allocated globe descriptors evolved        by time dt, where ngd is the number of gbd, and ndt is the        number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_evolve.html#glb_evolve", "glb_evolve", 'routine in <a href="obj/glb/glb_evolve.html">glb_evolve.pro</a>', "glb_evolve.pro", "", "glb_evolve", "", "nodvcopygbddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_cusp_points.html", "glb_get_cusp_points.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_cusp_points.pro", "", "", " NAME: 	glb_get_cusp_points    PURPOSE: 	Iteratively computes the two points that occupy the limb from two 	different viewpoints for each given globe object.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	cusp_pts = glb_get_cusp_points(gbd, r1, r2, epsilon, niter)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	r1, r2:	 Arrays (1,3,nt) of viewer positions in the BODY frame.  	epsilon:	Controls the precision of the iteration.  Default 			is 1d-3.  	niter:	Maximum number of iterations, default is 1000     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2, 3, nt) of cusp points in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_get_cusp_points.html#_glb_get_cusp_points", "_glb_get_cusp_points", 'routine in <a href="obj/glb/glb_get_cusp_points.html">glb_get_cusp_points.pro</a>', "glb_get_cusp_points.pro", "", "_glb_get_cusp_points", "", "gbdr1r2epsilonniter", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/glb/glb_get_cusp_points.html#glb_get_cusp_points", "glb_get_cusp_points", 'routine in <a href="obj/glb/glb_get_cusp_points.html">glb_get_cusp_points.pro</a>', "glb_get_cusp_points.pro", "", "glb_get_cusp_points", "", "gbdr1r2epsilonniter", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_grid_points.html", "glb_get_grid_points.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_grid_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_get_grid_points.html#glb_get_grid_points", "glb_get_grid_points", 'routine in <a href="obj/glb/glb_get_grid_points.html">glb_get_grid_points.pro</a>', "glb_get_grid_points.pro", "", "glb_get_grid_points", "", "latlonscan_latscan_longbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_limb_points.html", "glb_get_limb_points.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_limb_points.pro", "", "", " NAME: 	glb_get_limb_points    PURPOSE: 	Iteratively computes the points on the limb for each given globe 	object.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	limb_pts = glb_get_limb_points(gbd, r, np, epsilon, niter)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	r:	Array (1,3,nt) giving viewer position in the BODY frame.  	np:	Number of points to compute around the limb.  	epsilon:	Controls the precision of the iteration.  Default 			is 1d-3.  	niter:	Maximum number of iterations, default is 1000     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	alpha:	Array (np) of azimuths for each output point.    RETURN: 	Array (np, 3, nt) of limb points in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_get_limb_points.html#_glb_get_limb_points", "_glb_get_limb_points", 'routine in <a href="obj/glb/glb_get_limb_points.html">glb_get_limb_points.pro</a>', "glb_get_limb_points.pro", "", "_glb_get_limb_points", "", "alphagbdrn_pointsepsilonniter", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/glb/glb_get_limb_points.html#glb_get_limb_points", "glb_get_limb_points", 'routine in <a href="obj/glb/glb_get_limb_points.html">glb_get_limb_points.pro</a>', "glb_get_limb_points.pro", "", "glb_get_limb_points", "", "alphagbdrn_pointsepsilonniter", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_radius.html", "glb_get_radius.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_radius.pro", "", "", " NAME: 	glb_get_radius    PURPOSE: 	Computes the local radius of a GLOBE object at the given lat/lon.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	radius = glb_get_radius(gbd, lat, lon)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	lat:	Array (nv) of latitudes.  	lon:	Array (nv) of longitudes.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv, nt) of radius values.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_get_radius.html#glb_get_radius", "glb_get_radius", 'routine in <a href="obj/glb/glb_get_radius.html">glb_get_radius.pro</a>', "glb_get_radius.pro", "", "glb_get_radius", "", "noeventgbdlatlon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_ranges.html", "glb_get_ranges.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_ranges.pro", "", "", " NAME: 	glb_get_ranges    PURPOSE: 	Returns ranges of valid coordinates for the given GLOBE object.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	ranges = glb_get_ranges(gbd)    ARGUMENTS:   INPUT: 	bx:	 Any subclass of GLOBE.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (2 x 3) giving the ranges in globe coordinates.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_get_ranges.html#glb_get_ranges", "glb_get_ranges", 'routine in <a href="obj/glb/glb_get_ranges.html">glb_get_ranges.pro</a>', "glb_get_ranges.pro", "", "glb_get_ranges", "", "gbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_surface_normal.html", "glb_get_surface_normal.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_surface_normal.pro", "", "", " NAME: 	glb_get_surface_normal    PURPOSE: 	Computes the surface normal of a GLOBE object at the given 	globe position.   CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	n = glb_get_surface_normal_body(gbd, p)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	p:	Array (nv,3,nt) of points in the GLOBE system.     OUTPUT: NONE    KEYWORDS:   INPUT: 	nonorm:	If set, the returned vectors are not normalized.  	body:	If set, the inputs given in the BODY system instead of GLOBE.    OUTPUT: NONE    RETURN: 	Array (nv, 3, nt) of surface normals in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_get_surface_normal.html#glb_get_surface_normal", "glb_get_surface_normal", 'routine in <a href="obj/glb/glb_get_surface_normal.html">glb_get_surface_normal.pro</a>', "glb_get_surface_normal.pro", "", "glb_get_surface_normal", "", "noeventnonormbodygbdglobe_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/glb/glb_get_surface_normal.html#___glb_get_surface_normal", "___glb_get_surface_normal", 'routine in <a href="obj/glb/glb_get_surface_normal.html">glb_get_surface_normal.pro</a>', "glb_get_surface_normal.pro", "", "___glb_get_surface_normal", "", "noeventgbdlatlon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_globe_to_body.html", "glb_globe_to_body.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_globe_to_body.pro", "", "", " NAME: 	glb_globe_to_body   PURPOSE:        Transforms the given column vectors from the globe coordinate        system to the body coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	body_pts = glb_globe_to_body(gbd, globe_pts)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	globe_pts:	Array (nv,3,nt) of column vectors in the globe frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_globe_to_body.html#glb_globe_to_body", "glb_globe_to_body", 'routine in <a href="obj/glb/glb_globe_to_body.html">glb_globe_to_body.pro</a>', "glb_globe_to_body.pro", "", "glb_globe_to_body", "", "gbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_globe_to_graphic.html", "glb_globe_to_graphic.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_globe_to_graphic.pro", "", "", " NAME: 	glb_globe_to_graphic    PURPOSE:        Converts the given vectors from the globe coordinate        system to the graphic coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	graphic_pts = glb_globe_to_graphic(gbd, globe_pts)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	globe_pts:	Array (nv,3,nt) of column vectors in the globe system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the graphic system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_globe_to_graphic.html#glb_globe_to_graphic", "glb_globe_to_graphic", 'routine in <a href="obj/glb/glb_globe_to_graphic.html">glb_globe_to_graphic.pro</a>', "glb_globe_to_graphic.pro", "", "glb_globe_to_graphic", "", "gbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_graphic_to_globe.html", "glb_graphic_to_globe.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_graphic_to_globe.pro", "", "", " NAME: 	glb_graphic_to_globe    PURPOSE:        Converts the given vectors from the graphic coordinate        system to the globe coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	globe_pts = glb_graphic_to_globe(gbd, graphic_pts)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	graphic_pts:	Array (nv,3,nt) of column vectors in the graphic system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the globe system.    STATUS: 	 Not complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_graphic_to_globe.html#glb_graphic_to_globe", "glb_graphic_to_globe", 'routine in <a href="obj/glb/glb_graphic_to_globe.html">glb_graphic_to_globe.pro</a>', "glb_graphic_to_globe.pro", "", "glb_graphic_to_globe", "", "noeventgbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_hide_points.html", "glb_hide_points.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_hide_points.pro", "", "", " NAME: 	glb_hide_points    PURPOSE: 	Hides points that are obscured by a GLOBE with respect to a given 	viewpoint.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	sub = glb_hide_points(gbd, r, p)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	r:	Columns vector giving the BODY-frame position of the viewer.  	p:	Array (nv) of BODY-frame vectors giving the points to hide.     OUTPUT: NONE    KEYWORDS:   INPUT: 	rm:	If set, points are flagged for being in front of or behind 		the globe, rather then just behind it.    OUTPUT: NONE    RETURN: 	Subscripts of the points in p that are hidden by the object.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_hide_points.html#glb_hide_points", "glb_hide_points", 'routine in <a href="obj/glb/glb_hide_points.html">glb_hide_points.pro</a>', "glb_hide_points.pro", "", "glb_hide_points", "", "rmgbdvpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_hide_points_limb.html", "glb_hide_points_limb.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_hide_points_limb.pro", "", "", " NAME: 	glb_hide_points_limb    PURPOSE: 	Hides points lying on the surface of a GLOBE object that are 	obscured by the limb with respect to a given viewpoint.  This 	procedure is much faster then the more general glb_hide_points.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	sub = glb_hide_points_limb(gbd, r, p)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	r:	Columns vector givnng the BODY-frame position of the viewer.  	p:	Array (nv) of BODY-frame vectors giving the points to hide.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Subscripts of the points in p that are hidden by the object. 	Note that this routine is only valid for points that lie on 	the surface of the globe.  This routine is faster than 	glb_hide_points.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_hide_points_limb.html#glb_hide_points_limb", "glb_hide_points_limb", 'routine in <a href="obj/glb/glb_hide_points_limb.html">glb_hide_points_limb.pro</a>', "glb_hide_points_limb.pro", "", "glb_hide_points_limb", "", "gbdrpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/glb_image_bounds.html", "glb_image_bounds.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "glb_image_bounds.pro", "", "", " NAME:        glb_image_bounds    PURPOSE: 	Determines globe coordinate ranges visible in an image described 	by a given camera descriptor.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        glb_image_bounds, cd, gbx, $ 	        latmin=latmin, latmax=latmax, lonmin=lonmin, lonmax=lonmax    ARGUMENTS:   INPUT: 	cd:	Camera descripor.  	gbx:	Any subclass of GLOBE.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	corners:	Array(2,2) giving corers of image region to consider.  	slop:	Number of pixels by which to expand the image in each 		direction.     OUTPUT: 	latmin:	Minimum latitude in image.  	latmax:	Maximum latitude in image.  	lonmin:	Minimum longitude in image.  	lonmax:	Maximum longitude in image.  	border_pts_im:	Array (2,np) of points along the edge of the image.  	status:	-1 if no globe in the image, 0 otherwise.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/glb_image_bounds.html#glb_image_bounds", "glb_image_bounds", 'routine in <a href="obj/tools/glb_image_bounds.html">glb_image_bounds.pro</a>', "glb_image_bounds.pro", "", "glb_image_bounds", "", "slopborder_pts_imcornerscenterlatminlatmaxlonminlonmaxstatuscdpd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_intersect.html", "glb_intersect.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_intersect.pro", "", "", " NAME: 	glb_intersect    PURPOSE: 	Computes the intersection of rays with GLOBE objects.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	int_pts = glb_intersect(gbd, v, r)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	v:	Array (nv,3,nt) giving ray origins in the BODY frame.  	r:	Array (nv,3,nt) giving ray directions in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: 	near:	If set, only the  near  points are returned.  More specifically, 		these points correspond to the furthest along the ray from the 		observer to the globe.  If the observer is exterior, these are 		the nearest interesections to the observer; if the observer is 		interior, these intersections are behind the observer.  	far:	If set, only the  far  points are returned.  See above; if the 		observer is exterior, these are the furthest interesections from 		the observer; if the observer is interior, these intersections 		are in front of the observer.  	hit:	Array giving the indices of rays the hit the object.  	valid:	Array in which each element indicates whether the object 		was hit.  	nosolve: If set, the intersections are not computed, though the 		 discrimiant is.    OUTPUT: 	discriminant:	Discriminant of the quadriatic equation used to 			determine the intersections.    RETURN: 	Array (2*nv,3,nt) of points in the BODY frame, where 	int_pts[0:nv-1,*,*] correspond to the near-side intersections 	and int_pts[nv:2*nv-1,*,1] correspond to the far side.  Zero 	vector is returned for points with no solution.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_intersect.html#glb_intersect", "glb_intersect", 'routine in <a href="obj/glb/glb_intersect.html">glb_intersect.pro</a>', "glb_intersect.pro", "", "glb_intersect", "", "hitnearfardiscriminantnosolvevalidgbdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_intersect_discriminant.html", "glb_intersect_discriminant.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_intersect_discriminant.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_intersect_discriminant.html#glb_intersect_discriminant", "glb_intersect_discriminant", 'routine in <a href="obj/glb/glb_intersect_discriminant.html">glb_intersect_discriminant.pro</a>', "glb_intersect_discriminant.pro", "", "glb_intersect_discriminant", "", "noeventalphabetagammagbdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_intersect_plane.html", "glb_intersect_plane.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_intersect_plane.pro", "", "", " NAME: 	glb_intersect_plane    PURPOSE: 	Computesthe intersection of a plane with a GLOBE object.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	int_pts = glb_intersect_plane(gbd, v, n)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	v:	Array (1,3,nt) giving plane origins in the BODY frame.  	n:	Array (1,3,nt) giving the plane unit normals in the 		BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (np,3,nt) of points in the BODY frame, np is the number of 	points on the curve of intersection.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_intersect_plane.html#glb_intersect_plane", "glb_intersect_plane", 'routine in <a href="obj/glb/glb_intersect_plane.html">glb_intersect_plane.pro</a>', "glb_intersect_plane.pro", "", "glb_intersect_plane", "", "npgbdvn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_intersect_points.html", "glb_intersect_points.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_intersect_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_intersect_points.html#glb_intersect_points", "glb_intersect_points", 'routine in <a href="obj/glb/glb_intersect_points.html">glb_intersect_points.pro</a>', "glb_intersect_points.pro", "", "glb_intersect_points", "", "validnosolvenearfargbdvrdiscriminantalphabetagamma", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_j.html", "glb_j.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_j.pro", "", "", " NAME: 	glb_j    PURPOSE:        Returns the zonal harmonics for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	mass = glb_j(gbd)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nj,nt) of zonal harmonics associated with each given globe 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_j.html#glb_j", "glb_j", 'routine in <a href="obj/glb/glb_j.html">glb_j.pro</a>', "glb_j.pro", "", "glb_j", "", "noeventgbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_local_to_altaz.html", "glb_local_to_altaz.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_local_to_altaz.pro", "", "", " NAME: 	glb_local_to_altaz   PURPOSE:        Converts the given column vectors from the local coordinate        system to the altaz coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	altaz_dir = glb_local_to_altaz(gbd, surf_pts, local_dir)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body                        frame (representing points on the surface of                        the globe).         local_dir:      Array (3,nt) of column vectors in the local                        frame, giving the direction from each surf_pts.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the altaz system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_local_to_altaz.html#glb_local_to_altaz", "glb_local_to_altaz", 'routine in <a href="obj/glb/glb_local_to_altaz.html">glb_local_to_altaz.pro</a>', "glb_local_to_altaz.pro", "", "glb_local_to_altaz", "", "gbdv_r", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_local_to_body.html", "glb_local_to_body.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_local_to_body.pro", "", "", " NAME: 	glb_local_to_body   PURPOSE:        Converts the given column vectors from the local coordinate        system to the body coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	body_dir = glb_local_to_body(gbd, body_pts, local_dir)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body                        frame (representing points on the surface of                        the globe).         local_dir:      Array (3,nt) of column vectors in the local                        system, giving the direction from each surface point.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_local_to_body.html#glb_local_to_body", "glb_local_to_body", 'routine in <a href="obj/glb/glb_local_to_body.html">glb_local_to_body.pro</a>', "glb_local_to_body.pro", "", "glb_local_to_body", "", "gbdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_lora.html", "glb_lora.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_lora.pro", "", "", " NAME: 	glb_lora    PURPOSE: 	Returns the longitude of the first ellipsoid radius for each 	given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	lora = glb_lora(gbd)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Longitude of the first ellipsoid radius associated with each        given globe descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_lora.html#glb_lora", "glb_lora", 'routine in <a href="obj/glb/glb_lora.html">glb_lora.pro</a>', "glb_lora.pro", "", "glb_lora", "", "noeventgbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_lref.html", "glb_lref.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_lref.pro", "", "", " NAME: 	glb_lref    PURPOSE:        Returns the longitude system reference for each given globe        descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	lref = glb_lref(gbd)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Longitude system reference associated with each given globe        descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_lref.html#glb_lref", "glb_lref", 'routine in <a href="obj/glb/glb_lref.html">glb_lref.pro</a>', "glb_lref.pro", "", "glb_lref", "", "noeventgbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_nj.html", "glb_nj.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_nj.pro", "", "", " NAME: 	glb_nj    PURPOSE: 	Returns an integer indicating the maximum number of zonal harmonics 	allowed in the 'j' field of the globe descriptor.  This number 	can be adjusted using the environment variable 'GLB_NJ'.  The default 	is 11.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	nj = glb_nj()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    ENVIRONMENT VARIABLES: 	GLB_NJ:		Sets the nj value.    RETURN: 	Current nj value.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_nj.html#glb_nj", "glb_nj", 'routine in <a href="obj/glb/glb_nj.html">glb_nj.pro</a>', "glb_nj.pro", "", "glb_nj", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/glb_projected_resolution.html", "glb_projected_resolution.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "glb_projected_resolution.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/glb_projected_resolution.html#glb_projected_resolution", "glb_projected_resolution", 'routine in <a href="obj/tools/glb_projected_resolution.html">glb_projected_resolution.pro</a>', "glb_projected_resolution.pro", "", "glb_projected_resolution", "", "minmaxrrgbdcdpscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_query.html", "glb_query.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_query.pro", "", "", " NAME: 	glb_query    PURPOSE: 	Returns the fields associated with a GLOBE object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/GLB    CALLING SEQUENCE: 	glb_query, gbd, <keywords>=<values>    ARGUMENTS:   INPUT: 	gbd:	GLOBE object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	GLOBE object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_query.html#glb_query", "glb_query", 'routine in <a href="obj/glb/glb_query.html">glb_query.pro</a>', "glb_query.pro", "", "glb_query", "", "conditioncatnoeventxd@glb__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_radii.html", "glb_radii.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_radii.pro", "", "", " NAME: 	glb_radii    PURPOSE:        Returns the triaxial radii for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	radii = glb_radii(gbd)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Triaxial radii associated with each given globe descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_radii.html#glb_radii", "glb_radii", 'routine in <a href="obj/glb/glb_radii.html">glb_radii.pro</a>', "glb_radii.pro", "", "glb_radii", "", "noeventgbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_reflect.html", "glb_reflect.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_reflect.pro", "", "", " NAME: 	glb_reflect    PURPOSE: 	Computes the reflection of rays with GLOBE objects.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	int_pts = glb_reflect(gbd, v, r)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	v:	Array (nv,3,nt) giving observer positions in the BODY frame.  	r:	Array (nv,3,nt) giving point positions in the BODY frame.  	epsilon:	Controls the precision of the iteration.  Default 			is 1d-3.  	niter:	Maximum number of iterations, default is 1000     OUTPUT: NONE    KEYWORDS:   INPUT: 	near:	If set, near-side reflections are computed.  This is the default.  	far: 	If set, far-side reflections are computed.    OUTPUT: NONE    RETURN: 	Array (2*nv,3,nt) of points in the BODY frame, where 	int_pts[0:nv-1,*,*] correspond to the near-side reflections 	and int_pts[nv:2*nv-1,*,1] correspond to the far side.  Zero 	vector is returned for points with no solution.    STATUS: 	Not well tested    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_reflect.html#glb_reflect", "glb_reflect", 'routine in <a href="obj/glb/glb_reflect.html">glb_reflect.pro</a>', "glb_reflect.pro", "", "glb_reflect", "", "hitnearfarallvalidgbdvrepsilonniter", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_replicate.html", "glb_replicate.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_replicate.pro", "", "", " NAME: 	glb_replicate    PURPOSE: 	Replicates the given globe descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	new_gbd = cam_replicate(gbd, dim)    ARGUMENTS:   INPUT: 	gbd:	 One descriptor of any subclass of GLOBE descriptor  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	globe descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_replicate.html#glb_replicate", "glb_replicate", 'routine in <a href="obj/glb/glb_replicate.html">glb_replicate.pro</a>', "glb_replicate.pro", "", "glb_replicate", "", "gbddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_rref.html", "glb_rref.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_rref.pro", "", "", " NAME: 	glb_rref    PURPOSE:        Returns the reference radius for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	mass = glb_rref(gbd)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of reference radii associated with each given globe 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_rref.html#glb_rref", "glb_rref", 'routine in <a href="obj/glb/glb_rref.html">glb_rref.pro</a>', "glb_rref.pro", "", "glb_rref", "", "noeventgbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_j.html", "glb_set_j.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_j.pro", "", "", " NAME: 	glb_set_j    PURPOSE:        Replaces the zonal harmonics for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	glb_set_j, gbd, j    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	j:	 Array (nj,nt) of new zonal harmonics.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_set_j.html#glb_set_j", "glb_set_j", 'routine in <a href="obj/glb/glb_set_j.html">glb_set_j.pro</a>', "glb_set_j.pro", "", "glb_set_j", "", "noeventgbdJ", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_lora.html", "glb_set_lora.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_lora.pro", "", "", " NAME: 	glb_set_lora    PURPOSE:        Replaces the longitude of the first ellipsoid radius for each        given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	glb_set_lora, gbd, lora    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	lora:	 Array (nt) of new longitude values of the first ellipsoid radius.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_set_lora.html#glb_set_lora", "glb_set_lora", 'routine in <a href="obj/glb/glb_set_lora.html">glb_set_lora.pro</a>', "glb_set_lora.pro", "", "glb_set_lora", "", "noeventgbdlora", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_lref.html", "glb_set_lref.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_lref.pro", "", "", " NAME: 	glb_set_lref    PURPOSE:        Replaces the longitude system reference for each given globe        descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	glb_set_lref, gbd, lref    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	lref:	 String array (nt) of new longitude system names.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_set_lref.html#glb_set_lref", "glb_set_lref", 'routine in <a href="obj/glb/glb_set_lref.html">glb_set_lref.pro</a>', "glb_set_lref.pro", "", "glb_set_lref", "", "noeventgbdlref", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_radii.html", "glb_set_radii.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_radii.pro", "", "", " NAME: 	glb_set_radii    PURPOSE:        Replaces the triaxial radii for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	glb_set_radii, gbd, radii    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	radii:	 Array (3,nt) of new triaxial radii.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_set_radii.html#glb_set_radii", "glb_set_radii", 'routine in <a href="obj/glb/glb_set_radii.html">glb_set_radii.pro</a>', "glb_set_radii.pro", "", "glb_set_radii", "", "noeventgbdradii", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_rref.html", "glb_set_rref.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_rref.pro", "", "", " NAME: 	glb_set_rref    PURPOSE:        Replaces the reference radius for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	glb_set_rref, gbd, rref    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	rref:	 String array (nt) of new reference radii.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_set_rref.html#glb_set_rref", "glb_set_rref", 'routine in <a href="obj/glb/glb_set_rref.html">glb_set_rref.pro</a>', "glb_set_rref.pro", "", "glb_set_rref", "", "noeventgbdrref", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_type.html", "glb_set_type.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_type.pro", "", "", " NAME: 	glb_set_type    PURPOSE:        Replaces the type string for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	glb_set_type, gbd, type    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	type:	 String array (nt) of new type strings.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_set_type.html#glb_set_type", "glb_set_type", 'routine in <a href="obj/glb/glb_set_type.html">glb_set_type.pro</a>', "glb_set_type.pro", "", "glb_set_type", "", "noeventgbdtype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_sub_point.html", "glb_sub_point.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_sub_point.pro", "", "", " NAME: 	glb_sub_point    PURPOSE: 	Computes the planetocentric sub-point in body coordinates.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	n = glb_sub_point(gbd, r)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	r:	Array (nv,3,nt) of points in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) points in the BODY frame that lie on the surface 	of each globe, directly 'beneath' r, i.e., such that each 	planetocentric surface normal points at each r.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_sub_point.html#glb_sub_point", "glb_sub_point", 'routine in <a href="obj/glb/glb_sub_point.html">glb_sub_point.pro</a>', "glb_sub_point.pro", "", "glb_sub_point", "", "noeventgbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_sub_point_graphic.html", "glb_sub_point_graphic.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_sub_point_graphic.pro", "", "", " NAME: 	glb_sub_point_graphic    PURPOSE: 	Computes the planetographic sub-point in body coordinates.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	n = glb_sub_point_graphic(gbd, r)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	r:	Array (nv,3,nt) of points in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: 	epsilon:	Convergence criterion for angular deviation from normal. 			Default is 1d-8.  	niter:		Maximum number of iterations.  Default is 5000.    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) points in the BODY frame that lie on the surface 	of each globe, directly 'beneath' r, i.e., such that each 	planetographic surface normal points at each r.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:		Spitale, 1/1998  	Adapted by:		Spitale, 5/2016 	Added iteration count:	Moretto, 8/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_sub_point_graphic.html#glb_sub_point_graphic", "glb_sub_point_graphic", 'routine in <a href="obj/glb/glb_sub_point_graphic.html">glb_sub_point_graphic.pro</a>', "glb_sub_point_graphic.pro", "", "glb_sub_point_graphic", "", "noeventepsilonnitergbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_type.html", "glb_type.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_type.pro", "", "", " NAME: 	glb_type    PURPOSE:        Returns the type string for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	type = glb_type(gbd)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of type strings associated with each given globe 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_type.html#glb_type", "glb_type", 'routine in <a href="obj/glb/glb_type.html">glb_type.pro</a>', "glb_type.pro", "", "glb_type", "", "noeventgbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/globe_to_image.html", "globe_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "globe_to_image.pro", "", "", " NAME:        globe_to_image    PURPOSE:        Transforms points in body globe coordinates to image coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = globe_to_image(cd, gbd, p)    ARGUMENTS:   INPUT: 	cd:	Array of nt Camera or map descriptor  	gbx:	Array of nt Object descriptor (of type GLOBE)  	p:	Array (nv x 3 x nt) of globe points    OUTPUT: 	body_pts:	Body coordinates of output points.    RETURN:        Array (2 x nv x nt) of image points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale;  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/globe_to_image.html#globe_to_image", "globe_to_image", 'routine in <a href="obj/tools/composite/globe_to_image.html">globe_to_image.pro</a>', "globe_to_image.pro", "", "globe_to_image", "", "body_ptsvalidcdgbxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/globe_to_map.html", "globe_to_map.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "globe_to_map.pro", "", "", " NAME:        globe_to_map    PURPOSE:        Transforms points in globe coordinates to map coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = globe_to_map(md, gbx, globe_pts)    ARGUMENTS:   INPUT: 	md:	Array of nt map descriptor.  	gbx:	Array of nt globe descriptor.  	globe_pts:	Array (nv x 3 x nt) of globe points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (2 x nv x nt) of map coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/globe_to_map.html#globe_to_map", "globe_to_map", 'routine in <a href="obj/tools/composite/globe_to_map.html">globe_to_map.pro</a>', "globe_to_map.pro", "", "globe_to_map", "", "mdgbxglobe_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/interface/gr_draw.html", "gr_draw.pro", '.pro file in <a href="grim/interface/dir-overview.html">grim/interface/ directory</a>', "gr_draw.pro", "", "", " NAME: 	gr_    PURPOSE: 	xx    CATEGORY: 	NV/GR    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/interface/gr_draw.html#gr_draw", "gr_draw", 'routine in <a href="grim/interface/gr_draw.html">gr_draw.pro</a>', "gr_draw.pro", "", "gr_draw", "", "gdcdpdrdsdardstdsundodpsymsymsizecolortagpngrnumpp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html", "gr_lsqtool.pro", '.pro file in <a href="grim/tools/dir-overview.html">grim/tools/ directory</a>', "gr_lsqtool.pro", "", "", " NAME: 	gr_lsqtool    DESCRIPTION: 	Graphical least-squares navigation tool.    CALLING SEQUENCE:  	gr_lsqtool    ARGUMENTS:   INPUT: NONE     OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    LAYOUT: 	The gr_lsqtool layout consists of the following items:  	 Scan width: 		Width if the scan about the model points.  	 Edge proximity: 		Points closer than this to the edge of the image are not 		scanned.  	 Min correlation: 		Miniumum acceptable correlation coefficient in the scan.  	 Max correlation: 		Maxiumum acceptable correlation coefficient in the scan.  	Scan button: 		Scans the image according to the current widget settings. 		The resulting points are entered as user points in the 		appropriate GRIM widget.  	Fix buttons: 		Select fit parameters to fix.  x and y are the image offsets 		in the repective direction, theta is the rotation about the 		center given by the parameter center_ptdp.  If center_ptdp 		contains no points, then theta is automatically fixed.  	Fit button: 		Performs a simultaneous linear least-square fit to all of the 		objects that have been scanned.  This button causes the given 		camera descriptor to be modified.  	Close button 		Causes gr_lsqtool to exit.     OPERATION:    gr_lsqtool allows the user to produce a subpixel  pointing correction    by fitting model points to those observed in the image.  When the     Scan  button is pressed, an image scan is performed for each active    array in the primary grim window.  Limbs, terminators, and rings are    scanned as edges, while stars and planet centers are scanned as point    sources.  Scans may also be performed individually on different objects.    The  Scan Width  entry specifies the width of the scan about each active    array.  The  Edge Proximity  field specifies the closest that a scan    will come to the image edge.  The correlation fields give the    correlation criterion for accepting scanned points.     After you have scanned your points, you can use the  Fit  button to    perform a least-square fit between each active object and the    corresponding scanned points.  The Fit statistics are displayed in    the text window at the bottom.  You can specify which parameters to    fix using the  Fix  buttons.     Because this fit is linear, it requires the initial guess to be close    to the actual solution.  You may need to iterate to converge to a    good solution; you must rescan your points each time, however.    STATUS: 	Incomplete.    MODIFICATION HISTORY:  	Written by:	Spitale 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#lsq_descriptor__define", "lsq_descriptor__define", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "lsq_descriptor__define", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_print", "grlsq_print", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_print", "", "cleardatas", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_descriptor", "grlsq_descriptor", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_descriptor", "", "minmaxwidthedgefixscannedalgorithmmodel_fninvert", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_parse_entry", "grlsq_parse_entry", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_parse_entry", "", "dropidstagstag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_set_entry", "grlsq_set_entry", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_set_entry", "", "dropsensitivebuttonidstagstagvalue", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_form_to_lsqd", "grlsq_form_to_lsqd", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_form_to_lsqd", "", "objectdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_lsqd_to_form", "grlsq_lsqd_to_form", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_lsqd_to_form", "", "datalsqd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_get_ptdps", "grlsq_get_ptdps", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_get_ptdps", "", "pdsrdssdsgrim_datadatalsqd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_invert_model", "grlsq_invert_model", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_invert_model", "", "modelmzero", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_draw_models", "grlsq_draw_models", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_draw_models", "", "datamodel_pmzerotag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_edge_model_psf_ring", "grlsq_edge_model_psf_ring", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_edge_model_psf_ring", "", "zerogddesc", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_edge_model_nav_ring", "grlsq_edge_model_nav_ring", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_edge_model_nav_ring", "", "zerogddesc", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_edge_model_nav_limb", "grlsq_edge_model_nav_limb", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_edge_model_nav_limb", "", "zerogddesc", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_edge_model_atan", "grlsq_edge_model_atan", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_edge_model_atan", "", "zerogddesc", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_get_model_type", "grlsq_get_model_type", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_get_model_type", "", "_tag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_get_model_fn", "grlsq_get_model_fn", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_get_model_fn", "", "lsqdtag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_get_inner", "grlsq_get_inner", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_get_inner", "", "cdrdtag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_get_model", "grlsq_get_model", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_get_model", "", "cdrdlsqdtaglzero", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_make_tag", "grlsq_make_tag", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_make_tag", "", "ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_scan", "grlsq_scan", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_scan", "", "nocreatestatusnoscanlsqdgrim_datadata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_fit", "grlsq_fit", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_fit", "", "statusgrim_datadatalsqd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#gr_lsqtool_event", "gr_lsqtool_event", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "gr_lsqtool_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_primary_notify", "grlsq_primary_notify", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_primary_notify", "", "init_data_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#grlsq_cleanup", "grlsq_cleanup", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html#gr_lsqtool", "gr_lsqtool", 'routine in <a href="grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "gr_lsqtool", "", "top", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/tools/gr_maptool.html", "gr_maptool.pro", '.pro file in <a href="grim/tools/dir-overview.html">grim/tools/ directory</a>', "gr_maptool.pro", "", "", " NAME: 	gr_maptool    DESCRIPTION: 	Graphical map projection tool.    CALLING SEQUENCE:  	gr_maptool    ARGUMENTS:   INPUT: NONE     OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    LAYOUT: 	The gr_maptool layout consists of the following items:  	 Map projection control: 		A map projection is selected using the droplist and 		the map parameters are input using the text widgets below. 		Angles are in radians.  	'Ok' button: 		Creates the map projection described by the current widget 		settings and exits.  	'Apply' button: 		Creates the map projection described by the current widget 		settings without exiting.  	'Cancel' button 		Exits with no map projection.     OPERATION: 	gr_ maptool allows the user to create map projections of images 	using a simple graphical interface.  It is most easily run from within 	GRIM, but may be run directly from the command line as well.    STATUS: 	Incomplete.    MODIFICATION HISTORY:  	Written by:	Spitale 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/tools/gr_maptool.html#grmt_get_md", "grmt_get_md", 'routine in <a href="grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_get_md", "", "indexdatatype", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_maptool.html#grmt_create_map", "grmt_create_map", 'routine in <a href="grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_create_map", "", "datamd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_maptool.html#grmt_parse_entry", "grmt_parse_entry", 'routine in <a href="grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_parse_entry", "", "dropidstagstag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_maptool.html#grmt_set_entry", "grmt_set_entry", 'routine in <a href="grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_set_entry", "", "dropidstagstagvalue", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_maptool.html#grmt_form_to_md", "grmt_form_to_md", 'routine in <a href="grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_form_to_md", "", "typedata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_maptool.html#grmt_md_to_form", "grmt_md_to_form", 'routine in <a href="grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_md_to_form", "", "datamd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_maptool.html#grmt_cleanup", "grmt_cleanup", 'routine in <a href="grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_maptool.html#grmt_refresh_callback", "grmt_refresh_callback", 'routine in <a href="grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_refresh_callback", "", "data_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_maptool.html#gr_maptool_event", "gr_maptool_event", 'routine in <a href="grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "gr_maptool_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_maptool.html#gr_maptool", "gr_maptool", 'routine in <a href="grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "gr_maptool", "", "order", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html", "gr_phttool.pro", '.pro file in <a href="grim/tools/dir-overview.html">grim/tools/ directory</a>', "gr_phttool.pro", "", "", " NAME: 	gr_phttool    DESCRIPTION: 	Graphical photometric correction tool.    CALLING SEQUENCE:  	gr_phttool    ARGUMENTS:   INPUT: NONE     OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    ENVIRONMENT VARIABLES: 	GR_PHT_DIR:	Sets the directory in which to find the photometric 			functions.    LAYOUT: 	The gr_phttool layout consists of the following items:  	 Reflectance function controls: 		A reflectance function is selected using the droplist and 		the relevant parameters (whose purpose depend on the specific 		function) are input using the text widgets below.  	 Phase function controls: 		A phase function is selected using the droplist and 		the relevant parameters (whose purpose depend on the specific 		function) are input using the text widgets below.  	   Reflectance and phase functions are determined by looking for any 	   complied function whose name starts with 'pht_refl_' or 'pht_phase', 	   or any routines in the directory pointed to by the environment variable 	   GR_PHT_DIR. The function lists may be updated using the corresponding 	   'Refresh' button.  The calling sequences are as follows:  	   refl_corr = refl_fn(mu, mu0, refl_parm) 	   phase_corr = phase_fn(g, phase_parm)  	   where the photometric arguments are all cosines, and the *_parm 	   arguments come from the corresponding input text widgets.   	'Ok' button: 		Applies the photometric correction described by the current 		widget settings and exits.  	'Apply' button: 		Applies the photometric correction described by the current 		widget settings without exiting.  	'Apply All' button: 		Applies the photometric correction described by the current 		widget settings to all planes of the primary grim window for 		which outline points have been activated.  	'Cancel' button 		Exits with no photometric correction.     OPERATION: 	gr_phttool allows the user to apply photometric corrections to images 	using a simple graphical interface.  Corrections are applied to data 	within any active limb points.    STATUS: 	Incomplete.    MODIFICATION HISTORY:  	Written by:	Spitale 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#pht_descriptor__define", "pht_descriptor__define", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "pht_descriptor__define", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_get_prefix", "grpht_get_prefix", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_get_prefix", "", "type", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_descriptor", "grpht_descriptor", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_descriptor", "", "refl_fnphase_fnrefl_parmphase_parmn_refl_parmn_phase_parm", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_get_phtd", "grpht_get_phtd", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_get_phtd", "", "indexdatarefl_fn", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_apply_correction", "grpht_apply_correction", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_apply_correction", "", "dataphtdddcdpdsundoutline_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_apply_correction_primary", "grpht_apply_correction_primary", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_apply_correction_primary", "", "grim_datadataphtd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_apply_correction_all", "grpht_apply_correction_all", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_apply_correction_all", "", "grim_datadataphtd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_parse_entry", "grpht_parse_entry", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_parse_entry", "", "nulldropidstagstag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_set_entry", "grpht_set_entry", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_set_entry", "", "dropidstagstagvalue", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_form_to_phtd", "grpht_form_to_phtd", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_form_to_phtd", "", "refl_fndata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_get_functions", "grpht_get_functions", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_get_functions", "", "defaulttype", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_refresh_fn", "grpht_refresh_fn", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_refresh_fn", "", "datatype", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_phtd_to_form", "grpht_phtd_to_form", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_phtd_to_form", "", "dataphtd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#gr_phttool_event", "gr_phttool_event", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "gr_phttool_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_primary_notify", "grpht_primary_notify", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_primary_notify", "", "init_data_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#grpht_cleanup", "grpht_cleanup", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html#gr_phttool", "gr_phttool", 'routine in <a href="grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "gr_phttool", "", "top", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/scripts/gr_png_all.html", "gr_png_all.pro", '.pro file in <a href="grim/scripts/dir-overview.html">grim/scripts/ directory</a>', "gr_png_all.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/scripts/gr_png_all.html#gr_png_all", "gr_png_all", 'routine in <a href="grim/scripts/gr_png_all.html">gr_png_all.pro</a>', "gr_png_all.pro", "", "gr_png_all", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/interface/gr_tp.html", "gr_tp.pro", '.pro file in <a href="grim/interface/dir-overview.html">grim/interface/ directory</a>', "gr_tp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/interface/gr_tp.html#gr_tp", "gr_tp", 'routine in <a href="grim/interface/gr_tp.html">gr_tp.pro</a>', "gr_tp.pro", "", "gr_tp", "", "pngrnumptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim.html", "grim.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim.pro", "", "", " NAME: 	GRIM    PURPOSE: 	General-purpose GRaphical Interface for oMinas.    CATEGORY: 	NV/GR    CALLING SEQUENCE:  	grim, arg1, arg2    ARGUMENTS:   INPUT: 	arg1, arg2: 		Grim accepts up to two arguments, which can appear in either 		order.  Possible arguments are:   			data descriptors (object) 			file specification (string)  			grnum (scalar)  			plot (1d array)  			image (2d array)  			cube (3d array)  	Plots are displayed as graphs whose abscissa are the array index, unless 	an abscissa is present in the data descriptor.  Many functions are not 	available in this mode.  	Cubes are handled as multiple image planes unless /rgb is used 	(see below).  All grim planes will contain the same data array, 	but display only data ranges corresponding to one channel of the cube. 	For /rgb (assuming the cube has three channels), the data are placed 	on a single image plane with each cube channel assigned the R, G, or B 	color channel.     OUTPUT: NONE    KEYWORDS:   INPUT: 	Descriptor Keywords 	------------------- 	The following inputs replace objects already maintained by GRIM.  For 	the case of a single plane, all given descriptors are placed in that 	plane.  In that case, only one cd, od, or sund are allowed.  For a cube, 	cd and od must have either one element, or the same number of elements 	as the number of channels in the cube, and are assigned one-to-one to 	the grim planes.  In this case, all other decriptors are assigned to all 	planes.  For multiple images, descriptors are assigned to planes by 	matching their generic decsriptor dd fields (or assoc_dd if given) to 	the data descriptor for each plane.  	 cd:	Replaces the current camera descriptor.  This may also be 		a map descriptor, in which case some of GRIM's functions 		will not be available.  When using a map descriptor instead 		of a camera descriptor, you can specify a camera descriptor 		as the observer descriptor (see the 'od' keyword below) and 		some additional geometry functions will be available.  	 od:	Replaces the current observer descriptor.  The observer 		descriptor is used to allow some geometry objects (limb, 		terminator) to be computed when using a map descriptor instead 		of a camera descriptor.  	 sund:	Replaces the current sun descriptor.  	 pd:	Adds/replaces planet descriptors.  	 rd:	Adds/replaces ring descriptors.  	 sd:	Adds/replaces star descriptors.  	 std:	Adds/replaces station descriptors  	 ard:	Adds/replaces array descriptors  	 gd:	Generic descriptor containing some or all of the above 		descriptors.  	 assoc_dd: 		If given, use these data descriptors to assign descriptors to 		planes instead of matching the data descriptors from their 		generic descriptors.   	Descriptor Select Keywords 	-------------------------- 	Descriptor select keywords (see pg_get_*) are specified using the 	standard prefix corresponding to the descriptor type.  For example, 	the fov keyword to pg_get_planets would be given to grim as plt_fov.   	Initial Colormap Keywords 	------------------------- 	The colormap structure (see colormap_descriptor__define) can be 	be initialized via keywords prefied with 'cmd_', e.g., 'cmd_shade'. 	In addition, the following keywords apply to the initial color map:  	*auto_stretch: 		If set, the color table for each plane is automatically 		stretched.  This is identical to using the 'Auto' button 		on on the grim color tool.   	Translator Keywords 	------------------- 	The following keywords are passed directly to the translators, which 	are responsible for interpreting their meanings.  	*cam_trs: 		String giving translator keywords for the camera descriptors.  	*sun_trs: 		String giving translator keywords for the sun descriptors.  	*plt_trs: 		String giving translator keywords for the planet descriptors.   	*rng_trs: 		String giving translator keywords for the ring descriptors.   	*str_trs: 		String giving translator keywords for the star descriptors.   	*stn_trs: 		String giving translator keywords for the stations descriptors.   	*arr_trs: 		String giving translator keywords for the array descriptors.   	TVIM Keywords 	------------- 	The following keywords set the initial viewing parameters and are 	simply passed to TVIM.  	*xsize:	Size of the graphics window in the x direction.  Defaults to 		400 pixels.  	*ysize:	Size of the graphics window in the y direction.  Defaults to 		400 pixels.  	*zoom:	Initial zoom to be applied to the image.  If not given, grim 		computes an initial zoom such that the entire image fits on the 		screen.  	*rotate: 		Initial rotate value to be applied to the image (as in the IDL 		ROTATE routine).  If not given, 0 is assumed.  	*order:	Initial display order to be applied to the image.  	*offset: 		Initial offset (dx,dy) to be applied to the image.  	 doffset: 		Change the offset viewing parameter by this amount.  	 default: 		If set, use default tvim properties (zoom=[1,1], offset=[0,0]                order=0 [bottom-up])  	 previous: 		If set, restore last-used tvim viewing parameters.  	 restore: 		If set, use saved tvim viewing paramters.   	Customization Keywords 	---------------------- 	*menu_extensions: 		Array of strings giving the names of functions that return 		menu definitions, as defined by cw_pdmenu.  These menus are 		added to the built-in GRIM menus between the Overlays menu 		and the Help menu.  The default is 'grim_default_menus'.  If 		the first character in the first menu function is '+', then 		grim_default_menus is retained an the new menu are appended 		after that menu.  Otherwise, 'grim_default_menus' is replaced.  	*button_extensions: 		Array of strings giving the names of definition functions 		for custom cursor modes to be added after the built-in 		cursor modes.  The definition function takes one argument 		(see arg_extensions below) and returns a grim_user_mode_struct.  	*arg_extensions: 		Argument to be provided to the button extension definition 		function above.  	*menu_fname: 		Name of a file containing additional menus to add to 		the grim widget.  The file syntax follows that for cw_pdmenu.   	Other Keywords 	-------------- 	*extensions: 		String array giving extensions to try for each input file. 		see dat_read.  	*new:	If set, a new grim instance is created and all keywords apply 		to that instance.  	 erase:	If set, erase the current image before doing anything else.  	*mode_init: 		Initial cursor mode.  See below.  	*mode_args: 		Array giving arguments for the cursor modes initialization 		functions.  If a string, then syntax is NAME:ARG, where NAME 		is the name of the cursor mode, and ARG is the argument for 		that mode.  For example:  			mode_args='READOUT:myreadout_fn'  		would cause the function 'myreadout_fn' to be added to 		the list of functions called by pg_cursor and pg_measure 		via the readout cursor mode.  If not a string, the argument 		is passed to the initialization function with no processing.  	*retain: 		Retain settings for backing store (see  backing store  in 		the IDL reference guide).  Defaults to 2.  	*clip:	Controls the number of fields of view in which overlays are 		computed.  	*fov:	Controls the number of fields of view in which to request 		planet, ring and star descriptors.  Values are as follows:   			 0 : get all descriptors                   	<0 : relative to viewport                  	>0 : relative to image / optic axis  		Note that fov > 0 is the same as setting the fov descriptor 		select keywords (see above).  Default is 0, but stars operate 		best when fov > 0.  	*hide:	If set, overlays are hidden w.r.t shadows and obstructions.  		Default is on.  	 no_erase: 		If set, GRIM does not erase the draw window.  When called.  	*rgb:	If set, grim interprets a 3-plane cube as a 3-channel image                to be displayed on a single plane.  	*channel: 		Array of bitmasks specifying the color channel in which to 		display each given image: 1b, 2b, or 4b.  	*visibility: 		Initial visibility setting for planes:                  	0: Only the current plane is drawn.                 	1: All planes are drawn.                  Default is 0.  	*max:	Maximum data value to scale to when displaying images. 		Values larger than this are set to the maximum color table 		index.  If not set, the maximum value in the data set is used. 		In cases where the data array is being subsampled, this value 		may not be known, resulting in varying image scaling as more 		and more data values are sampled.  That problem may be 		eliminated via this keyword.  	 exit:	If set, GRIM immediately exits.  This can be used to kill an 		existing GRIM window.  	 modal:	If set, grim is run as a modal widget, i.e., there is no command 		prompt.  	*frame:	If set, the initial view is set such that all members of the 		named overlay types are are visible.  If /frame, then all 		overlays are framed.  Note that object types that rely on the 		view to determine which objects to compute (e.g., stars) 		cannot be framed in this way.  	 refresh_callbacks: 		Array of strings giving the names of procedures to be 		called after each refresh.  See CALLBACK PROCEDURES 		below.  Refresh callbacks receive only the data argument.  	 refresh_callback_data_ps: 		Array of pointers (one per callback) to data for the refresh 		callback procedures specified using the refresh_callbacks 		keyword.  See CALLBACK PROCEDURES below.  	 plane_callbacks: 		Array of strings giving the names of procedures to be 		called after each plane change.  See CALLBACK PROCEDURES 		below.  Plane callbacks receive only the data argument.  	 plane_callback_data_ps: 		Array of pointers (one per callback) to data for the plane 		callback procedures specified using the plane_callbacks 		keyword.  See CALLBACK PROCEDURES below.  	*nhist:	History setting to be applied to data decriptor (see 		ominas_data__define).  GRIM uses data descriptor history to 		undo changes to the data array.  If nhist is not set, or is 		equal to 1, the undo menu option will not function.  	*maintain: 		If given, this maintainance setting is applied to the data 		descriptor (see ominas_data__define).  	*compress: 		Compression setting to be applied to data decriptor (see 		ominas_data__define).  	*filter: 		Initial filter to use when loading or browsing files.  	*load_path: 		Initial path for the file loading dialog.  	*save_path: 		Initial path for the file saving dialog.  	*path:	Sets both load_path and save_path to this value.  	*workdir: 		Default directory for saving user points, masks, tie 		points, curves  	 user_psym: 		Default plotting symbol for user overlays.  	 grnum:	Identifies a specific GRIM window by number.  Grim numbers are 		displayed in the status bar, e.g.: grim <grnum>.  	 pn:	Directs GRIM to change to the plane correspondng to this plane 		number.  	*cursor_swap: 		If set, cursor bitmaps are byte-order swapped.  	*loadct: 		Index of color table to load.  	*beta:	If set beta features are enabled.  	*npoints: 		Number of point to compute for various overlays.  Default is 1000.   	*plane_syncing: Turns plane syncing on (1) or off(0).  Default is 0.   	*tiepoint_syncing: Turns tiepoint syncing on (1) or off(0).  Default is 0.   	*curve_syncing: Turns curve syncing on (1) or off(0).  Default is 0.   	 position: 		Sets the plot position; see the POSITION grahics keyword.   	 color:	Sets the line color index for plots.  One element per plane.   	 xrange: 		Sets the X-axis range for plots.   	 yrange: 		Sets the Y-axis range for plots.  	 thick:	Sets the line thickness for plots.  One element per plane.  	 title:	For plots, sets the plot title for plots; one element per plane. 		For images, sets the base default title.  	 xtitle: 		Sets the X-axis label for plots.  One element per plane.  	 ytitle: 		Sets the Y-axis label for plots.  One element per plane.  	 psym:	Sets the plotting symbol for plots.  One element per plane.  	 nsum:	See OPLOT.  One element per plane.   	*overlays: 		List of initial overlays to compute on startup.  Each element 		is of the form:                            type[:name1,name2,...]  		where 'type' is one of {limb, terminator, planet_center, 		star, ring, planet_grid, array, station} and the names 		identify the name of the desired object.  Note that grim 		will load more objects than named if required by another 		startup overlay.  For example:                           overlays='ring:a_ring'  		will cause only one ring descriptor to load, whereas                           overlays=['limb:saturn', 'ring:a_ring']  		will cause all of Saturn's rings to load because they are 		required in computing the limb points (for hiding).  		Different results may be obtained using translator keywords, 		because those keywords are evaluated at the translator level. 		For example:  			overlays='ring:fn54'  		may result in no ring, while:  			overlays='ring', trs_rd='name=fn54'  		would be more likely to yield a ring.  In the former example, 		the specified name is compared against whatever default ring 		descriptors are returned by the tranlators, while in the latter 		case, the 'name' translator keyword is compared against all 		rings available to the translator.   	*delay_overlays: 		If set, initial overlays (see 'overlays' above) are not computed 		until the first time they are accessed.  This option can greatly 		improve performance in cases where a large number of image planes 		are loaded with initial overlays, particularly if it is not 		expected that all planes will necesarily be viewed or otherwise 		accessed.  Typically this option will cause overlays to be 		computed only for the initially visible planes, with other 		planes loading overlays only as they are made visible.  However, 		there may be other cirumstances that can cause initial overlays 		to be loaded without actually viewing a plane.  	*activate: 		If set, inital overlay are activated.  	*ndd: 	Sets the global ndd value in the OMINAS sate structure, which 		controls the maximum number of data descriptors with maintain == 1 		to keep in memory at any given time  	*render_sample: 		Over-sampling value for rendering.  See pg_render.  	*render_pht_min: 		Minimum value to assign to photometric output in renderings. 		See pg_render.   	Incomplete Keywords 	------------------- 	*rendering: 		If set, perform a rendering on the initial descriptor set.     OUTPUT: NONE    RESOURCE FILE: 	The keywords marked above with an asterisk may be overridden using 	the file $HOME/.ominas/grimrc.  Keyword=value pairs may be entered, one per 	line, using the same syntax as if the keyword were entered on the IDL 	command line to invoke grim.  Lines beginning with '#' are ignored. 	Keywords entered in the resource file override the default values, and 	are themselves overridden by keywords entered on the command line.   SHELL INTERFACE 	The 'grim' alias may be used to start grim from the shell prompt 	via the XIDL interface.  The shell interface accepts all keywords 	marked above with an asterisk.  See grim.bat.  	Example (assuming the grim alias described in grim.bat):  	 % grim -beta data/*.img overlay=planet_center,limb:JUPITER    ENVIRONMENT VARIABLES: 	Grim currently defines no environment variables..    COMMON BLOCKS: 	 grim_block: 		Keeps track of most recent grim instance and which ones are 		selected.    SIDE EFFECTS: 	Grim operates directly on the memory images of the descriptors that 	it is given.  Therefore, those descriptors are modified during 	a session.  This architecture allows data to be operated on concurrently 	through grim and from the command line; see ingrid.pro for details.    LAYOUT: 	The philosphy that drives GRIM's layout is that the maximum possible 	screen space should be devoted to displaying the data.  This policy 	allows for many GRIM windows to be used simultaneously without being 	obscured by crazy control panels full of buttons, gadgets, widgets, 	doodads, whirly-gigs, and what-nots.  The grim layout consists of the 	following items:  	 Title bar: 		The title bar displays the grim window number (grnum), 		the current plane number (pn), the total number of planes, the 		name field of the data descriptor for the current plane, the 		default title (if given; see the title keyword above), and 		a string indicating which RGB channels are associated with the 		current plane.  	 Menu bar: 		Most of grim's functionality is accessed through the 		system of pulldown menus at the top.  Individual menu 		items are described in their own sections.  	 Shortcut buttons: 		Some commonly used menu options are duplicated as shortcut 		buttons arranged horizontally just beneath the menu bar.  The 		function of each button is displayed in the status bar (see 		below) when the mouse cursor is hovered ove the button.  	 Cursor mode buttons: 		Cursor mode shortcut buttons are arranged vertically along the 		left side of the GRIM window, and as provided as shortcuts 		for the corresponding options in the Mode menu.  The following 		modes are available:  		Activate: 			In activate mode, overlay objects may be activated 			or deactivated by clicking and/or dragging using the 			left or right mouse buttons respectively.  This 			activation mechanism allows the user to select which 			among a certain type of objects should be used in a 			given menu selection.  A left click on an overlay 			activates that overlay and a right click deactivates 			it.  A double click activates or deactivates all 			overlays associated with a given descriptor, or all 			stars.  Active overlays appear in the colors selected 			in the 'Overlay Settings' menu selection.  Inactive 			overlays appear in cyan.  A descriptor is active 			whenever any of its overlays are active.  		Zoom:	The zoom button puts grim in a zoom cursor mode, wherein 			the image zoom and offset are controlled by selecting 			a box in the image.  When the box is created using the 			left mouse button, zoom and offset are changed so that 			the contents of the box best fill the current graphics 			window.  When the right button is used, the contents of 			the current graphics window are shrunken so as to best 			fill the box.  In other words, the left button zooms in 			and the right button zooms out.  		Pan: 	The pan button puts grim in a pan cursor mode, wherein the 			image offset is controlled by selecting an offset vector 			using the left mouse button.  The middle button may be 			used to center the image on a selected point.  		Pixel Readout: 			In pixel readout mode, a text window appears 			and displays data about the pixel selected 			using the left mouse button.  		Tiepoint: 			In tiepoint mode, tiepoints are added using the 			left mouse button and deleted using the right button. 			Tiepoints appear as crosses identified by numbers. 			The use of tiepoints is determined by the particular 			option selected by the user.  		Curve: 			In curve mode, curves are added using the 			left mouse button and deleted using the right button. 			Curves appear as red lines identified by numbers at 			each end.  The use of curves is determined by the 			particular option selected by the user.  		Mask: 			GRIM maintains a mask for each plane whose use is 			appication-dependent.  Mask mode allows pixels in the 			mask to be toggled on and off.  		Magnify: 			In magnify mode, image pixels in the graphics 			window may be magnifed using either the right or left 			mouse buttons.  The left button magnifies the displayed 			pixels, directly from the graphics window.  The right 			button magnifies the data itself, without the overlays.  		XY Zoom: 			Same as 'zoom' above, except the aspect ratio is 			set by the proportions of the selected box.  		Remove overlays: 			Allows the user to remove overlay arrays.  		Trim overlays: 			Allows the user to trim points from overlay arrays.  		Select within overlays: 			Allows the user to select points within overlay arrays.  		Define Region: 			Allows the user to define GRIM's region of interest.  		Smooth: 			Allows the user to select a smoothing box to be applied 			to the data array.  		Select Plane: 			Allows the user to change planes using the pointer. 			This option is only useful in cases where multiple 			planes are displayed.  		Drag Image: 			Allows the user to reposition the current plane by 			clicking and dragging.  		Navigate: 			Allows the user to modify the camera position and 			orientation usng the mouse.   	 Graphics window: 		The graphics window displays the data associated with the 		given data descriptor using the current zoom, offset, and 		display order.  The edges of an image are indicated by a dotted 		line.  The camera optic axis is indicated by a large red cross.  	 Pixel readout: 		The cursor position and corresponding data value are are 		displayed beneath the graphics window, next to the message line.  	 Message line: 		The message line displays short messages pertaining GRIM's 		 current state, or displayng button functions.   CALLBACK PROCEDURES: 	GRIM callback procedures are called with one or two arguments:        the first argument is a pointer to data that was provided 	when the callback was added.  The second argument, if present, depends 	on the applicatation.    RESOURCE NAMES 	The following X-windows resource names apply to grim: 	 grim_base:		top level base 	 grim_mbar:		menu bar 	 grim_shortcuts_base:	base containing shortcut buttons 	 grim_modes_base:	base containing modes buttons 	 grim_draw:		grim draw widget 	 grim_label:		grim bottom label widget  	To turn off the confusing higlight box around the modes buttons, 	put the following line in your ~/.Xdefaults file:  	 Idl*grim_modes_base*highlightThickness:	0    OPERATION: 	GRIM displays 1-, 2-, and 3-dimensional data sets.  1-dimensional 	data arrays are displayed as plots.  In that case, the abscissa is 	the sample number unless the data descriptor contains an abscissa. 	2- and 3-dimensional arrays are displaye as image planes.  The only 	difference between images and cubes in GRIM is that images planes 	each have their own data descriptor, while cubes are represented by 	multiple image planes that share a common data descriptor; each plane 	in a cube corresponds to a unique offset in the data array stored in 	the common data descriptor.  Some functionality is not available when 	working with plots.  In that case, those options do not appear in the 	menus.  	GRIM requests only the data samples needed for the current viewing 	parameters.  Therefore, GRIM can display data sets of arbitrary size 	when used with a file reader that supports subsampling.  However, note 	that specific menu options may request the entire data array, depending 	on the application.  	Each GRIM window may contain any number of planes as well as 	associated geometric data (i.e. object descriptors) and overlay arrays 	for displaying various geometric objects -- limbs, rings, stars, etc. 	An array of user overlay points is maintained to be used for application- 	specific purposes.  Generally, a set of overlay points or a descriptor 	must be activated in order to be used as input to a menu item; see 	activate mode above.  	There are exclusive and non-exclusive mechanisms for selecting grim 	windows.  Grim windows may be non-exclusively selected using the select 	mode button mentioned above (upper-left corner).  The exclusive 	selection mechanism consists of a  primary  GRIM window, indicated by 	a red outline in the graphics window.  The primary selection is 	changed by pressing any mode or shortcut button, or by clicking in 	the graphics area of the desired grim window.  The meaning of the 	various selections depends on the application.  	The functions of the left and right mouse buttons are determined by the 	cursor mode; some cursor modes define modifier keys to broaden the number 	of functions available in that mode.  The middle mouse button toggles 	the activation state of overlay arrays, or pans the image if no overlay 	appears beneath the cursor.  The mouse wheel cycles among cursor modes, 	or zooms about the cursor position if the control key is held down.  	Objects maintained by GRIM are accessible via the INGRID interface, 	for example:  		IDL> ingrid, dd=dd, cd=cd, pd=pd, limb_ptd=limb_ptd  	returns the data desciptor, camera descriptor, planet descriptors, 	and limb points associated with the current plane.  	GRIM registers event handlers for all of its objects, so the window 	is updated any time an object is modifed, whether by GRIM or by some 	other program, or from the command line.    EXAMPLES: 	(1) To create a new grim instance with no data:  		IDL> grim, /new  	(2) To create a new grim instance with data from a file of name 	     filename :  		IDL> dd = dat_read(filename) 		IDL> grim, dd  		   or  		IDL> grim, filename  	(3) To give an existing grim instance a new camera descriptor:  		IDL> grim, cd=cd    KNOWN BUGS: 	Window resizing is not precise.  GRIM tries to resize to the selected 	size, but typically overshoots.  This is probably platform-dependent.  	Objects inherited by rendering planes do not respond to events.  	Image shifting: 	 -  Descriptors not updated if shift performed form another window 	    because the there's no way for the irst window to know to 	    update its descriptors         - fix wrap-around; clip instead  	Plane->Coregister does not update descriptors  	Navigate mode gets weird when you do certain modifer key presses 	   --> maybe a conflict with <ctrl> wheel zoom action  	Crashes occur with File->Close  	/no_erase is not enabled for images, just plots.  Probably should fix 	that.  	Initial visibility setting does not seem to work until applied 	using plane settings window.  	/frame causes a crash if there are no initial overlays.  	It's not clear whether the symsize keyword is actually used.  	pn keyword does not function.  	Crash when tiepoint syncing is on and tiepoint selected with 	multiple planes.  	Title keyword does not properly map multiple elements to multiple 	planes.  	Nsum keyword does not properly map multiple elements to multiple 	planes.  	Plane syncing appears to be incomplete and I don't remember what it 	was supposed to be.  I'm sure it was awesome, though.  	Not sure what slave_overlays keyword does, or was supposed to do.  	Overlays on rendered planes do not respond to events  	Menu toggles don't update propoerly in some circumsumstances.  	grim_message sometimes pops up messages from nv_message, which can 	be pretty obnxious.  This probably has to do with the calls to 	grim_message in grim_compute.include    STATUS: 	Incomplete.    SEE ALSO: 	ingrid, gr_draw    MODIFICATION HISTORY:  	Written by:	Spitale 7/2002    FILE MENU    NAME: 	grim_menu_file_load_event    PURPOSE: 	Allows user to load images into new image planes.  The user is 	prompted for filenames and dat_read is used to read each image. 	Multiple images may be selected and a new plane is created for 	each image.  On X-windows systems, multiple files may be selected 	either by dragging across the filenames or by holding down the 	control key to toggle the selected files.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_file_browse_event    PURPOSE: 	Allows user to load images into new image planes using the brim 	browser.  Images are selected using the left mouse button and 	each image is loaded on a new plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002    NAME: 	grim_menu_file_save_event    PURPOSE: 	Allows user to save the current image plane and geometry.  If there 	is no current filename for the current plane, then the user is 	prompted for one.  All descriptors are written through the translators 	and then dat_write is used to write the data file.  Specific behavior 	is governed by OMINAS' configuration.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_file_save_as_event    PURPOSE: 	Same as 'Save' above, except always prompts for a filename.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_open_as_rgb_event    PURPOSE: 	Opens a new grim window with the current channal configuration 	reduced to a 3-channel RGB cube.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2016    NAME: 	grim_menu_file_save_user_ptd_event    PURPOSE: 	Writes user points for the current plane to a file called 	[image name].user_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_save_all_user_ptd_event    PURPOSE: 	Writes user points for all planes to files called 	[image name].user_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_load_user_ptd_event    PURPOSE: 	loads user points for the current plane from a file called 	[image name].user_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_load_all_user_ptd_event    PURPOSE: 	Loads user points for all planes from files called 	[image name].user_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_save_tie_ptd_event    PURPOSE: 	Writes tie points for the current plane to a file called 	[image name].tie_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_save_all_tie_ptd_event    PURPOSE: 	Writes tie points for all planes to files called 	[image name].tie_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_load_tie_ptd_event    PURPOSE: 	loads tie points for the current plane from a file called 	[image name].tie_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_load_all_tie_ptd_event    PURPOSE: 	Loads tie points for all planes from files called 	[image name].tie_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_save_curves_event    PURPOSE: 	Writes curves for the current plane to a file called 	[image name].curve_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2015    NAME: 	grim_menu_file_save_all_curves_event    PURPOSE: 	Writes curves for all planes to files called 	[image name].curve_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2015    NAME: 	grim_menu_file_load_curves_event    PURPOSE: 	loads curves for the current plane from a file called 	[image name].curve_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2015    NAME: 	grim_menu_file_load_all_curves_event    PURPOSE: 	Loads curves for all planes from files called 	[image name].curve_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2015    NAME: 	grim_menu_file_save_mask_event    PURPOSE: 	Writes mask points for the current plane to a file called 	[image name].mask    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013    NAME: 	grim_menu_file_save_all_masks_event    PURPOSE: 	Writes mask points for all planes to files called 	[image name].mask    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013    NAME: 	grim_menu_file_load_mask_event    PURPOSE: 	loads mask points for the current plane from a file called 	[image name].mask    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013    NAME: 	grim_menu_file_load_all_masks_event    PURPOSE: 	Loads mask points for all planes from files called 	[image name].mask    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013    NAME: 	grim_menu_file_save_ps_event    PURPOSE: 	Saves the current view as a postscript file.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2002    NAME: 	grim_menu_repeat_event    PURPOSE: 	Repeats the last menu option.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2006    NAME: 	grim_menu_undo_event    PURPOSE: 	Undoes the last data modification.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2006    NAME: 	grim_menu_redo_event    PURPOSE: 	Redoes the last data modification.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2006    NAME: 	grim_select_event    PURPOSE: 	Selects or unselects a grim window.  This functionality is for use 	with functions that require input from more than one grim instance. 	The selected state is red; unselected is gray.    CATEGORY: 	NV/GR    OPERATION: 	This option toggles a given grim instance between selected 	and unselected states, for use with functions that require 	input from more than one grim instance.  When a given instance 	is selected, this button displays an asterisk.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_identify_event    PURPOSE: 	Causes grim to identify itself on the IDL command line.    CATEGORY: 	NV/GR    OPERATION: 	This option causes grim to print a message on the IDL command line. 	It is useful in cases where multiple grim instances are running in 	multiple IDL sessions.    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2009    NAME: 	grim_menu_file_close_event    PURPOSE: 	Closes the current image plane.  All other image plane numbers 	remain the same.  If there is only one image plane, the grim exits.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    PLANE MENU    NAME: 	grim_menu_plane_next_event    PURPOSE: 	Changes to the next-numbered image plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_plane_previous_event    PURPOSE: 	Changes to the previous-numbered image plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_plane_jump_event    PURPOSE: 	Prompts the user and jumps to a new plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2005    NAME: 	grim_menu_plane_browse_event    PURPOSE: 	Opens a brim browser showing all planes.  The left mouse button 	may be used to jump among planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002    NAME: 	grim_menu_plane_open_event    PURPOSE: 	Opens the image of the current plane in a new grim window.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2002    NAME: 	grim_menu_plane_evolve_event    PURPOSE: 	Evolves the selected objects onto all other planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_plane_crop_event    PURPOSE: 	Crops the data to the current viewing parameters.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2013    NAME: 	grim_menu_plane_reorder_time_event    PURPOSE: 	Rearranges all planes in time order.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_plane_sequence_event    PURPOSE: 	Displays all planes in sequence using xinteranimate.  This option is 	useful or blinking as well.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    NAME: 	grim_menu_plane_dump_event    PURPOSE: 	Dumps all planes to png files entitled [filename].png.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2004    NAME: 	grim_menu_plane_coregister_event    PURPOSE: 	Shifts the images on each plane so as to center the active object 	at the same pixel on each plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2002    NAME: 	grim_menu_plane_coadd_event    PURPOSE: 	Averages all planes.  Not implemented.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2004    NAME: 	grim_menu_plane_toggle_plane_syncing_event    PURPOSE: 	Toggles plane syncing on/off.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2016    NAME: 	grim_menu_plane_highlight_event    PURPOSE: 	Toggles highlighting of the current plane image.  Useful when 	multiple planes are visible simultaneously.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008    NAME: 	grim_menu_plane_copy_tiepoints_event    PURPOSE: 	Copies all tieppoints from the current plane to all other planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2004    NAME: 	grim_menu_plane_propagate_tiepoints_event    PURPOSE: 	Copies all tieppoints from the current plane to all other planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2004    NAME: 	grim_menu_plane_toggle_tiepoint_syncing_event    PURPOSE: 	Toggles tiepoint syncing on/off.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012    NAME: 	grim_menu_plane_clear_tiepoints_event    PURPOSE: 	Clears all tiepoints from the current plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2004    NAME: 	grim_menu_plane_copy_curves_event    PURPOSE: 	Copies all curves from the current plane to all other planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2004    NAME: 	grim_menu_plane_toggle_curve_syncing_event    PURPOSE: 	Toggles curve syncing on/off.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012    NAME: 	grim_menu_plane_clear_curves_event    PURPOSE: 	Clears all curves from the current plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2004    NAME: 	grim_menu_plane_copy_mask_event    PURPOSE: 	Copies mask from the current plane to all other planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013    NAME: 	grim_menu_plane_clear_mask_event    PURPOSE: 	Clears the mask from the current plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013    NAME: 	grim_menu_plane_settings_event    PURPOSE: 	Allows the user modify settings for the loaded image planes. 	Each plane may displayed in any combination of the three color 	channels.  Also, a plane may be made visible even when it is not 	the current plane, instead of the default behavior, which is to 	display the plane only whenit is current.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    DATA MENU    NAME: 	grim_menu_data_adjust_event    PURPOSE: 	This option allows the user to adjust data values.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2014    VIEW MENU    NAME: 	grim_menu_view_refresh_event    PURPOSE: 	Redraws the overlays on the graphics display.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_view_zoom_event    PURPOSE: 	Prompts the user for a new zoom factor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2005    NAME: 	grim_menu_view_zoom_double_event    PURPOSE: 	Doubles the current zoom, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_half_event    PURPOSE: 	Halves the current zoom, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_event    PURPOSE: 	Sets the current zoom to 1, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_2_event    PURPOSE: 	Sets the current zoom to 2, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_3_event    PURPOSE: 	Sets the current zoom to 3, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_4_event    PURPOSE: 	Sets the current zoom to 4, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_5_event    PURPOSE: 	Sets the current zoom to 5, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_6_event    PURPOSE: 	Sets the current zoom to 6, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_7_event    PURPOSE: 	Sets the current zoom to 7, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_8_event    PURPOSE: 	Sets the current zoom to 8, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_9_event    PURPOSE: 	Sets the current zoom to 9, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_10_event    PURPOSE: 	Sets the current zoom to 10, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_2_event    PURPOSE: 	Sets the current zoom to 1/2, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_3_event    PURPOSE: 	Sets the current zoom to 1/3, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_4_event    PURPOSE: 	Sets the current zoom to 1/4, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_5_event    PURPOSE: 	Sets the current zoom to 1/5, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_5_event    PURPOSE: 	Sets the current zoom to 1/5, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_6_event    PURPOSE: 	Sets the current zoom to 1/6, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_7_event    PURPOSE: 	Sets the current zoom to 1/7, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_8_event    PURPOSE: 	Sets the current zoom to 1/8, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_9_event    PURPOSE: 	Sets the current zoom to 1/9, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_10_event    PURPOSE: 	Sets the current zoom to 1/10, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_rotate_0_event    PURPOSE: 	Sets the current rotate to 0, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_1_event    PURPOSE: 	Sets the current rotate to 1, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_2_event    PURPOSE: 	Sets the current rotate to 2, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_3_event    PURPOSE: 	Sets the current rotate to 3, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_4_event    PURPOSE: 	Sets the current rotate to 4, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_5_event    PURPOSE: 	Sets the current rotate to 5, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_6_event    PURPOSE: 	Sets the current rotate to 6, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_7_event    PURPOSE: 	Sets the current rotate to 7, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_recenter_event    PURPOSE: 	Recenters the view at the cursor position.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_apply_event    PURPOSE: 	Applys the current view to all planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2016    NAME: 	grim_menu_view_home_event    PURPOSE: 	Sets the tvim home view settings.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2005    NAME: 	grim_menu_view_save_event    PURPOSE: 	Saves the current view settings.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_view_restore_event    PURPOSE: 	Restores the last-saved view settings.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_view_previous_event    PURPOSE: 	Restores the previous view settings.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_view_entire_event    PURPOSE: 	Applies the 'entire' display parameters, as given in tvim.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_view_initial_event    PURPOSE: 	Reverts to the initial view parameters for this grim widget.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2007    NAME: 	grim_menu_view_flip_event    PURPOSE: 	Reverses the curent display order.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_view_frame_event    PURPOSE: 	Modifies view settings so as to display the either all overlays 	or those that are active.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2007    NAME: 	grim_menu_view_header_event    PURPOSE: 	Opens a text window showing the image header.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2003    NAME: 	grim_menu_notes_event    PURPOSE: 	Opens a text window allowing the user to enter notes for each plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2003    NAME: 	grim_menu_toggle_image_event    PURPOSE: 	Toggles the image On/Off.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2012    NAME: 	grim_menu_toggle_image_overlays_event    PURPOSE: 	Toggles the image and overlays On/Off.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2012    NAME: 	grim_menu_context_event    PURPOSE: 	Toggles the context window On/Off.   CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2005    NAME: 	grim_menu_axes_event    PURPOSE: 	Toggles the axes window On/Off.  The colors are as follows:  	 Blue	- Inertial axes. 	 Red	- Camera axes. 	 Green	- Direction to primary planet, not foreshortened. 	 Yellow	- Direction to Sun, not foreshortened.  	Vectors pointing away from the camera are dotted.  The vectors are 	rooted at a point 1d5 distance units in front of the camera . 	In the direction corresponding to the image position of the drawn 	axes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2005    NAME: 	grim_menu_render_event    PURPOSE: 	Renders the visible scene and places it in a new plane unless 	the current plane is already rendering.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015    NAME: 	grim_menu_view_colors_event    PURPOSE: 	Opens grim_colortool.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    OVERLAYS MENU    NAME: 	grim_menu_points_planet_centers_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	planet center positions using pg_center for all active objects.  If no 	active objects, then all centers are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_points_limbs_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	limbs using pg_limbs for all active objects.  If no active objects, 	then all limbs are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_points_terminators_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	terminators using pg_limb with the sun as the observer for all active 	objects.  If no active objects, then all terminators are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_points_planet_grids_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	planet grids using pg_grid for all active objects.  If no active 	objects, then all grids are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_points_rings_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	ring outlines using pg_disk.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_points_ring_grids_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	ring grids using pg_grid for all active objects.  If no active 	objects, then all grids are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2004    NAME: 	grim_menu_points_stations_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	planet stations for all active objects.  If no active objects, then 	all stations are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2009    NAME: 	grim_menu_points_arrays_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	arrays for all active objects.  If no active objects, then 	all arrays are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2012    NAME: 	grim_menu_points_stars_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	star positions using pg_center.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_points_shadows_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	shadows of the currently active overlay points on all other objects. 	Note that you may have to disable overlay hiding in order to compute 	and activate all of the appropriate source points for the shadows 	since many point that are not visible to the observer may still have 	a line of sight to the sun.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2003    NAME: 	grim_menu_points_reflections_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	reflections of the currently active overlay points on all other objects. 	Note that you may have to disable overlay hiding in order to compute 	and activate all of the appropriate source points for the reflections 	since many point that are not visible to the observer may still have 	a line of sight to the sun.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2003    NAME: 	grim_menu_hide_all_event    PURPOSE: 	 Hides/unhides all overlay objects.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2003    NAME: 	grim_menu_clear_all_event    PURPOSE: 	 Clears all objects.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2002    NAME: 	grim_menu_clear_active_event    PURPOSE: 	 Clears all active objects.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2002    NAME: 	grim_menu_activate_all_event    PURPOSE: 	 Activates all objects.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2002    NAME: 	grim_menu_deactivate_all_event    PURPOSE: 	 Deactivates all objects.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2002    NAME: 	grim_menu_invert_all_event    PURPOSE: 	 Inverts current overlay activations.  Desccriptor activations are 	 determined by the resulting overlay activations.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2002    NAME: 	grim_menu_points_settings_event    PURPOSE: 	Allows the user modify settings relevant to the overlay points.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_constants", "grim_constants", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_constants", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_resize", "grim_resize", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_resize", "", "initgrim_database_xsizebase_ysize", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_set_tracking", "grim_set_tracking", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_set_tracking", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_test_motion_event", "grim_test_motion_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_test_motion_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_set_ct", "grim_set_ct", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_set_ct", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_set_mode", "grim_set_mode", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_set_mode", "", "newinitdata_pgrim_datamode", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_write_ptd", "grim_write_ptd", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_write_ptd", "", "grim_datafilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_write", "grim_write", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_write", "", "filetypegrim_datafilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_get_save_filename", "grim_get_save_filename", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_get_save_filename", "", "filetypegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_kill_notify", "grim_kill_notify", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_kill_notify", "", "top", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_load_files", "grim_load_files", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_load_files", "", "load_pathgrim_datafilenames", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_deactivate_all", "grim_deactivate_all", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_deactivate_all", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_activate_all", "grim_activate_all", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_activate_all", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_modify_colors", "grim_modify_colors", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_modify_colors", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_edit_header", "grim_edit_header", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_edit_header", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_edit_notes", "grim_edit_notes", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_edit_notes", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_user_ptd_fname", "grim_user_ptd_fname", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_user_ptd_fname", "", "basenamegrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_write_user_points", "grim_write_user_points", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_write_user_points", "", "fnamegrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_mask_fname", "grim_mask_fname", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_mask_fname", "", "basenamegrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_write_mask", "grim_write_mask", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_write_mask", "", "fnamegrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_read_user_points", "grim_read_user_points", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_read_user_points", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_read_mask", "grim_read_mask", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_read_mask", "", "fnamegrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_jumpto", "grim_jumpto", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_jumpto", "", "grim_dataid", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_recenter", "grim_recenter", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_recenter", "", "grim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_zoom", "grim_zoom", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_zoom", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_zoom_to_cursor", "grim_zoom_to_cursor", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_zoom_to_cursor", "", "relativezoomzz", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_modes_list", "grim_modes_list", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_modes_list", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_interrupt_begin", "grim_interrupt_begin", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_interrupt_begin", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_interrupt_end", "grim_interrupt_end", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_interrupt_end", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_toggle_context", "grim_toggle_context", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_toggle_context", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_toggle_axes", "grim_toggle_axes", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_toggle_axes", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_render", "grim_render", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_render", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_erase_guideline", "grim_erase_guideline", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_erase_guideline", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_draw_guideline", "grim_draw_guideline", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_draw_guideline", "", "grim_dataxy", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_repeat", "grim_repeat", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_repeat", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_exit", "grim_exit", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_exit", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_undo", "grim_undo", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_undo", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_redo", "grim_redo", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_redo", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_interrupt_callback", "grim_interrupt_callback", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_interrupt_callback", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_sampling_fn", "grim_sampling_fn", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_sampling_fn", "", "ddsource_image_pts_sampledata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_render_dim_fn", "grim_render_dim_fn", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_render_dim_fn", "", "dddim_orig", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_render_sampling_fn", "grim_render_sampling_fn", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_render_sampling_fn", "", "ddsource_image_pts_samplesource_image_pts_grid", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_draw_vectors", "grim_draw_vectors", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_draw_vectors", "", "cdcurves_ptdpoints_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_increment_mode", "grim_increment_mode", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_increment_mode", "", "grim_datadm", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_event", "grim_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_update_guideline", "grim_update_guideline", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_update_guideline", "", "grim_dataplanexy", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_update_xy_label", "grim_update_xy_label", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_update_xy_label", "", "grim_dataplanexy", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_scroll", "grim_scroll", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_scroll", "", "grim_dataplaneclicksmodifiers", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_middle", "grim_middle", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_middle", "", "grim_dataplaneidxypressclicksmodifiersoutput_wnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_draw_event", "grim_draw_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_draw_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_help_event", "grim_menu_file_load_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_event", "grim_menu_file_load_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_browse_help_event", "grim_menu_file_browse_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_browse_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_browse_file_left_event", "grim_browse_file_left_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_browse_file_left_event", "", "statusbaseiid", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_browse_event", "grim_menu_file_browse_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_browse_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_help_event", "grim_menu_file_save_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_event", "grim_menu_file_save_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_as_help_event", "grim_menu_file_save_as_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_as_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_as_event", "grim_menu_file_save_as_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_as_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_open_as_rgb_help_event", "grim_menu_open_as_rgb_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_open_as_rgb_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_open_as_rgb_event", "grim_menu_open_as_rgb_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_open_as_rgb_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_user_ptd_help_event", "grim_menu_file_save_user_ptd_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_user_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_user_ptd_event", "grim_menu_file_save_user_ptd_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_user_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_all_user_ptd_help_event", "grim_menu_file_save_all_user_ptd_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_user_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_all_user_ptd_event", "grim_menu_file_save_all_user_ptd_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_user_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_user_ptd_help_event", "grim_menu_file_load_user_ptd_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_user_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_user_ptd_event", "grim_menu_file_load_user_ptd_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_user_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_all_user_ptd_help_event", "grim_menu_file_load_all_user_ptd_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_user_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_all_user_ptd_event", "grim_menu_file_load_all_user_ptd_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_user_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_tie_ptd_help_event", "grim_menu_file_save_tie_ptd_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_tie_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_tie_ptd_event", "grim_menu_file_save_tie_ptd_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_tie_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_all_tie_ptd_help_event", "grim_menu_file_save_all_tie_ptd_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_tie_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_all_tie_ptd_event", "grim_menu_file_save_all_tie_ptd_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_tie_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_tie_ptd_help_event", "grim_menu_file_load_tie_ptd_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_tie_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_tie_ptd_event", "grim_menu_file_load_tie_ptd_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_tie_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_all_tie_ptd_help_event", "grim_menu_file_load_all_tie_ptd_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_tie_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_all_tie_ptd_event", "grim_menu_file_load_all_tie_ptd_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_tie_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_curves_help_event", "grim_menu_file_save_curves_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_curves_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_curves_event", "grim_menu_file_save_curves_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_curves_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_all_curves_help_event", "grim_menu_file_save_all_curves_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_curves_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_all_curves_event", "grim_menu_file_save_all_curves_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_curves_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_curves_help_event", "grim_menu_file_load_curves_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_curves_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_curves_event", "grim_menu_file_load_curves_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_curves_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_all_curves_help_event", "grim_menu_file_load_all_curves_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_curves_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_all_curves_event", "grim_menu_file_load_all_curves_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_curves_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_mask_help_event", "grim_menu_file_save_mask_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_mask_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_mask_event", "grim_menu_file_save_mask_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_mask_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_all_masks_help_event", "grim_menu_file_save_all_masks_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_masks_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_all_masks_event", "grim_menu_file_save_all_masks_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_masks_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_mask_help_event", "grim_menu_file_load_mask_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_mask_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_mask_event", "grim_menu_file_load_mask_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_mask_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_all_masks_help_event", "grim_menu_file_load_all_masks_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_masks_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_load_all_masks_event", "grim_menu_file_load_all_masks_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_masks_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_ps_help_event", "grim_menu_file_save_ps_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_ps_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_save_ps_event", "grim_menu_file_save_ps_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_ps_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_repeat_help_event", "grim_menu_repeat_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_repeat_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_repeat_event", "grim_menu_repeat_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_repeat_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_undo_help_event", "grim_menu_undo_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_undo_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_undo_event", "grim_menu_undo_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_undo_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_redo_help_event", "grim_menu_redo_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_redo_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_redo_event", "grim_menu_redo_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_redo_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_select_help_event", "grim_select_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_select_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_select_event", "grim_select_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_select_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_identify_help_event", "grim_identify_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_identify_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_identify_event", "grim_identify_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_identify_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_close_help_event", "grim_menu_file_close_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_close_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_file_close_event", "grim_menu_file_close_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_close_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_next_help_event", "grim_menu_plane_next_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_next_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_next_event", "grim_menu_plane_next_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_next_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_previous_help_event", "grim_menu_plane_previous_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_previous_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_previous_event", "grim_menu_plane_previous_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_previous_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_jump_help_event", "grim_menu_plane_jump_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_jump_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_jump_event", "grim_menu_plane_jump_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_jump_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_browse_help_event", "grim_menu_plane_browse_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_browse_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_browse_plane_left_event", "grim_browse_plane_left_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_browse_plane_left_event", "", "statusbaseiid", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_browse_refresh_event", "grim_browse_refresh_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_browse_refresh_event", "", "data_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_browse_event", "grim_menu_plane_browse_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_browse_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_open_help_event", "grim_menu_plane_open_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_open_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_open_event", "grim_menu_plane_open_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_open_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_evolve_help_event", "grim_menu_plane_evolve_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_evolve_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_evolve_event", "grim_menu_plane_evolve_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_evolve_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_crop_help_event", "grim_menu_plane_crop_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_crop_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_crop_event", "grim_menu_plane_crop_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_crop_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_reorder_time_help_event", "grim_menu_plane_reorder_time_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_reorder_time_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_reorder_time_event", "grim_menu_plane_reorder_time_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_reorder_time_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_sequence_help_event", "grim_menu_plane_sequence_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_sequence_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_sequence_event", "grim_menu_plane_sequence_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_sequence_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_dump_help_event", "grim_menu_plane_dump_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_dump_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_dump_event", "grim_menu_plane_dump_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_dump_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_coregister_help_event", "grim_menu_plane_coregister_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_coregister_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_coregister_event", "grim_menu_plane_coregister_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_coregister_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_coadd_help_event", "grim_menu_plane_coadd_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_coadd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_coadd_event", "grim_menu_plane_coadd_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_coadd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_toggle_plane_syncing_help_event", "grim_menu_plane_toggle_plane_syncing_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_toggle_plane_syncing_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_toggle_plane_syncing_event", "grim_menu_plane_toggle_plane_syncing_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_toggle_plane_syncing_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_highlight_help_event", "grim_menu_plane_highlight_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_highlight_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_highlight_event", "grim_menu_plane_highlight_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_highlight_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_copy_tiepoints_help_event", "grim_menu_plane_copy_tiepoints_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_copy_tiepoints_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_copy_tiepoints_event", "grim_menu_plane_copy_tiepoints_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_copy_tiepoints_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_propagate_tiepoints_help_event", "grim_menu_plane_propagate_tiepoints_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_propagate_tiepoints_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_propagate_tiepoints_event", "grim_menu_plane_propagate_tiepoints_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_propagate_tiepoints_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_toggle_tiepoint_syncing_help_event", "grim_menu_plane_toggle_tiepoint_syncing_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_toggle_tiepoint_syncing_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_toggle_tiepoint_syncing_event", "grim_menu_plane_toggle_tiepoint_syncing_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_toggle_tiepoint_syncing_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_clear_tiepoints_help_event", "grim_menu_plane_clear_tiepoints_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_clear_tiepoints_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_clear_tiepoints_event", "grim_menu_plane_clear_tiepoints_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_clear_tiepoints_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_copy_curves_help_event", "grim_menu_plane_copy_curves_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_copy_curves_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_copy_curves_event", "grim_menu_plane_copy_curves_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_copy_curves_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_toggle_curve_syncing_help_event", "grim_menu_plane_toggle_curve_syncing_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_toggle_curve_syncing_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_toggle_curve_syncing_event", "grim_menu_plane_toggle_curve_syncing_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_toggle_curve_syncing_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_clear_curves_help_event", "grim_menu_plane_clear_curves_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_clear_curves_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_clear_curves_event", "grim_menu_plane_clear_curves_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_clear_curves_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_copy_mask_help_event", "grim_menu_plane_copy_mask_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_copy_mask_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_copy_mask_event", "grim_menu_plane_copy_mask_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_copy_mask_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_clear_mask_help_event", "grim_menu_plane_clear_mask_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_clear_mask_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_clear_mask_event", "grim_menu_plane_clear_mask_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_clear_mask_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_settings_help_event", "grim_menu_plane_settings_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_settings_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_plane_settings_event", "grim_menu_plane_settings_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_settings_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_data_adjust_help_event", "grim_menu_data_adjust_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_data_adjust_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_data_adjust_event", "grim_menu_data_adjust_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_data_adjust_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_refresh_help_event", "grim_menu_view_refresh_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_refresh_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_refresh_event", "grim_menu_view_refresh_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_refresh_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_help_event", "grim_menu_view_zoom_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_event", "grim_menu_view_zoom_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_double_help_event", "grim_menu_view_zoom_double_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_double_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_double_event", "grim_menu_view_zoom_double_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_double_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_half_help_event", "grim_menu_view_zoom_half_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_half_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_half_event", "grim_menu_view_zoom_half_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_half_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_help_event", "grim_menu_view_zoom_1_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_event", "grim_menu_view_zoom_1_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_2_help_event", "grim_menu_view_zoom_2_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_2_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_2_event", "grim_menu_view_zoom_2_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_2_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_3_help_event", "grim_menu_view_zoom_3_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_3_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_3_event", "grim_menu_view_zoom_3_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_3_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_4_help_event", "grim_menu_view_zoom_4_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_4_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_4_event", "grim_menu_view_zoom_4_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_4_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_5_help_event", "grim_menu_view_zoom_5_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_5_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_5_event", "grim_menu_view_zoom_5_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_5_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_6_help_event", "grim_menu_view_zoom_6_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_6_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_6_event", "grim_menu_view_zoom_6_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_6_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_7_help_event", "grim_menu_view_zoom_7_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_7_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_7_event", "grim_menu_view_zoom_7_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_7_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_8_help_event", "grim_menu_view_zoom_8_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_8_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_8_event", "grim_menu_view_zoom_8_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_8_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_9_help_event", "grim_menu_view_zoom_9_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_9_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_9_event", "grim_menu_view_zoom_9_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_9_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_10_help_event", "grim_menu_view_zoom_10_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_10_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_10_event", "grim_menu_view_zoom_10_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_10_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_2_help_event", "grim_menu_view_zoom_1_2_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_2_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_2_event", "grim_menu_view_zoom_1_2_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_2_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_3_help_event", "grim_menu_view_zoom_1_3_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_3_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_3_event", "grim_menu_view_zoom_1_3_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_3_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_4_help_event", "grim_menu_view_zoom_1_4_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_4_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_4_event", "grim_menu_view_zoom_1_4_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_4_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_5_help_event", "grim_menu_view_zoom_1_5_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_5_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_5_event", "grim_menu_view_zoom_1_5_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_5_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_5_help_event", "grim_menu_view_zoom_1_5_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_5_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_5_event", "grim_menu_view_zoom_1_5_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_5_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_6_help_event", "grim_menu_view_zoom_1_6_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_6_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_6_event", "grim_menu_view_zoom_1_6_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_6_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_7_help_event", "grim_menu_view_zoom_1_7_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_7_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_7_event", "grim_menu_view_zoom_1_7_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_7_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_8_help_event", "grim_menu_view_zoom_1_8_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_8_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_8_event", "grim_menu_view_zoom_1_8_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_8_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_9_help_event", "grim_menu_view_zoom_1_9_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_9_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_9_event", "grim_menu_view_zoom_1_9_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_9_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_10_help_event", "grim_menu_view_zoom_1_10_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_10_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_zoom_1_10_event", "grim_menu_view_zoom_1_10_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_10_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_0_help_event", "grim_menu_view_rotate_0_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_0_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_0_event", "grim_menu_view_rotate_0_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_0_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_1_help_event", "grim_menu_view_rotate_1_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_1_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_1_event", "grim_menu_view_rotate_1_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_1_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_2_help_event", "grim_menu_view_rotate_2_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_2_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_2_event", "grim_menu_view_rotate_2_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_2_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_3_help_event", "grim_menu_view_rotate_3_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_3_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_3_event", "grim_menu_view_rotate_3_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_3_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_4_help_event", "grim_menu_view_rotate_4_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_4_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_4_event", "grim_menu_view_rotate_4_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_4_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_5_help_event", "grim_menu_view_rotate_5_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_5_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_5_event", "grim_menu_view_rotate_5_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_5_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_6_help_event", "grim_menu_view_rotate_6_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_6_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_6_event", "grim_menu_view_rotate_6_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_6_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_7_help_event", "grim_menu_view_rotate_7_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_7_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_rotate_7_event", "grim_menu_view_rotate_7_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_7_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_recenter_help_event", "grim_menu_view_recenter_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_recenter_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_recenter_event", "grim_menu_view_recenter_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_recenter_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_apply_help_event", "grim_menu_view_apply_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_apply_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_apply_event", "grim_menu_view_apply_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_apply_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_home_help_event", "grim_menu_view_home_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_home_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_home_event", "grim_menu_view_home_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_home_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_save_help_event", "grim_menu_view_save_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_save_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_save_event", "grim_menu_view_save_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_save_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_restore_help_event", "grim_menu_view_restore_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_restore_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_restore_event", "grim_menu_view_restore_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_restore_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_previous_help_event", "grim_menu_view_previous_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_previous_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_previous_event", "grim_menu_view_previous_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_previous_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_entire_help_event", "grim_menu_view_entire_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_entire_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_entire_event", "grim_menu_view_entire_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_entire_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_initial_help_event", "grim_menu_view_initial_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_initial_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_initial_event", "grim_menu_view_initial_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_initial_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_flip_help_event", "grim_menu_view_flip_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_flip_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_flip_event", "grim_menu_view_flip_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_flip_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_frame_help_event", "grim_menu_view_frame_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_frame_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_frame_event", "grim_menu_view_frame_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_frame_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_header_help_event", "grim_menu_view_header_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_header_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_header_event", "grim_menu_view_header_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_header_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_notes_help_event", "grim_menu_notes_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_notes_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_notes_event", "grim_menu_notes_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_notes_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_image_help_event", "grim_menu_image_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_image_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_toggle_image_event", "grim_menu_toggle_image_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_toggle_image_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_image_overlays_help_event", "grim_menu_image_overlays_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_image_overlays_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_toggle_image_overlays_event", "grim_menu_toggle_image_overlays_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_toggle_image_overlays_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_context_help_event", "grim_menu_context_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_context_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_context_event", "grim_menu_context_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_context_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_axes_help_event", "grim_menu_axes_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_axes_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_axes_event", "grim_menu_axes_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_axes_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_render_help_event", "grim_menu_render_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_render_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_render_event", "grim_menu_render_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_render_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_colors_help_event", "grim_menu_view_colors_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_colors_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_view_colors_event", "grim_menu_view_colors_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_colors_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_planet_centers_help_event", "grim_menu_points_planet_centers_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_planet_centers_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_planet_centers_event", "grim_menu_points_planet_centers_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_planet_centers_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_limbs_help_event", "grim_menu_points_limbs_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_limbs_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_limbs_event", "grim_menu_points_limbs_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_limbs_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_terminators_help_event", "grim_menu_points_terminators_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_terminators_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_terminators_event", "grim_menu_points_terminators_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_terminators_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_planet_grids_help_event", "grim_menu_points_planet_grids_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_planet_grids_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_planet_grids_event", "grim_menu_points_planet_grids_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_planet_grids_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_rings_help_event", "grim_menu_points_rings_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_rings_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_rings_event", "grim_menu_points_rings_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_rings_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_ring_grids_help_event", "grim_menu_points_ring_grids_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_ring_grids_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_ring_grids_event", "grim_menu_points_ring_grids_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_ring_grids_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_stations_help_event", "grim_menu_points_stations_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_stations_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_stations_event", "grim_menu_points_stations_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_stations_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_arrays_help_event", "grim_menu_points_arrays_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_arrays_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_arrays_event", "grim_menu_points_arrays_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_arrays_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_stars_help_event", "grim_menu_points_stars_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_stars_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_stars_event", "grim_menu_points_stars_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_stars_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_shadows_help_event", "grim_menu_points_shadows_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_shadows_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_shadows_event", "grim_menu_points_shadows_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_shadows_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_reflections_help_event", "grim_menu_points_reflections_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_reflections_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_reflections_event", "grim_menu_points_reflections_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_reflections_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_hide_all_help_event", "grim_menu_hide_all_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_hide_all_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_hide_all_event", "grim_menu_hide_all_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_hide_all_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_clear_all_help_event", "grim_menu_clear_all_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_clear_all_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_clear_all_event", "grim_menu_clear_all_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_clear_all_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_clear_active_help_event", "grim_menu_clear_active_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_clear_active_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_clear_active_event", "grim_menu_clear_active_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_clear_active_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_activate_all_help_event", "grim_menu_activate_all_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_activate_all_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_activate_all_event", "grim_menu_activate_all_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_activate_all_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_deactivate_all_help_event", "grim_menu_deactivate_all_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_deactivate_all_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_deactivate_all_event", "grim_menu_deactivate_all_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_deactivate_all_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_invert_all_help_event", "grim_menu_invert_all_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_invert_all_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_invert_event", "grim_menu_invert_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_invert_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_settings_help_event", "grim_menu_points_settings_help_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_settings_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_points_settings_event", "grim_menu_points_settings_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_settings_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_previous_event", "grim_previous_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_previous_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_jumpto_event", "grim_jumpto_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_jumpto_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_next_event", "grim_next_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_next_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_crop_event", "grim_crop_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_crop_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_refresh_event", "grim_refresh_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_refresh_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_entire_event", "grim_entire_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_entire_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_view_previous_event", "grim_view_previous_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_view_previous_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_colors_event", "grim_colors_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_colors_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_settings_event", "grim_settings_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_settings_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_header_event", "grim_header_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_header_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_notes_event", "grim_notes_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_notes_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_undo_event", "grim_undo_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_undo_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_redo_event", "grim_redo_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_redo_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_toggle_image_event", "grim_toggle_image_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_toggle_image_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_toggle_image_overlays_event", "grim_toggle_image_overlays_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_toggle_image_overlays_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_hide_event", "grim_hide_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_hide_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_tracking_event", "grim_tracking_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_tracking_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_grid_event", "grim_grid_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_grid_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_pixel_grid_event", "grim_pixel_grid_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_pixel_grid_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_guideline_event", "grim_guideline_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_guideline_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_context_event", "grim_context_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_context_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_axes_event", "grim_axes_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_axes_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_render_event", "grim_render_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_render_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_activate_all_event", "grim_activate_all_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_activate_all_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_deactivate_all_event", "grim_deactivate_all_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_deactivate_all_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_repeat_event", "grim_repeat_event", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_repeat_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_help", "grim_help", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_help", "", "grim_datatext", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_create_help_menu", "grim_create_help_menu", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_create_help_menu", "", "_menu_desc", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_cull_menu_desc", "grim_cull_menu_desc", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_cull_menu_desc", "", "map_itemsmap_indicesod_map_itemsod_map_indicesplot_itemsplot_indicesplot_only_itemsplot_only_indicesbeta_only_indices_menu_descplotmapbeta", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_parse_menu_desc", "grim_parse_menu_desc", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_parse_menu_desc", "", "map_itemsmap_indicesod_map_itemsod_map_indicesplot_itemsplot_indicesplot_only_itemsplot_only_indicesbeta_only_indices_menu_desc", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_desc", "grim_menu_desc", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_desc", "", "cursor_modes", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_get_window_size", "grim_get_window_size", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_get_window_size", "", "xsizeysizegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_menu_capture", "grim_menu_capture", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_capture", "", "fnevent", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_widgets", "grim_widgets", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_widgets", "", "xsizeysizecursor_modesmenu_fnamemenu_extensionsgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_get_default_zoom", "grim_get_default_zoom", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_get_default_zoom", "", "dd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_save_initial_view", "grim_save_initial_view", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_save_initial_view", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_initial_framing", "grim_initial_framing", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_initial_framing", "", "delay_overlaysgrim_dataframe", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_initial_overlays", "grim_initial_overlays", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_initial_overlays", "", "planeexcludeonlytempptdgrim_data_overlays", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_rgb_dim_fn", "grim_rgb_dim_fn", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_rgb_dim_fn", "", "dddat", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_get_arg", "grim_get_arg", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_get_arg", "", "ddgrnumextensionsarg", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_get_args", "grim_get_args", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_get_args", "", "ddgrnumtypexzeronhistmaintaincompressextensionsrgbarg1arg2", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_create_cursor_mode", "grim_create_cursor_mode", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_create_cursor_mode", "", "no_prefixnamemode_argscursor_modes", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim", "grim", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim", "", "gd_extracdpdrdsdstdardsundodnewxsizeysizedefaultpreviousrestoreactivatedoffsetno_erasefilterrgbvisibilitychannelexitzoomrotateorderoffsetretainmaintainmode_initmodalxzeroframerefresh_callbacksrefresh_callback_data_psplane_callbacksplane_callback_data_psnhistcompresspathsymsizeuser_psymworkdirmode_argssave_pathload_pathoverlayspnmenu_fnamecursor_swapfovcliphidemenu_extensionsbutton_extensionsarg_extensionsloadctmaxgrnumextensionsbetarenderingnpointscam_trsplt_trsrng_trsstr_trssun_trsstn_trsarr_trsassoc_ddplane_syncingtiepoint_syncingcurve_syncingrender_samplerender_pht_minslave_overlayspositiondelay_overlaysauto_stretchcolorxrangeyrangethicknsumnddxtitleytitlepsymtitlearg1arg2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html", "grim_bitmaps_include.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_bitmaps_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_identify_bitmap", "grim_identify_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_identify_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_rotate_bitmap", "grim_rotate_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_rotate_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_reorient_bitmap", "grim_reorient_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_reorient_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_mp40_bitmap", "grim_mp40_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_mp40_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_dagger_bitmap", "grim_dagger_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_dagger_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_crop_bitmap", "grim_crop_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_crop_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_redo_bitmap", "grim_redo_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_redo_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_undo_bitmap", "grim_undo_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_undo_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_notes_bitmap", "grim_notes_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_notes_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_remove1_bitmap", "grim_remove1_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_remove1_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_remove2_bitmap", "grim_remove2_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_remove2_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_repeat_bitmap", "grim_repeat_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_repeat_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_unselect_bitmap", "grim_unselect_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_unselect_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_select_bitmap", "grim_select_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_select_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_context_bitmap", "grim_context_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_context_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_previous_bitmap", "grim_previous_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_previous_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_next_bitmap", "grim_next_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_next_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_mag_bitmap", "grim_mag_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_mag_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_refresh_bitmap", "grim_refresh_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_refresh_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_entire_bitmap", "grim_entire_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_entire_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_view_previous_bitmap", "grim_view_previous_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_view_previous_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_hide_bitmap", "grim_hide_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_hide_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_unhide_bitmap", "grim_unhide_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_unhide_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_colors_bitmap", "grim_colors_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_colors_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_tracking_bitmap", "grim_tracking_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_tracking_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_activate_all_bitmap", "grim_activate_all_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_activate_all_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_deactivate_all_bitmap", "grim_deactivate_all_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_deactivate_all_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_grid_bitmap", "grim_grid_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_grid_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_header_bitmap", "grim_header_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_header_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_axes_bitmap", "grim_axes_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_axes_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_unhide_image_bitmap", "grim_unhide_image_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_unhide_image_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_hide_image_bitmap", "grim_hide_image_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_hide_image_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_unrender_bitmap", "grim_unrender_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_unrender_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_render_bitmap", "grim_render_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_render_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_settings_bitmap", "grim_settings_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_settings_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_pixel_grid_bitmap", "grim_pixel_grid_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_pixel_grid_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_guideline_bitmap", "grim_guideline_bitmap", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_guideline_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_bitmaps_include.html#grim_bitmaps_include", "grim_bitmaps_include", 'routine in <a href="grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_bitmaps_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_colortool.html", "grim_colortool.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_colortool.pro", "", "", " NAME: 	GRIM_COLORTOOL    PURPOSE: 	Tool for adjusting colors in GRIM.    CATEGORY: 	NV/GRIM    CALLING SEQUENCE:  	grim_colortool    ARGUMENTS: NONE    KEYWORDS: NONE    OPERATION: 	Color table plot: 		Displays a plot of the current color table, with a color 		bar at the bottom.  	Stretch Top slider: 		Controls the top value for the color table stretch.  	Stretch Bottom slider: 		Controls the bottom value for the color table stretch.  	Gamma slider: 		Controls the gamma value for the color table stretch.  	Shade slider: 		Vertial slider on the left side of the tool controlling the 		total brightness.  	Color table droplist: 		Selects IDL color table.  	Auto button: 		Performs an automatic stretch.  	All button: 		If set (or activated), the current color table is applied 		to all GRIM planes.  If 'Auto' is pressed while 'All' is 		on, the automatic stretch is performed independently for 		each plane.    SEE ALSO: 	grim    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_colortool.html#grct_slider_to_gamma", "grct_slider_to_gamma", 'routine in <a href="grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_slider_to_gamma", "", "value", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_colortool.html#grct_gamma_to_slider", "grct_gamma_to_slider", 'routine in <a href="grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_gamma_to_slider", "", "value", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_colortool.html#grct_print_gamma", "grct_print_gamma", 'routine in <a href="grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_print_gamma", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_colortool.html#grct_widget_to_descriptor", "grct_widget_to_descriptor", 'routine in <a href="grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_widget_to_descriptor", "", "datacmd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_colortool.html#grct_descriptor_to_widget", "grct_descriptor_to_widget", 'routine in <a href="grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_descriptor_to_widget", "", "noslidedatacmd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_colortool.html#grct_plot", "grct_plot", 'routine in <a href="grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_plot", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_colortool.html#grct_cleanup", "grct_cleanup", 'routine in <a href="grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_colortool.html#grct_update", "grct_update", 'routine in <a href="grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_update", "", "allautocmd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_colortool.html#grim_colortool_event", "grim_colortool_event", 'routine in <a href="grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grim_colortool_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_colortool.html#grim_colortool_change", "grim_colortool_change", 'routine in <a href="grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grim_colortool_change", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_colortool.html#grct_primary_notify", "grct_primary_notify", 'routine in <a href="grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_primary_notify", "", "data_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_colortool.html#grim_colortool", "grim_colortool", 'routine in <a href="grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grim_colortool", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_compute_include.html", "grim_compute_include.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_compute_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_compute_planet_center", "grim_compute_planet_center", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_planet_center", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_symsize_planet_center", "grim_symsize_planet_center", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_planet_center", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_shade_planet_center", "grim_shade_planet_center", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_planet_center", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_compute_limb", "grim_compute_limb", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_limb", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_symsize_limb", "grim_symsize_limb", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_limb", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_shade_limb", "grim_shade_limb", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_limb", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_compute_terminator", "grim_compute_terminator", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_terminator", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_symsize_terminator", "grim_symsize_terminator", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_terminator", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_shade_terminator", "grim_shade_terminator", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_terminator", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_compute_planet_grid", "grim_compute_planet_grid", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_planet_grid", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_symsize_planet_grid", "grim_symsize_planet_grid", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_planet_grid", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_shade_planet_grid", "grim_shade_planet_grid", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_planet_grid", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_compute_station", "grim_compute_station", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_station", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_symsize_station", "grim_symsize_station", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_station", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_shade_station", "grim_shade_station", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_station", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_compute_array", "grim_compute_array", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_array", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_symsize_array", "grim_symsize_array", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_array", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_shade_array", "grim_shade_array", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_array", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_compute_star", "grim_compute_star", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_star", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_symsize_star", "grim_symsize_star", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_star", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_shade_star", "grim_shade_star", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_star", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_compute_shadow", "grim_compute_shadow", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_shadow", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_symsize_shadow", "grim_symsize_shadow", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_shadow", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_shade_shadow", "grim_shade_shadow", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_shadow", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_compute_reflection", "grim_compute_reflection", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_reflection", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_symsize_reflection", "grim_symsize_reflection", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_reflection", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_shade_reflection", "grim_shade_reflection", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_reflection", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_compute_ring", "grim_compute_ring", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_ring", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_symsize_ring", "grim_symsize_ring", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_ring", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_shade_ring", "grim_shade_ring", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_ring", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_compute_ring_grid", "grim_compute_ring_grid", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_ring_grid", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_symsize_ring_grid", "grim_symsize_ring_grid", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_ring_grid", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_shade_ring_grid", "grim_shade_ring_grid", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_ring_grid", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_compute_include.html#grim_compute_include", "grim_compute_include", 'routine in <a href="grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_data_include.html", "grim_data_include.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_data_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_blank", "grim_blank", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_blank", "", "xsizeysize", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_init", "grim_init", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_init", "", "dd0zoomwnumgrnumfilterretainuser_callbacksuser_psymuser_graphics_fnuser_thickuser_linecursor_swapcmdpathsave_pathload_pathfovclipcam_trsplt_trsrng_trsstr_trsstn_trsarr_trssun_trshidetypecam_selectplt_selectrng_selectsun_selectstr_selectstn_selectarr_selectcolorxrangeyrangepositionnpointsthicknsumxtitleytitlepsymcursor_modessymsizenhistmaintainworkdircompressextensionsmaxbetavisibilitychanneltitleslave_overlaysrender_samplerender_pht_minoverlaysactivatedd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_exists", "grim_exists", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_exists", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_grnum_to_top", "grim_grnum_to_top", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_grnum_to_top", "", "grnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_get_data", "grim_get_data", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_get_data", "", "grnumplanedeadprimaryno_wsettop", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_set_data", "grim_set_data", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_set_data", "", "primarygrim_datatop", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_set_primary", "grim_set_primary", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_set_primary", "", "top", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_set_mode_data", "grim_set_mode_data", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_set_mode_data", "", "grim_datadata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_add_primary_callback", "grim_add_primary_callback", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_add_primary_callback", "", "callbacksdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_rm_primary_callback", "grim_rm_primary_callback", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_rm_primary_callback", "", "data_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_call_primary_callbacks", "grim_call_primary_callbacks", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_call_primary_callbacks", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_add_plane_callback", "grim_add_plane_callback", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_add_plane_callback", "", "topno_wsetcallbacksdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_rm_plane_callback", "grim_rm_plane_callback", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_rm_plane_callback", "", "topdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_call_plane_callbacks", "grim_call_plane_callbacks", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_call_plane_callbacks", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_get_selected", "grim_get_selected", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_get_selected", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_select", "grim_select", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_select", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_identify", "grim_identify", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_identify", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_grnum_create", "grim_grnum_create", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_grnum_create", "", "top", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_grnum_destroy", "grim_grnum_destroy", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_grnum_destroy", "", "grnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_top_to_grnum", "grim_top_to_grnum", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_top_to_grnum", "", "newtop", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_jump_to_plane", "grim_jump_to_plane", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_jump_to_plane", "", "validnosyncgrim_datapn", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_sync_planes", "grim_sync_planes", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_sync_planes", "", "norefreshgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_data_include.html#grim_data_include", "grim_data_include", 'routine in <a href="grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_data_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_default_menus.html", "grim_default_menus.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_default_menus.pro", "", "", " NAME: 	grim_menu_core_event    PURPOSE: 	This option allows you extract a brightness profile at the selected 	location for each plane in the image.  The left button selects a single 	point, and the right button selects a region to average over.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2016    NAME: 	grim_menu_image_profile_event    PURPOSE: 	This option allows you extract a brightness profile in an arbitrary 	direction in the image.  The left button selects the region's length 	and then width; the right button selects a region with a width of 	one-pixel.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2005    NAME: 	grim_menu_ring_box_profile_radial_event    PURPOSE:   This option allows you create a radial brightness profile from a   rectangular image region.     1) Activate the ring from which you wish to extract the profile.     2) Select this option and use the mouse to outline a ring sector:    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2003    NAME: 	grim_menu_ring_box_profile_longitudinal_event    PURPOSE:   This option allows you create a longitudinal brightness profile from a   rectangular image region.      1) Activate the ring from which you wish to extract the profile.      2) Select this option and use the mouse to outline a ring sector.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2003    NAME: 	grim_menu_ring_profile_radial_event    PURPOSE:   This option allows you create a radial brightness profile.     1) Activate the ring from which you wish to extract the profile.     2) Select this option and use the mouse to outline a ring sector:        Left Button:   the sector is bounded by lines of constant                      longitude.', $       Middle Button: the sector is selected in an arbitrary direction.       Left Button:   the sector is bounded by lines perpendicular to                      the projected longitudinal direction.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2003    NAME: 	grim_menu_ring_profile_longitudinal_event    PURPOSE:   This option allows you create a longitudinal brightness profile.      1) Activate the ring from which you wish to extract the profile.      2) Select this option and use the mouse to outline a ring sector.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2003    NAME: 	grim_menu_limb_profile_azimuthal_event    PURPOSE:   This option allows you create an azimutal brightness profile about a limb.      1) Activate the planet from which you wish to extract the profile.      2) Select this option and use the mouse to outline a sector.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2006    NAME: 	grim_menu_limb_profile_radial_event    PURPOSE:   This option allows you create radial brightness profile across a limb.      1) Activate the planet from which you wish to extract the profile.      2) Select this option and use the mouse to outline a sector.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2006    NAME: 	grim_menu_pointing_manual_event    PURPOSE:    This option allows you to change the pointing manually using pg_drag.      1) Activate the points that you wish to drag.      2) Select this option and use the left button to translate your        points, the middle button to rotate them, and the right button        to accept the change and correct the pointing.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_pointing_farfit_event    PURPOSE:    This option produces a rough pointing correction by comparing the    active points with edges detected in the image using pg_edges and    pg_farfit.      1) Activate the edges that you wish to correlate.      2) Select this option.     Only active limbs, terminators, and ring edges are used.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_pointing_renderfit_event    PURPOSE:    This option uses pg_renderfit to produce a pointing correction by comparing    the image with a simulated image.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017    NAME: 	grim_menu_pointing_lsq_event    PURPOSE: 	Opens a gr_lsqtool widget.  Using the current data, camera, active 	planet, and active ring descriptors.  See gr_lsqtool.pro for details.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    NAME: 	grim_menu_toggle_reorigin_event    PURPOSE:    This option allows the user to set whether geometry descriptors are    updated whenever the data array is shifted.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2016    NAME: 	grim_menu_shift_enter_step_event    PURPOSE:    This option prompts the user to enter the step size for the image-shift    menu options.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2012    NAME: 	grim_menu_shift_enter_offset_event    PURPOSE:    This option prompts the user to shift an image by entering an offset.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2012    NAME: 	grim_menu_shift_left_event    PURPOSE:    This option shifts the image left and corrects the camera pointing    accordingly.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    NAME: 	grim_menu_shift_right_event    PURPOSE:    This option shifts the image right and corrects the camera pointing    accordingly.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    NAME: 	grim_menu_shift_up_event    PURPOSE:    This option shifts the image up and corrects the camera pointing    accordingly.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    NAME: 	grim_menu_shift_down_event    PURPOSE:    This option shifts the image down and corrects the camera pointing    accordingly.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    NAME: 	grim_menu_corrections_photometry_event    PURPOSE: 	Opens a gr_phttool widget.  Using the primary data, camera, planet, and 	ring descriptors.  See gr_phttool.pro for details.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_project_map_event    PURPOSE: 	Opens a gr_maptool widget.  Using the primary data, camera, planet, and 	ring descriptors.  See gr_maptool.pro for details.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_mosaic_event    PURPOSE: 	Uses pg_mosaic to combine all visible image planes into a mosaic. 	The new mosiac is opened in a new grim instance.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_core_help_event", "grim_menu_core_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_core_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_core_event", "grim_menu_core_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_core_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_image_profile_help_event", "grim_menu_image_profile_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_image_profile_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_image_profile_event", "grim_menu_image_profile_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_image_profile_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_ring_box_profile_radial_help_event", "grim_menu_ring_box_profile_radial_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_box_profile_radial_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_ring_box_profile_radial_event", "grim_menu_ring_box_profile_radial_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_box_profile_radial_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_ring_box_profile_longitudinal_help_event", "grim_menu_ring_box_profile_longitudinal_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_box_profile_longitudinal_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_ring_box_profile_longitudinal_event", "grim_menu_ring_box_profile_longitudinal_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_box_profile_longitudinal_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_ring_profile_radial_help_event", "grim_menu_ring_profile_radial_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_profile_radial_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_ring_profile_radial_event", "grim_menu_ring_profile_radial_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_profile_radial_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_ring_profile_longitudinal_help_event", "grim_menu_ring_profile_longitudinal_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_profile_longitudinal_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_ring_profile_longitudinal_event", "grim_menu_ring_profile_longitudinal_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_profile_longitudinal_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_limb_profile_azimuthal_help_event", "grim_menu_limb_profile_azimuthal_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_limb_profile_azimuthal_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_limb_profile_azimuthal_event", "grim_menu_limb_profile_azimuthal_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_limb_profile_azimuthal_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_limb_profile_radial_help_event", "grim_menu_limb_profile_radial_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_limb_profile_radial_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_limb_profile_radial_event", "grim_menu_limb_profile_radial_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_limb_profile_radial_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_pointing_manual_help_event", "grim_menu_pointing_manual_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_manual_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_pointing_manual_event", "grim_menu_pointing_manual_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_manual_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_pointing_farfit_help_event", "grim_menu_pointing_farfit_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_farfit_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_pointing_farfit_event", "grim_menu_pointing_farfit_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_farfit_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_pointing_renderfit_help_event", "grim_menu_pointing_renderfit_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_renderfit_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_pointing_renderfit_event", "grim_menu_pointing_renderfit_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_renderfit_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_pointing_lsq_help_event", "grim_menu_pointing_lsq_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_lsq_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_pointing_lsq_event", "grim_menu_pointing_lsq_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_lsq_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_get_shift_step", "grim_get_shift_step", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_get_shift_step", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_reposition", "grim_reposition", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_reposition", "", "cdgrim_dataplaneshift", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_toggle_reorigin_event_help_event", "grim_menu_toggle_reorigin_event_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_toggle_reorigin_event_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_toggle_reorigin_event", "grim_menu_toggle_reorigin_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_toggle_reorigin_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_enter_step_event_help_event", "grim_menu_shift_enter_step_event_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_enter_step_event_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_enter_step_event", "grim_menu_shift_enter_step_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_enter_step_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_enter_offset_event_help_event", "grim_menu_shift_enter_offset_event_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_enter_offset_event_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_enter_offset_event", "grim_menu_shift_enter_offset_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_enter_offset_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_left_help_event", "grim_menu_shift_left_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_left_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_left_event", "grim_menu_shift_left_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_left_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_right_help_event", "grim_menu_shift_right_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_right_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_right_event", "grim_menu_shift_right_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_right_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_up_help_event", "grim_menu_shift_up_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_up_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_up_event", "grim_menu_shift_up_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_up_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_down_help_event", "grim_menu_shift_down_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_down_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_down_event", "grim_menu_shift_down_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_down_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_corrections_photometry_help_event", "grim_menu_corrections_photometry_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_corrections_photometry_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_corrections_photometry_event", "grim_menu_corrections_photometry_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_corrections_photometry_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_project_map_help_event", "grim_menu_project_map_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_project_map_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_project_map_event", "grim_menu_project_map_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_project_map_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_mosaic_help_event", "grim_menu_mosaic_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_mosaic_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_mosaic_event", "grim_menu_mosaic_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_mosaic_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_read_mind_event", "grim_menu_read_mind_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_read_mind_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_default_menus_init", "grim_default_menus_init", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_default_menus_init", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_default_menus", "grim_default_menus", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_default_menus", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html", "grim_descriptors_include.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_descriptors_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_compute_fov", "grim_compute_fov", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_compute_fov", "", "covgrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_descriptor_notify_handle", "grim_descriptor_notify_handle", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_descriptor_notify_handle", "", "refreshnewgrim_dataxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_suspend_events", "grim_suspend_events", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_suspend_events", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_resume_events", "grim_resume_events", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_resume_events", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_descriptor_notify", "grim_descriptor_notify", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_descriptor_notify", "", "refreshnewevents", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_rm_descriptor", "grim_rm_descriptor", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_rm_descriptor", "", "planegrim_dataxdpxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_mark_descriptor", "grim_mark_descriptor", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_mark_descriptor", "", "xdval", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_demark_descriptor", "grim_demark_descriptor", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_demark_descriptor", "", "xd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_mark_descriptors", "grim_mark_descriptors", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_mark_descriptors", "", "allcdpdrdsdstdardsundplanesgrim_dataval", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_add_descriptor", "grim_add_descriptor", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_add_descriptor", "", "onenoregisterassoc_ddgrim_dataxdp_xd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_get_cameras", "grim_get_cameras", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_cameras", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_get_planets", "grim_get_planets", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_planets", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_get_sun", "grim_get_sun", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_sun", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_get_stars", "grim_get_stars", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_stars", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_get_rings", "grim_get_rings", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_rings", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_get_stations", "grim_get_stations", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_stations", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_get_arrays", "grim_get_arrays", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_arrays", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_clear_descriptors", "grim_clear_descriptors", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_clear_descriptors", "", "planesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_load_descriptors", "grim_load_descriptors", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_load_descriptors", "", "planeclasscdpdrdsundsdardstdodobj_namegdgrim_dataname", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_descriptors_include.html#grim_descriptors_include", "grim_descriptors_include", 'routine in <a href="grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_descriptors_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_footprint_cursor.html", "grim_footprint_cursor.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_footprint_cursor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_footprint_cursor.html#grim_footprint_cursor", "grim_footprint_cursor", 'routine in <a href="grim/grim_footprint_cursor.html">grim_footprint_cursor.pro</a>', "grim_footprint_cursor.pro", "", "grim_footprint_cursor", "", "swap", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_image_include.html", "grim_image_include.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_image_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_get_n_colors", "grim_get_n_colors", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_get_n_colors", "", "planetypegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_visible_planes", "grim_visible_planes", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_visible_planes", "", "planecurrentgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_get_plane_by_xy", "grim_get_plane_by_xy", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_get_plane_by_xy", "", "grim_dataxy", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_get_plane_by_overlay", "grim_get_plane_by_overlay", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_get_plane_by_overlay", "", "grim_dataxy", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_test_single_channel", "grim_test_single_channel", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_test_single_channel", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_toggle_image", "grim_toggle_image", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_toggle_image", "", "no_refreshbmgrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_toggle_image_overlays", "grim_toggle_image_overlays", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_toggle_image_overlays", "", "no_refreshgrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_render_image", "grim_render_image", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_render_image", "", "planeimage_ptsgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_image", "grim_image", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_image", "", "planepncolormapchannelcurrentxrangeyrangegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_scale_image", "grim_scale_image", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_scale_image", "", "currentplaneno_scaletopxrangeyrangegrim_datargb", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_display_image", "grim_display_image", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_display_image", "", "planeentirewnumdoffsetzoomrotateorderdefaultpreviousfliprestorexsizeysizeoffsettopnoplotno_scaleno_wsetno_coordtvimagehomedraw_pixmapcurrentno_copygrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_display_plot", "grim_display_plot", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_display_plot", "", "planedoffsetwnumxrangeyrangeno_wsetdefaultpreviousfliprestorexsizeysizepositiondxdyentireeraseno_coordcolornodrawcurrentgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_display", "grim_display", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_display", "", "planewnumhomeno_imageno_axesdoffsetno_erasezoomrotateorderxsizeysizeoffsetdefaultpreviousfliprestoreuse_pixmappixmap_box_centerno_copypixmap_box_sideno_backentireno_wsetno_coordtvimageno_plotnodrawxrangeyrangedxdycurrentpixmap_to_usegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_show_context_image", "grim_show_context_image", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_show_context_image", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_show_axes", "grim_show_axes", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_show_axes", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_add_refresh_callback", "grim_add_refresh_callback", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_add_refresh_callback", "", "topno_wsetcallbacksdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_rm_refresh_callback", "grim_rm_refresh_callback", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_rm_refresh_callback", "", "topdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_call_refresh_callbacks", "grim_call_refresh_callbacks", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_call_refresh_callbacks", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_title", "grim_title", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_title", "", "primaryplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_channel_string", "grim_channel_string", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_channel_string", "", "plane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_refresh", "grim_refresh", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_refresh", "", "wnumplaneno_imageno_objectsno_axesno_titlehomexrangeyrangedoffsetno_erasezoomrotateorderdefaultpreviousfliprestorexsizeysizeoffsetuse_pixmappixmap_box_centerpixmap_box_sidecontextentirenoglassno_wsetno_contextno_callbackno_backno_coordtvimageno_plotjust_imagedxdyupdatecurrentno_copyno_mainno_usergrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_image_include.html#grim_image_include", "grim_image_include", 'routine in <a href="grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_image_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_message.html", "grim_message.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_message.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_message.html#grim_message", "grim_message", 'routine in <a href="grim/grim_message.html">grim_message.pro</a>', "grim_message.pro", "", "grim_message", "", "clearsuspendrestorequestionresultmessage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_activate.html", "grim_mode_activate.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_activate.pro", "", "", " NAME: 	grim_mode_activate_button_event    PURPOSE: 	Selects the activate cursor mode.    CATEGORY: 	NV/GR    OPERATION:  	Overlay objects may be activated or deactivated by clicking 	and/or dragging using the left or right mouse buttons 	respectively.  This activation mechanism allows the user to 	select which among a certain type of objects should be used 	in a given menu selection.  A left click on an overlay 	activates that overlay and a right click deactivates it.  A 	double click activates or deactivates all overlays associated 	with a given descriptor, or all stars.  Active overlays appear 	in the colors selected in the 'Overlay Settings' menu selection. 	Inactive overlays appear in cyan.  A descriptor is active 	whenever any of its overlays are active.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_activate.html#grim_mode_activate_bitmap", "grim_mode_activate_bitmap", 'routine in <a href="grim/grim_mode_activate.html">grim_mode_activate.pro</a>', "grim_mode_activate.pro", "", "grim_mode_activate_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_activate.html#grim_mode_activate_mouse_event", "grim_mode_activate_mouse_event", 'routine in <a href="grim/grim_mode_activate.html">grim_mode_activate.pro</a>', "grim_mode_activate.pro", "", "grim_mode_activate_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_activate.html#grim_mode_activate_mode", "grim_mode_activate_mode", 'routine in <a href="grim/grim_mode_activate.html">grim_mode_activate.pro</a>', "grim_mode_activate.pro", "", "grim_mode_activate_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_activate.html#grim_mode_activate_button_event", "grim_mode_activate_button_event", 'routine in <a href="grim/grim_mode_activate.html">grim_mode_activate.pro</a>', "grim_mode_activate.pro", "", "grim_mode_activate_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_activate.html#grim_mode_activate_init", "grim_mode_activate_init", 'routine in <a href="grim/grim_mode_activate.html">grim_mode_activate.pro</a>', "grim_mode_activate.pro", "", "grim_mode_activate_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_activate.html#grim_mode_activate", "grim_mode_activate", 'routine in <a href="grim/grim_mode_activate.html">grim_mode_activate.pro</a>', "grim_mode_activate.pro", "", "grim_mode_activate", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_curves.html", "grim_mode_curves.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_curves.pro", "", "", " NAME: 	grim_mode_curves_button_event    PURPOSE: 	Selects the curves cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	curves are added using the left mouse button and deleted 	using the right button.    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_curves.html#grim_mode_curves_bitmap", "grim_mode_curves_bitmap", 'routine in <a href="grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_curves.html#grim_mode_curves_mouse_event", "grim_mode_curves_mouse_event", 'routine in <a href="grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_curves.html#grim_mode_curves_cursor", "grim_mode_curves_cursor", 'routine in <a href="grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_curves.html#grim_mode_curves_mode", "grim_mode_curves_mode", 'routine in <a href="grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_curves.html#grim_mode_curves_button_event", "grim_mode_curves_button_event", 'routine in <a href="grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_curves.html#grim_mode_curves_init", "grim_mode_curves_init", 'routine in <a href="grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_curves.html#grim_mode_curves", "grim_mode_curves", 'routine in <a href="grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_drag.html", "grim_mode_drag.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_drag.pro", "", "", " NAME: 	grim_mode_drag_button_event    PURPOSE: 	Selects the drag cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Allow the user to drag the image.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2009   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_drag.html#grim_mode_drag_bitmap", "grim_mode_drag_bitmap", 'routine in <a href="grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_drag.html#grim_mode_drag_translate", "grim_mode_drag_translate", 'routine in <a href="grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag_translate", "", "dataxarryarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_drag.html#grim_mode_drag_mouse_event", "grim_mode_drag_mouse_event", 'routine in <a href="grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_drag.html#grim_mode_drag_mode", "grim_mode_drag_mode", 'routine in <a href="grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_drag.html#grim_mode_drag_button_event", "grim_mode_drag_button_event", 'routine in <a href="grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_drag.html#grim_mode_drag_init", "grim_mode_drag_init", 'routine in <a href="grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_drag.html#grim_mode_drag", "grim_mode_drag", 'routine in <a href="grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html", "grim_mode_magnify.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_magnify.pro", "", "", " NAME: 	grim_mode_magnify_button_event    PURPOSE: 	Selects the magnify cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Image pixels in the graphics window may be magnifed using 	either the left or right mouse buttons.  The left button 	magnifies the displayed pixels, directly from the graphics 	window.  The right button magnifies the data itself, without 	the overlays.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html#grim_mode_magnify_bitmap", "grim_mode_magnify_bitmap", 'routine in <a href="grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html#grim_mode_magnify_cursor", "grim_mode_magnify_cursor", 'routine in <a href="grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html#grim_mag_erase", "grim_mag_erase", 'routine in <a href="grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mag_erase", "", "grim_datawnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html#grim_mag_frame", "grim_mag_frame", 'routine in <a href="grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mag_frame", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html#grim_magnify", "grim_magnify", 'routine in <a href="grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_magnify", "", "datagrim_dataplanep_device", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html#grim_mode_magnify_mouse_event", "grim_mode_magnify_mouse_event", 'routine in <a href="grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html#grim_mode_magnify_mode", "grim_mode_magnify_mode", 'routine in <a href="grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html#grim_mode_magnify_button_event", "grim_mode_magnify_button_event", 'routine in <a href="grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html#grim_mode_magnify_init", "grim_mode_magnify_init", 'routine in <a href="grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html#grim_mode_magnify", "grim_mode_magnify", 'routine in <a href="grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_mask.html", "grim_mode_mask.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_mask.pro", "", "", " NAME: 	grim_mode_mask_button_event    PURPOSE: 	Selects the mask cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Allowqs the user to select pixel to include in the mask.    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_mask.html#grim_mode_mask_bitmap", "grim_mode_mask_bitmap", 'routine in <a href="grim/grim_mode_mask.html">grim_mode_mask.pro</a>', "grim_mode_mask.pro", "", "grim_mode_mask_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_mask.html#grim_mode_mask_mouse_event", "grim_mode_mask_mouse_event", 'routine in <a href="grim/grim_mode_mask.html">grim_mode_mask.pro</a>', "grim_mode_mask.pro", "", "grim_mode_mask_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_mask.html#grim_mode_mask_mode", "grim_mode_mask_mode", 'routine in <a href="grim/grim_mode_mask.html">grim_mode_mask.pro</a>', "grim_mode_mask.pro", "", "grim_mode_mask_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_mask.html#grim_mode_mask_button_event", "grim_mode_mask_button_event", 'routine in <a href="grim/grim_mode_mask.html">grim_mode_mask.pro</a>', "grim_mode_mask.pro", "", "grim_mode_mask_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_mask.html#grim_mode_mask_init", "grim_mode_mask_init", 'routine in <a href="grim/grim_mode_mask.html">grim_mode_mask.pro</a>', "grim_mode_mask.pro", "", "grim_mode_mask_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_mask.html#grim_mode_mask", "grim_mode_mask", 'routine in <a href="grim/grim_mode_mask.html">grim_mode_mask.pro</a>', "grim_mode_mask.pro", "", "grim_mode_mask", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html", "grim_mode_navigate.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_navigate.pro", "", "", " NAME: 	grim_mode_navigate_button_event    PURPOSE: 	Selects the navigate cursor mode.  	 Camera orientation: 	   Left button:		Allows the optic axis to be repointed.  	   Right button:	Allows the camera to twist about an axis 				corresponding to the selected pixel location.  	 Camera position: 	   <Shift> Left:	Allows the camera to be repositioned in the 				X-Z plane (image plane).  Speeds depend on 				the object under the cursor.  	   <Shift> Right:	Allows the camera to be repositioned and 				reoriented simultaneosly by tracking the 				object under the cursor.  	   <Shift> Wheel:	Allows the camera to be repositioned in the 				Y (optic axis) direction.  Speeds depend on 				the object under the cursor.    CATEGORY: 	NV/GR    OPERATION: 	Allow the user to fly around the system.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2009   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_bitmap", "grim_mode_navigate_bitmap", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_get_points", "grim_mode_navigate_get_points", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_get_points", "", "planegrim_datapoints_ptdcurves_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_reposition", "grim_mode_navigate_reposition", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reposition", "", "axescdcd0curves_ptdpoints_ptdtrackingxarryarr", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_reposition_xy", "grim_mode_navigate_reposition_xy", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reposition_xy", "", "dataxarryarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_reposition_xz", "grim_mode_navigate_reposition_xz", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reposition_xz", "", "dataxarryarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_reposition_track", "grim_mode_navigate_reposition_track", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reposition_track", "", "dataxarryarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_draw", "grim_mode_navigate_draw", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_draw", "", "wnumpixmaperase_pixmapcdcurves_ptdpoints_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_reposition_y_event", "grim_mode_navigate_reposition_y_event", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reposition_y_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_reposition_y", "grim_mode_navigate_reposition_y", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reposition_y", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_reorient_nod", "grim_mode_navigate_reorient_nod", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reorient_nod", "", "dataxarryarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_reorient_twist", "grim_mode_navigate_reorient_twist", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reorient_twist", "", "dataxarryarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_mouse_event", "grim_mode_navigate_mouse_event", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_mode", "grim_mode_navigate_mode", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_button_event", "grim_mode_navigate_button_event", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_init", "grim_mode_navigate_init", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate", "grim_mode_navigate", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_pan.html", "grim_mode_pan.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_pan.pro", "", "", " NAME: 	grim_mode_pan_button_event    PURPOSE: 	Selects the pan cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	The image offset is controlled by selecting an offset vector 	using the left mouse button, or the middle button may be 	used to center the image on a selected point.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan.html#grim_mode_pan_bitmap", "grim_mode_pan_bitmap", 'routine in <a href="grim/grim_mode_pan.html">grim_mode_pan.pro</a>', "grim_mode_pan.pro", "", "grim_mode_pan_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan.html#grim_mode_pan_mouse_event", "grim_mode_pan_mouse_event", 'routine in <a href="grim/grim_mode_pan.html">grim_mode_pan.pro</a>', "grim_mode_pan.pro", "", "grim_mode_pan_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan.html#grim_mode_pan_mode", "grim_mode_pan_mode", 'routine in <a href="grim/grim_mode_pan.html">grim_mode_pan.pro</a>', "grim_mode_pan.pro", "", "grim_mode_pan_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan.html#grim_mode_pan_button_event", "grim_mode_pan_button_event", 'routine in <a href="grim/grim_mode_pan.html">grim_mode_pan.pro</a>', "grim_mode_pan.pro", "", "grim_mode_pan_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan.html#grim_mode_pan_init", "grim_mode_pan_init", 'routine in <a href="grim/grim_mode_pan.html">grim_mode_pan.pro</a>', "grim_mode_pan.pro", "", "grim_mode_pan_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan.html#grim_mode_pan", "grim_mode_pan", 'routine in <a href="grim/grim_mode_pan.html">grim_mode_pan.pro</a>', "grim_mode_pan.pro", "", "grim_mode_pan", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_pan_plot.html", "grim_mode_pan_plot.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_pan_plot.pro", "", "", " NAME: 	grim_mode_pan_plot_button_event    PURPOSE: 	Selects the pan cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	The image offset is controlled by selecting an offset vector 	using the left mouse button, or the middle button may be 	used to center the image on a selected point.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan_plot.html#grim_mode_pan_plot_bitmap", "grim_mode_pan_plot_bitmap", 'routine in <a href="grim/grim_mode_pan_plot.html">grim_mode_pan_plot.pro</a>', "grim_mode_pan_plot.pro", "", "grim_mode_pan_plot_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan_plot.html#grim_mode_pan_plot_mouse_event", "grim_mode_pan_plot_mouse_event", 'routine in <a href="grim/grim_mode_pan_plot.html">grim_mode_pan_plot.pro</a>', "grim_mode_pan_plot.pro", "", "grim_mode_pan_plot_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan_plot.html#grim_mode_pan_plot_mode", "grim_mode_pan_plot_mode", 'routine in <a href="grim/grim_mode_pan_plot.html">grim_mode_pan_plot.pro</a>', "grim_mode_pan_plot.pro", "", "grim_mode_pan_plot_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan_plot.html#grim_mode_pan_plot_button_event", "grim_mode_pan_plot_button_event", 'routine in <a href="grim/grim_mode_pan_plot.html">grim_mode_pan_plot.pro</a>', "grim_mode_pan_plot.pro", "", "grim_mode_pan_plot_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan_plot.html#grim_mode_pan_plot_init", "grim_mode_pan_plot_init", 'routine in <a href="grim/grim_mode_pan_plot.html">grim_mode_pan_plot.pro</a>', "grim_mode_pan_plot.pro", "", "grim_mode_pan_plot_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan_plot.html#grim_mode_pan_plot", "grim_mode_pan_plot", 'routine in <a href="grim/grim_mode_pan_plot.html">grim_mode_pan_plot.pro</a>', "grim_mode_pan_plot.pro", "", "grim_mode_pan_plot", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_plane.html", "grim_mode_plane.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_plane.pro", "", "", " NAME: 	grim_mode_plane_button_event    PURPOSE: 	Selects the plane cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Planes can be selected by clicking in the image window.  This option 	is not useful unless planes other than the current plane are visible. 	If more than one plane under the cursor contains data, the one with 	the lowest plane number is selected, unless one of them is the current 	plane.    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2008   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_plane.html#grim_mode_plane_bitmap", "grim_mode_plane_bitmap", 'routine in <a href="grim/grim_mode_plane.html">grim_mode_plane.pro</a>', "grim_mode_plane.pro", "", "grim_mode_plane_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_plane.html#grim_mode_plane_mouse_event", "grim_mode_plane_mouse_event", 'routine in <a href="grim/grim_mode_plane.html">grim_mode_plane.pro</a>', "grim_mode_plane.pro", "", "grim_mode_plane_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_plane.html#grim_mode_plane_mode", "grim_mode_plane_mode", 'routine in <a href="grim/grim_mode_plane.html">grim_mode_plane.pro</a>', "grim_mode_plane.pro", "", "grim_mode_plane_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_plane.html#grim_mode_plane_button_event", "grim_mode_plane_button_event", 'routine in <a href="grim/grim_mode_plane.html">grim_mode_plane.pro</a>', "grim_mode_plane.pro", "", "grim_mode_plane_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_plane.html#grim_mode_plane_init", "grim_mode_plane_init", 'routine in <a href="grim/grim_mode_plane.html">grim_mode_plane.pro</a>', "grim_mode_plane.pro", "", "grim_mode_plane_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_plane.html#grim_mode_plane", "grim_mode_plane", 'routine in <a href="grim/grim_mode_plane.html">grim_mode_plane.pro</a>', "grim_mode_plane.pro", "", "grim_mode_plane", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_readout.html", "grim_mode_readout.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_readout.pro", "", "", " NAME: 	grim_mode_readout_button_event    PURPOSE: 	Selects the readout cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	A text window appears and displays data about the pixel selected 	using the left mouse button.  The amount and type of information 	displayed depends on which descriptors are loaded.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_readout.html#grim_mode_readout_bitmap", "grim_mode_readout_bitmap", 'routine in <a href="grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_readout.html#grim_mode_readout_cursor", "grim_mode_readout_cursor", 'routine in <a href="grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_readout.html#grim_pixel_readout_event", "grim_pixel_readout_event", 'routine in <a href="grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_pixel_readout_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_readout.html#grpr_hide_button_event", "grpr_hide_button_event", 'routine in <a href="grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grpr_hide_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_readout.html#grim_pixel_readout", "grim_pixel_readout", 'routine in <a href="grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_pixel_readout", "", "textgrnumbase", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_readout.html#grim_mode_readout_mouse_event", "grim_mode_readout_mouse_event", 'routine in <a href="grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_readout.html#grim_mode_readout_mode", "grim_mode_readout_mode", 'routine in <a href="grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_readout.html#grim_mode_readout_button_event", "grim_mode_readout_button_event", 'routine in <a href="grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_readout.html#grim_mode_readout_init", "grim_mode_readout_init", 'routine in <a href="grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_readout.html#grim_mode_readout", "grim_mode_readout", 'routine in <a href="grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_region.html", "grim_mode_region.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_region.pro", "", "", " NAME: 	grim_mode_region_button_event    PURPOSE: 	Selects the 'region' cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	An image region is defined by clicking and dragging a box or curve.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_region.html#grim_mode_region_bitmap", "grim_mode_region_bitmap", 'routine in <a href="grim/grim_mode_region.html">grim_mode_region.pro</a>', "grim_mode_region.pro", "", "grim_mode_region_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_region.html#grim_mode_region_mouse_event", "grim_mode_region_mouse_event", 'routine in <a href="grim/grim_mode_region.html">grim_mode_region.pro</a>', "grim_mode_region.pro", "", "grim_mode_region_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_region.html#grim_mode_region_mode", "grim_mode_region_mode", 'routine in <a href="grim/grim_mode_region.html">grim_mode_region.pro</a>', "grim_mode_region.pro", "", "grim_mode_region_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_region.html#grim_mode_region_button_event", "grim_mode_region_button_event", 'routine in <a href="grim/grim_mode_region.html">grim_mode_region.pro</a>', "grim_mode_region.pro", "", "grim_mode_region_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_region.html#grim_mode_region_init", "grim_mode_region_init", 'routine in <a href="grim/grim_mode_region.html">grim_mode_region.pro</a>', "grim_mode_region.pro", "", "grim_mode_region_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_region.html#grim_mode_region", "grim_mode_region", 'routine in <a href="grim/grim_mode_region.html">grim_mode_region.pro</a>', "grim_mode_region.pro", "", "grim_mode_region", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_remove.html", "grim_mode_remove.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_remove.pro", "", "", " NAME: 	grim_mode_remove_button_event    PURPOSE: 	Selects the remove cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	A single click on an overlay causes it to be deleted.  A        double click causes the entire object to be deleted.  The left 	button applies to standard overlays; the right button applies 	to user overlays.    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_remove.html#grim_mode_remove_bitmap", "grim_mode_remove_bitmap", 'routine in <a href="grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_remove.html#grim_mode_remove_flash", "grim_mode_remove_flash", 'routine in <a href="grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_flash", "", "p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_remove.html#grim_mode_remove_mouse_event", "grim_mode_remove_mouse_event", 'routine in <a href="grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_remove.html#grim_mode_remove_cursor", "grim_mode_remove_cursor", 'routine in <a href="grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_remove.html#grim_mode_remove_mode", "grim_mode_remove_mode", 'routine in <a href="grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_remove.html#grim_mode_remove_button_event", "grim_mode_remove_button_event", 'routine in <a href="grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_remove.html#grim_mode_remove_init", "grim_mode_remove_init", 'routine in <a href="grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_remove.html#grim_mode_remove", "grim_mode_remove", 'routine in <a href="grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_select.html", "grim_mode_select.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_select.pro", "", "", " NAME: 	grim_mode_select_button_event    PURPOSE: 	Selects the 'select' cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Overlay points are selected by clicking and dragging and curve around 	the desired points.  The left button selects overlay points, the right 	deselects overlay points.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_select.html#grim_mode_select_bitmap", "grim_mode_select_bitmap", 'routine in <a href="grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_select.html#grim_mode_select_mouse_event", "grim_mode_select_mouse_event", 'routine in <a href="grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_select.html#grim_mode_select_cursor", "grim_mode_select_cursor", 'routine in <a href="grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_select.html#grim_mode_select_mode", "grim_mode_select_mode", 'routine in <a href="grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_select.html#grim_mode_select_button_event", "grim_mode_select_button_event", 'routine in <a href="grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_select.html#grim_mode_select_init", "grim_mode_select_init", 'routine in <a href="grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_select.html#grim_mode_select", "grim_mode_select", 'routine in <a href="grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_smooth.html", "grim_mode_smooth.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_smooth.pro", "", "", " NAME: 	grim_mode_smooth_button_event    PURPOSE: 	Selects the smooth cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	The user selects a box, which is used to determine the kernel 	size for smothing the data set.    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_smooth.html#grim_mode_smooth_bitmap", "grim_mode_smooth_bitmap", 'routine in <a href="grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_mode_smooth_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_smooth.html#grim_smooth", "grim_smooth", 'routine in <a href="grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_smooth", "", "planegrim_databox", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_smooth.html#grim_mode_smooth_mouse_event", "grim_mode_smooth_mouse_event", 'routine in <a href="grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_mode_smooth_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_smooth.html#grim_mode_smooth_mode", "grim_mode_smooth_mode", 'routine in <a href="grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_mode_smooth_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_smooth.html#grim_mode_smooth_button_event", "grim_mode_smooth_button_event", 'routine in <a href="grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_mode_smooth_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_smooth.html#grim_mode_smooth_init", "grim_mode_smooth_init", 'routine in <a href="grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_mode_smooth_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_smooth.html#grim_mode_smooth", "grim_mode_smooth", 'routine in <a href="grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_mode_smooth", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_tiepoints.html", "grim_mode_tiepoints.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_tiepoints.pro", "", "", " NAME: 	grim_mode_tiepoints_button_event    PURPOSE: 	Selects the tiepoints cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Tiepoints are added using the left mouse button and deleted 	using the right button.  Tiepoints appear as crosses labeled 	by numbers.  The use of tiepoints is determined by the 	particular option selected by the user.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_tiepoints.html#grim_mode_tiepoints_bitmap", "grim_mode_tiepoints_bitmap", 'routine in <a href="grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_tiepoints.html#grim_mode_tiepoints_mouse_event", "grim_mode_tiepoints_mouse_event", 'routine in <a href="grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_tiepoints.html#grim_mode_tiepoints_cursor", "grim_mode_tiepoints_cursor", 'routine in <a href="grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_tiepoints.html#grim_mode_tiepoints_mode", "grim_mode_tiepoints_mode", 'routine in <a href="grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_tiepoints.html#grim_mode_tiepoints_button_event", "grim_mode_tiepoints_button_event", 'routine in <a href="grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_tiepoints.html#grim_mode_tiepoints_init", "grim_mode_tiepoints_init", 'routine in <a href="grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_tiepoints.html#grim_mode_tiepoints", "grim_mode_tiepoints", 'routine in <a href="grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_trim.html", "grim_mode_trim.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_trim.pro", "", "", " NAME: 	grim_mode_trim_button_event    PURPOSE: 	Selects the trim cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Overlay points are trimmed by clicking and dragging and curve around 	the desired points.  The left button trims standard overlays, the right 	trims user overlay points.    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_trim.html#grim_mode_trim_bitmap", "grim_mode_trim_bitmap", 'routine in <a href="grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_trim.html#grim_mode_trim_mouse_event", "grim_mode_trim_mouse_event", 'routine in <a href="grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_trim.html#grim_mode_trim_cursor", "grim_mode_trim_cursor", 'routine in <a href="grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_trim.html#grim_mode_trim_mode", "grim_mode_trim_mode", 'routine in <a href="grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_trim.html#grim_mode_trim_button_event", "grim_mode_trim_button_event", 'routine in <a href="grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_trim.html#grim_mode_trim_init", "grim_mode_trim_init", 'routine in <a href="grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_trim.html#grim_mode_trim", "grim_mode_trim", 'routine in <a href="grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_xyzoom.html", "grim_mode_xyzoom.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_xyzoom.pro", "", "", " NAME: 	grim_mode_xyzoom_button_event    PURPOSE: 	Selects the xy-zoom cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Same as 'zoom' mode, except the aspect ratio is set by the 	proportions of the selected box.    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_xyzoom.html#grim_mode_xyzoom_bitmap", "grim_mode_xyzoom_bitmap", 'routine in <a href="grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_xyzoom.html#grim_mode_xyzoom_mouse_event", "grim_mode_xyzoom_mouse_event", 'routine in <a href="grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_xyzoom.html#grim_mode_xyzoom_cursor", "grim_mode_xyzoom_cursor", 'routine in <a href="grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_xyzoom.html#grim_mode_xyzoom_mode", "grim_mode_xyzoom_mode", 'routine in <a href="grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_xyzoom.html#grim_mode_xyzoom_button_event", "grim_mode_xyzoom_button_event", 'routine in <a href="grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_xyzoom.html#grim_mode_xyzoom_init", "grim_mode_xyzoom_init", 'routine in <a href="grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_xyzoom.html#grim_mode_xyzoom", "grim_mode_xyzoom", 'routine in <a href="grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_zoom.html", "grim_mode_zoom.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_zoom.pro", "", "", " NAME: 	grim_mode_zoom_button_event    PURPOSE: 	Selects the zoom cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	The image zoom and offset are controlled by selecting 	a box in the image.  When the box is created using the 	left mouse button, zoom and offset are changed so that 	the contents of the box best fill the current graphics 	window.  When the right button is used, the contents of 	the current graphics window are shrunken so as to best 	fill the box.  In other words, the left button zooms in 	and the right button zooms out.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom.html#grim_mode_zoom_bitmap", "grim_mode_zoom_bitmap", 'routine in <a href="grim/grim_mode_zoom.html">grim_mode_zoom.pro</a>', "grim_mode_zoom.pro", "", "grim_mode_zoom_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom.html#grim_mode_zoom_mouse_event", "grim_mode_zoom_mouse_event", 'routine in <a href="grim/grim_mode_zoom.html">grim_mode_zoom.pro</a>', "grim_mode_zoom.pro", "", "grim_mode_zoom_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom.html#grim_mode_zoom_mode", "grim_mode_zoom_mode", 'routine in <a href="grim/grim_mode_zoom.html">grim_mode_zoom.pro</a>', "grim_mode_zoom.pro", "", "grim_mode_zoom_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom.html#grim_mode_zoom_button_event", "grim_mode_zoom_button_event", 'routine in <a href="grim/grim_mode_zoom.html">grim_mode_zoom.pro</a>', "grim_mode_zoom.pro", "", "grim_mode_zoom_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom.html#grim_mode_zoom_init", "grim_mode_zoom_init", 'routine in <a href="grim/grim_mode_zoom.html">grim_mode_zoom.pro</a>', "grim_mode_zoom.pro", "", "grim_mode_zoom_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom.html#grim_mode_zoom", "grim_mode_zoom", 'routine in <a href="grim/grim_mode_zoom.html">grim_mode_zoom.pro</a>', "grim_mode_zoom.pro", "", "grim_mode_zoom", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_zoom_plot.html", "grim_mode_zoom_plot.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_zoom_plot.pro", "", "", " NAME: 	grim_mode_zoom_plot_button_event    PURPOSE: 	Selects the zoom cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	The image zoom and offset are controlled by selecting 	a box in the image.  When the box is created using the 	left mouse button, zoom and offset are changed so that 	the contents of the box best fill the current graphics 	window.  When the right button is used, the contents of 	the current graphics window are shrunken so as to best 	fill the box.  In other words, the left button zooms in 	and the right button zooms out.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom_plot.html#grim_mode_zoom_plot_bitmap", "grim_mode_zoom_plot_bitmap", 'routine in <a href="grim/grim_mode_zoom_plot.html">grim_mode_zoom_plot.pro</a>', "grim_mode_zoom_plot.pro", "", "grim_mode_zoom_plot_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom_plot.html#grim_mode_zoom_plot_mouse_event", "grim_mode_zoom_plot_mouse_event", 'routine in <a href="grim/grim_mode_zoom_plot.html">grim_mode_zoom_plot.pro</a>', "grim_mode_zoom_plot.pro", "", "grim_mode_zoom_plot_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom_plot.html#grim_mode_zoom_plot_mode", "grim_mode_zoom_plot_mode", 'routine in <a href="grim/grim_mode_zoom_plot.html">grim_mode_zoom_plot.pro</a>', "grim_mode_zoom_plot.pro", "", "grim_mode_zoom_plot_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom_plot.html#grim_mode_zoom_plot_button_event", "grim_mode_zoom_plot_button_event", 'routine in <a href="grim/grim_mode_zoom_plot.html">grim_mode_zoom_plot.pro</a>', "grim_mode_zoom_plot.pro", "", "grim_mode_zoom_plot_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom_plot.html#grim_mode_zoom_plot_init", "grim_mode_zoom_plot_init", 'routine in <a href="grim/grim_mode_zoom_plot.html">grim_mode_zoom_plot.pro</a>', "grim_mode_zoom_plot.pro", "", "grim_mode_zoom_plot_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom_plot.html#grim_mode_zoom_plot", "grim_mode_zoom_plot", 'routine in <a href="grim/grim_mode_zoom_plot.html">grim_mode_zoom_plot.pro</a>', "grim_mode_zoom_plot.pro", "", "grim_mode_zoom_plot", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_no_cursor.html", "grim_no_cursor.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_no_cursor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_no_cursor.html#grim_no_cursor", "grim_no_cursor", 'routine in <a href="grim/grim_no_cursor.html">grim_no_cursor.pro</a>', "grim_no_cursor.pro", "", "grim_no_cursor", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_overlay_settings.html", "grim_overlay_settings.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_overlay_settings.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_overlay_settings.html#gros_user_tag", "gros_user_tag", 'routine in <a href="grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "gros_user_tag", "", "iname", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlay_settings.html#gros_overlay_tag", "gros_overlay_tag", 'routine in <a href="grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "gros_overlay_tag", "", "iname", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlay_settings.html#gros_update_form", "gros_update_form", 'routine in <a href="grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "gros_update_form", "", "grim_dataplanebase", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlay_settings.html#gros_cleanup", "gros_cleanup", 'routine in <a href="grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "gros_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlay_settings.html#gros_apply_settings", "gros_apply_settings", 'routine in <a href="grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "gros_apply_settings", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlay_settings.html#gros_ok", "gros_ok", 'routine in <a href="grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "gros_ok", "", "database", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlay_settings.html#grim_overlay_settings_event", "grim_overlay_settings_event", 'routine in <a href="grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "grim_overlay_settings_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlay_settings.html#grim_overlay_settings", "grim_overlay_settings", 'routine in <a href="grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "grim_overlay_settings", "", "grim_dataplane", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_overlays_include.html", "grim_overlays_include.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_overlays_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_set_overlay_update_flag", "grim_set_overlay_update_flag", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_set_overlay_update_flag", "", "ptdvalue", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_get_overlay_update_flag", "grim_get_overlay_update_flag", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_overlay_update_flag", "", "ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_get_updated_ptd", "grim_get_updated_ptd", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_updated_ptd", "", "iiclear_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_get_xd", "grim_get_xd", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_xd", "", "planegrim_dataclass", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_get_overlay_ptdp", "grim_get_overlay_ptdp", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_overlay_ptdp", "", "planedataclassdeplabelsiicolorpsymtlabtshadesymsizeshadetfillgenrefastgrim_dataname", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_get_active_overlays", "grim_get_active_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_active_overlays", "", "planeactive_indicesinactive_indicesgrim_datatype", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_get_all_active_overlays", "grim_get_all_active_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_all_active_overlays", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_get_all_overlays", "grim_get_all_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_all_overlays", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_get_active_xds", "grim_get_active_xds", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_active_xds", "", "active_indicesinactive_indicesplaneclass", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_update_activated", "grim_update_activated", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_update_activated", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_add_activation_callback", "grim_add_activation_callback", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_activation_callback", "", "topno_wsetcallbacksdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_rm_activation_callback", "grim_rm_activation_callback", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_activation_callback", "", "topdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_call_activation_callbacks", "grim_call_activation_callbacks", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_call_activation_callbacks", "", "planeptdarg", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_fill", "grim_fill", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_fill", "", "ptdnamecolor", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_draw_standard_points", "grim_draw_standard_points", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_standard_points", "", "psympsizeplabelslabel_shadegrim_dataplane_ptdnamedatacolortshadeshade", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_draw_standard_overlays", "grim_draw_standard_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_standard_overlays", "", "updatemlabgrim_dataplaneinactive_color", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_draw_user_points", "grim_draw_user_points", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_user_points", "", "xmapgrim_dataplanetags", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_draw_user_overlays", "grim_draw_user_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_user_overlays", "", "grim_dataplaneinactive_color", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_draw_roi", "grim_draw_roi", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_roi", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_draw_indexed_arrays", "grim_draw_indexed_arrays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_indexed_arrays", "", "psymptdp", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_draw_curves", "grim_draw_curves", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_curves", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_draw_tiepoints", "grim_draw_tiepoints", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_tiepoints", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_draw_mask", "grim_draw_mask", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_mask", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_draw", "grim_draw", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw", "", "planesallwnumusertiepointsmaskcurveslabelreadoutmeasureupdatenopointsroino_usergrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_draw_grids", "grim_draw_grids", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_grids", "", "planeno_wsetgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_draw_axes", "grim_draw_axes", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_axes", "", "planeno_contextno_wsetgrim_datadata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_cat_points", "grim_cat_points", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_cat_points", "", "allactiveplanegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_rm_points", "grim_rm_points", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_points", "", "planeptdpii", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_match_overlays", "grim_match_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_match_overlays", "", "ptdptd0", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_add_new_points", "grim_add_new_points", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_new_points", "", "planegrim_dataptdpptdnamecd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_rm_matched_points", "grim_rm_matched_points", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_matched_points", "", "planegrim_dataptdpptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_update_points", "grim_update_points", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_update_points", "", "planegrim_dataptd0ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_add_points", "grim_add_points", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_points", "", "planenamecddatagrim_dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_default_activations", "grim_default_activations", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_default_activations", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_clear_overlay_points", "grim_clear_overlay_points", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_clear_overlay_points", "", "ptdpactive_ptdp", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_clear_active_overlays", "grim_clear_active_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_clear_active_overlays", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_frame_overlays", "grim_frame_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_frame_overlays", "", "slopxygrim_dataplaneptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_hide_overlays", "grim_hide_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_hide_overlays", "", "no_refreshbmgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_clear_objects", "grim_clear_objects", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_clear_objects", "", "allcdpdrdsdstdsundplanesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_place_readout_mark", "grim_place_readout_mark", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_place_readout_mark", "", "grim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_place_measure_mark", "grim_place_measure_mark", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_place_measure_mark", "", "grim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_get_indexed_array", "grim_get_indexed_array", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_indexed_array", "", "planename", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_indexed_array_fname", "grim_indexed_array_fname", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_indexed_array_fname", "", "basenamegrim_dataplanename", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_write_indexed_arrays", "grim_write_indexed_arrays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_write_indexed_arrays", "", "fnamegrim_dataplanename", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_read_indexed_arrays", "grim_read_indexed_arrays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_read_indexed_arrays", "", "fnamegrim_dataplanename", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_unique_array_label", "grim_unique_array_label", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_unique_array_label", "", "ptdp", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_add_indexed_array", "grim_add_indexed_array", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_indexed_array", "", "ptdnointerpspacingflagslabelptdpp", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_select_array_by_box", "grim_select_array_by_box", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_select_array_by_box", "", "planegrim_dataptdcxcy", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_select_array_by_point", "grim_select_array_by_point", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_select_array_by_point", "", "allplanegrim_dataptdp", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_select_array", "grim_select_array", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_select_array", "", "planegrim_dataptdp", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_rm_indexed_array", "grim_rm_indexed_array", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_indexed_array", "", "planeallgrim_datanamep", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_add_tiepoint", "grim_add_tiepoint", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_tiepoint", "", "planenointerpspacingno_syncflagsgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_add_curve", "grim_add_curve", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_curve", "", "planenointerpspacingno_syncflagsgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_rm_tiepoint", "grim_rm_tiepoint", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_tiepoint", "", "allplanenosyncgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_rm_curve", "grim_rm_curve", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_curve", "", "allplanenosyncgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_set_roi", "grim_set_roi", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_set_roi", "", "planegrim_dataroip", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_add_mask", "grim_add_mask", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_mask", "", "planereplacesubscriptgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_copy_mask", "grim_copy_mask", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_copy_mask", "", "grim_dataplaneplanes", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_copy_indexed_array", "grim_copy_indexed_array", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_copy_indexed_array", "", "grim_dataplaneplanesname", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_copy_tiepoint", "grim_copy_tiepoint", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_copy_tiepoint", "", "grim_dataplaneplanes", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_copy_curve", "grim_copy_curve", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_copy_curve", "", "grim_dataplaneplanes", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_get_tiepoint_indices", "grim_get_tiepoint_indices", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_tiepoint_indices", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_replace_tiepoints", "grim_replace_tiepoints", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_replace_tiepoints", "", "planegrim_dataiip", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_image_to_surface", "grim_image_to_surface", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_image_to_surface", "", "body_ptsfar_ptsnamesbxgrim_dataplaneimage_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_surface_to_image", "grim_surface_to_image", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_surface_to_image", "", "validgrim_dataplanesurf_ptsnames", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_sync_indexed_array", "grim_sync_indexed_array", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_sync_indexed_array", "", "grim_dataplaneptd_grim_data_plane_ptdp", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_push_indexed_array", "grim_push_indexed_array", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_push_indexed_array", "", "rmgrim_dataptdname", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_rm_mask_by_point", "grim_rm_mask_by_point", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_mask_by_point", "", "planeppgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_rm_mask_by_box", "grim_rm_mask_by_box", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_mask_by_box", "", "planeppgrim_datacxcy", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_rm_mask", "grim_rm_mask", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_mask", "", "allplaneppgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_get_object_overlays", "grim_get_object_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_object_overlays", "", "grim_dataplanexd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_deactivate_xd", "grim_deactivate_xd", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_deactivate_xd", "", "planexds", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_deactivate_overlay", "grim_deactivate_overlay", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_deactivate_overlay", "", "xdsassoc_xdspptdno_callbackgrim_dataplaneptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_activate_xd", "grim_activate_xd", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_xd", "", "planexds", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_deactivate_all_xds", "grim_deactivate_all_xds", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_deactivate_all_xds", "", "plane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_activate_all_xds", "grim_activate_all_xds", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_all_xds", "", "plane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_activate_overlay", "grim_activate_overlay", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_overlay", "", "xdspptdno_callbackgrim_dataplaneptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_activate_all_overlays", "grim_activate_all_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_all_overlays", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_deactivate_all_overlays", "grim_deactivate_all_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_deactivate_all_overlays", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_invert_active_overlays", "grim_invert_active_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_invert_active_overlays", "", "xdsgrim_dataplaneptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_invert_all_overlays", "grim_invert_all_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_invert_all_overlays", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_nearest_overlay", "grim_nearest_overlay", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_nearest_overlay", "", "mmplanepobject_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_enclosed_overlays", "grim_enclosed_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_enclosed_overlays", "", "mmcornersobject_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_remove_by_point", "grim_remove_by_point", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_remove_by_point", "", "clicksuserplanep0", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_activate_by_point", "grim_activate_by_point", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_by_point", "", "deactivateclicksinvertgrim_dataplanep0", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_trim_overlays", "grim_trim_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_trim_overlays", "", "planegrim_dataregion", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_select_overlay_points", "grim_select_overlay_points", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_select_overlay_points", "", "planedeselectgrim_dataregion", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_remove_by_box", "grim_remove_by_box", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_remove_by_box", "", "statuserplanecxcy", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_activate_by_box", "grim_activate_by_box", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_by_box", "", "deactivategrim_dataplanecxcy", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_activate_select", "grim_activate_select", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_select", "", "deactivateclicksptdgrim_dataplanep0", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_remove_overlays", "grim_remove_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_remove_overlays", "", "clicksstatuserplanep0", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_create_overlay", "grim_create_overlay", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_create_overlay", "", "classdep_classescolorpsymsymsizeshadetlabtshadetfillgenregrim_dataplanenamedep_overlays", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_create_overlays", "grim_create_overlays", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_create_overlays", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_hide", "grim_hide", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_hide", "", "gdgrim_dataplaneptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_overlay", "grim_overlay", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_overlay", "", "planedepptdsource_ptdobj_nametempgrim_dataname", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_overlays_include.html#grim_overlays_include", "grim_overlays_include", 'routine in <a href="grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_overlays_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_plane_settings.html", "grim_plane_settings.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_plane_settings.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_plane_settings.html#grps_overlay_tag", "grps_overlay_tag", 'routine in <a href="grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grps_overlay_tag", "", "iname", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_plane_settings.html#grps_update_form", "grps_update_form", 'routine in <a href="grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grps_update_form", "", "grim_dataplanebase", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_plane_settings.html#grps_invert", "grps_invert", 'routine in <a href="grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grps_invert", "", "databases", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_plane_settings.html#grps_cleanup", "grps_cleanup", 'routine in <a href="grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grps_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_plane_settings.html#grps_apply_settings", "grps_apply_settings", 'routine in <a href="grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grps_apply_settings", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_plane_settings.html#grps_ok", "grps_ok", 'routine in <a href="grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grps_ok", "", "database", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_plane_settings.html#grim_plane_settings_event", "grim_plane_settings_event", 'routine in <a href="grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grim_plane_settings_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_plane_settings.html#grim_plane_settings", "grim_plane_settings", 'routine in <a href="grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grim_plane_settings", "", "grim_data", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_planes_include.html", "grim_planes_include.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_planes_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_next_plane", "grim_next_plane", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_next_plane", "", "norefreshgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_previous_plane", "grim_previous_plane", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_previous_plane", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_get_plane", "grim_get_plane", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_get_plane", "", "allpnvisiblegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_test_map", "grim_test_map", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_test_map", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_test_rgb", "grim_test_rgb", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_test_rgb", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_get_image", "grim_get_image", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_get_image", "", "planeabscissacurrentsamplechannelndgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_stretch_plane", "grim_stretch_plane", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_stretch_plane", "", "grim_dataplanes", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_plane_set_visible", "grim_plane_set_visible", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_plane_set_visible", "", "togglegrim_dataplanesval", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_get_visible_planes", "grim_get_visible_planes", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_get_visible_planes", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_set_plane", "grim_set_plane", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_set_plane", "", "pngrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_rm_plane", "grim_rm_plane", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_rm_plane", "", "grim_datapn", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_crop_plane", "grim_crop_plane", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_crop_plane", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_init_parms", "grim_init_parms", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_init_parms", "", "colorthicknsumpsymsymsizen", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_clone_plane", "grim_clone_plane", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_clone_plane", "", "planespawngrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_channel_to_rgb", "grim_channel_to_rgb", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_channel_to_rgb", "", "channel", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_add_planes", "grim_add_planes", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_add_planes", "", "pnsfilterfovcliphidepathsave_pathload_pathcam_trsplt_trsrng_trsstr_trsstn_trsarr_trssun_trscolorpositionxrangeyrangethicknsumxtitleytitlepsymsymsizemaxvisibilitychannelrender_samplerender_pht_minoverlayscmdgrim_datadd", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_planes_include.html#grim_planes_include", "grim_planes_include", 'routine in <a href="grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_planes_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_print.html", "grim_print.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_print.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_print.html#grim_print", "grim_print", 'routine in <a href="grim/grim_print.html">grim_print.pro</a>', "grim_print.pro", "", "grim_print", "", "appendarg1arg2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_rc_settings.html", "grim_rc_settings.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_rc_settings.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_rc_settings.html#grim_rc_value", "grim_rc_value", 'routine in <a href="grim/grim_rc_settings.html">grim_rc_settings.pro</a>', "grim_rc_settings.pro", "", "grim_rc_value", "", "keywordsvalue_pskeyword", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_rc_settings.html#grim_rc_add_values", "grim_rc_add_values", 'routine in <a href="grim/grim_rc_settings.html">grim_rc_settings.pro</a>', "grim_rc_settings.pro", "", "grim_rc_add_values", "", "selectkeywordsvalue_psprefix", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_rc_settings.html#grim_rc_selections", "grim_rc_selections", 'routine in <a href="grim/grim_rc_settings.html">grim_rc_settings.pro</a>', "grim_rc_settings.pro", "", "grim_rc_selections", "", "cam_selectplt_selectrng_selectstr_selectstn_selectarr_selectsun_selectkeywordsvalue_pskeyvals", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_rc_settings.html#grim_rc_settings", "grim_rc_settings", 'routine in <a href="grim/grim_rc_settings.html">grim_rc_settings.pro</a>', "grim_rc_settings.pro", "", "grim_rc_settings", "", "rcfilekeyvalscam_selectplt_selectrng_selectstr_selectstn_selectarr_selectsun_selectcmdnewxsizeysizemode_initnpointszoomrotateorderoffsetfilterretainpathsave_pathload_pathsymsizeoverlaysmenu_fnamecursor_swapfovclipmenu_extensionsbutton_extensionscam_trsplt_trsrng_trsstr_trsstn_trsarr_trssun_trsfiletypehidemode_argsxzerorgbpsymnhistmaintainnddworkdiractivateframecompressloadctmaxarg_extensionsextensionsbetarenderingplane_syncingtiepoint_syncingcurve_syncingvisibilitychannelrender_samplerender_pht_minslave_overlaysdelay_overlaysauto_stretch", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_user_include.html", "grim_user_include.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_user_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_user_ptd_struct__define", "grim_user_ptd_struct__define", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_user_ptd_struct__define", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_add_user_points", "grim_add_user_points", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_add_user_points", "", "grnumupdatecolorshade_fnpsymthicklinesymsizeshade_thresholdgraphics_fnxgraphicsnodrawinactiveno_refreshplaneuser_ptdtag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_user_notify", "grim_user_notify", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_user_notify", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_update_user_points", "grim_update_user_points", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_update_user_points", "", "planegrnumcolorshade_fnpsymthicklinesymsizeshade_thresholdgraphics_fnxgraphicsnodrawno_refreshuser_ptdtag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_rm_user_points", "grim_rm_user_points", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_rm_user_points", "", "planegrnumgrim_datatag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_test_active_user_ptd", "grim_test_active_user_ptd", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_test_active_user_ptd", "", "prefixplanetag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_get_user_ptd", "grim_get_user_ptd", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_get_user_ptd", "", "grnumprefixplanecolorshade_fnxgraphicsgraphics_fnshade_thresholdpsymthicklinesymsizetagsactivetag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_get_active_user_overlays", "grim_get_active_user_overlays", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_get_active_user_overlays", "", "active_tagsinactive_tagsplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_trim_user_overlays", "grim_trim_user_overlays", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_trim_user_overlays", "", "planegrim_dataregion", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_activate_user_overlay", "grim_activate_user_overlay", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_activate_user_overlay", "", "planeindices", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_deactivate_user_overlay", "grim_deactivate_user_overlay", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_deactivate_user_overlay", "", "planeindices", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_clear_user_overlays", "grim_clear_user_overlays", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_clear_user_overlays", "", "planetags", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_clear_active_user_overlays", "grim_clear_active_user_overlays", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_clear_active_user_overlays", "", "plane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_invert_active_user_overlays", "grim_invert_active_user_overlays", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_invert_active_user_overlays", "", "plane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_user_include.html#grim_user_include", "grim_user_include", 'routine in <a href="grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_user_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_user_mode_struct__define.html", "grim_user_mode_struct__define.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_user_mode_struct__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_user_mode_struct__define.html#grim_user_mode_struct__define", "grim_user_mode_struct__define", 'routine in <a href="grim/grim_user_mode_struct__define.html">grim_user_mode_struct__define.pro</a>', "grim_user_mode_struct__define.pro", "", "grim_user_mode_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/grim_util_include.html", "grim_util_include.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_util_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_set_user_data", "grim_set_user_data", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_set_user_data", "", "grim_datatagdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_get_user_data", "grim_get_user_data", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_get_user_data", "", "grim_datatag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_n_colors", "grim_n_colors", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_n_colors", "", "type", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_get_body_by_name_single", "grim_get_body_by_name_single", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_get_body_by_name_single", "", "xd_pname", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_get_body_by_name", "grim_get_body_by_name", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_get_body_by_name", "", "planename", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_shade_threshold", "grim_shade_threshold", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_shade_threshold", "", "ptdshadethreshold", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_parse_overlay", "grim_parse_overlay", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_parse_overlay", "", "overlaynames", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_cat_bodies", "grim_cat_bodies", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_cat_bodies", "", "plane", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_get_cursor_swap", "grim_get_cursor_swap", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_get_cursor_swap", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_wset", "grim_wset", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_wset", "", "get_infosavenoplotgrim_datawnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_logging_callback", "grim_logging_callback", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_logging_callback", "", "data_pmessage", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_logging", "grim_logging", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_logging", "", "startstopgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_menu_delim_event", "grim_menu_delim_event", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_menu_delim_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_parse_form_entry", "grim_parse_form_entry", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_parse_form_entry", "", "nulldropnumericstringidstagstag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_set_form_entry", "grim_set_form_entry", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_set_form_entry", "", "dropcwbuttonsensitiveidstagstagvalue", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_add_callback", "grim_add_callback", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_add_callback", "", "callbacksdata_pscallbacks_listdata_ps_list", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_rm_callback", "grim_rm_callback", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_rm_callback", "", "data_pscallbacks_listdata_ps_list", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_call_callbacks", "grim_call_callbacks", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_call_callbacks", "", "_callbacks_list_data_ps_listevent", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_get_menu_id", "grim_get_menu_id", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_get_menu_id", "", "grim_datadesc", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_update_menu_toggle", "grim_update_menu_toggle", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_update_menu_toggle", "", "grim_datanameflag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_get_toggle_flag", "grim_get_toggle_flag", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_get_toggle_flag", "", "grim_dataname", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_set_toggle_flag", "grim_set_toggle_flag", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_set_toggle_flag", "", "grim_datanameflag", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_compare", "grim_compare", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_compare", "", "x1x2", "          -1", "");
  
  libdata[libdataItem++] = new Array("grim/grim_util_include.html#grim_util_include", "grim_util_include", 'routine in <a href="grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_util_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/hide_points.html", "hide_points.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "hide_points.pro", "", "", " NAME:        hide_points    PURPOSE: 	Hides points with respect to given object and observer.   CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = hide_points(bx, r, p)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY.  	r:	Columns vector giving the BODY-frame position of the viewer.  	p:	Array (nv) of BODY-frame vectors giving the points to hide.    OUTPUT:        NONE   KEYWORDS:    INPUT: 	rm:	If set, points are flagged for being in front of or behind 		the globe, rather then just behind it.     OUTPUT: NONE    RETURN: 	Subscripts of the points in p that are hidden by the object.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale	3/2017  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/hide_points.html#hide_points", "hide_points", 'routine in <a href="obj/tools/composite/hide_points.html">hide_points.pro</a>', "hide_points.pro", "", "hide_points", "", "rmbxrp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_chisq.html", "icv_chisq.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_chisq.pro", "", "", " NAME: 	icv_chisq    PURPOSE: 	Computes chi-squared value for given curve fit parameters.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_chisq(dxy, dtheta, fix, cos_alpha, sin_alpha, scan_offsets)    ARGUMENTS:   INPUT: 	dxy:		Array (2) giving x- and y-offset solution.  	dtheta:		Scalar giving theta-offset solution.  	fix:		Array specifying which parameters to fix as 			[dx,dy,dtheta].  	cos_alpha:	Array (n_points) of direction cosines computed by 			icv_compute_directions.  	sin_alpha:	Array (n_points) of direction sines computed by 			icv_compute_directions.  	scan_offsets:	Array (n_points) containing offset of best correlation 			at each point on the curve.  Produced by icv_scan_strip.  	scan_pts:	Array (2, n_points) of image coordinates corresponding 			to each scan offset.  	axis:		Array (2) giving image coordinates of rotation axis 			in the case of a 3-parameter fit.    OUTPUT: NONE    KEYWORDS:   INPUT: 	norm:		If set, the returned value is normalized by dividing 			it by the number of degrees of freedom.    OUTPUT: NONE    RETURN: 	The chi-squared value is returned.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_chisq.html#icv_chisq", "icv_chisq", 'routine in <a href="obj/tools/icv/icv_chisq.html">icv_chisq.pro</a>', "icv_chisq.pro", "", "icv_chisq", "", "normdxydthetafixcos_alphasin_alphascan_offsetsscan_ptsaxis", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_coeff.html", "icv_coeff.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_coeff.pro", "", "", " NAME: 	icv_coeff    PURPOSE: 	Computes coefficients for the 2- or 3-parameter linear least-square fit.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	icv_coeff, cos_alpha, sin_alpha, scan_offsets, scan_pts, axis, M=M, b=b    ARGUMENTS:   INPUT: 	cos_alpha:	Array (n_points) of direction cosines computed by 			icv_compute_directions.  	sin_alpha:	Array (n_points) of direction sines computed by 			icv_compute_directions.  	scan_offsets:	Array (n_points) containing offset of best correlation 			at each point on the curve.  Produced by icv_scan_strip.  	scan_pts:	Array (2, n_points) of image coordinates corresponding 			to each scan offset.  	axis:		Array (2) giving image coordinates of rotation axis 			in the case of a 3-parameter fit.    OUTPUT: NONE    KEYWORDS:   INPUT: 	sigma:	Uncertainty in each scan_offset.  Defaults to 1.    OUTPUT: 	M:	3x3 matrix of coefficients for the linear fit.  	b:	3-element column vector rhs of the linear fit.    PROCEDURE: 	Since the fit has been linearized, it can be written as a matrix 	equation:  				Mx = b,  	where x is the 3-element column vector [dx, dy, dtheta] of the 	independent variables. 	This routine computes the matrix M and the 	vector b.  Once these are known, mbfit can be used to solve the 	linear system.  Moreover, since the fit is linear, a simultaneous 	fit can be performed by simply adding together any number of 	coefficient matrices and vectors, which can also be done using 	mbfit.    RESTRICTIONS: 	The fit associated with these coefficients has been linearized 	and is only valid for small corrections.  For larger corrections, 	this procedure can be iterated.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_coeff.html#icv_coeff", "icv_coeff", 'routine in <a href="obj/tools/icv/icv_coeff.html">icv_coeff.pro</a>', "icv_coeff.pro", "", "icv_coeff", "", "sigmaMb_cos_alpha_sin_alphascan_offsetsscan_ptsaxis", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_compute_directions.html", "icv_compute_directions.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_compute_directions.pro", "", "", " NAME: 	icv_compute_directions    PURPOSE: 	Computes the normal to a specified curve at every point.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	icv_compute_directions, curve_pts, $ 	                        cos_alpha=cos_alpha, sin_alpha=sin_alpha    ARGUMENTS:   INPUT: 	curve_pts:	Array (2, n_points) of image points making up the curve.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	cos_alpha:	Array (n_points) of direction cosines.  	sin_alpha:	Array (n_points) of direction sines.    RETURN: 	NONE    RESTRICTIONS: 	It is assumed that the curve is closed; if this is not the case, then 	the results will not be meaningful at the endpoints of the curve.    PROCEDURE: 	At each point on the specified curve, the two nearest neighbors are 	used to compute the components of the normal.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_compute_directions.html#icv_compute_directions", "icv_compute_directions", 'routine in <a href="obj/tools/icv/icv_compute_directions.html">icv_compute_directions.pro</a>', "icv_compute_directions.pro", "", "icv_compute_directions", "", "centercos_alphasin_alphacurve_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_convert_scan_offsets.html", "icv_convert_scan_offsets.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_convert_scan_offsets.pro", "", "", " NAME: 	icv_convert_scan_offsets    PURPOSE: 	Converts offsets produced by icv_scan_strip to image coordinates.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_convert_scan_offsets(curve_pts, scan_offsets, $ 	                                  cos_alpha, sin_alpha)   ARGUMENTS:   INPUT: 	curve_pts:	Array (2, n_points) of image points making up the curve.  	scan_offsets:	Array (n_points) containing offset of best correlation 			at each point on the curve.  Produced by icv_scan_strip.  	cos_alpha:	Array (n_points) of direction cosines computed by 			icv_compute_directions.  	sin_alpha:	Array (n_points) of direction sines computed by 			icv_compute_directions.    OUTPUT: NONE    KEYWORDS: NONE    RETURN: 	Array (2, n_points) of image coordinates corresponding to each scan 	offset.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_convert_scan_offsets.html#icv_convert_scan_offsets", "icv_convert_scan_offsets", 'routine in <a href="obj/tools/icv/icv_convert_scan_offsets.html">icv_convert_scan_offsets.pro</a>', "icv_convert_scan_offsets.pro", "", "icv_convert_scan_offsets", "", "curve_ptsscan_offsetscos_alphasin_alpha", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_invert_scan_offsets.html", "icv_invert_scan_offsets.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_invert_scan_offsets.pro", "", "", " NAME: 	icv_invert_scan_offsets    PURPOSE: 	Uses scan image coordinates to produce scan offsets and angles.  This 	routine is the reverse of icv_convert_scan_offsets.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_invert_scan_offsets(curve_pts, scan_pts, $ 	                                       cos_alpha, sin_alpha)   ARGUMENTS:   INPUT: 	curve_pts:	Array (2, n_points) of image points making up the curve.  	scan_pts:	Array (2, n_points) of image coordinates corresponding to each scan 			offset.  	cos_alpha:	Array (n_points) of direction cosines.  	sin_alpha:	Array (n_points) of direction sines.    OUTPUT: NONE    KEYWORDS: NONE    RETURN: 	Array (2, n_points) of image coordinates corresponding to each scan 	offset.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_invert_scan_offsets.html#icv_invert_scan_offsets", "icv_invert_scan_offsets", 'routine in <a href="obj/tools/icv/icv_invert_scan_offsets.html">icv_invert_scan_offsets.pro</a>', "icv_invert_scan_offsets.pro", "", "icv_invert_scan_offsets", "", "curve_ptsscan_ptscos_alphasin_alpha", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_reset_scan_precision.html", "icv_reset_scan_precision.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_reset_scan_precision.pro", "", "", " NAME: 	icv_reset_scan_precision    PURPOSE: 	Modifies the scan precision by rebinning the given image strip.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	icv_reset_scan_precision, strip, model, szero, mzero, precision    ARGUMENTS:   INPUT: 	strip:		Image strip to modify.  	model:		Corresponding edge models.  	szero:		Zero-offset position in the strip.  	mzero:		Zero-offset position in the model.  	precision:	New precision in inverse pixels.    OUTPUT: 	strip:		Modified image strip.  	model:		Modified edge models.  	szero:		Zero-offset position in the modified strip.  	mzero:		Zero-offset position in the modified model.     KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	NONE    PROCEDURE: 	The strip and model are rebinned by the specified precision factor 	using cubic interpolation.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_reset_scan_precision.html#icv_reset_scan_precision", "icv_reset_scan_precision", 'routine in <a href="obj/tools/icv/icv_reset_scan_precision.html">icv_reset_scan_precision.pro</a>', "icv_reset_scan_precision.pro", "", "icv_reset_scan_precision", "", "stripmodelszeromzeroprecision", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip.html", "icv_scan_strip.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip.pro", "", "", " NAME: 	icv_scan_strip    PURPOSE: 	At each point along an image strip, determines the point at which 	some criterion is optimized, depending on an externally-supplied 	function.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_scan_strip(strip, model, szero, mzero, algorithm=algorithm)    ARGUMENTS:   INPUT: 	strip:	Image strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.  	model:	Model (n_points,nm) to correlate with strip at each point 		on the curve.  Must have nm < ns.  	szero:	Zero-offset position in the strip.  	mzero:	Zero-offset position in the model.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	cc:	Maximum correlation coefficient at each point on the curve.  	sigma:	Offset uncertainty for each point on the curve, computed as 		one half of the half-width of the correlation peak.  	algorithm:	String giving the subscript for the name of a 			function as icv_scan_strip_<algorithm>.  The algorithm 			function should be structured like the present function, 			except with no  algorithm  keyword.  Default is 			'model'.    RETURN: 	Offset of best correlation at each point on the curve.    PROCEDURE: 	This program is a wrapper for a number of functions that use various 	algorithms determined by the 'algorithm' keyword.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip.html#icv_scan_strip", "icv_scan_strip", 'routine in <a href="obj/tools/icv/icv_scan_strip.html">icv_scan_strip.pro</a>', "icv_scan_strip.pro", "", "icv_scan_strip", "", "ccsigmaalgorithmargstripmodelszeromzero", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_grad.html", "icv_scan_strip_grad.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip_grad.pro", "", "", " NAME: 	icv_scan_strip_grad    PURPOSE: 	At each point along an image strip, finds a sharp edge using the 	maximum-gradient method.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_scan_strip_grad(strip, model, szero, mzero)    ARGUMENTS:   INPUT: 	strip:	Image strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.  	model:	Not used.  	szero:	Zero-offset position in the strip.  	mzero:	Not used.    OUTPUT: NONE    KEYWORDS:   INPUT: 	norm:	If set, only the absolute value of the gradient is evaluated.    OUTPUT: 	cc:	Not used, hardwired to 0.9999999d.  	sigma:	Offset uncertainty for each point on the curve, computed as 		one half of the half-width of the gradient peak.    RETURN: 	Offset of maximum gradient points at each point on the curve.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_grad.html#icv_scan_strip_grad", "icv_scan_strip_grad", 'routine in <a href="obj/tools/icv/icv_scan_strip_grad.html">icv_scan_strip_grad.pro</a>', "icv_scan_strip_grad.pro", "", "icv_scan_strip_grad", "", "argccsigmanormstripmodelszeromzero", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_grad_norm.html", "icv_scan_strip_grad_norm.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip_grad_norm.pro", "", "", " NAME: 	icv_scan_strip_grad_norm    PURPOSE: 	Calls icv_scan_strip_grad with /norm set.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_scan_strip_grad_norm(strip, model, szero, mzero)    ARGUMENTS:   INPUT: 	strip:	Image strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.  	model:	Not used.  	szero:	Zero-offset position in the strip.  	mzero:	Not used.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	cc:	Not used, hardwired to 0.9999999d.  	sigma:	Offset uncertainty for each point on the curve, computed as 		one half of the half-width of the gradient peak.    RETURN: 	Offset of maximum gradient points at each point on the curve.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_grad_norm.html#icv_scan_strip_grad_norm", "icv_scan_strip_grad_norm", 'routine in <a href="obj/tools/icv/icv_scan_strip_grad_norm.html">icv_scan_strip_grad_norm.pro</a>', "icv_scan_strip_grad_norm.pro", "", "icv_scan_strip_grad_norm", "", "argccsigmastripmodelszeromzero", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_half.html", "icv_scan_strip_half.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip_half.pro", "", "", " NAME: 	icv_scan_strip_half    PURPOSE: 	At each point along an image strip, finds a sharp edge using the 	half-power method.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_scan_strip_half(strip, model, szero, mzero)    ARGUMENTS:   INPUT: 	strip:	Image strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.  	model:	Not used.  	szero:	Zero-offset position in the strip.  	mzero:	Not used.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	cc:	Not used, hardwired to 0.9999999d.  	sigma:	Offset uncertainty for each point on the curve, computed as 		one half of the half-width of the half-power peak.    RETURN: 	Offset of half-power points at each point on the curve.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_half.html#icv_scan_strip_half", "icv_scan_strip_half", 'routine in <a href="obj/tools/icv/icv_scan_strip_half.html">icv_scan_strip_half.pro</a>', "icv_scan_strip_half.pro", "", "icv_scan_strip_half", "", "argccsigmacenterstripmodelszeromzero", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_inflection.html", "icv_scan_strip_inflection.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip_inflection.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_inflection.html#icv_scan_strip_inflection", "icv_scan_strip_inflection", 'routine in <a href="obj/tools/icv/icv_scan_strip_inflection.html">icv_scan_strip_inflection.pro</a>', "icv_scan_strip_inflection.pro", "", "icv_scan_strip_inflection", "", "argccsigmanormstripmodelszeromzero", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_model.html", "icv_scan_strip_model.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip_model.pro", "", "", " NAME: 	icv_scan_strip_model    PURPOSE: 	At each point along an image strip, determines the subpixel offset at 	which the correlation coefficient between a specified model and the 	image is maximum.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_scan_strip_model(strip, model, szero, mzero)    ARGUMENTS:   INPUT: 	strip:	Image strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.  	model:	Model (n_points,nm) to correlate with strip at each point 		on the curve.  Must have nm < ns.  	szero:	Zero-offset position in the strip.  	mzero:	Zero-offset position in the model.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	cc:	Maximum correlation coefficient at each point on the curve.  	sigma:	Offset uncertainty for each point on the curve, computed as 		one half of the half-width of the correlation peak.    RETURN: 	Offset of best correlation at each point on the curve.    PROCEDURE: 	At every point on the curve, a correlation coefficient is computed 	for every offset at which the model completely overlays the strip. 	In other words, the model is swept across the strip.  	At each point, Lagrange interpolation is used on the three correlations 	surrounding the correlation peak to find the subpixel offset of maximum 	correlation.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_model.html#icv_scan_strip_model", "icv_scan_strip_model", 'routine in <a href="obj/tools/icv/icv_scan_strip_model.html">icv_scan_strip_model.pro</a>', "icv_scan_strip_model.pro", "", "icv_scan_strip_model", "", "argccsigmacenterstripmodelszeromzero", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_strip_curve.html", "icv_strip_curve.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_strip_curve.pro", "", "", " NAME: 	icv_strip_curve    PURPOSE: 	Using Lagrange interpolation, extracts an image strip of a specified 	width centered on the specified curve.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	strip = icv_strip_curve(cd, image, curve_pts, width, nD, $                                                    cos_alpha, sin_alpha)    ARGUMENTS:   INPUT: 	cd:		Camera descriptor.  	image:		Image from which to extract the strip.  	curve_pts:	Array (2, n_points) of image points making up the curve.  	width:		Width of the strip in pixels.  	nD:		Number of samples across the width of the strip.  	cos_alpha:	Array (n_points) of direction cosines computed by 			icv_compute_directions.  	sin_alpha:	Array (n_points) of direction sines computed by 			icv_compute_directions.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	zero:		Zero-offset position in the strip.  This position 			corresponds to where the specified curve falls in the 			strip.    RETURN: 	Image strip (n_points, nD).    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_strip_curve.html#icv_strip_curve", "icv_strip_curve", 'routine in <a href="obj/tools/icv/icv_strip_curve.html">icv_strip_curve.pro</a>', "icv_strip_curve.pro", "", "icv_strip_curve", "", "zerogrid_xgrid_ycdimagecurve_ptswidthnDcos_alphasin_alpha", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/illumination_fraction.html", "illumination_fraction.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "illumination_fraction.pro", "", "", " NAME:        illumination_fraction    PURPOSE: 	Assuming the body gbx is a sphere, this routine computes the fraction of 	its disk that appears illuminated by the source sund, as seen from the 	inertial position vectors v.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        v = illumination_fraction(gbx, sund, v)    ARGUMENTS:   INPUT: 	gbx:	Any subclass of GLOBE.  	sund:	Any subclass of STAR representing the sun.  	v:	Array (nv,3) Inertial positions of viewer.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv) giving the illumination fraction for each gbx.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/illumination_fraction.html#illumination_fraction", "illumination_fraction", 'routine in <a href="obj/tools/illumination_fraction.html">illumination_fraction.pro</a>', "illumination_fraction.pro", "", "illumination_fraction", "", "gbxsundv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_ansa.html", "image_ansa.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_ansa.pro", "", "", " NAME:        image_ansa    PURPOSE: 	Computes ring ansa true anomalies.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        tas = image_ansa(cd, rd, radius)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	dkx:	Any subclass of DISK.  	radius:	Disk radius at which to compute ansa.    OUTPUT:  NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	image_pts:	Image points corresponding to each ansa true anomaly 			at the given radius.    RETURN: 	Array (2) of true anomalies    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_ansa.html#ia_compute", "ia_compute", 'routine in <a href="obj/tools/image_ansa.html">image_ansa.pro</a>', "image_ansa.pro", "", "ia_compute", "", "image_ptcdrdradiusta0", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/image_ansa.html#image_ansa", "image_ansa", 'routine in <a href="obj/tools/image_ansa.html">image_ansa.pro</a>', "image_ansa.pro", "", "image_ansa", "", "image_ptscdrdradius", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_ansa_far.html", "image_ansa_far.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_ansa_far.pro", "", "", " NAME:        image_ansa_far    PURPOSE: 	Computes ring ansa longitudes assuming observer is very far from the 	rings.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        lons = image_ansa_far(cd, rd)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	dkx:	Any subclass of DISK.    OUTPUT:  NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2) of longitudes    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_ansa_far.html#image_ansa_far", "image_ansa_far", 'routine in <a href="obj/tools/image_ansa_far.html">image_ansa_far.pro</a>', "image_ansa_far.pro", "", "image_ansa_far", "", "cdrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_azimuth.html", "image_azimuth.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_azimuth.pro", "", "", " NAME:        image_azimuth_pos    PURPOSE: 	Computes azimuth angle of projection of inertial vector v 	into the image plane.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        v = image_azimuth_pos(cd, v)    ARGUMENTS:   INPUT: 	cd:	Any subclass of GLOBE.  	v:	Inertial vector.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Image azimuth.  When the image is displayed with (0,0) at 	the top-left, the azimuth angle is measured counterclockwise from 	 up .    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_azimuth.html#image_azimuth", "image_azimuth", 'routine in <a href="obj/tools/image_azimuth.html">image_azimuth.pro</a>', "image_azimuth.pro", "", "image_azimuth", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_azimuth_pos.html", "image_azimuth_pos.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_azimuth_pos.pro", "", "", " NAME:        image_azimuth_pos    PURPOSE: 	Computes azimuth angle of projection of inertial position vector v 	into the image plane.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        v = image_azimuth_pos(cd, v)    ARGUMENTS:   INPUT: 	cd:	Any subclass of GLOBE.  	v:	Inertial position vector.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Image azimuth.  When the image is displayed with (0,0) at 	the top-left, the azimuth angle is measured counterclockwise from 	 up .    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_azimuth_pos.html#image_azimuth_pos", "image_azimuth_pos", 'routine in <a href="obj/tools/image_azimuth_pos.html">image_azimuth_pos.pro</a>', "image_azimuth_pos.pro", "", "image_azimuth_pos", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_celestial_northangle.html", "image_celestial_northangle.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_celestial_northangle.pro", "", "", " NAME:        image_celestial_northangle    PURPOSE: 	Computes the image azimuth (see image_azimuth.pro) of celestial north.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = image_celestial_northangle(cd)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	orient:	Orientation matrix to use instead of cd.    OUTPUT: NONE    RETURN:        Angle in radians.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_celestial_northangle.html#image_celestial_northangle", "image_celestial_northangle", 'routine in <a href="obj/tools/image_celestial_northangle.html">image_celestial_northangle.pro</a>', "image_celestial_northangle.pro", "", "image_celestial_northangle", "", "orientcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_interp_cam.html", "image_interp_cam.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_interp_cam.pro", "", "", " NAME:        image_interp_cam    PURPOSE:        Extracts a region from an image using the desired interpolation, 	accouting for the camera point-spread function is applicable.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = image_interp_cam(image, grid_x, grid_y, args)    ARGUMENTS:   INPUT: 	image:	An array of image point arrays.  	grid_x:	The grid of x positions for interpolation  	grid_y:	The grid of y positions for interpolation  	args:	Arguments to pass to the interpolation function.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	cd:	Camera descriptor.  	interp:	Type of interpolation to use.  Options are: 		'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.  	k:	 Half-width  of the convolution window.  The 		window actually covers the central pixel, plus 		k pixel in each direction.  Default is 3, which 		gives a 7x7 window.  	kmax:	Maximum value for k.    OUTPUT: NONE    RETURN:        Array of interpolated points at the (grid_x, grid_y) points.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_interp_cam.html#image_interp_cam", "image_interp_cam", 'routine in <a href="obj/tools/image_interp_cam.html">image_interp_cam.pro</a>', "image_interp_cam.pro", "", "image_interp_cam", "", "cdvalidkinterpkmaxmaskzmaskimagegrid_xgrid_yargs", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_northangle.html", "image_northangle.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_northangle.pro", "", "", " NAME:        image_northangle    PURPOSE: 	Computes the image azimuth (see image_azimuth.pro) of the north 	direction on the surface of the given body at the specified pixel 	location p.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = image_northangle(cd, gbx, p)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Any subclass of GLOBE.  	p:	Array (2) giving the image point.    OUTPUT:  NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: 	valid:	Indicates whether the result has a solution.  -1 if no 		solution, 1 otherwise.    RETURN:        Angle in radians.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_northangle.html#image_northangle", "image_northangle", 'routine in <a href="obj/tools/image_northangle.html">image_northangle.pro</a>', "image_northangle.pro", "", "image_northangle", "", "validcdgbxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_origin.html", "image_origin.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_origin.pro", "", "", " NAME:        image_origin    PURPOSE: 	Returns the origin of a map or camera image.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        image_origin(xd)    ARGUMENTS:   INPUT: 	xd:      Camera or map descriptor     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	2-element array giving the origin in the x and y directions.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_origin.html#image_origin", "image_origin", 'routine in <a href="obj/tools/composite/image_origin.html">image_origin.pro</a>', "image_origin.pro", "", "image_origin", "", "cd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_predict.html", "image_predict.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_predict.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_predict.html#image_predict", "image_predict", 'routine in <a href="obj/tools/image_predict.html">image_predict.pro</a>', "image_predict.pro", "", "image_predict", "", "cGGposcdrxgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_predict_orbit.html", "image_predict_orbit.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_predict_orbit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_predict_orbit.html#image_predict_orbit", "image_predict_orbit", 'routine in <a href="obj/tools/image_predict_orbit.html">image_predict_orbit.pro</a>', "image_predict_orbit.pro", "", "image_predict_orbit", "", "cGGposppradecnotestsloprxtcdgbxrx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_predict_orbit_error.html", "image_predict_orbit_error.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_predict_orbit_error.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_predict_orbit_error.html#image_predict_orbit_error", "image_predict_orbit_error", 'routine in <a href="obj/tools/image_predict_orbit_error.html">image_predict_orbit_error.pro</a>', "image_predict_orbit_error.pro", "", "image_predict_orbit_error", "", "cGGnsamplesimplecdgbxrxsig_rx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_predict_ring.html", "image_predict_ring.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_predict_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_predict_ring.html#image_predict_ring", "image_predict_ring", 'routine in <a href="obj/tools/image_predict_ring.html">image_predict_ring.pro</a>', "image_predict_ring.pro", "", "image_predict_ring", "", "sundrxtcdgbxrx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_predict_wind.html", "image_predict_wind.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_predict_wind.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_predict_wind.html#image_predict_wind", "image_predict_wind", 'routine in <a href="obj/tools/image_predict_wind.html">image_predict_wind.pro</a>', "image_predict_wind.pro", "", "image_predict_wind", "", "posvdegcdgbxt0surf_ptvel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_shift.html", "image_shift.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_shift.pro", "", "", " NAME:        image_shift    PURPOSE: 	Shifts an image by a specified (non-integer) amount using 	interpolation.  If applicable, the camera pont-spread function 	is accounted for in the interpolation.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = image_shift(image, dx, dy)    ARGUMENTS:   INPUT: 	image:	2-D array giving the image.  	dx:	Offset in the x direction.  	dy:	Offset in the y direction.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	cd:	Camera descriptor.    OUTPUT: NONE    RETURN:        Shifted image.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_shift.html#image_shift", "image_shift", 'routine in <a href="obj/tools/image_shift.html">image_shift.pro</a>', "image_shift.pro", "", "image_shift", "", "cdimagedxdy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_size.html", "image_size.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_size.pro", "", "", " NAME:        image_size    PURPOSE: 	Returns the size of a map or camera image.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        image_size(xd)    ARGUMENTS:   INPUT: 	xd:      Camera or map descriptor     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	2-element array giving the size in the x and y directions.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_size.html#image_size", "image_size", 'routine in <a href="obj/tools/composite/image_size.html">image_size.pro</a>', "image_size.pro", "", "image_size", "", "cd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_body.html", "image_to_body.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_body.pro", "", "", " NAME:        image_to_body    PURPOSE:        Transforms points in image coordinates to body coordinates on the 	object.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_body(cd, bx, p)    ARGUMENTS:   INPUT: 	cd:       Array of nt camera or map descriptor.  	bx:       Array of nt body descriptor (subclass of GLOBE or DISK).  	p:       Array (2 x nv x nt) of image points.    OUTPUT:        hit:	Array with one element per input point.  1 if point 		falls on the body, 0 if not.   RETURN:        Array (nv x 3 x nt) of body-frame vectors.  Zero vectors are returned if a 	body point cannot be computed (e.g., the ray misses the planet).   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale; 8/2006  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_body.html#image_to_body", "image_to_body", 'routine in <a href="obj/tools/composite/image_to_body.html">image_to_body.pro</a>', "image_to_body.pro", "", "image_to_body", "", "hitbackallcdbxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_disk.html", "image_to_disk.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_disk.pro", "", "", " NAME:        image_to_disk    PURPOSE:        Transforms points in image coordinates to disk coordinates    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_disk(cd, dkx, p)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera or map descriptors.  	dkx:	Array of nt object descriptors (subclass of DISK).  	p:	Array (2 x nv x nt) of image points.    OUTPUT:        hit:	Array with one element per input point.  1 if point 		falls on the body, 0 if not.    KEYWORDS:    INPUT: NONE     OUTPUT: 	valid:	Indices of valid output points.         hit:	Array with one element per input point.  1 if point 		falls on the body, 0 if not.  	body_pts:	Body coordinates of output points.    RETURN:        Array (nv x 3 x nt) of disk positions.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Tiscareno (modified from image_to_surface)  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_disk.html#image_to_disk", "image_to_disk", 'routine in <a href="obj/tools/composite/image_to_disk.html">image_to_disk.pro</a>', "image_to_disk.pro", "", "image_to_disk", "", "hitvalidbody_ptscddkxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_globe.html", "image_to_globe.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_globe.pro", "", "", " NAME:        image_to_globe    PURPOSE:        Transforms points in image coordinates to body globe coordinates    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_globe(cd, od, p)    ARGUMENTS:   INPUT: 	cd:       Array of nt camera or map descriptors.  	od:       Array of nt object descriptors (of type GLOBE).  	p:       Array (2 x nv x nt) of image points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: 	valid:	Indices of valid output points.  	body_pts:	Body coordinates of output points.  	discriminant:	Determinant D from the ray trace.  No solutions for 			D<0, two solutions for D=0, one slution for D>0.    RETURN:        Array (nv x 3 x nt) of globe positions.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale;  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_globe.html#image_to_globe", "image_to_globe", 'routine in <a href="obj/tools/composite/image_to_globe.html">image_to_globe.pro</a>', "image_to_globe.pro", "", "image_to_globe", "", "body_ptsdiscriminantvalidcdodp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_inertial.html", "image_to_inertial.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_inertial.pro", "", "", " NAME:        image_to_inertial    PURPOSE:        Transforms points in image coordinates to unit vectors with 	inertial coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_inertial(cd, p)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera descriptors.  	p:	Array (2 x nv x nt) of image points.    OUTPUT:        NONE   RETURN:        Array (nv x 3 x nt) of of inertial unit vectors.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale 4/2003  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_inertial.html#image_to_inertial", "image_to_inertial", 'routine in <a href="obj/tools/composite/image_to_inertial.html">image_to_inertial.pro</a>', "image_to_inertial.pro", "", "image_to_inertial", "", "cdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_map.html", "image_to_map.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_map.pro", "", "", " NAME:        image_to_map    PURPOSE:        Transforms points in image coordinates to map coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_map(cd, gbd, p)    ARGUMENTS:   INPUT: 	md:	Array of nt map or camera descriptors.  	gbx:	Array of nt object descriptors (of type GLOBE).  	p:	Array (2 x nv x nt) of image points    OUTPUT:        NONE   KEYWORDS:    INPUT: 	bx:	If md is not a map descriptor, bx gives a subclass of BODY 		needed for transforming surface to map coordinates.     OUTPUT: 	valid:	Indices of valid output points.  	body_pts:	Body coordinates of output points.    RETURN:        Array (nv x 3 x nt) of map points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale;  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_map.html#image_to_map", "image_to_map", 'routine in <a href="obj/tools/composite/image_to_map.html">image_to_map.pro</a>', "image_to_map.pro", "", "image_to_map", "", "bxvalidbody_ptsmdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_orbit.html", "image_to_orbit.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_orbit.pro", "", "", " NAME:        image_to_orbit    PURPOSE: 	Computes orbital elements corresponding to image points, assuming 	a circular orbit.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        dkd = image_to_orbit(cd, gbx, dkx, image_pts)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera or map descriptors.  	gbx:	Array of nt globe descriptor describing the primary body.  	dkx:	Array of nt disk descriptor describing the assumed orbit plane.  	image_pts:	Array (1,3,nt) of image points.     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	Array of nt disk descriptors reresenting the computed orbits.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_orbit.html#image_to_orbit", "image_to_orbit", 'routine in <a href="obj/tools/composite/image_to_orbit.html">image_to_orbit.pro</a>', "image_to_orbit.pro", "", "image_to_orbit", "", "GG_cd_gbxdkx0image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_radec.html", "image_to_radec.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_radec.pro", "", "", " NAME:        image_to_radec    PURPOSE:        Transforms points in image coordinates to polar ra/dec coords 	w.r.t the inertial frame.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_radec(cd, p)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera descriptors.  	p:	Array (2 x nv x nt) of image points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: 	body_pts:	Body coordinates of output points.    RETURN:        Array (nv x 3 x nt) of radec vectors in the cd BODY frame.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale 3/2002, to replace image_to_ra_dec  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_radec.html#image_to_radec", "image_to_radec", 'routine in <a href="obj/tools/composite/image_to_radec.html">image_to_radec.pro</a>', "image_to_radec.pro", "", "image_to_radec", "", "body_ptscdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_surface.html", "image_to_surface.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_surface.pro", "", "", " NAME:        image_to_surface    PURPOSE:        Transforms points in image coordinates to surface coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_surface(cd, bx, p)    ARGUMENTS:   INPUT: 	cd:      Array of nt camera or map descriptor  	bx:      Array of nt object descriptors (subclass of BODY).  	p:       Array (2 x nv x nt) of image points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: 	valid:	Indices of valid output points.         hit:	Array with one element per input point.  1 if point 		falls on the body, 0 if not.  	body_pts:	Body coordinates of output points.  	discriminant:	Determinant D from the ray trace.  No solutions for 			 D<0, two solutions for D=0, one slution for D>0.    RETURN:        Array (nv x 3 x nt) of surface points.  In the case of a camera descriptor, ray 	tracing is used.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_surface.html#image_to_surface", "image_to_surface", 'routine in <a href="obj/tools/composite/image_to_surface.html">image_to_surface.pro</a>', "image_to_surface.pro", "", "image_to_surface", "", "body_ptsdiscriminanthitvalidcdbxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/impact_param.html", "impact_param.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "impact_param.pro", "", "", " NAME:        impact_param    PURPOSE: 	Computes the impact parameter of a vector originating at the 	given camera, relative to the given planet object.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        B = impact_param(cd, pd)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	pd:	Planet descriptor.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	p:	Image point specifying te ray to project.  If not given, 		the camera optic axis is used.    OUTPUT: NONE    RETURN:        Shifted image.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/impact_param.html#impact_param", "impact_param", 'routine in <a href="obj/tools/impact_param.html">impact_param.pro</a>', "impact_param.pro", "", "impact_param", "", "pcdpd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/in_image.html", "in_image.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "in_image.pro", "", "", " NAME:        in_image    PURPOSE: 	Determines which input points lie within an image described by the 	given camera descriptor.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        sub = in_image(cd, p)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	p:	Array (2,nv) of image points.    OUTPUT:  NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Subscripts of points that lie in the image.  -1 if there are none.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/in_image.html#in_image", "in_image", 'routine in <a href="obj/tools/in_image.html">in_image.pro</a>', "in_image.pro", "", "in_image", "", "xminxmaxyminymaxslopcornerscd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_disk.html", "inertial_to_disk.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_disk.pro", "", "", " NAME:        inertial_to_disk    PURPOSE:        Transforms vectors in inertial coordinates to disk coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = inertial_to_image(dkx, v)    ARGUMENTS:   INPUT: 	dkx:	Array of nt descriptors, subclass of DISK.  	v:	Array (nv x 3 x nt) of inertial vectors.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of disk points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 2/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_disk.html#inertial_to_disk", "inertial_to_disk", 'routine in <a href="obj/tools/composite/inertial_to_disk.html">inertial_to_disk.pro</a>', "inertial_to_disk.pro", "", "inertial_to_disk", "", "dkxv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_disk_pos.html", "inertial_to_disk_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_disk_pos.pro", "", "", " NAME:        inertial_to_disk_pos    PURPOSE:        Transforms position vectors in inertial coordinates to disk 	coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = inertial_to_disk_pos(dkx, v)    ARGUMENTS:   INPUT: 	dkx:	Array of nt descritors, subclass of DISK.  	v:	Array (nv x 3 x nt) of inertial vectors    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of disk points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 3/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_disk_pos.html#inertial_to_disk_pos", "inertial_to_disk_pos", 'routine in <a href="obj/tools/composite/inertial_to_disk_pos.html">inertial_to_disk_pos.pro</a>', "inertial_to_disk_pos.pro", "", "inertial_to_disk_pos", "", "dkxv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_globe.html", "inertial_to_globe.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_globe.pro", "", "", " NAME:        inertial_to_globe    PURPOSE:        Transforms vectors in inertial coordinates to globe coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = inertial_to_image(gbx, v)    ARGUMENTS:   INPUT: 	gbx:	Array of nt descriptors, subclass of globe.  	v:	Array (nv x 3 x nt) of inertial vectors.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of globe points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 9/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_globe.html#inertial_to_globe", "inertial_to_globe", 'routine in <a href="obj/tools/composite/inertial_to_globe.html">inertial_to_globe.pro</a>', "inertial_to_globe.pro", "", "inertial_to_globe", "", "gbxv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_globe_pos.html", "inertial_to_globe_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_globe_pos.pro", "", "", " NAME:        inertial_to_globe_pos    PURPOSE:        Transforms position vectors in inertial coordinates to globe 	coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = inertial_to_globe_pos(gbx, v)    ARGUMENTS:   INPUT: 	gbx:	Array of nt descritors, subclass of globe.  	v:	Array (nv x 3 x nt) of inertial vectors    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of globe points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 9/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_globe_pos.html#inertial_to_globe_pos", "inertial_to_globe_pos", 'routine in <a href="obj/tools/composite/inertial_to_globe_pos.html">inertial_to_globe_pos.pro</a>', "inertial_to_globe_pos.pro", "", "inertial_to_globe_pos", "", "gbxv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_image.html", "inertial_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_image.pro", "", "", " NAME:        inertial_to_image    PURPOSE:        Transforms vectors in inertial coordinates to image coordinates    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = inertial_to_image(cd, v)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera descriptors.  	v:	Array (nv x 3 x nt) of inertial vectors    OUTPUT:        NONE   RETURN:        Array (2 x nv x nt) of image points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_image.html#inertial_to_image", "inertial_to_image", 'routine in <a href="obj/tools/composite/inertial_to_image.html">inertial_to_image.pro</a>', "inertial_to_image.pro", "", "inertial_to_image", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_image_pos.html", "inertial_to_image_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_image_pos.pro", "", "", " NAME:        inertial_to_image_pos    PURPOSE:        Transforms vectors in inertial coordinates to image coordinates    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = inertial_to_image_pos(cd, v)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera descriptors.  	v:	Array (nv x 3 x nt) of inertial vectors    OUTPUT:        NONE   RETURN:        Array (2 x nv x nt) of image points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_image_pos.html#inertial_to_image_pos", "inertial_to_image_pos", 'routine in <a href="obj/tools/composite/inertial_to_image_pos.html">inertial_to_image_pos.pro</a>', "inertial_to_image_pos.pro", "", "inertial_to_image_pos", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/interface/ingrid.html", "ingrid.pro", '.pro file in <a href="grim/interface/dir-overview.html">grim/interface/ directory</a>', "ingrid.pro", "", "", " NAME: 	INGRID    PURPOSE: 	INterface to GRIm Data -- command-line access to GRIM data. 	The returned descriptors allow direct access to the memory images of 	GRIM's descriptor set.  Therefore changes made from the command line 	affect the descriptors that GRIM is using.  GRIM monitors those 	descriptors and updates itself whenever a change occurs.    CATEGORY: 	NV/GR    CALLING SEQUENCE: 	ingrid, arg, <xd>=<xd>    ARGUMENTS:   INPUT: 	arg:	GRIM window number or GRIM data struture.  If not given, the 		most recently accessed grim instance is used.    OUTPUT: NONE    KEYWORDS:   INPUT: 	plane:	Grim plane structure(s) instead of giving pn.  Note all planes 		must belong to the same grim instance.  	pn:	Plane numer(s) to access.  If not given, then current plane 		is used.  	all:	If set, all planes are used.    OUTPUT: 	dd:	GRIM's data descriptor.  	cd:	GRIM's camera descriptor.  	od:	GRIM's observer descriptor.  	sund:	GRIM's sun descriptor.  	pd:	GRIM's planet descriptors.  	rd:	GRIM's ring descriptors.  	sd:	GRIM's star descriptors.  	std:	GRIM's station descriptors.  	ard:	GRIM's array descriptors.  	gd:	Generic descriptor containing all of the above descriptors.  	center_ptd: 		POINT object giving the planet centers.  	limb_ptd: 		POINT object giving the limb points.  	ring_ptd: 		POINT object giving the ring points.  	star_ptd: 		POINT object giving the star points.  	term_ptd: 		POINT object giving the terminator points.  	station_ptd: 		POINT object giving the station points.  	array_ptd: 		POINT object giving the array points.  	plgrid_ptd: 		POINT object giving the planet grid points.  	shadow_ptd: 		POINT object giving the shadow points.  	object_ptd: 		POINT object giving all overlay points.  	tie_ptd: 		POINT object giving the tie points.  	curve_ptd: 		POINT object giving the curve points.  	active_*_ptd: 		Returns same as above ptd outputs, except ony active arrays 		are returned.    EXAMPLE: 	(1) Open a GRIM window, load an image, and compute limb points.  	(2) At the command line, type:  		IDL> ingrid, cd=cd 		IDL> pg_repoint, [50,50], 0d, cd=cd  	GRIM should detect the change to the camera descriptor and update 	itself by recomputing the limb points and refreshing the display.    KNOWN ISSUES: 	This procedure has unresolved issues, is unreliable, behaves 	irrationally, is overly complicated, and has periodic breakdowns for 	no externally apparent reason.    STATUS: 	Has unresolved issues that need to be confronted and addressed.    SEE ALSO: 	grim, gr_draw    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/interface/ingrid.html#ingrid", "ingrid", 'routine in <a href="grim/interface/ingrid.html">ingrid.pro</a>', "ingrid.pro", "", "ingrid", "", "planegdddcdpdrdsdstdardsundodlimb_ptdring_ptdstar_ptdstation_ptdarray_ptdterm_ptdplgrid_ptdcenter_ptdobject_ptdtie_ptdcurve_ptdshadow_ptdreflection_ptdpnallgrnumactive_pdactive_rdactive_sdactive_stdactive_ardactive_xdactive_limb_ptdactive_ring_ptdactive_star_ptdactive_term_ptdactive_plgrid_ptdactive_center_ptdactive_shadow_ptdactive_reflection_ptdactive_station_ptdactive_array_ptdarg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/ipt/ipt_chisq.html", "ipt_chisq.pro", '.pro file in <a href="obj/tools/ipt/dir-overview.html">obj/tools/ipt/ directory</a>', "ipt_chisq.pro", "", "", " NAME: 	ipt_chisq    PURPOSE: 	Computes chi-squared value for given point fit parameters.    CATEGORY: 	UTIL/NV/LIB/TOOLS/IPT    CALLING SEQUENCE: 	result = ipt_chisq(dxy, dtheta, fix, pts_dx, pts_dy, pts)    ARGUMENTS:   INPUT: 	dxy:		Array (2) giving x- and y-offset solution.  	dtheta:		Scalar giving theta-offset solution.  	fix:		Array specifying which parameters to fix as 			[dx,dy,dtheta].         pts_dx:         Array (n_points) containing offset of actual                        point from predicted point in x.         pts_dy:         Array (n_points) containing offset of actual                        point from predicted point in y.         pts:            Array (2,n_points) of image coordinates corresponding                        to actual point.  	axis:		Array (2) giving image coordinates of rotation axis 			in the case of a 3-parameter fit.    OUTPUT: NONE    KEYWORDS:   INPUT: 	norm:		If set, the returned value is normalized by dividing 			it by the number of degrees of freedom.    OUTPUT: NONE    RETURN: 	The chi-squared value is returned.    STATUS: 	Completed.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 12/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/ipt/ipt_chisq.html#ipt_chisq", "ipt_chisq", 'routine in <a href="obj/tools/ipt/ipt_chisq.html">ipt_chisq.pro</a>', "ipt_chisq.pro", "", "ipt_chisq", "", "normdxydthetafixpts_dxpts_dyptsaxis", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/ipt/ipt_coeff.html", "ipt_coeff.pro", '.pro file in <a href="obj/tools/ipt/dir-overview.html">obj/tools/ipt/ directory</a>', "ipt_coeff.pro", "", "", " NAME: 	ipt_coeff    PURPOSE: 	Computes coefficients for the 2- or 3-parameter linear least-square fit.    CATEGORY: 	UTIL/NV/LIB/TOOLS/IPT    CALLING SEQUENCE: 	ipt_coeff, pts_x, pts_y, pts, axis, M=M, b=b    ARGUMENTS:   INPUT:  	pts_x:	        Value containing offset of actual 			point from predicted point in x.         pts_y:          Value containing offset of actual                        point from predicted point in y.  	pts:	        Array (2) of image coordinates corresponding 			to actual point.  	axis:		Array (2) giving image coordinates of rotation axis 			in the case of a 3-parameter fit.    OUTPUT: NONE    KEYWORDS:   INPUT: 	sigma:	Uncertainty in each point position.    OUTPUT: 	M:	3x3 matrix of coefficients for the linear fit.  	b:	3-element column vector rhs of the linear fit.    PROCEDURE: 	Since the fit has been linearized, it can be written as a matrix 	equation:  				Mx = b,  	where x is the 3-element column vector [dx, dy, dtheta] of the 	independent variables. 	This routine computes the matrix M and the 	vector b.  Once these are known, mbfit can be used to solve the 	linear system.  Furthermore, since the fit is linear, a simultaneous 	fit can be performed by simply adding together any number of 	coefficient matrices and vectors, which can also be done using 	mbfit.    RESTRICTIONS: 	The fit associated with these coefficients has been linearized 	and is only valid for small corrections.  For larger corrections, 	this procedure can be iterated.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 5/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/ipt/ipt_coeff.html#ipt_coeff", "ipt_coeff", 'routine in <a href="obj/tools/ipt/ipt_coeff.html">ipt_coeff.pro</a>', "ipt_coeff.pro", "", "ipt_coeff", "", "Mbsigmapts_xpts_yptsaxis", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/keyval_struct__define.html", "keyval_struct__define.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "keyval_struct__define.pro", "", "", " NAME: 	keyval_struct__define    PURPOSE: 	Structure defining a keyword/value pair.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	N/A    FIELDS: 	keywords_p:	Pointer to list of keywords.  	values_p:	Pointer to list of value strings.   STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/keyval_struct__define.html#keyval_struct__define", "keyval_struct__define", 'routine in <a href="obj/dat/keyval_struct__define.html">keyval_struct__define.pro</a>', "keyval_struct__define.pro", "", "keyval_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/ltcorr.html", "ltcorr.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "ltcorr.pro", "", "", " NAME:        ltcorr    PURPOSE: 	Performs a light-travel-time correction on objects for which the 	correction has not already been performed.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        ltcorr, obs_bx, targ_bx0, c=c    ARGUMENTS:   INPUT: 	obs_bx:  Any subclass of BODY describing the observer.  	targ_bx: Array(nt) of any subclass of BODY describing the targets.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	c:		Speed of light.  	iterate:	If set, then the routine will iterate to refine 			the solution.  	epsilon:	Stopping criterion: maximum allowable timing error. 			Default is 1d-7.  	invert:		If set, the inverse correction is performed.    OUTPUT: NONE    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/ltcorr.html#ltcorr", "ltcorr", 'routine in <a href="obj/tools/ltcorr.html">ltcorr.pro</a>', "ltcorr.pro", "", "ltcorr", "", "cepsiloniterateinvertobs_bx_targ_bx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_assign.html", "map_assign.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_assign.pro", "", "", " NAME: 	map_assign    PURPOSE: 	Replaces fields in a MAP object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/MAP    CALLING SEQUENCE: 	map_assign, md, <keywords>=<values>    ARGUMENTS:   INPUT: 	md:		MAP object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	MAP fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	map_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_assign.html#map_assign", "map_assign", 'routine in <a href="obj/map/map_assign.html">map_assign.pro</a>', "map_assign.pro", "", "map_assign", "", "noeventxd@map__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_center.html", "map_center.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_center.pro", "", "", " NAME: 	map_center    PURPOSE: 	Returns the center for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	center = map_center(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (2,nt) of centers associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_center.html#map_center", "map_center", 'routine in <a href="obj/map/map_center.html">map_center.pro</a>', "map_center.pro", "", "map_center", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_centric_to_graphic.html", "map_centric_to_graphic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_centric_to_graphic.pro", "", "", " NAME: 	map_centric_to_graphic    PURPOSE: 	Converts latitudes from the planetocentric to the planetographic 	convention.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts_g = map_centric_to_graphic(md, map_pts_c)    ARGUMENTS:   INPUT: 	md:	Array (nt) of map descriptors.  	map_pts_c:	Array (2,nv,nt) of map points in which the 			latitudes are planetocentric.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2,nv,nt) of map points in which the latitudes are 	planetographic.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_centric_to_graphic.html#map_centric_to_graphic", "map_centric_to_graphic", 'routine in <a href="obj/map/map_centric_to_graphic.html">map_centric_to_graphic.pro</a>', "map_centric_to_graphic.pro", "", "map_centric_to_graphic", "", "mdmap_pts0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_condense.html", "map_condense.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_condense.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_condense.html#map_condense", "map_condense", 'routine in <a href="obj/map/map_condense.html">map_condense.pro</a>', "map_condense.pro", "", "map_condense", "", "mdbounds", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_create_descriptors.html", "map_create_descriptors.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_create_descriptors.pro", "", "", " NAME: 	map_create_descriptors    PURPOSE: 	Init method for the MAP class.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	md = map_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	Number of descriptors to create.    OUTPUT: NONE    KEYWORDS (in addition to those accepted by all superclasses):   INPUT: 	md:	Map descriptor(s) to initialize, instead of creating a new one.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	type:	Array (1 x n) of strings giving the map types.  	units:	Array (2 x n) giving the map units.  	size:	Array (2 x n) giving the map sizes.  	scale:	Array (1 x n) giving the map scales.  	center:	Array (2 x n) giving the map centers.  	range:	Array (2x2 x n) giving the map centers.  	origin:	Array (2 x n) giving the map origins.  	rotate:	Array (1 x n) giving the map rotate codes.  	graphic: Array (1 x n) giving the map graphic flags.  	radii:	Array (3 x n) giving the map ellipsoid radii.  	radii:	Array (1 x n) of pointers giving the map functon data.     OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized disk descriptors, depending 	on the presence of the dkd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_create_descriptors.html#map_create_descriptors", "map_create_descriptors", 'routine in <a href="obj/map/map_create_descriptors.html">map_create_descriptors.pro</a>', "map_create_descriptors.pro", "", "map_create_descriptors", "", "crdmdn@map__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_fn_data.html", "map_fn_data.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_fn_data.pro", "", "", " NAME: 	map_fn_data    PURPOSE: 	Returns the function data for a map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	data = map_fn_data(md)    ARGUMENTS:   INPUT: NONE 	md:	 Map descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Function data associated with the given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Adapted by:	Spitale, 7/2016; adapted from map_fn_data_p   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_fn_data.html#map_fn_data", "map_fn_data", 'routine in <a href="obj/map/map_fn_data.html">map_fn_data.pro</a>', "map_fn_data.pro", "", "map_fn_data", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_fn_image_to_map.html", "map_fn_image_to_map.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_fn_image_to_map.pro", "", "", " NAME: 	map_fn_image_to_map    PURPOSE: 	Returns the name of the image->map function for each given map 	descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	fn_image_to_map = map_fn_image_to_map(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of image->map function names associated with each given 	map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_fn_image_to_map.html#map_fn_image_to_map", "map_fn_image_to_map", 'routine in <a href="obj/map/map_fn_image_to_map.html">map_fn_image_to_map.pro</a>', "map_fn_image_to_map.pro", "", "map_fn_image_to_map", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_fn_map_to_image.html", "map_fn_map_to_image.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_fn_map_to_image.pro", "", "", " NAME: 	map_fn_map_to_image    PURPOSE: 	Returns the name of the map->image function for each given map 	descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	fn_image_to_map = map_fn_image_to_map(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of map->image function names associated with each given 	map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_fn_map_to_image.html#map_fn_map_to_image", "map_fn_map_to_image", 'routine in <a href="obj/map/map_fn_map_to_image.html">map_fn_map_to_image.pro</a>', "map_fn_map_to_image.pro", "", "map_fn_map_to_image", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_fn_valid.html", "map_fn_valid.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_fn_valid.pro", "", "", " NAME: 	map_fn_valid    PURPOSE: 	Returns the name of the map->image validation function for each given 	map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	fn_valid = map_fn_image_to_map(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of map->image validation function names associated with each given 	map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2012  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_fn_valid.html#map_fn_valid", "map_fn_valid", 'routine in <a href="obj/map/map_fn_valid.html">map_fn_valid.pro</a>', "map_fn_valid.pro", "", "map_fn_valid", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_get_grid_points.html", "map_get_grid_points.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_get_grid_points.pro", "", "", " NAME: 	map_get_grid_points    PURPOSE: 	Generates a lat/lon grid of points.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_get_grid_points(lat=lat, lon=lon)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	lat:	Array giving the latitudes for each constant latitude line.  	lon:	Array giving the longitudes for each constant longitude line.  	nt:	Number of grids to produce.  	scan_lat:	Latitudes to scan for each constant longitude line.  	scan_lon:	Longitudes to scan for each constant latitude line.    OUTPUT: NONE    RETURN: 	Array (2,np,nt) of map coordinate points where np is the number of 	scan_lats times the number of scan_lons.    STATUS: 	Complete  	Adapted by:	Spitale, 5/2016    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_get_grid_points.html#map_get_grid_points", "map_get_grid_points", 'routine in <a href="obj/map/map_get_grid_points.html">map_get_grid_points.pro</a>', "map_get_grid_points.pro", "", "map_get_grid_points", "", "latlonntscan_latscan_lon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_get_ranges.html", "map_get_ranges.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_get_ranges.pro", "", "", " NAME: 	map_get_ranges    PURPOSE: 	Returns ranges of valid coordinates for the given MAP object.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	ranges = map_get_ranges(md)    ARGUMENTS:   INPUT: 	md:	 MAP descriptor.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (2 x 2) giving the ranges in latitude, longitude.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_get_ranges.html#map_get_ranges", "map_get_ranges", 'routine in <a href="obj/map/map_get_ranges.html">map_get_ranges.pro</a>', "map_get_ranges.pro", "", "map_get_ranges", "", "md", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_graphic.html", "map_graphic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_graphic.pro", "", "", " NAME: 	map_graphic    PURPOSE: 	Returns the graphic flag for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	graphic = map_graphic(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of graphic flags associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_graphic.html#map_graphic", "map_graphic", 'routine in <a href="obj/map/map_graphic.html">map_graphic.pro</a>', "map_graphic.pro", "", "map_graphic", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_graphic_to_centric.html", "map_graphic_to_centric.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_graphic_to_centric.pro", "", "", " NAME: 	map_graphic_to_centric    PURPOSE: 	Converts latitudes from the planetographic to the planetocentric 	convention.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts_c = map_graphic_to_centric(md, map_pts_g)    ARGUMENTS:   INPUT: 	md:	Array (nt) of map descriptors.  	map_pts_g:	Array (2,nv,nt) of map points in which the 			latitudes are planetographic.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2,nv,nt) of map points in which the latitudes are 	planetocentric.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_graphic_to_centric.html#map_graphic_to_centric", "map_graphic_to_centric", 'routine in <a href="obj/map/map_graphic_to_centric.html">map_graphic_to_centric.pro</a>', "map_graphic_to_centric.pro", "", "map_graphic_to_centric", "", "mdmap_pts0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map.html", "map_image_to_map.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map.pro", "", "", " NAME: 	map_image_to_map    PURPOSE: 	Transforms the given image points to map coordinate points.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map.html#map_image_to_map", "map_image_to_map", 'routine in <a href="obj/map/map_image_to_map.html">map_image_to_map.pro</a>', "map_image_to_map.pro", "", "map_image_to_map", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_equatorial_ring.html", "map_image_to_map_equatorial_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_equatorial_ring.pro", "", "", " NAME: 	map_image_to_map_rectangular    PURPOSE: 	Transforms the given image points to map coordinate points 	using a rectangular projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_rectangular(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		lat = (y - origin[1])/a[0] + center[0]  		lon = (x - origin[0])/a[1] + center[1]  	where the latitude equation is solved iteratively.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_equatorial_ring.html#map_image_to_map_equatorial_ring", "map_image_to_map_equatorial_ring", 'routine in <a href="obj/map/map_image_to_map_equatorial_ring.html">map_image_to_map_equatorial_ring.pro</a>', "map_image_to_map_equatorial_ring.pro", "", "map_image_to_map_equatorial_ring", "", "validmdimage_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_equatorial_ring.html#_map_image_to_map_rectangular", "_map_image_to_map_rectangular", 'routine in <a href="obj/map/map_image_to_map_equatorial_ring.html">map_image_to_map_equatorial_ring.pro</a>', "map_image_to_map_equatorial_ring.pro", "", "_map_image_to_map_rectangular", "", "validmdimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_mercator.html", "map_image_to_map_mercator.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_mercator.pro", "", "", " NAME: 	map_image_to_map_mercator    PURPOSE: 	Transforms the given image points to map coordinate points 	using a mercator projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_mercator(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in a mercator projection. 	This projection results from projecting a sphere onto a cylinder 	that is tangent at the equator.  The scale is true along the equator 	only.  Areas are distorted, especially near the poles.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	and:  		e = sqrt(1 - (A/(B+C)/2)^2),  	where A, B, and C are the triaxial ellipsoid radii, the 	transformation is:  		pi/2 - 2*atan(exp(-y/a[0]) * 		         ((1 - e*sin(lat))/(1 + e*sin(lat)))^(e/2))  		lon = x/a[1] + center[1]  	where the latitude equation is solved iteratively.  	See [1], p. 45 for the mathematical derivation.  	[1] Snyder (1987) 	    Map projections -- A working manual 	    USGS professional paper 1395    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_mercator.html#immc_fn", "immc_fn", 'routine in <a href="obj/map/map_image_to_map_mercator.html">map_image_to_map_mercator.pro</a>', "map_image_to_map_mercator.pro", "", "immc_fn", "", "xdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_mercator.html#map_image_to_map_mercator", "map_image_to_map_mercator", 'routine in <a href="obj/map/map_image_to_map_mercator.html">map_image_to_map_mercator.pro</a>', "map_image_to_map_mercator.pro", "", "map_image_to_map_mercator", "", "validmd_image_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_mercator.html#_map_image_to_map_mercator", "_map_image_to_map_mercator", 'routine in <a href="obj/map/map_image_to_map_mercator.html">map_image_to_map_mercator.pro</a>', "map_image_to_map_mercator.pro", "", "_map_image_to_map_mercator", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_mollweide.html", "map_image_to_map_mollweide.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_mollweide.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_mollweide.html#map_image_to_map_mollweide", "map_image_to_map_mollweide", 'routine in <a href="obj/map/map_image_to_map_mollweide.html">map_image_to_map_mollweide.pro</a>', "map_image_to_map_mollweide.pro", "", "map_image_to_map_mollweide", "", "validmd_image_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_mollweide.html#_map_image_to_map_mollweide", "_map_image_to_map_mollweide", 'routine in <a href="obj/map/map_image_to_map_mollweide.html">map_image_to_map_mollweide.pro</a>', "map_image_to_map_mollweide.pro", "", "_map_image_to_map_mollweide", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_orthographic.html", "map_image_to_map_orthographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_orthographic.pro", "", "", " NAME: 	map_image_to_map_orthographic    PURPOSE: 	Transforms the given image points to map coordinate points 	using an orthographic projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_orthographic(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in an orthographic 	projection.  This projection portrays a planet as seen from a 	great distance.  Scale is true only at the map center.  Areas 	are distorted, especially away from the map center.  	With:  	  R = min(size[0],size[1])/2 * scale,  	and:  	  rho = sqrt(x^2 + y^2),  	and:  	  c = asin(rho/R),  	the transformation is:  	  lat = asin( cos(c)*sin(center[0]) + 	                    y*sin(c)*cos(center[0])/rho ) / units[0]  	  lon = center[1] + 	          atan( x*sin(c)/(rho*cos(center[0])*cos(c) - 	                        y*sin(center[0])*sin(c)) ) + units[1]   	See [1], p. 150 for the mathematical derivation.  	[1] Snyder (1987) 	    Map projections -- A working manual 	    USGS professional paper 1395     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_orthographic.html#map_image_to_map_orthographic", "map_image_to_map_orthographic", 'routine in <a href="obj/map/map_image_to_map_orthographic.html">map_image_to_map_orthographic.pro</a>', "map_image_to_map_orthographic.pro", "", "map_image_to_map_orthographic", "", "validmd_image_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_orthographic.html#_map_image_to_map_orthographic", "_map_image_to_map_orthographic", 'routine in <a href="obj/map/map_image_to_map_orthographic.html">map_image_to_map_orthographic.pro</a>', "map_image_to_map_orthographic.pro", "", "_map_image_to_map_orthographic", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_orthographic_disk.html", "map_image_to_map_orthographic_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_orthographic_disk.pro", "", "", " NAME: 	map_image_to_map_orthographic_disk    PURPOSE: 	Transforms the given image points to map coordinate points 	using an orthographic projection for a disk.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_orthographic_disk(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in an orthographic disk 	projection.  This projection portrays a disk as seen from a 	great distance.  Scale is uniform, but it is only true if the 	projection is polar.  Likewise, areas are distorted for non-polar 	projections.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_orthographic_disk.html#map_image_to_map_orthographic_disk", "map_image_to_map_orthographic_disk", 'routine in <a href="obj/map/map_image_to_map_orthographic_disk.html">map_image_to_map_orthographic_disk.pro</a>', "map_image_to_map_orthographic_disk.pro", "", "map_image_to_map_orthographic_disk", "", "validmd_image_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_orthographic_disk.html#_map_image_to_map_orthographic_disk", "_map_image_to_map_orthographic_disk", 'routine in <a href="obj/map/map_image_to_map_orthographic_disk.html">map_image_to_map_orthographic_disk.pro</a>', "map_image_to_map_orthographic_disk.pro", "", "_map_image_to_map_orthographic_disk", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_rectangular.html", "map_image_to_map_rectangular.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_rectangular.pro", "", "", " NAME: 	map_image_to_map_rectangular    PURPOSE: 	Transforms the given image points to map coordinate points 	using a rectangular projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_rectangular(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		lat = (y - origin[1])/a[0] + center[0]  		lon = (x - origin[0])/a[1] + center[1]  	where the latitude equation is solved iteratively.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_rectangular.html#map_image_to_map_rectangular", "map_image_to_map_rectangular", 'routine in <a href="obj/map/map_image_to_map_rectangular.html">map_image_to_map_rectangular.pro</a>', "map_image_to_map_rectangular.pro", "", "map_image_to_map_rectangular", "", "validmdimage_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_rectangular.html#_map_image_to_map_rectangular", "_map_image_to_map_rectangular", 'routine in <a href="obj/map/map_image_to_map_rectangular.html">map_image_to_map_rectangular.pro</a>', "map_image_to_map_rectangular.pro", "", "_map_image_to_map_rectangular", "", "validmdimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_rectangular_disk.html", "map_image_to_map_rectangular_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_rectangular_disk.pro", "", "", " NAME: 	map_image_to_map_rectangular_disk    PURPOSE: 	Transforms the given image points to map coordinate points 	using a rectangular projection on a disk.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_rectangular_disk(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		lat = (y - origin[1])/a[0] + center[0]  		lon = (x - origin[0])/a[1] + center[1]  	where the latitude equation is solved iteratively.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_rectangular_disk.html#map_image_to_map_rectangular_disk", "map_image_to_map_rectangular_disk", 'routine in <a href="obj/map/map_image_to_map_rectangular_disk.html">map_image_to_map_rectangular_disk.pro</a>', "map_image_to_map_rectangular_disk.pro", "", "map_image_to_map_rectangular_disk", "", "validmdimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_ring.html", "map_image_to_map_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_ring.pro", "", "", " NAME: 	map_image_to_map_ring    PURPOSE: 	Transforms the given image points to map coordinate points 	using a rectangular projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_rectangular(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		lat = (y - origin[1])/a[0] + center[0]  		lon = (x - origin[0])/a[1] + center[1]  	where the latitude equation is solved iteratively.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_ring.html#map_image_to_map_ring", "map_image_to_map_ring", 'routine in <a href="obj/map/map_image_to_map_ring.html">map_image_to_map_ring.pro</a>', "map_image_to_map_ring.pro", "", "map_image_to_map_ring", "", "validmdimage_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_ring.html#_map_image_to_map_rectangular", "_map_image_to_map_rectangular", 'routine in <a href="obj/map/map_image_to_map_ring.html">map_image_to_map_ring.pro</a>', "map_image_to_map_ring.pro", "", "_map_image_to_map_rectangular", "", "validmdimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_sinusoidal.html", "map_image_to_map_sinusoidal.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_sinusoidal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_sinusoidal.html#map_image_to_map_sinusoidal", "map_image_to_map_sinusoidal", 'routine in <a href="obj/map/map_image_to_map_sinusoidal.html">map_image_to_map_sinusoidal.pro</a>', "map_image_to_map_sinusoidal.pro", "", "map_image_to_map_sinusoidal", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_stereographic.html", "map_image_to_map_stereographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_stereographic.pro", "", "", " NAME: 	map_image_to_map_stereographic    PURPOSE: 	Transforms the given image points to map coordinate points 	using an stereographic projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_stereographic(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in an stereographic 	projection.  This projection results from the projection through 	a sphere onto a plane, from a point on the surface of the sphere. 	Scale is true only at the map center.  Areas are distorted, 	especially away from the map center.  	With:  	  a = [size[0],size[1]]/4 * scale,  	and:  	  e = sqrt(1 - (A/(B+C)/2)^2),  	where A, B, and C are the triaxial ellipsoid radii, and:  	  m1 = cos(center[0]]) / sqrt(1 - e^2*sin(center[0])^2)  	  rho = sqrt(x^2 + y^2)  	  X1 = 2*atan(tan(pi/4 + center[0]/2) * 	       ((1 - e*sin(center[0]))/(1 + e*sin(center[0])))^(e/2)) - pi/2d  	  ce = 2*atan(rho*cos(X1), 2*a*scale*m1)  	  X = asin(cos(ce)*sin(X1) + y*sin(ce)*cos(X1)/rho)  	the transformation is:  	  2*atan(tan(pi/4 + X/2) * $ 	              ((1 + e*sin(lat))/(1 - e*sin(lat)))^(e/2) ) - pi/2  	  lon = center[1] + atan( x*sin(ce) / 	          rho*cos(X1)*cos(ce) - y*sin(X1)*sin(ce) ) / units[1]  	where the latitude equation is solved iteratively.  	See [1], p. 161 for the mathematical derivation.  	[1] Snyder (1987) 	    Map projections -- A working manual 	    USGS professional paper 1395    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_stereographic.html#imst_fn", "imst_fn", 'routine in <a href="obj/map/map_image_to_map_stereographic.html">map_image_to_map_stereographic.pro</a>', "map_image_to_map_stereographic.pro", "", "imst_fn", "", "xdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_stereographic.html#map_image_to_map_stereographic", "map_image_to_map_stereographic", 'routine in <a href="obj/map/map_image_to_map_stereographic.html">map_image_to_map_stereographic.pro</a>', "map_image_to_map_stereographic.pro", "", "map_image_to_map_stereographic", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_lookup_defaults.html", "map_lookup_defaults.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_lookup_defaults.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_lookup_defaults.html#map_lookup_defaults", "map_lookup_defaults", 'routine in <a href="obj/map/map_lookup_defaults.html">map_lookup_defaults.pro</a>', "map_lookup_defaults.pro", "", "map_lookup_defaults", "", "md0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image.html", "map_map_to_image.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image.pro", "", "", " NAME: 	map_map_to_image    PURPOSE: 	Transforms the given map points to map image points.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image.html#map_map_to_image", "map_map_to_image", 'routine in <a href="obj/map/map_map_to_image.html">map_map_to_image.pro</a>', "map_map_to_image.pro", "", "map_map_to_image", "", "validnowrapallmd_map_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_equatorial_ring.html", "map_map_to_image_equatorial_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_equatorial_ring.pro", "", "", " NAME: 	map_map_to_image_rectangular    PURPOSE: 	Transforms the given map points to map image points using a 	rectangular projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_rectangular(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		x = a[1] * (lon - center[1]) + origin[0]  		y = a[0] * (lat - center[0]) + origin[1]    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_equatorial_ring.html#map_map_to_image_equatorial_ring", "map_map_to_image_equatorial_ring", 'routine in <a href="obj/map/map_map_to_image_equatorial_ring.html">map_map_to_image_equatorial_ring.pro</a>', "map_map_to_image_equatorial_ring.pro", "", "map_map_to_image_equatorial_ring", "", "mdmap_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_equatorial_ring.html#_map_map_to_image_rectangular", "_map_map_to_image_rectangular", 'routine in <a href="obj/map/map_map_to_image_equatorial_ring.html">map_map_to_image_equatorial_ring.pro</a>', "map_map_to_image_equatorial_ring.pro", "", "_map_map_to_image_rectangular", "", "validmdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_mercator.html", "map_map_to_image_mercator.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_mercator.pro", "", "", " NAME: 	map_map_to_image_mercator    PURPOSE: 	Transforms the given map points to map image points using the 	mercator projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_mercator(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in a mercator projection. 	This projection results from projecting a sphere onto a cylinder 	that is tangent at the equator.  The scale is true along the equator 	only.  Areas are distorted, especially near the poles.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	and:  		e = sqrt(1 - (A/(B+C)/2)^2),  	where A, B, and C are the triaxial ellipsoid radii, the 	transformation is:  		x = a[1] * (lon - center[1]) + origin[0]  		y = a[0] * log( tan(pi/4 + lat/2) * 		  ( (1 - e*sin(lat))/(1 + e*sin(lat)) )^(e/2) ) + origin[1]   	See [1], p. 44 for the mathematical derivation.  	[1] Snyder (1987) 	    Map projections -- A working manual 	    USGS professional paper 1395    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_mercator.html#map_map_to_image_mercator", "map_map_to_image_mercator", 'routine in <a href="obj/map/map_map_to_image_mercator.html">map_map_to_image_mercator.pro</a>', "map_map_to_image_mercator.pro", "", "map_map_to_image_mercator", "", "mdmap_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_mercator.html#_map_map_to_image_mercator", "_map_map_to_image_mercator", 'routine in <a href="obj/map/map_map_to_image_mercator.html">map_map_to_image_mercator.pro</a>', "map_map_to_image_mercator.pro", "", "_map_map_to_image_mercator", "", "validmdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_mollweide.html", "map_map_to_image_mollweide.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_mollweide.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_mollweide.html#mimw_fn", "mimw_fn", 'routine in <a href="obj/map/map_map_to_image_mollweide.html">map_map_to_image_mollweide.pro</a>', "map_map_to_image_mollweide.pro", "", "mimw_fn", "", "xdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_mollweide.html#map_map_to_image_mollweide", "map_map_to_image_mollweide", 'routine in <a href="obj/map/map_map_to_image_mollweide.html">map_map_to_image_mollweide.pro</a>', "map_map_to_image_mollweide.pro", "", "map_map_to_image_mollweide", "", "mdmap_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_mollweide.html#_map_map_to_image_mollweide", "_map_map_to_image_mollweide", 'routine in <a href="obj/map/map_map_to_image_mollweide.html">map_map_to_image_mollweide.pro</a>', "map_map_to_image_mollweide.pro", "", "_map_map_to_image_mollweide", "", "validmdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_orthographic.html", "map_map_to_image_orthographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_orthographic.pro", "", "", " NAME: 	map_map_to_image_orthographic    PURPOSE: 	Transforms the given map points to map image points using the 	orthographic projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_orthographic(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in an orthographic 	projection.  This projection portrays a planet as seen from a 	great distance.  Scale is true only at the map center.  Areas 	are distorted, especially away from the map center.  	With:  	  R = min(size[0],size[1])/2 * scale  	the transformation is:  	  x = R * cos(lat/units[0]) * sin(lon/units[1] 0 center[1]) + origin[0]  	  y = R * 	     ( cos(center[0])*sin(lat/units[0]) - 	        sin(center[0])*cos(lat/units[0])*cos(lon - center[1]) ) + 	                                                            origin[1]  	See [1], p. 149 for the mathematical derivation.  	[1] Snyder (1987) 	    Map projections -- A working manual 	    USGS professional paper 1395    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_orthographic.html#map_map_to_image_orthographic", "map_map_to_image_orthographic", 'routine in <a href="obj/map/map_map_to_image_orthographic.html">map_map_to_image_orthographic.pro</a>', "map_map_to_image_orthographic.pro", "", "map_map_to_image_orthographic", "", "mdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_orthographic_disk.html", "map_map_to_image_orthographic_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_orthographic_disk.pro", "", "", " NAME: 	map_map_to_image_orthographic_disk    PURPOSE: 	Transforms the given map points to map image points using the 	orthographic projection on a disk.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_orthographic_disk(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in an orthographic disk 	projection.  This projection portrays a disk as seen from a 	great distance.  Scale is uniform, but it is only true if the 	projection is polar.  Likewise, areas are distorted for non-polar 	projections.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_orthographic_disk.html#map_map_to_image_orthographic_disk", "map_map_to_image_orthographic_disk", 'routine in <a href="obj/map/map_map_to_image_orthographic_disk.html">map_map_to_image_orthographic_disk.pro</a>', "map_map_to_image_orthographic_disk.pro", "", "map_map_to_image_orthographic_disk", "", "mdmap_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_orthographic_disk.html#_map_map_to_image_orthographic_disk", "_map_map_to_image_orthographic_disk", 'routine in <a href="obj/map/map_map_to_image_orthographic_disk.html">map_map_to_image_orthographic_disk.pro</a>', "map_map_to_image_orthographic_disk.pro", "", "_map_map_to_image_orthographic_disk", "", "validmdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_rectangular.html", "map_map_to_image_rectangular.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_rectangular.pro", "", "", " NAME: 	map_map_to_image_rectangular    PURPOSE: 	Transforms the given map points to map image points using a 	rectangular projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_rectangular(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		x = a[1] * (lon - center[1]) + origin[0]  		y = a[0] * (lat - center[0]) + origin[1]    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_rectangular.html#map_map_to_image_rectangular", "map_map_to_image_rectangular", 'routine in <a href="obj/map/map_map_to_image_rectangular.html">map_map_to_image_rectangular.pro</a>', "map_map_to_image_rectangular.pro", "", "map_map_to_image_rectangular", "", "mdmap_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_rectangular.html#_map_map_to_image_rectangular", "_map_map_to_image_rectangular", 'routine in <a href="obj/map/map_map_to_image_rectangular.html">map_map_to_image_rectangular.pro</a>', "map_map_to_image_rectangular.pro", "", "_map_map_to_image_rectangular", "", "validmdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_rectangular_disk.html", "map_map_to_image_rectangular_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_rectangular_disk.pro", "", "", " NAME: 	map_map_to_image_rectangular_disk    PURPOSE: 	Transforms the given map points to map image points using a 	rectangular projection on a disk.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_rectangular_disk(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		x = a[1] * (lon - center[1]) + origin[0]  		y = a[0] * (lat - center[0]) + origin[1]    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_rectangular_disk.html#map_map_to_image_rectangular_disk", "map_map_to_image_rectangular_disk", 'routine in <a href="obj/map/map_map_to_image_rectangular_disk.html">map_map_to_image_rectangular_disk.pro</a>', "map_map_to_image_rectangular_disk.pro", "", "map_map_to_image_rectangular_disk", "", "mdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_ring.html", "map_map_to_image_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_ring.pro", "", "", " NAME: 	map_map_to_image_ring    PURPOSE: 	Transforms the given map points to map image points using a 	rectangular projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_rectangular(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		x = a[1] * (lon - center[1]) + origin[0]  		y = a[0] * (lat - center[0]) + origin[1]    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_ring.html#map_map_to_image_ring", "map_map_to_image_ring", 'routine in <a href="obj/map/map_map_to_image_ring.html">map_map_to_image_ring.pro</a>', "map_map_to_image_ring.pro", "", "map_map_to_image_ring", "", "mdmap_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_ring.html#_map_map_to_image_rectangular", "_map_map_to_image_rectangular", 'routine in <a href="obj/map/map_map_to_image_ring.html">map_map_to_image_ring.pro</a>', "map_map_to_image_ring.pro", "", "_map_map_to_image_rectangular", "", "validmdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_sinusoidal.html", "map_map_to_image_sinusoidal.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_sinusoidal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_sinusoidal.html#map_map_to_image_sinusoidal", "map_map_to_image_sinusoidal", 'routine in <a href="obj/map/map_map_to_image_sinusoidal.html">map_map_to_image_sinusoidal.pro</a>', "map_map_to_image_sinusoidal.pro", "", "map_map_to_image_sinusoidal", "", "mdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_stereographic.html", "map_map_to_image_stereographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_stereographic.pro", "", "", " NAME: 	map_map_to_image_stereographic    PURPOSE: 	Transforms the given map points to map image points using the 	stereographic projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_stereographic(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in an stereographic 	projection.  This projection results from the projection through 	a sphere onto a plane, from a point on the surface of the sphere. 	Scale is true only at the map center.  Areas are distorted, 	especially away from the map center.  	With:  	  a = [size[0],size[1]]/4 * scale,  	and:  	  e = sqrt(1 - (A/(B+C)/2)^2),  	where A, B, and C are the triaxial ellipsoid radii, and:  	  lat0 = lat / units[0]  	  lon0 = lon / units[1]  	  m1 = cos(center[0]]) / sqrt(1 - e^2*sin(center[0])^2)  	  X = 2*atan(tan(pi/4 + lat/2) * $ 	       ((1 - e*sin(lat0))/(1 + e*sin(lat0)))^(e/2)) - pi/2  	  X1 = 2*atan(tan(pi/4 + center[0]/2) * 	       ((1 - e*sin(center[0]))/(1 + e*sin(center[0])))^(e/2)) - pi/2d  	  A = 2*a*scale*m1 / 	   ( cos(X1)*(1 + sin(X1)*sin(X) + cos(X1)*cos(X)*cos(lon0 - center[1])) )  	the transformation is:  	  x = A * cos(X)*sin(lon0 - center[1]) + origin[0]  	  y = A * ( cos(X1)*sin(X) - sin(X1)*cos(X)*sin(lon0 - center[1]) ) + 	                                                              origin[1]  	See [1], p. 160 for the mathematical derivation.  	[1] Snyder (1987) 	    Map projections -- A working manual 	    USGS professional paper 1395    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_stereographic.html#map_map_to_image_stereographic", "map_map_to_image_stereographic", 'routine in <a href="obj/map/map_map_to_image_stereographic.html">map_map_to_image_stereographic.pro</a>', "map_map_to_image_stereographic.pro", "", "map_map_to_image_stereographic", "", "mdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_match_type.html", "map_match_type.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_match_type.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_match_type.html#map_match_type", "map_match_type", 'routine in <a href="obj/map/map_match_type.html">map_match_type.pro</a>', "map_match_type.pro", "", "map_match_type", "", "_type", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_optimize.html", "map_optimize.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_optimize.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_optimize.html#map_optimize", "map_optimize", 'routine in <a href="obj/map/map_optimize.html">map_optimize.pro</a>', "map_optimize.pro", "", "map_optimize", "", "mdtypesizeoriginlatminlonminradmin", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_origin.html", "map_origin.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_origin.pro", "", "", " NAME: 	map_origin    PURPOSE: 	Returns the origin for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	origin = map_origin(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (2,nt) of origins associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_origin.html#map_origin", "map_origin", 'routine in <a href="obj/map/map_origin.html">map_origin.pro</a>', "map_origin.pro", "", "map_origin", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_pole.html", "map_pole.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_pole.pro", "", "", " NAME: 	map_pole    PURPOSE: 	Returns the pole for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	pole = map_pole(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of ominas_map_pole structs associated with each given map 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_pole.html#map_pole", "map_pole", 'routine in <a href="obj/map/map_pole.html">map_pole.pro</a>', "map_pole.pro", "", "map_pole", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_query.html", "map_query.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_query.pro", "", "", " NAME: 	map_query    PURPOSE: 	Returns the fields associated with a MAP object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/MAP    CALLING SEQUENCE: 	map_query, md, <keywords>=<values>    ARGUMENTS:   INPUT: 	md:	MAP object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	MAP object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_query.html#map_query", "map_query", 'routine in <a href="obj/map/map_query.html">map_query.pro</a>', "map_query.pro", "", "map_query", "", "conditioncatnoeventxd@map__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_radii.html", "map_radii.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_radii.pro", "", "", " NAME: 	map_radii    PURPOSE: 	Returns the rference radii for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	radii = map_radii(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (3,nt) of refernce radii associated with each given map 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_radii.html#map_radii", "map_radii", 'routine in <a href="obj/map/map_radii.html">map_radii.pro</a>', "map_radii.pro", "", "map_radii", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_radii_to_ecc.html", "map_radii_to_ecc.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_radii_to_ecc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_radii_to_ecc.html#map_radii_to_ecc", "map_radii_to_ecc", 'routine in <a href="obj/map/map_radii_to_ecc.html">map_radii_to_ecc.pro</a>', "map_radii_to_ecc.pro", "", "map_radii_to_ecc", "", "radradii", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/map_radii_to_ecc.html#___map_radii_to_ecc", "___map_radii_to_ecc", 'routine in <a href="obj/map/map_radii_to_ecc.html">map_radii_to_ecc.pro</a>', "map_radii_to_ecc.pro", "", "___map_radii_to_ecc", "", "radii", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_range.html", "map_range.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_range.pro", "", "", " NAME: 	map_range    PURPOSE: 	Returns the range for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	range = map_range(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (2,2,nt) of ranges associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_range.html#map_range", "map_range", 'routine in <a href="obj/map/map_range.html">map_range.pro</a>', "map_range.pro", "", "map_range", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_replicate.html", "map_replicate.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_replicate.pro", "", "", " NAME: 	map_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	mds = map_replicate(md, dim)    ARGUMENTS:   INPUT: 	md:	 MAP descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_replicate.html#map_replicate", "map_replicate", 'routine in <a href="obj/map/map_replicate.html">map_replicate.pro</a>', "map_replicate.pro", "", "map_replicate", "", "mddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_rotate.html", "map_rotate.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_rotate.pro", "", "", " NAME: 	map_rotate    PURPOSE: 	Returns the rotate value for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	rotate = map_rotate(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of rotate values associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_rotate.html#map_rotate", "map_rotate", 'routine in <a href="obj/map/map_rotate.html">map_rotate.pro</a>', "map_rotate.pro", "", "map_rotate", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_scale.html", "map_scale.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_scale.pro", "", "", " NAME: 	map_scale    PURPOSE: 	Returns the scale factor for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	scale = map_scale(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of scale factors associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_scale.html#map_scale", "map_scale", 'routine in <a href="obj/map/map_scale.html">map_scale.pro</a>', "map_scale.pro", "", "map_scale", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/map_set_bounds.html", "map_set_bounds.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "map_set_bounds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/map_set_bounds.html#map_set_bounds", "map_set_bounds", 'routine in <a href="obj/tools/map_set_bounds.html">map_set_bounds.pro</a>', "map_set_bounds.pro", "", "map_set_bounds", "", "mdbounds", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_center.html", "map_set_center.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_center.pro", "", "", " NAME: 	map_set_center    PURPOSE: 	Replaces the center for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_center, md, center    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	center:	 Array (2,nt) of new map centers.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_center.html#map_set_center", "map_set_center", 'routine in <a href="obj/map/map_set_center.html">map_set_center.pro</a>', "map_set_center.pro", "", "map_set_center", "", "noeventmdcenter", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_fn_data.html", "map_set_fn_data.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_fn_data.pro", "", "", " NAME: 	map_set_fn_data    PURPOSE: 	Replaces the function data for a map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_fn_data, md, data    ARGUMENTS:   INPUT: 	md:	 Map descriptor.  	data:	 New function data.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Adapted by:	Spitale, 7/2016; adapted from map_set_fn_data_p   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_fn_data.html#map_set_fn_data", "map_set_fn_data", 'routine in <a href="obj/map/map_set_fn_data.html">map_set_fn_data.pro</a>', "map_set_fn_data.pro", "", "map_set_fn_data", "", "noeventmddata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_fn_image_to_map.html", "map_set_fn_image_to_map.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_fn_image_to_map.pro", "", "", " NAME: 	map_set_fn_image_to_map    PURPOSE: 	Replaces the name of the image->map function for each given map 	descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_fn_image_to_map, md, fn    ARGUMENTS:   INPUT: NONE 	md:	Array (nt) of map descriptors.  	fn:	Array (nt) of function names.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_fn_image_to_map.html#map_set_fn_image_to_map", "map_set_fn_image_to_map", 'routine in <a href="obj/map/map_set_fn_image_to_map.html">map_set_fn_image_to_map.pro</a>', "map_set_fn_image_to_map.pro", "", "map_set_fn_image_to_map", "", "noeventmdfn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_fn_map_to_image.html", "map_set_fn_map_to_image.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_fn_map_to_image.pro", "", "", " NAME: 	map_set_fn_map_to_image    PURPOSE: 	Replaces the name of the map->image function for each given map 	descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_fn_map_to_image, md, fn    ARGUMENTS:   INPUT: NONE 	md:	Array (nt) of map descriptors.  	fn:	Array (nt) of function names.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_fn_map_to_image.html#map_set_fn_map_to_image", "map_set_fn_map_to_image", 'routine in <a href="obj/map/map_set_fn_map_to_image.html">map_set_fn_map_to_image.pro</a>', "map_set_fn_map_to_image.pro", "", "map_set_fn_map_to_image", "", "noeventmdfn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_graphic.html", "map_set_graphic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_graphic.pro", "", "", " NAME: 	map_set_graphic    PURPOSE: 	Replaces the graphic flag for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_graphic, md, graphic    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	graphic:	 Array (nt) of new graphic flags.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_graphic.html#map_set_graphic", "map_set_graphic", 'routine in <a href="obj/map/map_set_graphic.html">map_set_graphic.pro</a>', "map_set_graphic.pro", "", "map_set_graphic", "", "noeventmdgraphic", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_origin.html", "map_set_origin.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_origin.pro", "", "", " NAME: 	map_set_origin    PURPOSE: 	Replaces the origin for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_origin, md, origin    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	origin:	 Array (2,nt) of new map origins.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_origin.html#map_set_origin", "map_set_origin", 'routine in <a href="obj/map/map_set_origin.html">map_set_origin.pro</a>', "map_set_origin.pro", "", "map_set_origin", "", "noeventmdorigin", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_pole.html", "map_set_pole.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_pole.pro", "", "", " NAME: 	map_set_pole    PURPOSE: 	Replaces the pole for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_pole, md, pole    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	pole:	 Array (nt) of new ominas_map_pole structs.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_pole.html#map_set_pole", "map_set_pole", 'routine in <a href="obj/map/map_set_pole.html">map_set_pole.pro</a>', "map_set_pole.pro", "", "map_set_pole", "", "noeventmdpole", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_radii.html", "map_set_radii.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_radii.pro", "", "", " NAME: 	map_set_radii    PURPOSE: 	Replaces the reference radii for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_radii, md, radii    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	radii:	 Array (3,nt) of new reference radii.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_radii.html#map_set_radii", "map_set_radii", 'routine in <a href="obj/map/map_set_radii.html">map_set_radii.pro</a>', "map_set_radii.pro", "", "map_set_radii", "", "noeventmdradii", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_range.html", "map_set_range.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_range.pro", "", "", " NAME: 	map_set_range    PURPOSE: 	Replaces the range for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_range, md, range    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	range:	 Array (2,2,nt) of new map ranges.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_range.html#map_set_range", "map_set_range", 'routine in <a href="obj/map/map_set_range.html">map_set_range.pro</a>', "map_set_range.pro", "", "map_set_range", "", "noeventmdrange", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_rotate.html", "map_set_rotate.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_rotate.pro", "", "", " NAME: 	map_set_rotate    PURPOSE: 	Replaces the rotate value for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_rotate, md, rotate    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	rotate:	 Array (nt) of new rotate values.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_rotate.html#map_set_rotate", "map_set_rotate", 'routine in <a href="obj/map/map_set_rotate.html">map_set_rotate.pro</a>', "map_set_rotate.pro", "", "map_set_rotate", "", "noeventmdrotate", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_scale.html", "map_set_scale.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_scale.pro", "", "", " NAME: 	map_set_scale    PURPOSE: 	Replaces the scale factor for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_scale, md, scale    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	scale:	 Array (2,nt) of new scale factors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_scale.html#map_set_scale", "map_set_scale", 'routine in <a href="obj/map/map_set_scale.html">map_set_scale.pro</a>', "map_set_scale.pro", "", "map_set_scale", "", "noeventmdscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_size.html", "map_set_size.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_size.pro", "", "", " NAME: 	map_set_size    PURPOSE: 	Replaces the size for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_size, md, size    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	size:	 Array (2,nt) of new map sizes.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_size.html#map_set_size", "map_set_size", 'routine in <a href="obj/map/map_set_size.html">map_set_size.pro</a>', "map_set_size.pro", "", "map_set_size", "", "noeventmdsize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_type.html", "map_set_type.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_type.pro", "", "", " NAME: 	map_set_type    PURPOSE: 	Replaces the type name for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_type, md, type    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	type:	 Array (nt) of new type names.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_type.html#map_set_type", "map_set_type", 'routine in <a href="obj/map/map_set_type.html">map_set_type.pro</a>', "map_set_type.pro", "", "map_set_type", "", "noeventmdtype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_units.html", "map_set_units.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_units.pro", "", "", " NAME: 	map_set_units    PURPOSE: 	Replaces the units for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_units, md, units    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	units:	 Array (2,nt) of new map units.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_units.html#map_set_units", "map_set_units", 'routine in <a href="obj/map/map_set_units.html">map_set_units.pro</a>', "map_set_units.pro", "", "map_set_units", "", "noeventmdunits", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_size.html", "map_size.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_size.pro", "", "", " NAME: 	map_size    PURPOSE: 	Returns the size for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	size = map_size(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (2,nt) of sizes associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_size.html#map_size", "map_size", 'routine in <a href="obj/map/map_size.html">map_size.pro</a>', "map_size.pro", "", "map_size", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/map_to_disk.html", "map_to_disk.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "map_to_disk.pro", "", "", " NAME:        map_to_disk    PURPOSE:        Transforms points in map coordinates to disk coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = map_to_disk(md, dkx, map_pts)    ARGUMENTS:   INPUT: 	md:	Array of nt map descriptors.  	dkx:	Array of nt disk descriptors.  	map_pts:       Array (2 x nv x nt) of map points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of disk coordinates, with the altitude coordinate set to 	zero.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/map_to_disk.html#map_to_disk", "map_to_disk", 'routine in <a href="obj/tools/composite/map_to_disk.html">map_to_disk.pro</a>', "map_to_disk.pro", "", "map_to_disk", "", "mddkdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/map_to_globe.html", "map_to_globe.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "map_to_globe.pro", "", "", " NAME:        map_to_globe    PURPOSE:        Transforms points in map coordinates to surface coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = map_to_globe(md, gbx, map_pts)    ARGUMENTS:   INPUT: 	md:	Array of nt map descriptors.  	gbx:	Array of nt globe descriptors.  	map_pts:	Array (2 x nv x nt) of map points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of globe coordinates, with the altitude coordinate set to 	zero.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/map_to_globe.html#map_to_globe", "map_to_globe", 'routine in <a href="obj/tools/composite/map_to_globe.html">map_to_globe.pro</a>', "map_to_globe.pro", "", "map_to_globe", "", "mdgbxmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/map_to_image.html", "map_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "map_to_image.pro", "", "", " NAME:        map_to_image    PURPOSE:        Transforms points from map coordinates to image coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:         result = map_to_image(md, cd, bx, map_pts)    ARGUMENTS:   INPUT: 	md:	Array of nt map descriptors describing the initial coordinate system. 		If bx is given, then this descriptor is not needed, though 		it may still be used to select between graphic/centric 		latitudes.  	cd:	Array of nt camera or map descriptor describing the final 		coordinate system.  	bx:	Array of nt Object descriptors (subclass of BODY).  	map_pts:       Array (2 x nv x nt) of map points    OUTPUT:        NONE   KEYWORDS:    INPUT: 	valid:	Indices of valid output points.  	body_pts:	Body coordinates of output points.      OUTPUT: NONE    RETURN:        Array (2 x nv x nt) of image points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/map_to_image.html#map_to_image", "map_to_image", 'routine in <a href="obj/tools/composite/map_to_image.html">map_to_image.pro</a>', "map_to_image.pro", "", "map_to_image", "", "body_ptsvalidmdcdbxmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/map_to_surface.html", "map_to_surface.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "map_to_surface.pro", "", "", " NAME:        map_to_surface    PURPOSE:        Transforms points in map coordinates to surface coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = map_to_surface(md, bx, map_pts)    ARGUMENTS:   INPUT: 	md:	Array of nt map descriptors.  	bx:	Array of nt object descriptors (subclass of BODY.  	map_pts:	Array (2 x nv x nt) of map points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of surface coordinates, with the altitude coordinate 	set to zero.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/map_to_surface.html#map_to_surface", "map_to_surface", 'routine in <a href="obj/tools/composite/map_to_surface.html">map_to_surface.pro</a>', "map_to_surface.pro", "", "map_to_surface", "", "mdbxmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_type.html", "map_type.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_type.pro", "", "", " NAME: 	map_type    PURPOSE: 	Returns the type name for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	type = map_type(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of type names associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_type.html#map_type", "map_type", 'routine in <a href="obj/map/map_type.html">map_type.pro</a>', "map_type.pro", "", "map_type", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/map_unfold.html", "map_unfold.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "map_unfold.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/map_unfold.html#map_unfold", "map_unfold", 'routine in <a href="obj/tools/map_unfold.html">map_unfold.pro</a>', "map_unfold.pro", "", "map_unfold", "", "mdmd0map0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_units.html", "map_units.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_units.pro", "", "", " NAME: 	map_units    PURPOSE: 	Returns the units for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	units = map_units(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (2,nt) of units associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_units.html#map_units", "map_units", 'routine in <a href="obj/map/map_units.html">map_units.pro</a>', "map_units.pro", "", "map_units", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/map_units_disk.html", "map_units_disk.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "map_units_disk.pro", "", "", " NAME:        map_units_disk    PURPOSE: 	Computes units for a map descriptor given pixel scales for 	the map center.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        v = map_units_disk(md, resrad=resrad, reslon=reslon)    ARGUMENTS:   INPUT: 	md:	Map descriptor.    OUTPUT:  NONE    KEYWORDS:   INPUT: 	resrad:	Scale (length/pixel) in radial direction.  	reslon:	Scale (radians/pixel) in longitude direction.    OUTPUT: NONE    RETURN: 	Array (2) giving the map units.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/map_units_disk.html#map_units_disk", "map_units_disk", 'routine in <a href="obj/tools/map_units_disk.html">map_units_disk.pro</a>', "map_units_disk.pro", "", "map_units_disk", "", "resradreslonmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_valid_points_equatorial_ring.html", "map_valid_points_equatorial_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_valid_points_equatorial_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_valid_points_equatorial_ring.html#map_valid_points_equatorial_ring", "map_valid_points_equatorial_ring", 'routine in <a href="obj/map/map_valid_points_equatorial_ring.html">map_valid_points_equatorial_ring.pro</a>', "map_valid_points_equatorial_ring.pro", "", "map_valid_points_equatorial_ring", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/map_valid_points_ring.html", "map_valid_points_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_valid_points_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_valid_points_ring.html#map_valid_points_ring", "map_valid_points_ring", 'routine in <a href="obj/map/map_valid_points_ring.html">map_valid_points_ring.pro</a>', "map_valid_points_ring.pro", "", "map_valid_points_ring", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/mask_globe.html", "mask_globe.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "mask_globe.pro", "", "", " NAME:        mask_globe    PURPOSE: 	Computes an image mask for a globe.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = mask_globe(cd, gbx)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Any subclass of GLOBE.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	slop:	Fractional amount by which to increase the globe 		radii before computing the mask.  	oversample:	Factor by wich to oversample the grid to reduce 			aliasing.    OUTPUT: NONE    RETURN:        Angle in radians.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/mask_globe.html#mask_globe", "mask_globe", 'routine in <a href="obj/tools/mask_globe.html">mask_globe.pro</a>', "mask_globe.pro", "", "mask_globe", "", "oversampleslopsubcd_gbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/minmax_latlon.html", "minmax_latlon.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "minmax_latlon.pro", "", "", " NAME:        minmax_latlon    PURPOSE: 	Computes latitide/longitude ranges visible in a given camera.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        minmax_latlon, cd, gbx, dkx    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptor.  	dkx:	Disk descriptor, for hiding points.    OUTPUT:  NONE    KEYWORDS:   INPUT: 	slop:	Amount by which to expand image border for search.    OUTPUT: 	latmin:	Southernmost latitude visible.  	latmax:	Northernmost latitude visible.  	lonmin:	Westernmost longitude visible.  	lonmax:	Easternmost longitude visible.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/minmax_latlon.html#minmax_latlon", "minmax_latlon", 'routine in <a href="obj/tools/minmax_latlon.html">minmax_latlon.pro</a>', "minmax_latlon.pro", "", "minmax_latlon", "", "sloplatminlatmaxlonminlonmaxstatuscdpdrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/mosaic.html", "mosaic.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "mosaic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/mosaic.html#mosaic", "mosaic", 'routine in <a href="obj/tools/mosaic.html">mosaic.pro</a>', "mosaic.pro", "", "mosaic", "", "combine_fnwt_fnsdatamosaicweightmaps", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/move_points.html", "move_points.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "move_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/move_points.html#move_points", "move_points", 'routine in <a href="obj/tools/move_points.html">move_points.pro</a>', "move_points.pro", "", "move_points", "", "axispointsdxydtheta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_clone.html", "nv_clone.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_clone.pro", "", "", " NAME: 	nv_clone    PURPOSE:        Allocates a new object as a copy of the given (existing) 	object.  All pointers in the new object are newly allocated.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	new_xd = nv_clone(xd)    ARGUMENTS:   INPUT: 	xd:	 Object to clone.  May be any pointer or structure.    OUTPUT: NONE    KEYWORDS:   INPUT: 	protect: 		String array giving the names of fields to be copied rather 		than cloned.    OUTPUT: NONE    RETURN:        Newly created object with all fields identical to        the input object, and new pointers.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_clone.html#nv_clone_match", "nv_clone_match", 'routine in <a href="sys/util/nv_clone.html">nv_clone.pro</a>', "nv_clone.pro", "", "nv_clone_match", "", "protecttag", "          -1", "");
  
  libdata[libdataItem++] = new Array("sys/util/nv_clone.html#nv_clone_recurse", "nv_clone_recurse", 'routine in <a href="sys/util/nv_clone.html">nv_clone.pro</a>', "nv_clone.pro", "", "nv_clone_recurse", "", "protectxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("sys/util/nv_clone.html#nv_clone", "nv_clone", 'routine in <a href="sys/util/nv_clone.html">nv_clone.pro</a>', "nv_clone.pro", "", "nv_clone", "", "noeventprotectxd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_compress_events.html", "nv_compress_events.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_compress_events.pro", "", "", " NAME: 	nv_compress_events    PURPOSE: 	Returns only unique events from the given buffer.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	events = nv_compress_events(buf)    ARGUMENTS:   INPUT: 	buf:	Array of nv_event_struct.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	All events in buf that are unique.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_compress_events.html#nv_compress_events", "nv_compress_events", 'routine in <a href="sys/event/nv_compress_events.html">nv_compress_events.pro</a>', "nv_compress_events.pro", "", "nv_compress_events", "", "buf", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_copy.html", "nv_copy.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_copy.pro", "", "", " NAME: 	nv_copy    PURPOSE: 	Copies all fields from one descriptor to another.  New pointers 	are allocated only when the destination field is null.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_copy, dst_xd, src_xd    ARGUMENTS:   INPUT: 	dst_xd:	 Object to copy to.  	src_xd:	 Object to copy from.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:  NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale		3/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_copy.html#nv_copy_is_scalar", "nv_copy_is_scalar", 'routine in <a href="sys/util/nv_copy.html">nv_copy.pro</a>', "nv_copy.pro", "", "nv_copy_is_scalar", "", "x", "          -1", "");
  
  libdata[libdataItem++] = new Array("sys/util/nv_copy.html#nv_copy_recurse", "nv_copy_recurse", 'routine in <a href="sys/util/nv_copy.html">nv_copy.pro</a>', "nv_copy.pro", "", "nv_copy_recurse", "", "allocdst_xdsrc_xd", "          -1", "");
  
  libdata[libdataItem++] = new Array("sys/util/nv_copy.html#nv_copy", "nv_copy", 'routine in <a href="sys/util/nv_copy.html">nv_copy.pro</a>', "nv_copy.pro", "", "nv_copy", "", "noeventdst_xdsrc_xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_debug.html", "nv_debug.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_debug.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_debug.html#nv_debug", "nv_debug", 'routine in <a href="sys/util/nv_debug.html">nv_debug.pro</a>', "nv_debug.pro", "", "nv_debug", "", "ptr_trackingptr_listptr_callsptr_call_level", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_directive_stop__define.html", "nv_directive_stop__define.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_directive_stop__define.pro", "", "", " NAME: 	nv_directive_stop__define    PURPOSE: 	Structure defining the NV_STOP directive.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	N/A    FIELDS: 	directive:	String giving the directive.     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_directive_stop__define.html#nv_directive_stop__define", "nv_directive_stop__define", 'routine in <a href="sys/util/nv_directive_stop__define.html">nv_directive_stop__define.pro</a>', "nv_directive_stop__define.pro", "", "nv_directive_stop__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_event_struct__define.html", "nv_event_struct__define.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_event_struct__define.pro", "", "", " NAME: 	nv_event_struct__define    PURPOSE: 	Structure defining the NV data event.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	N/A    FIELDS: 	xd:		Descriptor affected by this event.  	handler:	Name of event handler procedure, which should accept 			an array of events as its only argument.  	data_p:		Pointer to associated user data.  	data:		Scalar user data.  	desc:		String giving a description of the event.  	type:		Event type: 0 = set value, 1 = get_value.       STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_event_struct__define.html#nv_event_struct__define", "nv_event_struct__define", 'routine in <a href="sys/event/nv_event_struct__define.html">nv_event_struct__define.pro</a>', "nv_event_struct__define.pro", "", "nv_event_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_flush.html", "nv_flush.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_flush.pro", "", "", " NAME: 	nv_flush    PURPOSE: 	Flushes the nv event buffer.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_flush    ARGUMENTS:   INPUT: 	events:	If specified, these events are processed instead of those in 		the event buffer.    KEYWORDS: NONE    RETURN: 	NONE    PROCEDURE: 	Events are compressed so that duplicate events are not reported.  Each 	unique handler is called once with all of the relevant events given.    COMMON BLOCKS: 	nv_notify_block    STATUS: 	Complete    SEE ALSO: 	nv_notify    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_flush.html#nv_flush", "nv_flush", 'routine in <a href="sys/event/nv_flush.html">nv_flush.pro</a>', "nv_flush.pro", "", "nv_flush", "", "clearevents", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_free.html", "nv_free.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_free.pro", "", "", " NAME: 	nv_free    PURPOSE: 	Recursively frees a descriptor.  Pointers and structures are 	dereferenced and descended, freeing any pointers encountered.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_free, p    ARGUMENTS:   INPUT: 	p:	Pointer or structure.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_free.html#nvf_recurse", "nvf_recurse", 'routine in <a href="sys/util/nv_free.html">nv_free.pro</a>', "nv_free.pro", "", "nvf_recurse", "", "p", "          -1", "");
  
  libdata[libdataItem++] = new Array("sys/util/nv_free.html#nv_free", "nv_free", 'routine in <a href="sys/util/nv_free.html">nv_free.pro</a>', "nv_free.pro", "", "nv_free", "", "dp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_help.html", "nv_help.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_help.pro", "", "", " NAME: 	nv_help    PURPOSE: 	Prints information about various OMINAS objects.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_help, p    ARGUMENTS:   INPUT: 	p:	Object to query.  Actions that depend on this input are 		as follows:  		 p		action 		 ---------------------------------------------------- 		 No value	Print the full paths of all NV tables. 		 Numeric	Call IDL finction 'help'. 		 Ptr or struct	Descend recursively, printing info on all 				fields. 		 String		Assumes p is the name of an OMINAS routine 				and prints the documentation page if 				available.     OUTPUT: NONE    KEYWORDS:   INPUT: 	event:		If set, the event tables are printed and p 			is ignored.    OUTPUT: 	capture:	If present, the output in returned in this 			keyword instead of being printed.    ENVIRONMENT VARIABLES: 	OMINAS_DIR:	OMINAS top directory; used to find documentation files.    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_help.html#nv_help_print", "nv_help_print", 'routine in <a href="sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_print", "", "captures", "          -1", "");
  
  libdata[libdataItem++] = new Array("sys/util/nv_help.html#nv_help_sep", "nv_help_sep", 'routine in <a href="sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_sep", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("sys/util/nv_help.html#nv_help_state", "nv_help_state", 'routine in <a href="sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_state", "", "capture", "          -1", "");
  
  libdata[libdataItem++] = new Array("sys/util/nv_help.html#nv_help_descend", "nv_help_descend", 'routine in <a href="sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_descend", "", "capturedp0indentstringindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("sys/util/nv_help.html#nv_help_dump_events", "nv_help_dump_events", 'routine in <a href="sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_dump_events", "", "captureitems", "          -1", "");
  
  libdata[libdataItem++] = new Array("sys/util/nv_help.html#nv_help_event", "nv_help_event", 'routine in <a href="sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_event", "", "capture", "          -1", "");
  
  libdata[libdataItem++] = new Array("sys/util/nv_help.html#nv_help_doc", "nv_help_doc", 'routine in <a href="sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_doc", "", "capturename", "          -1", "");
  
  libdata[libdataItem++] = new Array("sys/util/nv_help.html#nv_help", "nv_help", 'routine in <a href="sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help", "", "captureeventdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/state/nv_init_state.html", "nv_init_state.pro", '.pro file in <a href="sys/state/dir-overview.html">sys/state/ directory</a>', "nv_init_state.pro", "", "", " NAME: 	nv_init_state    PURPOSE: 	Initializes the NV state structure.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	state = nv_init_state()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	New nv_state structure.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/state/nv_init_state.html#nv_init_state", "nv_init_state", 'routine in <a href="sys/state/nv_init_state.html">nv_init_state.pro</a>', "nv_init_state.pro", "", "nv_init_state", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_message.html", "nv_message.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_message.pro", "", "", " NAME: 	nv_message    PURPOSE: 	Prints an error message and halts execution.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_message, string    ARGUMENTS:   INPUT: 	string:	Message to print.    OUTPUT: NONE    KEYWORDS:   INPUT: 	name:		Name to use for the calling routine instead of 			taking it from the traceback list.  	anonymous:	If set, the traaceback list is not used to infer the 			name of the calling routine.  In this case, a name 			is printed nly if explicitly specified using the 'name' 			keyword.  	continue:	If set, execution is not halted.  	stop:		If set, execution is halted in nv_message.  	get_message:	If set, the last message sent through nv_message 			is returned in the _string keyword and no other 			action is taken.  	clear:		If set, the last message is cleared and no other action 			is taken.  	cb_tag:		If set, the callback procedure below is added to 			the cllaback list under this tag name and no other 			action is taken.  	cb_data_p:	Pointer to data for the callback procedure.  	callback:	Name of a callback procedure to add to the callback 			list.  Callback procedures are sent two arguments: 			cb_data_p (see above), and the message string.  	disconnect:	If set, the callback identified by the given cb_tag 			is removed from the callback list and no other 			action is taken.  	explanation:	String giving an extended explanation for the message.  	verbose:	Floating value in the range 0 to 1 specifying the 			verbosity threshold.  If set, and no string is given, 			then the threshold is set to this value.  If a string 			is given, then it will only be printed if this 			value is greater than or equal to current verbosity 			level.  Setting this keyword implies /continue. 			Verbosity threshold rules of thumb are as follows:  			 0.1:	Useful messages that you don't always need to see; 				files being loaded, written, etc. 			 0.5:	Useful messages that you want to see even less; 				file-not-found warnings, etc. 			 0.9:	Debugging messages that don't produce huge 				outputs. 			 1.0:	Mega debugging messages that may create 				huge outputs.  Your short message will get lost 				in this output, so use 0.9 instead.    	silent:		Suppressed printing of messages.  	format:		Format string.     OUTPUT: 	message:	If /get_message, this keyword will return the last 			message sent through nv_message.    ENVIRONMENT VARIABLES: 	NV_VERBOSITY:	Initial verbosity setting.    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_message.html#nv_message", "nv_message", 'routine in <a href="sys/util/nv_message.html">nv_message.pro</a>', "nv_message.pro", "", "nv_message", "", "nameanonymouscontinueclearget_messageformatmessageexplanationcallbackcb_data_pdisconnectcb_tagverbosesilentstopstring", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_notify.html", "nv_notify.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_notify.pro", "", "", " NAME: 	nv_notify    PURPOSE: 	Notify nv system of an event on some set of descriptors.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_notify, xd, type=type    ARGUMENTS:   INPUT: 	xd:	Descriptor for which an event has occurred.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	type:	Type of event: 		 0 - set value 		 1 - get value 		This input can have only one element.  If not given, the 		event type is assumed to be 0.  	flush:	Flush the write event buffer -- call the handlers for each 		unique event only once and clear the buffer.  	noevent: If set, nothing is done.    OUTPUT: 	NONE    RETURN: 	NONE    PROCEDURE: 	By default, write events are buffered.  Handlers for write events are 	only called when /flush is specified.  For read events, all event 	handlers of the specified type are called as procedures with an  	nv_event_struct as the argument.    COMMON BLOCKS: 	nv_notify_block    STATUS: 	Complete    SEE ALSO: 	nv_notify_register, nv_notify_unregister    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_notify.html#nv_notify", "nv_notify", 'routine in <a href="sys/event/nv_notify.html">nv_notify.pro</a>', "nv_notify.pro", "", "nv_notify", "", "typedescflushnoeventxd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_notify_list_struct__define.html", "nv_notify_list_struct__define.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_notify_list_struct__define.pro", "", "", " NAME: 	nv_notify_list_struct__define    PURPOSE: 	Structure defining an entry in the NV event registry.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	N/A    FIELDS: 	xd:		Descriptor affected by this event.  	handler:	Name of event handler procedure, which should accept 			an array of events as its only argument.  	data_p:		Pointer to associated user data.  	data:		Scalar user data.  	desc:		String giving a description of the event.  	type:		Event type: 0 = set value, 1 = get_value.  	compress:	If 1, compress events.  	dynamic:	1 if a pointer was allocated for the descriptor 			in this entry.       STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_notify_list_struct__define.html#nv_notify_list_struct__define", "nv_notify_list_struct__define", 'routine in <a href="sys/event/nv_notify_list_struct__define.html">nv_notify_list_struct__define.pro</a>', "nv_notify_list_struct__define.pro", "", "nv_notify_list_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_notify_register.html", "nv_notify_register.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_notify_register.pro", "", "", " NAME: 	nv_notify_register    PURPOSE: 	Register descriptor event handlers.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_notify_register, xd, handler, type, data=data    ARGUMENTS:   INPUT: 	xd:		Array of descriptors.  	handler:	Name of event handler functions.  If only one element, 			then this function will be registered for every given 			descriptor.  Otherwise must have the same number of 			elements as xd.  	type:		Type of data event to respond to: 			 0 - set value 			 1 - get value 			0 is default.  If only one element, then this type 			will be registered for every given descriptor. 			Otherwise must have the same number of elements as xd.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	data:		Arbitrary user data to associate with events on these 			descriptors.  A pointer to this data is allocated and 			returned in the 'data_p' field of the event structure. 			Note that only one descriptor xd may be specified 			per call when using this argument.  	scalar_data:	Scalar user data to associate with events on these 			descriptors.  This data is returned in the 'data' 			field of the event structure.  	compress:	Event compression flag.    OUTPUT: 	NONE    RETURN: 	NONE    COMMON BLOCKS: 	nv_notify_block    STATUS: 	Complete    SEE ALSO: 	nv_notify_unregister    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_notify_register.html#nv_notify_register", "nv_notify_register", 'routine in <a href="sys/event/nv_notify_register.html">nv_notify_register.pro</a>', "nv_notify_register.pro", "", "nv_notify_register", "", "datascalar_datacompress_xdhandlertype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_notify_unregister.html", "nv_notify_unregister.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_notify_unregister.pro", "", "", " NAME: 	nv_notify_unregister    PURPOSE: 	Unregister a descriptor event handler.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_notify_unregister, xd, handler    ARGUMENTS:   INPUT: 	xd:		Descriptors for which to discontinue notification.  	handler:	If given, names of event handler functions to remove 			for each given descriptor.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	all:		If set, all handlers are unregistered.    OUTPUT: 	NONE    RETURN: 	NONE    COMMON BLOCKS: 	nv_notify_block    STATUS: 	Complete    SEE ALSO: 	nv_notify_register    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_notify_unregister.html#nv_notify_unregister", "nv_notify_unregister", 'routine in <a href="sys/event/nv_notify_unregister.html">nv_notify_unregister.pro</a>', "nv_notify_unregister.pro", "", "nv_notify_unregister", "", "allxdhandler", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_ping.html", "nv_ping.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_ping.pro", "", "", " NAME: 	nv_ping    PURPOSE: 	Generates a write event on a set of descriptors.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_ping, xd    ARGUMENTS:   INPUT: 	xd:	Array of descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 5/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_ping.html#nv_ping", "nv_ping", 'routine in <a href="sys/event/nv_ping.html">nv_ping.pro</a>', "nv_ping.pro", "", "nv_ping", "", "noeventxdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_protected.html", "nv_protected.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_protected.pro", "", "", " NAME: 	nv_protected    PURPOSE: 	Tests whether a structure or field is protected.  Protected fields 	are not freed by nv_free, nor are they descended by nv_free 	or nv_clone.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	test = nv_protected(tag)    ARGUMENTS:   INPUT: 	tag:		Structure tag to test.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	1 if protected, 0 if not.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_protected.html#nv_protected", "nv_protected", 'routine in <a href="sys/util/nv_protected.html">nv_protected.pro</a>', "nv_protected.pro", "", "nv_protected", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_ptr_free.html", "nv_ptr_free.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_ptr_free.pro", "", "", " NAME: 	nv_ptr_free    PURPOSE: 	Wrapper to the IDL routine ptr_free.  In conjunction with nv_ptr_new, 	pointer allocations are tracked for debugging purposes.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_ptr_free, p    ARGUMENTS:   INPUT: 	p:	Pointer to free.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_ptr_free.html#nv_ptr_free", "nv_ptr_free", 'routine in <a href="sys/util/nv_ptr_free.html">nv_ptr_free.pro</a>', "nv_ptr_free.pro", "", "nv_ptr_free", "", "p", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_ptr_new.html", "nv_ptr_new.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_ptr_new.pro", "", "", " NAME: 	nv_ptr_new    PURPOSE: 	Wrapper for te IDL function ptr_new.  In conjunction with nv_ptr_free, 	pointer allocations are tracked for debugging purposes.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	p = nv_ptr_new(x)    ARGUMENTS:   INPUT: 	x:	Data to point to.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Newly allocated pointer    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_ptr_new.html#nv_ptr_new", "nv_ptr_new", 'routine in <a href="sys/util/nv_ptr_new.html">nv_ptr_new.pro</a>', "nv_ptr_new.pro", "", "nv_ptr_new", "", "allocate_heapno_copyx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/state/nv_reset.html", "nv_reset.pro", '.pro file in <a href="sys/state/dir-overview.html">sys/state/ directory</a>', "nv_reset.pro", "", "", " NAME: 	nv_reset    PURPOSE: 	Resets the NV state.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	nv_reset    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/state/nv_reset.html#nv_reset", "nv_reset", 'routine in <a href="sys/state/nv_reset.html">nv_reset.pro</a>', "nv_reset.pro", "", "nv_reset", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_resume_events.html", "nv_resume_events.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_resume_events.pro", "", "", " NAME: 	nv_resume_events    PURPOSE: 	Resumes data event tracking.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	nv_resume_events    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_resume_events.html#nv_resume_events", "nv_resume_events", 'routine in <a href="sys/event/nv_resume_events.html">nv_resume_events.pro</a>', "nv_resume_events.pro", "", "nv_resume_events", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/state/nv_state_struct__define.html", "nv_state_struct__define.pro", '.pro file in <a href="sys/state/dir-overview.html">sys/state/ directory</a>', "nv_state_struct__define.pro", "", "", " NAME: 	nv_state_struct__define    PURPOSE: 	Structure defining the NV state.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	N/A    FIELDS: 	ndd:	Maximum number of data descriptors with maintain == 1 to 		keep in memory at any given time.  	dds_p:	List of data descriptors kept in memory as a result of 		maintain == 1.  	translators_filenames_p:	Pointer to names of translators 					tables.  	tr_table_p:	Pointer to loaded translators table.  	transforms_filenames_p:	Pointer to names of transforms tables.  	trf_table_p:	Pointer to loaded transforms table.  	io_filenames_p:	Pointer to names of I/O tables.  	io_table_p:	Pointer to loaded I/O table.  	ftp_detectors_filenames_p:	Pointer to names of filetypes tables.  	ftp_table_p:	Pointer to loaded filetypes table.  	ins_detectors_filenames_p:	Pointer to names of instruments 					tables.  	ins_table_p:	Pointer to loaded instruments table.      STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/state/nv_state_struct__define.html#nv_state_struct__define", "nv_state_struct__define", 'routine in <a href="sys/state/nv_state_struct__define.html">nv_state_struct__define.pro</a>', "nv_state_struct__define.pro", "", "nv_state_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_suspend_events.html", "nv_suspend_events.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_suspend_events.pro", "", "", " NAME: 	nv_suspend_events    PURPOSE: 	Suspends data event tracking.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	nv_suspend_events    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_suspend_events.html#nv_suspend_events", "nv_suspend_events", 'routine in <a href="sys/event/nv_suspend_events.html">nv_suspend_events.pro</a>', "nv_suspend_events.pro", "", "nv_suspend_events", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/arr/ominas_array__define.html", "ominas_array__define.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "ominas_array__define.pro", "", "", " NAME: 	ominas_array__define    PURPOSE: 	Class structure for the ARRAY class.    CATEGORY: 	NV/LIB/arr    CALLING SEQUENCE: 	N/A    FIELDS: 	bd:	BODY class descriptor.  		Methods: arr_body, arr_set_body   	primary:	Primary descriptor.  			Methods: arr_primary, arr_set_primary  	surface_pts:	Vector giving the surface coordinates of the 			array points on the primary.  			Methods: arr_surface_pts, arr_set_surface_pts     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012  	Adapted by:	Spitale, 5/2016  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/ominas_array__define.html#ominas_array::init", "ominas_array::init", 'routine in <a href="obj/arr/ominas_array__define.html">ominas_array__define.pro</a>', "ominas_array__define.pro", "", "ominas_array::init", "", "crdardii@arr__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/arr/ominas_array__define.html#ominas_array__define", "ominas_array__define", 'routine in <a href="obj/arr/ominas_array__define.html">ominas_array__define.pro</a>', "ominas_array__define.pro", "", "ominas_array__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/bod/ominas_body__define.html", "ominas_body__define.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "ominas_body__define.pro", "", "", " NAME: 	ominas_body__define    PURPOSE: 	Class structure for the BODY class.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	N/A    FIELDS: 	crd:	CORE class descriptor.  		Methods: bod_core   	opaque:	Flag describing whether a body is  easily visible .  		Methods: bod_opaque, bod_set_opaque   	time:	Time, at body position, at which this descriptor is valid.  		Methods: bod_time, bod_set_time   	orient:	Orientation matrix, transforms body to inertial.  		Methods: bod_orient, bod_set_orient   	avel:	Angular velocity vector.  Each higher-order vector is the 		angular velocity for the vector of the preceding order.  		Methods: bod_avel, bod_set_avel   	pos:	Position of body center in the inertial frame.  		Methods: bod_pos, bod_set_pos   	vel:	Velocity of body center in the inertial frame.  		Methods: bod_vel, bod_set_vel   	libv:	Libration vector.  Each higher-order vector is the libration 		for the vector of the preceding order.  The body librates about 		the direction v_unit(libv), with an amplitude given by 		v_mag(libv).  		Methods: bod_libv, bod_set_libv   	lib:	Phase of the libraton vectors at body time.  		Methods: bod_lib, bod_set_lib   	dlibdt:	Frequency for each libration vector.  		Methods: bod_dlibdt, bod_set_dlibdt  	aberration: 		Aberration flag mask: 1=correction performed.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/ominas_body__define.html#ominas_body::init", "ominas_body::init", 'routine in <a href="obj/bod/ominas_body__define.html">ominas_body__define.pro</a>', "ominas_body__define.pro", "", "ominas_body::init", "", "crdbdii@bod__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/bod/ominas_body__define.html#ominas_body__define", "ominas_body__define", 'routine in <a href="obj/bod/ominas_body__define.html">ominas_body__define.pro</a>', "ominas_body__define.pro", "", "ominas_body__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cam/ominas_camera__define.html", "ominas_camera__define.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "ominas_camera__define.pro", "", "", " NAME: 	ominas_camera__define    PURPOSE: 	Class structure fo the CAMERA class.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	N/A    FIELDS: 	bd:	BODY class descriptor.  		Methods: cam_body, cam_set_body   	scale:	2-element array giving the camera scale (radians/pixel) in 		each direction.  The meaning of this quantity depends on the 		distortion model.  		Methods: cam_scale, cam_set_scale   	oaxis:	2-element array giving the image coordinates corresponding 		to the camera optic axis.  		Methods: cam_oaxis, cam_set_oaxis   	exposure:	Exposure duration.  BODY time refers to the 			center of this interval.  			Methods: cam_exposure, cam_set_exposure   	size:	Image size in pixels.  		Methods: cam_size, cam_set_size  	filters:	String array giving the names of each filter.   	fn_focal_to_image:	String giving the name of a function 				that transforms points in the focal 				plane coordinate system to points in 				the image coordinate system.  Default is 				cam_image_to_focal_linear().  				Methods: cam_fn_focal_to_image, 				         cam_set_fn_focal_to_image   	fn_image_to_focal:	String giving the name of a function 				that transforms points in the image 				coordinate system to points in the focal- 				plane coordinate system.  Default is 				cam_image_to_focal_linear().  				Methods: cam_fn_image_to_focal 				         cam_set_fn_image_to_focal   	fn_psf:	String giving the name of a function to be defined as 		follows:  		function <name>, cd, x, y, default=default  		The function should return an array of PSF values at the given 		coordinates, subject to the following rules:  		1) If neither x nor y are given, then a PSF function is returned 		   on some default grid, which is application-specific.  		2) If only x is given, then PSF values are returned for each x, 		   with y values set to zero.  		3) If x and y are given, then PSF values are returned at all 		   points (x,y).   		Methods: cam_fn_psf, cam_set_fn_psf, cam_psf, cam_psf_attrib    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/ominas_camera__define.html#ominas_camera::init", "ominas_camera::init", 'routine in <a href="obj/cam/ominas_camera__define.html">ominas_camera__define.pro</a>', "ominas_camera__define.pro", "", "ominas_camera::init", "", "crdbdcdii@cam__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/cam/ominas_camera__define.html#ominas_camera__define", "ominas_camera__define", 'routine in <a href="obj/cam/ominas_camera__define.html">ominas_camera__define.pro</a>', "ominas_camera__define.pro", "", "ominas_camera__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/cor/ominas_core__define.html", "ominas_core__define.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "ominas_core__define.pro", "", "", " NAME: 	ominas_core__define    PURPOSE: 	Class structure for the CORE class.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	N/A    FIELDS: 	name:	Name of the object.  		Methods: cor_name, cor_set_name   	user:	Username.  		Methods: cor_user   	tasks_p: 		Pointer to tasks list.  		Methods: cor_tasks, cor_add_task   	udata_tlp: 		Tag list containing user data.  		Methods: cor_set_udata, cor_test_udata, cor_udata  	abbrev:	Abbreviation for this descriptor class, e.g., COR.  	tag:	Tag for this descriptor class, e.g., CRD.  	gdp:	Pointer to generic descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/ominas_core__define.html#ominas_core::rereference", "ominas_core::rereference", 'routine in <a href="obj/cor/ominas_core__define.html">ominas_core__define.pro</a>', "ominas_core__define.pro", "", "ominas_core::rereference", "", "struct", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/cor/ominas_core__define.html#ominas_core::dereference", "ominas_core::dereference", 'routine in <a href="obj/cor/ominas_core__define.html">ominas_core__define.pro</a>', "ominas_core__define.pro", "", "ominas_core::dereference", "", "struct", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/cor/ominas_core__define.html#ominas_core::init", "ominas_core::init", 'routine in <a href="obj/cor/ominas_core__define.html">ominas_core__define.pro</a>', "ominas_core__define.pro", "", "ominas_core::init", "", "crdii@cor__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/cor/ominas_core__define.html#ominas_core__define", "ominas_core__define", 'routine in <a href="obj/cor/ominas_core__define.html">ominas_core__define.pro</a>', "ominas_core__define.pro", "", "ominas_core__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/ominas_data__define.html", "ominas_data__define.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "ominas_data__define.pro", "", "", " NAME: 	ominas_data__define    PURPOSE: 	Structure defining the data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	N/A    FIELDS: 	data_dap:	Pointer to data archive containing the data 			and nhist past versions.  	abscissa_dap:	Pointer to data archive containing the abscissa 			and nhist past versions.  	header_dap:	Pointer to data archive containing the header 			and nhist past versions.  	dap_index:	Index of archived data to use.  	dhp:		Pointer to detached header.  	max:		Maximum data value.  	min:		Minimum data value.  	abmax:		Maximum abscissa value.  	abmin:		Minimum abscissa value.  	cache:		Max cache size data array.  Used to deterine whether 			to load / unload data samples.  -1 means infinite.  	dim:		Array giving data dimensions.  	slice_struct:	Structure containing array giving coordinates for a 			subarray.  If slice coordinates exist, the dat methods 			act as if the data descriptor contains only this slice of 			data.  Dimensions, min, and max are set accordingly. 			Dimensions of the subarray are the difference between 			the dimensions of the full array and the dimensionality 			of the slice coordinates.  	typecode:	Data type code.  	filename:	Name of data file.  	filetype:	Filetype string determined by dat_detect_filetype.  	input_transforms_p:	Pointer to list of input transform 				functions determined by dat_lookup_transforms.  	output_transforms_p:	Pointer to list of output transform 				functions determined by dat_lookup_transforms.  	input_fn:	Name of function to read data file.  	output_fn:	Name of function to write data file.  	keyword_fn:	Name of function to read/write header keywords.  	instrument:	Instrument string from dat_detect_instrument.  	input_translators_p:	Pointer to list of input translator 				functions determined by dat_lookup_translators.  	output_translators_p:	Pointer to list of output translator 				functions determined by dat_lookup_translators.  	input_keyvals_p:	Keyword/value pairs for input translators.  	output_keyvals_p:	Keyword/value pairs for output translators.  	transient_keyvals_p:	Transient keyword/value pairs found in the 				translator argument string.  	last_translator:	Description of last translator called.  	sampling_fn:		Optional function to perform a transformation 				on the samples given to dat_data():  				function sampling_fn, dd, samples, data  	dim_fn:			Optional function to cause dat_dim() to report 				dimensions other than those stored in the 				data descriptor:  				function dim_fn, dd, data  	compress:	Compression suffix.  The full name of the 			compression function is dat_compress_data_<suffix>.  	compress_data_p:	Data for compression function.  	maintain:	Data maintenance mode: 				  0: load initially 				  1: load when needed; retain 				     only ndd data descriptor 				     arrays in memory. 				  2: Load when needed, but  				     do not retain.  	update:		Data update mode: 				 -1: Locked; applies to data, header, 				     and udata. 				  0: Normal 				  1: Clone a new descriptor 				     and leave original dd 				     unchanged.  	sibling_dd_h:	Handle giving dd spawned as a result of writing to 			this descriptor while update = 1.  Handle is used 			to protect this dd from nv_free. ;   STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/ominas_data__define.html#ominas_data::init", "ominas_data::init", 'routine in <a href="obj/dat/ominas_data__define.html">ominas_data__define.pro</a>', "ominas_data__define.pro", "", "ominas_data::init", "", "crdddii@dat__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dat/ominas_data__define.html#dat_dd0_struct__define", "dat_dd0_struct__define", 'routine in <a href="obj/dat/ominas_data__define.html">ominas_data__define.pro</a>', "ominas_data__define.pro", "", "dat_dd0_struct__define", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dat/ominas_data__define.html#ominas_data__define", "ominas_data__define", 'routine in <a href="obj/dat/ominas_data__define.html">ominas_data__define.pro</a>', "ominas_data__define.pro", "", "ominas_data__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dsk/ominas_disk__define.html", "ominas_disk__define.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "ominas_disk__define.pro", "", "", " NAME: 	ominas_disk__define    PURPOSE: 	Class structure for the DISK class.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	N/A    FIELDS: 	sld:	SOLID class descriptor.  		Methods: dsk_solid, dsk_set_solid   	sma:	Array ndv+1 x 2 giving the semimajor axes and derivatives 		for each edge.  		Methods: dsk_sma, dsk_set_sma   	ecc:	Array ndv+1 x 2 giving the eccentricities and derivatives 		for each edge.  		Methods: dsk_ecc, dsk_set_ecc   	dap:	Array ndv+1 giving the apsidal shift and derivatives.  		Methods: dsk_dap, dsk_set_dap   	scale:	2-elements array giving optional radial scale coefficients:  			 scaled_radii = scale[0] * radii*scale[1]  		Methods: dsk_scale, dsk_set_scale, dsk_apply_scale   	nm:	Integer giving the number of radial harmonics in the ring 		shape.  		Methods: dsk_nm, dsk_set_nm, dsk_get_nm   	m:	Array nm x 2 giving the m value for each harmonic, for 		each edge.  		Methods: dsk_m, dsk_set_m, dsk_get_nm   	em:	Array nm x 2 giving the eccentricity for each harmonic, for 		each edge.  		Methods: dsk_em, dsk_set_em   	tapm:	Array nm x 2 giving the true anmalies of periapse for each 		harmonic, for each edge.  		Methods: dsk_tapm, dsk_set_tapm   	dtapmdt:Array nm x 2 giving the tapm rate rate for each 		harmonic, for each edge.  		Methods: dsk_dtapmdt, dsk_set_dtapmdt   	libam:	Array nm x 2 giving the libration amplitude for each 		harmonic, for each edge.  		Methods: dsk_libam, dsk_set_libam   	libm:	Array nm x 2 giving the libration phase for each 		harmonic, for each edge.  		Methods: dsk_libm, dsk_set_libm   	dlibmdt:	Array nm x 2 giving the libration frequency for each 			harmonic, for each edge.  			Methods: dsk_dlibmdt, dsk_set_dlibmdt   	nl:	Integer giving the number of radial harmonics in the ring 		shape.  		Methods: dsk_nm, dsk_set_nm, dsk_get_nm   	l:	Array nl x 2 giving the l value for each harmonic, for 		each edge.  		Methods: dsk_m, dsk_set_m, dsk_get_nm   	il:	Array nl x 2 giving the inclination for each harmonic, for 		each edge.  		Methods: dsk_em, dsk_set_em   	taanl:	Array nl x 2 giving the true anomaly of periapse for each 		harmonic, for each edge.  		Methods: dsk_taanl, dsk_set_taanl   	dtaanldt:	Array nl x 2 giving the taanl rate for each 			harmonic, for each edge.  			Methods: dsk_dtaanldt, dsk_set_dtaanldt   	libal:	Array nl x 2 giving the libration amplitude for each 		harmonic, for each edge.  		Methods: dsk_libam, dsk_set_libam   	libl:	Array nl x 2 giving the libration phase for each 		harmonic, for each edge.  		Methods: dsk_libm, dsk_set_libm   	dlibldt:	Array nl x 2 giving the libration frequency for each 			harmonic, for each edge.  			Methods: dsk_dlibmdt, dsk_set_dlibmdt      STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/ominas_disk__define.html#ominas_disk::init", "ominas_disk::init", 'routine in <a href="obj/dsk/ominas_disk__define.html">ominas_disk__define.pro</a>', "ominas_disk__define.pro", "", "ominas_disk::init", "", "crdbdslddkdii@dsk__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dsk/ominas_disk__define.html#ominas_disk__define", "ominas_disk__define", 'routine in <a href="obj/dsk/ominas_disk__define.html">ominas_disk__define.pro</a>', "ominas_disk__define.pro", "", "ominas_disk__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/glb/ominas_globe__define.html", "ominas_globe__define.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "ominas_globe__define.pro", "", "", " NAME: 	ominas_globe__define    PURPOSE: 	Class structure fo the GLOBE class.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	N/A    FIELDS: 	sld:	SOLID class descriptor.  		Methods: glb_solid, glb_set_solid   	type:	String giving the type.  ELLIPSOID, FACET, or HARMONIC. 		Currently only ellipsoids are supported.   		Methods: glb_type, glb_set_type  	lref:	Longitude reference note.  Used to describe the longitude 		reference system.  		Methods: glb_lref, glb_set_lref   	radii:	3-element array giving the ellipsoid radii.  		Methods: glb_radii, glb_set_radii   	lora:	Longitude of first ellipsoid radius.  		Methods: glb_lora, glb_set_lora   	rref:	Reference radius.  		Methods: glb_rref, glb_set_rref   	J:	Array (nj) giving the zonal harmonics.  Indices in the 		array correspond to the standard harmonic orders, i.e., 		J[2] is J2.  		Methods: glb_j, glb_set_j    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/ominas_globe__define.html#ominas_globe::init", "ominas_globe::init", 'routine in <a href="obj/glb/ominas_globe__define.html">ominas_globe__define.pro</a>', "ominas_globe__define.pro", "", "ominas_globe::init", "", "crdbdsldgbdii@glb__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/glb/ominas_globe__define.html#ominas_globe__define", "ominas_globe__define", 'routine in <a href="obj/glb/ominas_globe__define.html">ominas_globe__define.pro</a>', "ominas_globe__define.pro", "", "ominas_globe__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/map/ominas_map__define.html", "ominas_map__define.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "ominas_map__define.pro", "", "", " NAME: 	ominas_map__define    PURPOSE: 	Class structure fo the MAP class.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	N/A    FIELDS: 	crd:	CORE class descriptor.  		Methods: map_core   	type:	String giving the map type, e.g., RECTANGULAR, 		ORTHOGRAPHIC.  Map transformation functions are named 		map_image_to_map_<type> and map_map_to_image_<type>.  		Methods: map_type, map_set_type   	units:	2-element array (lat,lon) to converts map radians to other   		units (map radians/unit).  		Methods: map_units, map_set_units   	size:	2-element array giving the map size in pixels.  		Methods: map_size, map_set_size   	scale:	Map scale (units/angle) at the center of the map.  		Methods: map_scale, map_set_scale   	center:	2-element array giving the map coordinates of the 		center of the map.  		Methods: map_center, map_set_center   	range:	2-element array giving the map coordinates of the 		lat/lon ranges of the map.  		Methods: map_range, map_set_range   	origin:	2-element array giving the image coordinates corresponding 		to the center of the map.  		Methods: map_origin, map_set_origin   	rotate:	Code specifying a rotation to be applied to the map, as in the 		IDL 'rotate' function.   	graphic:	Flag indicating whether latitudes are represented 			using the planetocrntric or planetographic convention.  	radii:	3-element array giving ellipsoid radii to use in projections. 		Only the relative ratios are important.  All elements are 		set to 1 by default.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/ominas_map__define.html#ominas_map::init", "ominas_map::init", 'routine in <a href="obj/map/ominas_map__define.html">ominas_map__define.pro</a>', "ominas_map__define.pro", "", "ominas_map::init", "", "crdmdii@map__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/map/ominas_map__define.html#ominas_map__define", "ominas_map__define", 'routine in <a href="obj/map/ominas_map__define.html">ominas_map__define.pro</a>', "ominas_map__define.pro", "", "ominas_map__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/plt/ominas_planet__define.html", "ominas_planet__define.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "ominas_planet__define.pro", "", "", " NAME: 	ominas_planet__define    PURPOSE: 	Class structure for the PLANET class.    CATEGORY: 	NV/LIB/PLT    CALLING SEQUENCE: 	N/A    FIELDS: 	gbd:	GLOBE class descriptor.  		Methods: str_globe, str_set_globe    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/ominas_planet__define.html#ominas_planet::init", "ominas_planet::init", 'routine in <a href="obj/plt/ominas_planet__define.html">ominas_planet__define.pro</a>', "ominas_planet__define.pro", "", "ominas_planet::init", "", "crdbdsldgbdpdii@plt__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/plt/ominas_planet__define.html#ominas_planet__define", "ominas_planet__define", 'routine in <a href="obj/plt/ominas_planet__define.html">ominas_planet__define.pro</a>', "ominas_planet__define.pro", "", "ominas_planet__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/ominas_point__define.html", "ominas_point__define.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "ominas_point__define.pro", "", "", " NAME: 	ominas_point__define    PURPOSE: 	Structure for managing points.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	N/A    FIELDS: 	desc:		Data set description.  	points_p:	Pointer to image points.  	vectors_p:	Pointer to inertial vectors.  	data_p:		Pointer to a point-by-point user data array.  	tags_p:		Tags for point-by-point user data.  	flags_p:	Pointer to point-by-point flag array.  	nv:		Number of elements in the nv direction.  	nt:		Number of elements in the nt direction.  	assoc_xd:	Associated descriptor.     STATUS: 	Complete    MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pg_points_struct__define   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/ominas_point__define.html#ominas_point::init", "ominas_point::init", 'routine in <a href="obj/pnt/ominas_point__define.html">ominas_point__define.pro</a>', "ominas_point__define.pro", "", "ominas_point::init", "", "crdptdii@pnt__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/pnt/ominas_point__define.html#ominas_point__define", "ominas_point__define", 'routine in <a href="obj/pnt/ominas_point__define.html">ominas_point__define.pro</a>', "ominas_point__define.pro", "", "ominas_point__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/rng/ominas_ring__define.html", "ominas_ring__define.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "ominas_ring__define.pro", "", "", " NAME: 	ominas_ring__define    PURPOSE: 	Class structure for the RING class.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	N/A    FIELDS: 	dkd:	DISK class descriptor.  		Methods: rng_disk, rng_set_disk   	primary:	Primary body descriptor.  			Methods: rng_primary, rng_set_primary  	desc:	String giving the description of the ring.  Valid values 		are 'EDGE', 'PEAK', 'TROUGH'.  		Methods: rng_desc, rng_set_desc    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/ominas_ring__define.html#ominas_ring::init", "ominas_ring::init", 'routine in <a href="obj/rng/ominas_ring__define.html">ominas_ring__define.pro</a>', "ominas_ring__define.pro", "", "ominas_ring::init", "", "crdbdslddkdrdii@rng__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/rng/ominas_ring__define.html#ominas_ring__define", "ominas_ring__define", 'routine in <a href="obj/rng/ominas_ring__define.html">ominas_ring__define.pro</a>', "ominas_ring__define.pro", "", "ominas_ring__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/ominas_solid__define.html", "ominas_solid__define.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "ominas_solid__define.pro", "", "", " NAME: 	ominas_solid__define    PURPOSE: 	Class structure fo the SOLID class.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	N/A    FIELDS: 	bd:	BODY class descriptor.  		Methods: sld_body, sld_set_body   	opacity: Normalized opacity for ray tracing.  		Methods: sld_opacity, sld_set_opacity   	GM:	Mass x gravitational constant.  		Methods: sld_gm, sld_set_gm   	mass:	Body mass.  This field and GM are kept in sync unless 		/nosync is used in sld_set_mass or sld_set_gm.  		Methods: sld_mass, sld_set_mass   	phase_fn: String giving the name of a phase function to be defined as 		  follows:  		  function <name>, mu, mu0, parm  		  The function should return a value corresponding to the 		  phase function with emission cosine mu and incidence 		  cosine mu0.  		  Methods: sld_phase_fn, sld_set_phase_fn   	phase_parm:	Array (npht) of parameters to pass to the phase 			function.  		  Methods: sld_phase_parm, sld_set_phase_parm   	refl_fn:  String giving the name of a reflection function to be defined as 		  follows:  		  function <name>, mu, mu0, parm  		  The function should return a value corresponding to the 		  reflection function with emission cosine mu and incidence 		  cosine mu0.  		  Methods: sld_refl_fn, sld_set_refl_fn   	refl_parm:	Array (npht) of parameters to pass to the reflection 			function.  		  Methods: sld_refl_parm, sld_set_refl_parm   	albedo:	Bond albedo.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/ominas_solid__define.html#ominas_solid::init", "ominas_solid::init", 'routine in <a href="obj/sld/ominas_solid__define.html">ominas_solid__define.pro</a>', "ominas_solid__define.pro", "", "ominas_solid::init", "", "crdbdsldii@sld__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/sld/ominas_solid__define.html#ominas_solid__define", "ominas_solid__define", 'routine in <a href="obj/sld/ominas_solid__define.html">ominas_solid__define.pro</a>', "ominas_solid__define.pro", "", "ominas_solid__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/str/ominas_star__define.html", "ominas_star__define.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "ominas_star__define.pro", "", "", " NAME: 	ominas_star__define    PURPOSE: 	Class structure for the STAR class.    CATEGORY: 	NV/LIB/STR    CALLING SEQUENCE: 	N/A    FIELDS: 	gbd:	GLOBE class descriptor.  		Methods: str_globe, str_set_globe   	lum:	Luminosity value.  		Methods: str_lum, str_set_lum   	sp:	Spectral class string.  		Methods: str_sp, str_set_sp    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/ominas_star__define.html#ominas_star::init", "ominas_star::init", 'routine in <a href="obj/str/ominas_star__define.html">ominas_star__define.pro</a>', "ominas_star__define.pro", "", "ominas_star::init", "", "crdbdsldgbdsdii@str__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/str/ominas_star__define.html#ominas_star__define", "ominas_star__define", 'routine in <a href="obj/str/ominas_star__define.html">ominas_star__define.pro</a>', "ominas_star__define.pro", "", "ominas_star__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/stn/ominas_station__define.html", "ominas_station__define.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "ominas_station__define.pro", "", "", " NAME: 	ominas_station__define    PURPOSE: 	Class structure for the STATION class.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	N/A    FIELDS: 	bd:	BODY class descriptor.  		Methods: stn_body, stn_set_body   	primary:	Primary body descriptor.  			Methods: stn_primary, stn_set_primary  	surface_pt:	Vector giving the surface coordinates of the 			stations location on the primary.  This 			is redundant with the location of bd, but it 			allows one to compute map coordinates without 			a body descriptor present.  			Methods: stn_surface_pt, stn_set_surface_pt     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/ominas_station__define.html#ominas_station::init", "ominas_station::init", 'routine in <a href="obj/stn/ominas_station__define.html">ominas_station__define.pro</a>', "ominas_station__define.pro", "", "ominas_station::init", "", "crdbdstdii@stn__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/stn/ominas_station__define.html#ominas_station__define", "ominas_station__define", 'routine in <a href="obj/stn/ominas_station__define.html">ominas_station__define.pro</a>', "ominas_station__define.pro", "", "ominas_station__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_anom_to_arg.html", "orb_anom_to_arg.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_anom_to_arg.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_anom_to_arg.html#orb_anom_to_arg", "orb_anom_to_arg", 'routine in <a href="obj/tools/orb/orb_anom_to_arg.html">orb_anom_to_arg.pro</a>', "orb_anom_to_arg.pro", "", "orb_anom_to_arg", "", "apxdanomframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_anom_to_arg_rate.html", "orb_anom_to_arg_rate.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_anom_to_arg_rate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_anom_to_arg_rate.html#orb_anom_to_arg_rate", "orb_anom_to_arg_rate", 'routine in <a href="obj/tools/orb/orb_anom_to_arg_rate.html">orb_anom_to_arg_rate.pro</a>', "orb_anom_to_arg_rate.pro", "", "orb_anom_to_arg_rate", "", "dapdtxddanomdtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_anom_to_lon.html", "orb_anom_to_lon.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_anom_to_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_anom_to_lon.html#orb_anom_to_lon", "orb_anom_to_lon", 'routine in <a href="obj/tools/orb/orb_anom_to_lon.html">orb_anom_to_lon.pro</a>', "orb_anom_to_lon.pro", "", "orb_anom_to_lon", "", "aplanxdanomframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_anom_to_lon_rate.html", "orb_anom_to_lon_rate.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_anom_to_lon_rate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_anom_to_lon_rate.html#orb_anom_to_lon_rate", "orb_anom_to_lon_rate", 'routine in <a href="obj/tools/orb/orb_anom_to_lon_rate.html">orb_anom_to_lon_rate.pro</a>', "orb_anom_to_lon_rate.pro", "", "orb_anom_to_lon_rate", "", "dapdtdlandtxddanomdtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_arg_to_anom.html", "orb_arg_to_anom.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_arg_to_anom.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_arg_to_anom.html#orb_arg_to_anom", "orb_arg_to_anom", 'routine in <a href="obj/tools/orb/orb_arg_to_anom.html">orb_arg_to_anom.pro</a>', "orb_arg_to_anom.pro", "", "orb_arg_to_anom", "", "apxdargframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_arg_to_anom_rate.html", "orb_arg_to_anom_rate.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_arg_to_anom_rate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_arg_to_anom_rate.html#orb_arg_to_anom_rate", "orb_arg_to_anom_rate", 'routine in <a href="obj/tools/orb/orb_arg_to_anom_rate.html">orb_arg_to_anom_rate.pro</a>', "orb_arg_to_anom_rate.pro", "", "orb_arg_to_anom_rate", "", "dapdtxddargdtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_arg_to_lon.html", "orb_arg_to_lon.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_arg_to_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_arg_to_lon.html#orb_arg_to_lon", "orb_arg_to_lon", 'routine in <a href="obj/tools/orb/orb_arg_to_lon.html">orb_arg_to_lon.pro</a>', "orb_arg_to_lon.pro", "", "orb_arg_to_lon", "", "lanxdargframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_arg_to_lon_rate.html", "orb_arg_to_lon_rate.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_arg_to_lon_rate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_arg_to_lon_rate.html#orb_arg_to_lon_rate", "orb_arg_to_lon_rate", 'routine in <a href="obj/tools/orb/orb_arg_to_lon_rate.html">orb_arg_to_lon_rate.pro</a>', "orb_arg_to_lon_rate.pro", "", "orb_arg_to_lon_rate", "", "dlandtxddargdtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_cartesian_to_orbit.html", "orb_cartesian_to_orbit.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_cartesian_to_orbit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_cartesian_to_orbit.html#orb_cartesian_to_orbit", "orb_cartesian_to_orbit", 'routine in <a href="obj/tools/orb/orb_cartesian_to_orbit.html">orb_cartesian_to_orbit.pro</a>', "orb_cartesian_to_orbit.pro", "", "orb_cartesian_to_orbit", "", "GGcirculargbx_r_v", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_dapdt.html", "orb_compute_dapdt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_compute_dapdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_dapdt.html#orb_compute_dapdt", "orb_compute_dapdt", 'routine in <a href="obj/tools/orb/orb_compute_dapdt.html">orb_compute_dapdt.pro</a>', "orb_compute_dapdt.pro", "", "orb_compute_dapdt", "", "GGsmaxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_dlandt.html", "orb_compute_dlandt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_compute_dlandt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_dlandt.html#orb_compute_dlandt", "orb_compute_dlandt", 'routine in <a href="obj/tools/orb/orb_compute_dlandt.html">orb_compute_dlandt.pro</a>', "orb_compute_dlandt.pro", "", "orb_compute_dlandt", "", "GGsmaxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_dlpdt.html", "orb_compute_dlpdt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_compute_dlpdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_dlpdt.html#orb_compute_dlpdt", "orb_compute_dlpdt", 'routine in <a href="obj/tools/orb/orb_compute_dlpdt.html">orb_compute_dlpdt.pro</a>', "orb_compute_dlpdt.pro", "", "orb_compute_dlpdt", "", "GGsmaxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_dmadt.html", "orb_compute_dmadt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_compute_dmadt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_dmadt.html#orb_compute_dmadt", "orb_compute_dmadt", 'routine in <a href="obj/tools/orb/orb_compute_dmadt.html">orb_compute_dmadt.pro</a>', "orb_compute_dmadt.pro", "", "orb_compute_dmadt", "", "GGsmaxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_dmldt.html", "orb_compute_dmldt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_compute_dmldt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_dmldt.html#orb_compute_dmldt", "orb_compute_dmldt", 'routine in <a href="obj/tools/orb/orb_compute_dmldt.html">orb_compute_dmldt.pro</a>', "orb_compute_dmldt.pro", "", "orb_compute_dmldt", "", "GGsmaxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_dtapdt.html", "orb_compute_dtapdt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_compute_dtapdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_dtapdt.html#orb_compute_dtapdt", "orb_compute_dtapdt", 'routine in <a href="obj/tools/orb/orb_compute_dtapdt.html">orb_compute_dtapdt.pro</a>', "orb_compute_dtapdt.pro", "", "orb_compute_dtapdt", "", "GGsmaxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_ea.html", "orb_compute_ea.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_compute_ea.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_ea.html#osk_eval", "osk_eval", 'routine in <a href="obj/tools/orb/orb_compute_ea.html">orb_compute_ea.pro</a>', "orb_compute_ea.pro", "", "osk_eval", "", "ea", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_ea.html#orb_compute_ea", "orb_compute_ea", 'routine in <a href="obj/tools/orb/orb_compute_ea.html">orb_compute_ea.pro</a>', "orb_compute_ea.pro", "", "orb_compute_ea", "", "eccrx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_elements.html", "orb_compute_elements.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_compute_elements.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_elements.html#orb_compute_elements", "orb_compute_elements", 'routine in <a href="obj/tools/orb/orb_compute_elements.html">orb_compute_elements.pro</a>', "orb_compute_elements.pro", "", "orb_compute_elements", "", "smaeccincaplandmldtdmadtdapdtliba_apdlibdt_aplib_apdlandtliba_landlibdt_lanlib_lanmamllptatlraddlpdttimerdtgbxtrdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_ma.html", "orb_compute_ma.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_compute_ma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_ma.html#orb_compute_ma", "orb_compute_ma", 'routine in <a href="obj/tools/orb/orb_compute_ma.html">orb_compute_ma.pro</a>', "orb_compute_ma.pro", "", "orb_compute_ma", "", "eccfearx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_r.html", "orb_compute_r.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_compute_r.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_r.html#orb_compute_r", "orb_compute_r", 'routine in <a href="obj/tools/orb/orb_compute_r.html">orb_compute_r.pro</a>', "orb_compute_r.pro", "", "orb_compute_r", "", "rx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/old/orb_compute_sma-old.html", "orb_compute_sma-old.pro", '.pro file in <a href="obj/tools/orb/old/dir-overview.html">obj/tools/orb/old/ directory</a>', "orb_compute_sma-old.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/old/orb_compute_sma-old.html#ocsma_fn", "ocsma_fn", 'routine in <a href="obj/tools/orb/old/orb_compute_sma-old.html">orb_compute_sma-old.pro</a>', "orb_compute_sma-old.pro", "", "ocsma_fn", "", "a", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/orb/old/orb_compute_sma-old.html#orb_compute_sma", "orb_compute_sma", 'routine in <a href="obj/tools/orb/old/orb_compute_sma-old.html">orb_compute_sma-old.pro</a>', "orb_compute_sma-old.pro", "", "orb_compute_sma", "", "GGdmldtxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_sma.html", "orb_compute_sma.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_compute_sma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_sma.html#ocsma_fn", "ocsma_fn", 'routine in <a href="obj/tools/orb/orb_compute_sma.html">orb_compute_sma.pro</a>', "orb_compute_sma.pro", "", "ocsma_fn", "", "a", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_sma.html#orb_compute_sma", "orb_compute_sma", 'routine in <a href="obj/tools/orb/orb_compute_sma.html">orb_compute_sma.pro</a>', "orb_compute_sma.pro", "", "orb_compute_sma", "", "GGJdmldtdlpdtdapdtdlandtxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_ta.html", "orb_compute_ta.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_compute_ta.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_compute_ta.html#orb_compute_ta", "orb_compute_ta", 'routine in <a href="obj/tools/orb/orb_compute_ta.html">orb_compute_ta.pro</a>', "orb_compute_ta.pro", "", "orb_compute_ta", "", "rx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_construct_descriptor.html", "orb_construct_descriptor.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_construct_descriptor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_construct_descriptor.html#orb_construct_descriptor", "orb_construct_descriptor", 'routine in <a href="obj/tools/orb/orb_construct_descriptor.html">orb_construct_descriptor.pro</a>', "orb_construct_descriptor.pro", "", "orb_construct_descriptor", "", "namesmaeccinclanaplpmamltatldmldtdmadtdlandtliba_landlibdt_lanlib_landapdtliba_apdlibdt_aplib_apdlpdtmmem_lpmdlpmdtlibamlibmdlibmdtllil_lanldlanldtliballibldlibldttimepptrd0ringGGnoevolvenocomputerdoutgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_evolve.html", "orb_evolve.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_evolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_evolve.html#orb_evolve", "orb_evolve", 'routine in <a href="obj/tools/orb/orb_evolve.html">orb_evolve.pro</a>', "orb_evolve.pro", "", "orb_evolve", "", "rxdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_evolve_ma.html", "orb_evolve_ma.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_evolve_ma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_evolve_ma.html#orb_evolve_ma", "orb_evolve_ma", 'routine in <a href="obj/tools/orb/orb_evolve_ma.html">orb_evolve_ma.pro</a>', "orb_evolve_ma.pro", "", "orb_evolve_ma", "", "rxdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_ap.html", "orb_get_ap.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_ap.html#_orb_get_ap", "_orb_get_ap", 'routine in <a href="obj/tools/orb/orb_get_ap.html">orb_get_ap.pro</a>', "orb_get_ap.pro", "", "_orb_get_ap", "", "xdframe_bd", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_ap.html#orb_get_ap", "orb_get_ap", 'routine in <a href="obj/tools/orb/orb_get_ap.html">orb_get_ap.pro</a>', "orb_get_ap.pro", "", "orb_get_ap", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_ascending_node.html", "orb_get_ascending_node.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_ascending_node.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_ascending_node.html#orb_get_ascending_node", "orb_get_ascending_node", 'routine in <a href="obj/tools/orb/orb_get_ascending_node.html">orb_get_ascending_node.pro</a>', "orb_get_ascending_node.pro", "", "orb_get_ascending_node", "", "arbitraryrefsafexdframe_bd", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_ascending_node.html#_orb_get_ascending_node", "_orb_get_ascending_node", 'routine in <a href="obj/tools/orb/orb_get_ascending_node.html">orb_get_ascending_node.pro</a>', "orb_get_ascending_node.pro", "", "_orb_get_ascending_node", "", "arbitraryrefxdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dapdt.html", "orb_get_dapdt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_dapdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dapdt.html#orb_get_dapdt", "orb_get_dapdt", 'routine in <a href="obj/tools/orb/orb_get_dapdt.html">orb_get_dapdt.pro</a>', "orb_get_dapdt.pro", "", "orb_get_dapdt", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dlandt.html", "orb_get_dlandt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_dlandt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dlandt.html#orb_get_dlandt", "orb_get_dlandt", 'routine in <a href="obj/tools/orb/orb_get_dlandt.html">orb_get_dlandt.pro</a>', "orb_get_dlandt.pro", "", "orb_get_dlandt", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dlibdt_ap.html", "orb_get_dlibdt_ap.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_dlibdt_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dlibdt_ap.html#orb_get_dlibdt_ap", "orb_get_dlibdt_ap", 'routine in <a href="obj/tools/orb/orb_get_dlibdt_ap.html">orb_get_dlibdt_ap.pro</a>', "orb_get_dlibdt_ap.pro", "", "orb_get_dlibdt_ap", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dlibdt_lan.html", "orb_get_dlibdt_lan.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_dlibdt_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dlibdt_lan.html#orb_get_dlibdt_lan", "orb_get_dlibdt_lan", 'routine in <a href="obj/tools/orb/orb_get_dlibdt_lan.html">orb_get_dlibdt_lan.pro</a>', "orb_get_dlibdt_lan.pro", "", "orb_get_dlibdt_lan", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dlpmdt.html", "orb_get_dlpmdt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_dlpmdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dlpmdt.html#orb_get_dlpmdt", "orb_get_dlpmdt", 'routine in <a href="obj/tools/orb/orb_get_dlpmdt.html">orb_get_dlpmdt.pro</a>', "orb_get_dlpmdt.pro", "", "orb_get_dlpmdt", "", "rdpd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dmadt.html", "orb_get_dmadt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_dmadt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dmadt.html#orb_get_dmadt", "orb_get_dmadt", 'routine in <a href="obj/tools/orb/orb_get_dmadt.html">orb_get_dmadt.pro</a>', "orb_get_dmadt.pro", "", "orb_get_dmadt", "", "xdjunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dmldt.html", "orb_get_dmldt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_dmldt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_dmldt.html#orb_get_dmldt", "orb_get_dmldt", 'routine in <a href="obj/tools/orb/orb_get_dmldt.html">orb_get_dmldt.pro</a>', "orb_get_dmldt.pro", "", "orb_get_dmldt", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_ecc.html", "orb_get_ecc.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_ecc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_ecc.html#orb_get_ecc", "orb_get_ecc", 'routine in <a href="obj/tools/orb/orb_get_ecc.html">orb_get_ecc.pro</a>', "orb_get_ecc.pro", "", "orb_get_ecc", "", "xdjunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_inc.html", "orb_get_inc.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_inc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_inc.html#orb_get_inc", "orb_get_inc", 'routine in <a href="obj/tools/orb/orb_get_inc.html">orb_get_inc.pro</a>', "orb_get_inc.pro", "", "orb_get_inc", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_lan.html", "orb_get_lan.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_lan.html#orb_get_lan", "orb_get_lan", 'routine in <a href="obj/tools/orb/orb_get_lan.html">orb_get_lan.pro</a>', "orb_get_lan.pro", "", "orb_get_lan", "", "refxdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_lib_ap.html", "orb_get_lib_ap.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_lib_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_lib_ap.html#orb_get_lib_ap", "orb_get_lib_ap", 'routine in <a href="obj/tools/orb/orb_get_lib_ap.html">orb_get_lib_ap.pro</a>', "orb_get_lib_ap.pro", "", "orb_get_lib_ap", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_lib_lan.html", "orb_get_lib_lan.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_lib_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_lib_lan.html#orb_get_lib_lan", "orb_get_lib_lan", 'routine in <a href="obj/tools/orb/orb_get_lib_lan.html">orb_get_lib_lan.pro</a>', "orb_get_lib_lan.pro", "", "orb_get_lib_lan", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_liba_ap.html", "orb_get_liba_ap.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_liba_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_liba_ap.html#orb_get_liba_ap", "orb_get_liba_ap", 'routine in <a href="obj/tools/orb/orb_get_liba_ap.html">orb_get_liba_ap.pro</a>', "orb_get_liba_ap.pro", "", "orb_get_liba_ap", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_liba_lan.html", "orb_get_liba_lan.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_liba_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_liba_lan.html#orb_get_liba_lan", "orb_get_liba_lan", 'routine in <a href="obj/tools/orb/orb_get_liba_lan.html">orb_get_liba_lan.pro</a>', "orb_get_liba_lan.pro", "", "orb_get_liba_lan", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_lpm.html", "orb_get_lpm.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_lpm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_lpm.html#orb_get_lpm", "orb_get_lpm", 'routine in <a href="obj/tools/orb/orb_get_lpm.html">orb_get_lpm.pro</a>', "orb_get_lpm.pro", "", "orb_get_lpm", "", "rdpd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_ma.html", "orb_get_ma.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_ma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_ma.html#orb_get_ma", "orb_get_ma", 'routine in <a href="obj/tools/orb/orb_get_ma.html">orb_get_ma.pro</a>', "orb_get_ma.pro", "", "orb_get_ma", "", "xdjunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_sma.html", "orb_get_sma.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_get_sma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_get_sma.html#orb_get_sma", "orb_get_sma", 'routine in <a href="obj/tools/orb/orb_get_sma.html">orb_get_sma.pro</a>', "orb_get_sma.pro", "", "orb_get_sma", "", "xdjunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_inertialize.html", "orb_inertialize.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_inertialize.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_inertialize.html#orb_inertialize", "orb_inertialize", 'routine in <a href="obj/tools/orb/orb_inertialize.html">orb_inertialize.pro</a>', "orb_inertialize.pro", "", "orb_inertialize", "", "frame_bx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_init_descriptors.html", "orb_init_descriptors.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_init_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_init_descriptors.html#orb_create_descriptors", "orb_create_descriptors", 'routine in <a href="obj/tools/orb/orb_init_descriptors.html">orb_init_descriptors.pro</a>', "orb_init_descriptors.pro", "", "orb_create_descriptors", "", "namesmaeccinclanapmadmadtdlandtdapdttngbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_lon_to_anom.html", "orb_lon_to_anom.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_lon_to_anom.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_lon_to_anom.html#orb_lon_to_anom", "orb_lon_to_anom", 'routine in <a href="obj/tools/orb/orb_lon_to_anom.html">orb_lon_to_anom.pro</a>', "orb_lon_to_anom.pro", "", "orb_lon_to_anom", "", "aplanxdlonframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_lon_to_anom_rate.html", "orb_lon_to_anom_rate.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_lon_to_anom_rate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_lon_to_anom_rate.html#orb_lon_to_anom_rate", "orb_lon_to_anom_rate", 'routine in <a href="obj/tools/orb/orb_lon_to_anom_rate.html">orb_lon_to_anom_rate.pro</a>', "orb_lon_to_anom_rate.pro", "", "orb_lon_to_anom_rate", "", "dapdtdlandtxddlondtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_lon_to_arg.html", "orb_lon_to_arg.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_lon_to_arg.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_lon_to_arg.html#orb_lon_to_arg", "orb_lon_to_arg", 'routine in <a href="obj/tools/orb/orb_lon_to_arg.html">orb_lon_to_arg.pro</a>', "orb_lon_to_arg.pro", "", "orb_lon_to_arg", "", "lanxdlonframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_lon_to_arg_rate.html", "orb_lon_to_arg_rate.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_lon_to_arg_rate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_lon_to_arg_rate.html#orb_lon_to_arg_rate", "orb_lon_to_arg_rate", 'routine in <a href="obj/tools/orb/orb_lon_to_arg_rate.html">orb_lon_to_arg_rate.pro</a>', "orb_lon_to_arg_rate.pro", "", "orb_lon_to_arg_rate", "", "dlandtxddlondtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_lon_to_body.html", "orb_lon_to_body.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_lon_to_body.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_lon_to_body.html#orb_lon_to_body", "orb_lon_to_body", 'routine in <a href="obj/tools/orb/orb_lon_to_body.html">orb_lon_to_body.pro</a>', "orb_lon_to_body.pro", "", "orb_lon_to_body", "", "frame_bdxdlon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_min_distance.html", "orb_min_distance.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_min_distance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_min_distance.html#_eval_omd", "_eval_omd", 'routine in <a href="obj/tools/orb/orb_min_distance.html">orb_min_distance.pro</a>', "orb_min_distance.pro", "", "_eval_omd", "", "p", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_min_distance.html#orb_min_distance", "orb_min_distance", 'routine in <a href="obj/tools/orb/orb_min_distance.html">orb_min_distance.pro</a>', "orb_min_distance.pro", "", "orb_min_distance", "", "frame_bdlon1lon2distanceslons_xd1_xd2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_plot.html", "orb_plot.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_plot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_plot.html#orb_plot", "orb_plot", 'routine in <a href="obj/tools/orb/orb_plot.html">orb_plot.pro</a>', "orb_plot.pro", "", "orb_plot", "", "cd_rdframe_bx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_precess.html", "orb_precess.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_precess.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_precess.html#orb_precess", "orb_precess", 'routine in <a href="obj/tools/orb/orb_precess.html">orb_precess.pro</a>', "orb_precess.pro", "", "orb_precess", "", "_pd_rdpd_precessrd_precessobs_bx_pd0pd_rd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_print_descriptor.html", "orb_print_descriptor.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_print_descriptor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_print_descriptor.html#orb_get_elements", "orb_get_elements", 'routine in <a href="obj/tools/orb/orb_print_descriptor.html">orb_print_descriptor.pro</a>', "orb_print_descriptor.pro", "", "orb_get_elements", "", "trdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_ap.html", "orb_set_ap.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_ap.html#orb_set_ap", "orb_set_ap", 'routine in <a href="obj/tools/orb/orb_set_ap.html">orb_set_ap.pro</a>', "orb_set_ap.pro", "", "orb_set_ap", "", "xdframe_bdap", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_dapdt.html", "orb_set_dapdt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_dapdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_dapdt.html#orb_set_dapdt", "orb_set_dapdt", 'routine in <a href="obj/tools/orb/orb_set_dapdt.html">orb_set_dapdt.pro</a>', "orb_set_dapdt.pro", "", "orb_set_dapdt", "", "xdframe_bddapdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_dlandt.html", "orb_set_dlandt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_dlandt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_dlandt.html#orb_set_dlandt", "orb_set_dlandt", 'routine in <a href="obj/tools/orb/orb_set_dlandt.html">orb_set_dlandt.pro</a>', "orb_set_dlandt.pro", "", "orb_set_dlandt", "", "xdframe_bddlandt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_dlibdt_ap.html", "orb_set_dlibdt_ap.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_dlibdt_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_dlibdt_ap.html#orb_set_dlibdt_ap", "orb_set_dlibdt_ap", 'routine in <a href="obj/tools/orb/orb_set_dlibdt_ap.html">orb_set_dlibdt_ap.pro</a>', "orb_set_dlibdt_ap.pro", "", "orb_set_dlibdt_ap", "", "xdframe_bddlibdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_dlibdt_lan.html", "orb_set_dlibdt_lan.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_dlibdt_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_dlibdt_lan.html#orb_set_dlibdt_lan", "orb_set_dlibdt_lan", 'routine in <a href="obj/tools/orb/orb_set_dlibdt_lan.html">orb_set_dlibdt_lan.pro</a>', "orb_set_dlibdt_lan.pro", "", "orb_set_dlibdt_lan", "", "xdframe_bddlibdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_dlpmdt.html", "orb_set_dlpmdt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_dlpmdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_dlpmdt.html#orb_set_dlpmdt", "orb_set_dlpmdt", 'routine in <a href="obj/tools/orb/orb_set_dlpmdt.html">orb_set_dlpmdt.pro</a>', "orb_set_dlpmdt.pro", "", "orb_set_dlpmdt", "", "rddlpmdtpd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_dmadt.html", "orb_set_dmadt.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_dmadt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_dmadt.html#orb_set_dmadt", "orb_set_dmadt", 'routine in <a href="obj/tools/orb/orb_set_dmadt.html">orb_set_dmadt.pro</a>', "orb_set_dmadt.pro", "", "orb_set_dmadt", "", "xddmadtjunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_ecc.html", "orb_set_ecc.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_ecc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_ecc.html#orb_set_ecc", "orb_set_ecc", 'routine in <a href="obj/tools/orb/orb_set_ecc.html">orb_set_ecc.pro</a>', "orb_set_ecc.pro", "", "orb_set_ecc", "", "xd_eccjunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_inc.html", "orb_set_inc.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_inc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_inc.html#orb_set_inc", "orb_set_inc", 'routine in <a href="obj/tools/orb/orb_set_inc.html">orb_set_inc.pro</a>', "orb_set_inc.pro", "", "orb_set_inc", "", "xdframe_bdinc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_lan.html", "orb_set_lan.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_lan.html#orb_set_lan", "orb_set_lan", 'routine in <a href="obj/tools/orb/orb_set_lan.html">orb_set_lan.pro</a>', "orb_set_lan.pro", "", "orb_set_lan", "", "xdframe_bdlan", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_lib_ap.html", "orb_set_lib_ap.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_lib_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_lib_ap.html#orb_set_lib_ap", "orb_set_lib_ap", 'routine in <a href="obj/tools/orb/orb_set_lib_ap.html">orb_set_lib_ap.pro</a>', "orb_set_lib_ap.pro", "", "orb_set_lib_ap", "", "xdframe_bdlib", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_lib_lan.html", "orb_set_lib_lan.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_lib_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_lib_lan.html#orb_set_lib_lan", "orb_set_lib_lan", 'routine in <a href="obj/tools/orb/orb_set_lib_lan.html">orb_set_lib_lan.pro</a>', "orb_set_lib_lan.pro", "", "orb_set_lib_lan", "", "xdframe_bdlib_lan", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_liba_ap.html", "orb_set_liba_ap.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_liba_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_liba_ap.html#orb_set_liba_ap", "orb_set_liba_ap", 'routine in <a href="obj/tools/orb/orb_set_liba_ap.html">orb_set_liba_ap.pro</a>', "orb_set_liba_ap.pro", "", "orb_set_liba_ap", "", "xdframe_bdliba_ap", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_liba_lan.html", "orb_set_liba_lan.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_liba_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_liba_lan.html#orb_set_liba_lan", "orb_set_liba_lan", 'routine in <a href="obj/tools/orb/orb_set_liba_lan.html">orb_set_liba_lan.pro</a>', "orb_set_liba_lan.pro", "", "orb_set_liba_lan", "", "xdframe_bdliba_lan", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_lpm.html", "orb_set_lpm.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_lpm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_lpm.html#orb_set_lpm", "orb_set_lpm", 'routine in <a href="obj/tools/orb/orb_set_lpm.html">orb_set_lpm.pro</a>', "orb_set_lpm.pro", "", "orb_set_lpm", "", "rdlpmpd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_ma.html", "orb_set_ma.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_ma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_ma.html#orb_set_ma", "orb_set_ma", 'routine in <a href="obj/tools/orb/orb_set_ma.html">orb_set_ma.pro</a>', "orb_set_ma.pro", "", "orb_set_ma", "", "xdmajunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_sma.html", "orb_set_sma.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_set_sma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_set_sma.html#orb_set_sma", "orb_set_sma", 'routine in <a href="obj/tools/orb/orb_set_sma.html">orb_set_sma.pro</a>', "orb_set_sma.pro", "", "orb_set_sma", "", "xd_smajunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/old/orb_solve_kepler.html", "orb_solve_kepler.pro", '.pro file in <a href="obj/tools/orb/old/dir-overview.html">obj/tools/orb/old/ directory</a>', "orb_solve_kepler.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/old/orb_solve_kepler.html#osk_eval", "osk_eval", 'routine in <a href="obj/tools/orb/old/orb_solve_kepler.html">orb_solve_kepler.pro</a>', "orb_solve_kepler.pro", "", "osk_eval", "", "EE", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/orb/old/orb_solve_kepler.html#orb_solve_kepler", "orb_solve_kepler", 'routine in <a href="obj/tools/orb/old/orb_solve_kepler.html">orb_solve_kepler.pro</a>', "orb_solve_kepler.pro", "", "orb_solve_kepler", "", "rx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_span_errors.html", "orb_span_errors.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_span_errors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_span_errors.html#ope_span_mc", "ope_span_mc", 'routine in <a href="obj/tools/orb/orb_span_errors.html">orb_span_errors.pro</a>', "orb_span_errors.pro", "", "ope_span_mc", "", "x0_sig_xnsignseed", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_span_errors.html#ope_span", "ope_span", 'routine in <a href="obj/tools/orb/orb_span_errors.html">orb_span_errors.pro</a>', "orb_span_errors.pro", "", "ope_span", "", "x0_sig_xnsignscanndim", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_span_errors.html#orb_span_errors", "orb_span_errors", 'routine in <a href="obj/tools/orb/orb_span_errors.html">orb_span_errors.pro</a>', "orb_span_errors.pro", "", "orb_span_errors", "", "nsignscannsamplesdkxgbxsig_dkx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_test.html", "orb_test.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_test.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_test.html#orb_test", "orb_test", 'routine in <a href="obj/tools/orb/orb_test.html">orb_test.pro</a>', "orb_test.pro", "", "orb_test", "", "xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/orb/orb_to_cartesian.html", "orb_to_cartesian.pro", '.pro file in <a href="obj/tools/orb/dir-overview.html">obj/tools/orb/ directory</a>', "orb_to_cartesian.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/orb/orb_to_cartesian.html#orb_to_cartesian", "orb_to_cartesian", 'routine in <a href="obj/tools/orb/orb_to_cartesian.html">orb_to_cartesian.pro</a>', "orb_to_cartesian.pro", "", "orb_to_cartesian", "", "velf_rx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_add_selections.html", "pg_add_selections.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_add_selections.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_add_selections.html#pg_add_selections", "pg_add_selections", 'routine in <a href="com/pg/pg_add_selections.html">pg_add_selections.pro</a>', "pg_add_selections.pro", "", "pg_add_selections", "", "trsselect", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_array.html", "pg_array.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_array.pro", "", "", " NAME: 	pg_array    PURPOSE: 	Computes image points for given array descriptors.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	array_ptd = pg_array(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	ard:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of array.  	gbx:	Array (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of GLOBE.  	dkx:	Array (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of DISK.  	bx:	Array (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of BODY, instead of gbx or dkx.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.     OUTPUT: NONE    RETURN: 	Array (n_objects) of objects containing image points and 	the corresponding inertial vectors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_array.html#pg_array", "pg_array", 'routine in <a href="com/pg/pg_array.html">pg_array.pro</a>', "pg_array.pro", "", "pg_array", "", "cdardgbxdkxbxddgdclipcull", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_bad_data.html", "pg_bad_data.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_bad_data.pro", "", "", " NAME: 	pg_bad_data    PURPOSE: 	Locates areas of bad data values like saturation and dropouts.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_bad_data(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing the image to be despiked.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	dropout:	Value to use for dropouts.  Default is 0  	sat:		If given, value above which to flag as saturated, 			inclusive.  	mask:		Byte image of the same size as the input image 			in which nonzero pixel values indicate locations 			where problems should not be flagged.  	extend:		Number of pixels away from masked pixels before 			locations may be flagged as spikes.  	edge:		Regions closer than this to the edge of the image 			will be ignored.  Default is 0.    OUTPUT: 	subscripts:	Subscript of each bad point.    RETURN: 	POINT objects containing the detected bad points.    STATUS: 	Complete    SEE ALSO: 	pg_spikes    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_bad_data.html#pg_bad_data", "pg_bad_data", 'routine in <a href="com/pg/pg_bad_data.html">pg_bad_data.pro</a>', "pg_bad_data.pro", "", "pg_bad_data", "", "dropoutsatmaskextendedgesubscriptsdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_blemish.html", "pg_blemish.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_blemish.pro", "", "", " NAME: 	pg_blemish    PURPOSE: 	Removes blemishes from an image using interpolation.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_blemish(dd, blem_ptd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing the image to be corrected.  	blem_ptd:	POINT object containing the known image 			coordinates of the blemishes.  If an array of 			objects is given, then the operation is 			performed repeatedly using each set of blemish 			coordinates.  			This argument can also be specified directly as an 			array of image points.    OUTPUT: 	NONE    KEYWORDS:   INPUT:         a:		Semimajor axis of elliptical blemish model.  Default is 			5 pixels.          b:		Semiminor axis of elliptical blemish model.  Default is 			5 pixels.          h:		Angle of rotation (in radians) of smimajor axis from 			horizontal.  Default is 0.  	 show:		If set, the outlines of the blemishes are plotted on 			the current graphics window.    OUTPUT: 	image:		The corrected image.    RETURN: 	Data descriptor containing the corrected image.    PROCEDURE: 	Blemishes are modeled as ellipses.  Pixels interior to the ellipse 	are interpolated from those on the boundary.    STATUS: 	Complete    SEE ALSO: 	pg_resloc, pg_linearize_image, pg_resfit    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_blemish.html#pg_blemish", "pg_blemish", 'routine in <a href="com/pg/pg_blemish.html">pg_blemish.pro</a>', "pg_blemish.pro", "", "pg_blemish", "", "abhimageshowddblem_ptdnom_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_center.html", "pg_center.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_center.pro", "", "", " NAME: 	pg_center    PURPOSE: 	Computes image coordinates of the center of each object.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	center_ptd = pg_center(cd=cd, bx=bx) 	center_ptd = pg_center(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (nt) of camera descriptors.  	bx:	Array (n_objects, nt) of descriptors of objects 		which must be a subclass of BODY.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.    OUTPUT: NONE    RETURN: 	Array (n_objects) of POINT objets containing image points and 	the corresponding inertial vectors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_center.html#pg_center", "pg_center", 'routine in <a href="com/pg/pg_center.html">pg_center.pro</a>', "pg_center.pro", "", "pg_center", "", "cdbxddgdclipcull", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_chisq.html", "pg_chisq.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_chisq.pro", "", "", " NAME: 	pg_chisq    PURPOSE: 	Computes chi-squared value for given curve- or point-fit parameters.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	chisq = pg_chisq(dxy, dtheta, scan_ptd, axis_ptd=axis_ptd)    ARGUMENTS:   INPUT: 	dxy:		2-element vector giving the translation as [dx,dy].  	dtheta:		Rotation in radians.  	scan_ptd:	Array (n_curves) of POINT objects output from 			pg_cvscan or pg_ptscan containing scan data.    OUTPUT: NONE    KEYWORDS:   INPUT: 	axis_ptd:	POINT object containing a single image point 			to be used as the axis of rotation.  	fix:		Array specifying which parameters to fix as 			[dx,dy,dtheta].    OUTPUT: NONE    RETURN: 	Normalized chi-square value.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, 	pg_ptchisq, pg_fit, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_chisq.html#pg_chisq", "pg_chisq", 'routine in <a href="com/pg/pg_chisq.html">pg_chisq.pro</a>', "pg_chisq.pro", "", "pg_chisq", "", "axis_ptdfixdxydthetascan_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_cntrd.html", "pg_cntrd.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cntrd.pro", "", "", " NAME: 	pg_cntrd    PURPOSE: 	Calculates the centroids centered near given features in 	an image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_cntrd(dd, object_ptd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor  	object_ptd: 	Array (n_pts) of POINT objects giving the points. 			Only the image coordinates of the points need to be 			specified.    OUTPUT:        NONE   KEYWORDS:   INPUT:         fwhm:           Full-Width Half-maximum to use around expected point                        location.  If not given, a default fwhm of 2 pixels                        is used.         edge:           Distance from edge from which to ignore points.  If                        not given, an edge distance of 0 is used.       sigmin:           If given, points are discarded if the sigma above                        the mean for the centroid pixel is below this value.     OUTPUT: NONE    RETURN: 	An array of type POINT objects giving the detected position for        each object.  The max values for each detection is        saved in the data portion of object with tag 'scan_cc'.        The x and y offset from the given position is also saved.    RESTRICTIONS: 	Currently does not work for multiple time steps.    PROCEDURE: 	For each visible object, a centroid is calcualted using the 	astronlib cntrd routine.    SEE ALSO: 	ptscan, pg_ptscan, pg_ptcntrd   STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 2/1999   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cntrd.html#pg_cntrd", "pg_cntrd", 'routine in <a href="com/pg/pg_cntrd.html">pg_cntrd.pro</a>', "pg_cntrd.pro", "", "pg_cntrd", "", "fwhmedgesigminddobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_coadd.html", "pg_coadd.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_coadd.pro", "", "", " NAME: 	pg_coadd    PURPOSE: 	Averages the given images and geometries.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dd0 = pg_coadd(dd, bx0, cd=cd, bx=bx)    ARGUMENTS:   INPUT: 	dd:	Array of data descriptors giving images to average.    OUTPUT: 	bx0:	Averaged bx body descriptors.    KEYWORDS:   INPUT: 	bx:	Array [ndd] or [ndd,n] of descriptors of any superclass of BODY, 		one for each input image, to be averaged.  Times, positions, and 		orientations are average.  In addition, for any camera 		descriptors, the optical axes are also averaged.  	gd:	Generic descriptor containing the body descriptors or an 		array [ndd] of generic descriptors.  	median: If set, the median is used instead of the average.  	minimum: If set, the minimum is used instead of the average.  	maximum: If set, the maximum is used instead of the average.  	algorithm: String giving the alogrithm to use instead of specifying 		   One of the above keyowrds.  Default is 'average .    OUTPUT: NONE     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 4/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_coadd.html#pgc_compute_average", "pgc_compute_average", 'routine in <a href="com/pg/pg_coadd.html">pg_coadd.pro</a>', "pg_coadd.pro", "", "pgc_compute_average", "", "dd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_coadd.html#pgc_compute_median", "pgc_compute_median", 'routine in <a href="com/pg/pg_coadd.html">pg_coadd.pro</a>', "pg_coadd.pro", "", "pgc_compute_median", "", "dd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_coadd.html#pgc_compute_minimum", "pgc_compute_minimum", 'routine in <a href="com/pg/pg_coadd.html">pg_coadd.pro</a>', "pg_coadd.pro", "", "pgc_compute_minimum", "", "dd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_coadd.html#pgc_compute_maximum", "pgc_compute_maximum", 'routine in <a href="com/pg/pg_coadd.html">pg_coadd.pro</a>', "pg_coadd.pro", "", "pgc_compute_maximum", "", "dd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_coadd.html#pg_coadd", "pg_coadd", 'routine in <a href="com/pg/pg_coadd.html">pg_coadd.pro</a>', "pg_coadd.pro", "", "pg_coadd", "", "cdbxgdmedianminimummaximumalgorithmddbx0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_core.html", "pg_core.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_core.pro", "", "", " NAME: 	pg_core    PURPOSE: 	Generates a dn profile through a cube, or stack of images.   CATEGORY: 	NV/PG    CALLING SEQUENCE:     result = pg_core(dd, cd=cd, outline_ptd)    ARGUMENTS:   INPUT: 	  dd:	 Data descriptor(s).   outline_ptd:   POINT descriptor giving the outline of the region to plot,                 as produced by the pg_select_region.    OUTPUT:         NONE   KEYWORDS:   INPUT: 	  cd:	Camera descriptor.  Needed for sinc interpolation. (to get PSF)           gd:   Optional generic descriptor containing cd.       interp:   Type of interpolation to use.  Options are:                'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.           bg:	Uniform value to subtract from profile.   arg_interp:   Arguments to pass to the interpolation function.     OUTPUT:     profile:   The profile.        sigma:   Array giving the standard deviation at each point in the 		profile.      distance:  Array giving the distance, in pixels, along the profile.     image_pts:  Image point for each point along the profile.    RETURN: 	Two data descriptors: the first contains the profile; the second contains 	the profile sigma.    MODIFICATION HISTORY:        Written by:     Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_core.html#pg_core", "pg_core", 'routine in <a href="com/pg/pg_core.html">pg_core.pro</a>', "pg_core.pro", "", "pg_core", "", "cdgddistanceinterparg_interpsigmaprofileimage_ptsbgddoutline_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_core.html#test", "test", 'routine in <a href="com/pg/pg_core.html">pg_core.pro</a>', "pg_core.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_coregister.html", "pg_coregister.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_coregister.pro", "", "", " NAME: 	pg_coregister    PURPOSE: 	Using the given geometry information, shifts the given images so as 	to center the given bodies at the same pixel in each image, or aligns 	images based on pointing.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_coregister, dd, cd=cd, bx=bx    ARGUMENTS:   INPUT: 	dd:	Array of data descriptors giving images to shift.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array of camera descripors, one for each input image.  	bx:	Array of descriptors of any superclass of BODY, one for each 		input image.  	gd:	Generic descriptor containing the camera and body 		descriptors or an array of generic descriptors, one for each 		input image.  	center: Image coordinates at which to center each body.  By default, 		the average center among all the bodies is used.  If this input 		contains a single element, it is taken as the index of the 		input image to use as the reference.  	p:	Array (1,3) giving surface coordinates at which to center 		each body.  	xshift:	Additional image offset by which to shift each image.  	wrap:	If set shifted pixels are wrapped to the opposite side 		of the image.  	subpixel: By default, each image is shifted by an integer number of 		  pixels in each direction. If this keyword is set, the 		  image is interpolated onto a new pixel grid such that the 		  sub-pixel shift is obtained.  (Not currently implemented)    OUTPUT: 	shift:	Offset applied to each image.    SIDE EFFECTS: 	The given data and camera descriptors are modified: the images are 	shifted and the camera descriptor optic axes are changed accordingly.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_coregister.html#pg_coregister", "pg_coregister", 'routine in <a href="com/pg/pg_coregister.html">pg_coregister.pro</a>', "pg_coregister.pro", "", "pg_coregister", "", "cdbxgdshiftcenterpxshiftwrapsubpixelno_shiftdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_covariance.html", "pg_covariance.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_covariance.pro", "", "", " NAME: 	pg_covariance    PURPOSE: 	Computes a covariance matrix for the least-square fit specified by the 	input scan coefficients.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dxy = pg_covariance(cf)    ARGUMENTS:   INPUT: 	cf:	Array of pg_fit_coeff_struct as produced by pg_cvscan_coeff or 		pg_ptscan_coeff.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	status:	0 if successful, -1 otherwise.    RETURN: 	Covariance matrix.  The diagonal elements are the variances in each fit 	parameter, the off-diagonal elements are the covariances.    RESTRICTIONS: 	It is the caller's responsibility to ensure that all of the input 	coefficients were computed using with the same set of fixed parameters.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvscan_coeff, pg_ptscan, pg_ptscan_coeff, 	pg_cvchisq, pg_ptchisq, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_covariance.html#pg_covariance", "pg_covariance", 'routine in <a href="com/pg/pg_covariance.html">pg_covariance.pro</a>', "pg_covariance.pro", "", "pg_covariance", "", "statuscf", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_crop.html", "pg_crop.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_crop.pro", "", "", " NAME:        pg_crop    PURPOSE:        Crops an image and modifies that camera descriptor accordingly.    CATEGORY:        NV/PG    CALLING SEQUENCE:        pg_crop, dd, corner_ptd, cd=cd, image=image    ARGUMENTS:   INPUT:        dd:        Data descriptor containing the image to be cropped.  	corner_ptd: POINT object containing 2 points, giving the corners 		    for cropping.  May also be an array of 2 image points.    OUTPUT:        dd:	The image contained in the input data descriptor is cropped.    KEYWORDS:   INPUT:        cd:     Camera descriptor.         gd:     Generic descriptor to use instead of cd.    OUTPUT: 	cd:	The optic axis of the camera descriptor is modified to 		correspond to the corrected image.         image:	The cropped image    RETURN:        NONE    EXAMPLE: 	pg_crop, dd, cd=cd, [[100,200], [800,900]], im=im    STATUS:        Complete.    NOTES: 	This routine should be modified to work with map descriptors as well.    MODIFICATION HISTORY:        Written by:     Spitale; 6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_crop.html#pg_crop", "pg_crop", 'routine in <a href="com/pg/pg_crop.html">pg_crop.pro</a>', "pg_crop.pro", "", "pg_crop", "", "cdgdimagecropddcorner_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_crop_points.html", "pg_crop_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_crop_points.pro", "", "", " NAME: 	pg_crop_points    PURPOSE: 	Hides image points that lie outside the field of view.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_crop_points, cd, ptd    ARGUMENTS:   INPUT: 	ptd:	POINT object containing points to be cropped.    OUTPUT: 	ptd:	The input POINT object is modified.    KEYWORDS:   INPUT: 	cd:	Camera descriptor, used to determine image dimenesions.  	slop:	Number of pixels outside image to include.  Defautl is 1.    OUTPUT: 	indices: Indices of retained points.    RETURN: 	NONE    RESTRICTIONS: 	The given POINT object is modified.    STATUS: 	xx    MODIFICATION HISTORY:  	Written by:	Spitale; 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_crop_points.html#pg_crop_points", "pg_crop_points", 'routine in <a href="com/pg/pg_crop_points.html">pg_crop_points.pro</a>', "pg_crop_points.pro", "", "pg_crop_points", "", "cdslopindicesptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_cursor.html", "pg_cursor.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cursor.pro", "", "", " NAME: 	pg_cursor    PURPOSE: 	Allows the user to obtain information about image pixels selected 	using the mouse in the current graphics window.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_cursor, dd    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing the image.  Multiple data 		descriptors may be given and the pixel values for each will 		be displayed.  However, descriptors for only one of the data 		descriptors may be given.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	cd:	Camera descriptor.  Must be included for planet and ring 		coordinate, RA/DEC, and photometric output.  A map descriptor 		may be substitued for this argument, in which case ring 		coordinates, RA/DEC, and photometric data are not output.  	gbx:	Object descriptors, subclass of 'GLOBE'.  Must be included for 		planet coordinate output.  	dkx:	Object descriptors, subclass of 'DISK'.  Must be included for 		ring coordinate output.  	sund:	Star descriptor specifying the state of the sun.  	sd:	Star descriptors.  Must be included for star otput.  	gd:	Generic descriptor.  If given, the above object descriptors are 		taken from this structure.  	radec:	If set, right ascension and declination with respect to the 		inertial coordinate system are output for each selected pixel.  	photom:	If set, photometric angles are output for each pixel that 		intersects a planet or ring.  (Ring photometry is not yet 		implememented)  	fn:	Names of functions to be called whenever a point is selected. 		Each function is called as follows:  		value = call_function(fn, p, image, gd=gd, $                                                format=_format, label=label)  		p is the image coords of the selected point, image is the 		input image and gd is a generic descriptor containing the 		object descriptors.  format and label are outputs used to label 		the returned value.  These functions are apended to the set of 		default functions.  	silent:	If set, no string is printed, although the 'string' output 		keyword remains valid.  	xy:	If present, this image point is used and the user is not 		prompted to select a point.     OUTPUT: 	string:	The string that's printed.  If /silent is specified, this 		string is valid, but not printed.  	values: Array (nfn,2,npoints) giving the numerical results in the order 		that they appear in the output.    RETURN: 	NONE    STATUS: 	Ring photometry is not yet implemented.    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#_pgc_xy", "_pgc_xy", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_xy", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#__pgc_dn", "__pgc_dn", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "__pgc_dn", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#_pgc_dn", "_pgc_dn", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_dn", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#_pgc_star", "_pgc_star", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_star", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#_pgc_radec", "_pgc_radec", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_radec", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#_pgc_globe", "_pgc_globe", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_globe", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#_pgc_map", "_pgc_map", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_map", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#_pgc_disk", "_pgc_disk", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_disk", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#_pgc_disk_scale", "_pgc_disk_scale", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_disk_scale", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#_pgc_eqplane", "_pgc_eqplane", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_eqplane", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#_pgc_eqplane_scale", "_pgc_eqplane_scale", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_eqplane_scale", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#_pgc_photom_globe", "_pgc_photom_globe", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_photom_globe", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#_pgc_photom_disk", "_pgc_photom_disk", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_photom_disk", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#_pgc_photom_eqplane", "_pgc_photom_eqplane", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_photom_eqplane", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#pgc_table", "pgc_table", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "pgc_table", "", "label_padvalue_padnamename_pvalue_plabel_pformat_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_cursor.html#pg_cursor", "pg_cursor", 'routine in <a href="com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "pg_cursor", "", "cdgbxdkxsundsdgdfnradecphotomxystringsilentvaluesddptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_cusps.html", "pg_cusps.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cusps.pro", "", "", " NAME: 	pg_cusps    PURPOSE: 	Computes image points at the limb/terminator cusps for each given 	globe object.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	cusp_ptd = pg_cusps(cd=cd, od=od, gbx=gbx) 	cusp_ptd = pg_cusps(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	 Array (n_timesteps) of camera descriptors.  	od:	 Array (n_timesteps) of descriptors for the observer, 		 default is the sun is gd given.  	gbx:	 Array (n_objects, n_timesteps) of descriptors of objects 		 which must be a subclass of GLOBE.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	epsilon: Maximum angular error in the result.  Default is 1e-3.  	reveal:	 Normally, points computed for objects whose opaque flag 		 is set are made invisible.  /reveal suppresses this behavior.     OUTPUT: NONE    RETURN: 	Array (n_objects) of POINT objects containing image 	points and the corresponding inertial vectors.    PROCEDURE: 	This program uses an iterative scheme to find the two points on 	the surface of the globe where the surface normal is simultaneously 	perpendicular to the vectors from the camera and the Sun.     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2010   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cusps.html#pg_cusps", "pg_cusps", 'routine in <a href="com/pg/pg_cusps.html">pg_cusps.pro</a>', "pg_cusps.pro", "", "pg_cusps", "", "cdodgbxddgdepsilonreveal", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_cvchisq.html", "pg_cvchisq.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cvchisq.pro", "", "", " NAME: 	pg_cvchisq    PURPOSE: 	Computes chi-squared value for given curve fit parameters.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	chisq = pg_cvchisq(dxy, dtheta, scan_ptd, axis_ptd=axis_ptd)    ARGUMENTS:   INPUT: 	dxy:		2-element vector giving the translation as [dx,dy].  	dtheta:		Rotation in radians.  	scan_ptd:	Array (n_curves) of POINT output from 			pg_cvscan containing scanned image points as well as 			other necessary scan data.    OUTPUT: NONE    KEYWORDS:   INPUT: 	axis_ptd:	POINT containing a single image  point 			to be used as the axis of rotation.  	fix:		Array specifying which parameters to fix as 			[dx,dy,dtheta].    OUTPUT: NONE    RETURN: 	Chi-square value.    RESTRICTIONS: 	The caller is responsible for ensuring that the input parameters are 	consistent with those used with other programs like pg_fit.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, 	pg_ptchisq, pg_fit, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cvchisq.html#pg_cvchisq", "pg_cvchisq", 'routine in <a href="com/pg/pg_cvchisq.html">pg_cvchisq.pro</a>', "pg_cvchisq.pro", "", "pg_cvchisq", "", "axis_ptdfixdxydthetascan_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_cvscan.html", "pg_cvscan.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cvscan.pro", "", "", " NAME: 	pg_cvscan    PURPOSE: 	Attempts to find points of highest correlation with a given model along 	curves in an image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	scan_ptd = pg_cvscan(dd, curve_ptd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor  	cd:		Camera descriptor.  not required, but some 			interpolation schemes will not work without it.  	bx:		Descriptor specifying the body associated with 			each POINT object.  Not required, but some algorithms 			will not work properly without it.  	gd:		Generic descriptor.  	curve_ptd:	Array (n_curves) of POINT objects giving the curves. 			Only the image coordinates of the curves need to be 			specified in the POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	model_p:	Array (n_curves) of pointers to model arrays.  Each 			model array has dimensions (n_points,nm), where n_points 			is the number of points in the curve and nm is the 			number of points in the model.  Thus, a model may be 			specified for each point on the curve.  Default 			model is edge_model_atan().  	mzero:		Array (n_curves) or (n_curves,n_points) of zero-point 			offsets for each model in model_p.  mzero must be 			specified if model_p is given.  	width:		Number of pixels to scan on either side of the curve. 			Default is 20.  	edge:		Distance from the edge of the image within which 			curve points will not be scanned.  Default is 0.  	algorithm:	Name of alrogithm to use to detect the edge. 			Choices are 'MODEL', 'GRAD', and 'HALF'. 			Default is 'MODEL'.  	arg:		Argument passed to the edge detection routine. 			For the GRAD algorithm, this argument specifies 			whether each edge is interior (arg=1) or 			exterior (arg=0).  	scan_ptd:	If given, these previously scanned points are updated 			to be consistent with the given data points.  The image 			is not scanned.  	dir:		If given the scan will be performed in this direction 			instead of normal to the curve.  Must be a 2-element 			unit vector.    OUTPUT: NONE    RETURN: 	Array (n_curves) of POINT objects containing resulting image points, 	as well as additional scan data to be used by pg_cvscan_coeff and 	possibly other programs.  The scan data is as follows:  		 tag			 description 	 	-----			------------- 		scan_cos		Cosine of normal at each point. 		scan_sin		Sine of normal at each point. 		scan_offsets		Raw offsets from computed curve. 		scan_cc			Correlation coefficient for each scanned 					point. 		scan_sigma		Scan offset uncertainties. 		scan_model_xpts		Model points corresponding to each 		scan_model_ypts		 scanned point    RESTRICTIONS: 	Currently does not work for multiple time steps.    PROCEDURE: 	Normal sines and cosines are computed using icv_compute_directions. 	These directions are input to icv_strip_curve along with the image 	in order to extract an image strip to be scanned.  icv_scan_strip is 	then used to find the optimum scan offsets and icv_convert_scan_offsets 	is used to obtain image coordinates corresponding to each scan offset. 	See the documentation for each of those routines for more details.    EXAMPLE: 	The following command scans for a limb in the image contained in the 	given data descriptor, dd:  	scan_ptd = pg_cvscan(dd, limb_ptd, width=40, edge=20)  	In this call, limb_ptd is a POINT containing computed limb 	points.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, pg_ptchisq, 	pg_fit, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cvscan.html#pg_cvscan", "pg_cvscan", 'routine in <a href="com/pg/pg_cvscan.html">pg_cvscan.pro</a>', "pg_cvscan.pro", "", "pg_cvscan", "", "algorithmcdbxgdmodel_pmzerodirwidthedgeargscan_ptdddobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_cvscan_coeff.html", "pg_cvscan_coeff.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cvscan_coeff.pro", "", "", " NAME: 	pg_cvscan_coeff    PURPOSE: 	Computes linear least-squares coefficients for a fit to the image 	coordinate translation and rotation that matches a computed curve to 	a scanned curve in an image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	scan_cf = pg_cvscan_coeff(scan_ptd, axis_ptd=axis_ptd)    ARGUMENTS:   INPUT: 	scan_ptd:	Array (n_curves) of POINT output from 			pg_cvscan containing scanned image points as well as 			other necessary scan data.    OUTPUT: NONE    KEYWORDS:   INPUT: 	axis_ptd:	POINT containing a single image  point 			to be used as the axis of rotation in the fit for 			every curve.  	fix:		Array specifying which parameters to fix in the 			fit as [dx,dy,dtheta].    OUTPUT: NONE    RETURN: 	Array (n_curves) of pg_fit_coeff_struct containing coefficients for 	the least-square fit to be input to pg_fit.    RESTRICTIONS: 	Currently does not work for multiple time steps.    PROCEDURE: 	pg_cvscan_coeff extracts the scan data from the given 	scan_ptd structure and uses icv_coeff to compute the coefficients. 	See the documentation for that routine for details.    EXAMPLE: 	The following command uses scan data from pg_cvscan to compute 	least square coefficients for a fit such that only dx and dtheta 	will be allowed to vary:  	cvscan_cf = pg_cvscan_coeff(scan_ptd, axis=center_ptd, fix=[1])  	In this call, scan_ptd is a POINT containing the scan data 	from pg_cvscan and center_ptd is a POINT giving the center 	of the planet as computed by pg_center.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, pg_ptchisq, 	pg_fit, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cvscan_coeff.html#pg_cvscan_coeff", "pg_cvscan_coeff", 'routine in <a href="com/pg/pg_cvscan_coeff.html">pg_cvscan_coeff.pro</a>', "pg_cvscan_coeff.pro", "", "pg_cvscan_coeff", "", "axis_ptdfixscan_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_data_adjust.html", "pg_data_adjust.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_data_adjust.pro", "", "", " NAME: 	pg_data_adjust   PURPOSE: 	Allows the user to adjust data values using the mouse.  A rectangle 	is selected height (positve or negative) gives the data value adjustment. 	Works for 1-D or 2_d data sets.   CATEGORY:        NV/PG   CALLING SEQUENCE:      pg_data_adjust, dd    ARGUMENTS:   INPUT:       dd:	Data descriptor.    OUTPUT: 	NONE     KEYWORDS:   INPUT:          NONE      OUTPUT:          NONE    RETURN:       NONE    ORIGINAL AUTHOR : J. Spitale ; 2/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_data_adjust.html#pg_data_adjust", "pg_data_adjust", 'routine in <a href="com/pg/pg_data_adjust.html">pg_data_adjust.pro</a>', "pg_data_adjust.pro", "", "pg_data_adjust", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_despike.html", "pg_despike.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_despike.pro", "", "", " NAME: 	pg_despike    PURPOSE: 	Removes previously-located spurious features like cosmic-ray hits.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_despike(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing the image to be despiked.  	spike_ptd:	POINT specifying the points to replace; 			typically computed by pg_spikes.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	scale:		Typical size of features to be removed.  Default 			is 10.  	n=n:		Number of timers to repeat the box filter.  Default 			is 5.  	kernel:		If set, this kernel is used to weight the replacement 			of all pixels in a box of size scale around each 			spike point, instead of replacing only the spike 			point.  If this is a scalar, then this is taken as the 			width of a Gaussian kernel.    OUTPUT: 	image:		The corrected image.    RETURN: 	Data descriptor containing the corrected image.  If /noclone 	is not set, set input data descriptor is modified.    PROCEDURE: 	pg_despike replaces the values of the desired pixels with those 	computed by smoothing the input image using a box filter of size 	'scale' repeatedly, 'n' times.    STATUS: 	Complete.    SEE ALSO: 	pg_spikes    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_despike.html#pg_despike", "pg_despike", 'routine in <a href="com/pg/pg_despike.html">pg_despike.pro</a>', "pg_despike.pro", "", "pg_despike", "", "imagescalenkernelnocloneddspike_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_disk.html", "pg_disk.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_disk.pro", "", "", " NAME: 	pg_disk    PURPOSE: 	Computes image points on the inner and outer edges of each given disk 	object at all given time steps.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_disk(cd=cd, dkx=dkx) 	result = pg_disk(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	 Array (n_timesteps) of camera descriptors.  	dkx:	 Array (n_objects, n_timesteps) of descriptors of objects 		 which must be a subclass of DISK.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	inner/outer: If either of these keywords are set, then only 	             that edge is computed.  	npoints: Number of points to compute around each edge.  Default is 		 1000.  	reveal:	 Normally, points computed for objects whose opaque flag 		 is set are made invisible.  /reveal suppresses this behavior.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.    OUTPUT: NONE    RETURN: 	Array (2*n_objects) of POINT containing image points and 	the corresponding inertial vectors.  The output array is arranged as 	[inner, outer, inner, outer, ...] in the order that the disk 	descriptors are given in the dkx argument.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_disk.html#pg_disk", "pg_disk", 'routine in <a href="com/pg/pg_disk.html">pg_disk.pro</a>', "pg_disk.pro", "", "pg_disk", "", "cddkxddgdclipcullinnerouternpointsreveal", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_drag.html", "pg_drag.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_drag.pro", "", "", " NAME: 	pg_drag    PURPOSE: 	Allows the user to graphically translate and rotate an array of points 	using the mouse.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dxy = pg_drag(object_ptd, dtheta=dtheta, axis_ptd=axis_ptd)    ARGUMENTS:   INPUT: 	object_ptd:	Array (n_objects) of POINT containing the 			image points to be dragged.    OUTPUT: 	object_ptd:	If /move, the input points will be modified by the 			offsets resulting from the drag.    KEYWORDS:   INPUT: 	axis_ptd:	POINT containing a single image point 			to be used as the axis of rotation.  	sample:		Sampling interval for drag graphics.  The input 			points are subsampled at this interval so that the 			dragging can be done smoothly.  Default is 10.  	move:		If set, object_ptd will be modified on return using 			pg_move.  	symbol:		If set, the symbol number will be passed to cursor_move 			so something other than a period can be used to mark 			points.  	silent:		If set, turns off the notification that cursor                        movement is required.  	xor_graphics:	If set, grahics are drawn using the XOR function.  	color:		Drawing color.  Default is ctyellow.    OUTPUT: 	dtheta:		Dragged rotation in radians.    RETURN: 	2-element array giving the drag translation as [dx,dy].    PROCEDURE: 	cursor_move is used to perfform the drag.  See that routine for more 	detail.    STATUS: 	Complete    SEE ALSO: 	pg_move    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998       Modified by:     Dyer Lytle, Vance Haemmerle 11/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_drag.html#pg_drag", "pg_drag", 'routine in <a href="com/pg/pg_drag.html">pg_drag.pro</a>', "pg_drag.pro", "", "pg_drag", "", "drawxor_graphicsdthetaaxis_ptdsamplemovesymbolsilentcolorfndataobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_drag_shadow_plane.html", "pg_drag_shadow_plane.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_drag_shadow_plane.pro", "", "", " NAME: 	pg_drag_shadow_plane    PURPOSE: 	Allows the user to graphically rotate a plane passing through the 	center of a planet by dragging the shadow cast by the planet on the 	plane using the mouse.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dxy = pg_drag_shadow_plane(cd=cd, gbx=gbx, sund=sund)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	 Camera descriptor.  	gbx:	 Subclass of GLOBE.  	sund:	 Star descriptor for the Sun.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	p0:	 Initial point to use instead  of prompting the user.  	n0:	 Initial plane orientation.  Default is the planet y-axis.  	gain:	 Radians / pixel offset from the initial point.  	axis:	 Rotation axis; default is the planet pole.  	silent:	 If set, turns off notifications.  	xor_graphics:	If set, grahics are drawn using the XOR function.  	color:		Drawing color.    OUTPUT: NONE    RETURN: 	Column vector giving the final plane orientation.     STATUS: 	Complete    SEE ALSO:     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_drag_shadow_plane.html#pgdsp_compute", "pgdsp_compute", 'routine in <a href="com/pg/pg_drag_shadow_plane.html">pg_drag_shadow_plane.pro</a>', "pg_drag_shadow_plane.pro", "", "pgdsp_compute", "", "ncdpdsundn0term_ptdaxistheta", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_drag_shadow_plane.html#pg_drag_shadow_plane", "pg_drag_shadow_plane", 'routine in <a href="com/pg/pg_drag_shadow_plane.html">pg_drag_shadow_plane.pro</a>', "pg_drag_shadow_plane.pro", "", "pg_drag_shadow_plane", "", "cdgbxsundddgdxor_graphicsp0n0silentcolorgainaxisshadow_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_draw.html", "pg_draw.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_draw.pro", "", "", " NAME: 	pg_draw    PURPOSE: 	Calls pg_draw_point or pg_draw_vector depending on the input arrays. 	pg_draw_point is called is only one argument is given.  Otherwise, 	it assumed that a source and target are given and pg_draw_vector is 	called.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_draw, object_ptd, target_ptd    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing image points 			to be plotted in the current data coordinate system. 			Or inertial vectors to be used as vector sources. 			May also be an array of image points or inertial 			vectors.  	target_ptd:	Array of POINTs giving the inertial 			positions of vector targets.  May also be an 			array of inertial vectors.  If this argument is 			present, then vectors are drawn instead of points.    OUTPUT: NONE    KEYWORDS: 	graphics:	Logical operation to use for drawing.  	See pg_draw or pg_draw_vector for more keywords.    RETURN: 	NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_draw.html#pg_draw", "pg_draw", 'routine in <a href="com/pg/pg_draw.html">pg_draw.pro</a>', "pg_draw.pro", "", "pg_draw", "", "literalcolorsshadespsymspsizesplabelsxormodecsizescthickswnumlabel_shadelabel_pointsthicklineprintcdgdcorientlengthsalignnoshortensolidfixedheadswinglengthgraphicslabel_colorshade_thresholdobject_ptdtarget_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_draw_point.html", "pg_draw_point.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_draw_point.pro", "", "", " NAME: 	pg_draw_point    PURPOSE: 	Draws points from the given POINT on the current graphics 	window using the current data coordinate system.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_draw_point, object_ptd    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing image points 			to be plotted in the current data coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: 	literal:	All of the following input keywords accept an array 			where each element corresponds to an element in the 			object_ptd array.  By default, if the keyword array is 			shorter than the object_ptd array, then the last element 	  		is used to fill out the array.  /literal suppresses 			this behavior and causes unspecified elements to 			take their default values.  	colors:		Array of plotting colors.  Default is !color.  String 			names will be converted using the ct<string>() 			functions.  Labels are also plotted in this color. 			If one element, then all points are plotted in this 			color; if multiple elements, and object_ptd also 			has multiple elements, each color will be assigned to 			all elements in the corresponding array (see /literal); 			if mulitple elements, and object_ptd has only one 			element, then each color will be assigned to each 			element of th object_ptd array.  	shades:		Array of plotting shades.  Default is 1.0.  	label_shade:	Array of plotting shades for labels.  Default is 1.0.  	shades:		Array of plotting shades.  Default is 1.0.  	psyms:		Array of plotting symbols.  Default is 3.  	thick:		Array of plotting thicknesses.  Default is 1.  	line:		Array of linestyles.  Default is 0.  	psizes:		Array of plotting symbol sizes.  Default is 1.0.  	csizes:		Array of character sizes.  Default is 1.0.  	cthicks:	Array of character thicknesses.  Default is 1.0.  	corient:	Array of character orientations.  Default is 1.0.  	plabels:	Array of object labels.  Default is ''.  	label_points:	If set, plabels will be applied element-by-element to 			each point in each points array instead of once 			to each object.  	align:		Label alignment.  See XYOUTS.  	wnum:		Window number in which to draw.  	xormode:	If set, XOR graphics mode is used for drawing.  	print:		Message to print before plotting.    OUTPUT: NONE    RETURN: 	NONE    EXAMPLE: 	The following command draws and labels a lavender 'limb' and a red 	'ring' (assuming that the points have already been computed):  	pg_draw_point, [limb_ptd, ring_ptd], color=[ctpurple(), ctred()], $ 	         plabels=['LIMB','RING']    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998 (pg_draw) 	Renamed pg_draw_point: Spitale, 9/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_draw_point.html#pgdp_draw", "pgdp_draw", 'routine in <a href="com/pg/pg_draw_point.html">pg_draw_point.pro</a>', "pg_draw_point.pro", "", "pgdp_draw", "", "label_pointsplabelspointscolorspsymspsizesthicklinecsizescthickscorientalignplabel_offsetlabel_colors", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_draw_point.html#pgdp_fill", "pgdp_fill", 'routine in <a href="com/pg/pg_draw_point.html">pg_draw_point.pro</a>', "pg_draw_point.pro", "", "pgdp_fill", "", "defall_valn_objects", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_draw_point.html#pg_draw_point", "pg_draw_point", 'routine in <a href="com/pg/pg_draw_point.html">pg_draw_point.pro</a>', "pg_draw_point.pro", "", "pg_draw_point", "", "literalcolorspsymspsizesplabelsxormodecsizescthickswnumshadeslabel_pointsthicklineprintlabel_shadealigncorientlabel_colorshade_threshold_pp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_draw_vector.html", "pg_draw_vector.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_draw_vector.pro", "", "", " NAME: 	pg_draw_vector     PURPOSE:          Draws vectors on an image from a source towards a          target. Very useful for locating off-image objects          (planets, say) in an image for referencing.  By default,          vectors are foreshortened to their projections onto the image          plane so that vectors with large  out-of-plane components          will be shorter.  (This can be deactivated with the          /noshorten keyword.)  Also by default, vectors that point          away from the camera will be drawn as dotted lines while          vectors which point towards the camera will be drawn solid.          (This can be controlled with the /solid keyword.)     CATEGORY:          NV/PG    CALLING SEQUENCE:                  pg_draw_vector, sources, targets,                  (cd=cd| gd=gd)[, /literal, thick=thick, lengths=lengths,                   colors=colors, plabels=plabels, csizes=csizes]     INPUTS:         sources:         Inertial positions of sources.  Either an array                          of column vectors (nv x 3 x nt) or an array of                          POINT objects containing the inertial vectors.          targets:         Inertial positions of targets, or inertial unit                          vectors giving directions to targets.  Either an                          array of column vectors (nv x 3 xnt) or an array                          of POINT objects.  There must either be a single                          target point or a one-to-one match between source                          and target points.     OPTIONAL INPUTS:     KEYWORD PARAMETERS:         cd or gd        A camera descriptor or a generic descriptor                        containing a camera descriptor.  Required unless 			source and target given as image points.  	literal:	All of the following input keywords accept an array 			where each element corresponds to an element in the 			object_ptd array.  By default, if the keyword array is 			shorter than the object_ptd array, then the last element 	  		is used to fill out the array.  /literal suppresses 			this behavior and causes unspecified elements to 			take their default values         lengths:        Lengths of the vectors.  (Default: 50 pixels)         thick:         Line thicknesses.  (Default: 1)         colors:         Colors to use in drawing.  (Default: current                        default color)         plabels:         Text with which to label vectors.  (Default:                        no label)         csizes:      Character sizes for plabels.  (Default: 1)         solid:         All lines are to be drawn solid (linestyle=0)                        rather than allow vectors pointing into the                        image plane to be dotted.         noshorten:     If set, vectors will not be foreshortened                        depending on how much they point into/out                        of the image plane.         fixedheads:     If set, arrowheads will not be scaled to                         match the foreshortening of the vector.   OUTPUTS:         None    EXAMPLE:        Say moon_points is a POINT object containing the center        data for the four Galilean satellites and jupiter_points has        Jupiter's center data.  Then         IDL> pg_draw_vector, moon_points, jupiter_points, colors=[100, $              150, 200, 250], thick=1.25, length=70, plabels= Jupiter , $              csizes=1.5         will draw vectors from each towards the planet.  Conversely,         IDL> pg_draw_vector, jupiter_points, moon_points, colors=[100, $              150, 200, 250], thick=1.25, length=70, plabels=[ Io ,  Europa , $               Ganymede ,  Callisto ], csizes=1.5         will draw vectors from Jupiter's center towards each moon,        labelling each by the moon's name.    MODIFICATION HISTORY:       Written: John W. Weiss, 5/05      Consolidated some functionality into plot_arrow; Spitale 9/2005    ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_draw_vector.html#pg_draw_vector", "pg_draw_vector", 'routine in <a href="com/pg/pg_draw_vector.html">pg_draw_vector.pro</a>', "pg_draw_vector.pro", "", "pg_draw_vector", "", "cdddgdliterallengthsplabelscolorsthickcsizeswnumnoshortensolidfixedheadswinglengthdraw_wnumshadeslabel_shadelabel_colorshade_thresholdsourcetarget", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_edges.html", "pg_edges.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_edges.pro", "", "", " NAME: 	pg_edges    PURPOSE: 	Scans an image for candidate edge points.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	edge_ptd = pg_edges(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor    OUTPUT: NONE    KEYWORDS:   INPUT: 	threshold:	Minimum activity to accept as an edge point.  	edge:		Distance from the edge of the image within which 			curve points will not be scanned.  Default is 0.  	npoints:	Maximum number of points to return.  	lowpass:	If given, the image is smoothed with a kernel of 			this size.     OUTPUT: NONE    RETURN: 	POINT giving the resulting edge points.    PROCEDURE: 	At each pixel in the image, an activity is computed (see activity.pro). 	Points with activity greater than the threshold value are accepted.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, pg_ptchisq, 	pg_fit, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 4/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_edges.html#pg_edges", "pg_edges", 'routine in <a href="com/pg/pg_edges.html">pg_edges.pro</a>', "pg_edges.pro", "", "pg_edges", "", "thresholdedgenpointsgatelowpassdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_exclude_points.html", "pg_exclude_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_exclude_points.pro", "", "", " NAME: 	pg_exclude_points    PURPOSE: 	xx    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_exclude_points.html#pg_exclude_points", "pg_exclude_points", 'routine in <a href="com/pg/pg_exclude_points.html">pg_exclude_points.pro</a>', "pg_exclude_points.pro", "", "pg_exclude_points", "", "radiusptdxptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_farfit.html", "pg_farfit.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_farfit.pro", "", "", " NAME: 	pg_farfit    PURPOSE: 	Searches for the offset (dx,dy) that gives the best agreement between 	two uncorrelated sets of image points.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dxy = pg_farfit(dd, base_ptd, model_ptd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	base_ptd:	POINT giving a set of points to fit to. 			This input may be produced by pg_edges, for example.  	model_ptd:	Array of POINT giving model points (computed 			limb points for example).    OUTPUT: NONE    KEYWORDS:   INPUT: 	show:		If specified, the search is displayed in the current 			graphics window.  This value can be specified as a 			2-element array giving the size of the displayed image.  	bin:		Initial bin size for point densities.  Default is 50 			pixels.  	max_density:	Maximum model point density.  Default = 5.  	nsamples:	Number of samples in each direction in the grid search. 			See image_correlate.  	region:		Size of region to scan, centered at offset [0,0].  If not 			specified, the entire image is scanned.  	sigma:		2-element array giving the width of the correlation 			peak in each direction.  	cc:		Cross correlation of final result.  	mcc:		Corss correlation at the model points.  	bias:		If given, solutions are biased toward the initial 			guess using a weighting function of the form:  				exp(-r^2/2*bias),  			where r is the distance between from the initial 			guess.  	nosearch:	If set, no search is performed.  An offset of [0,0] 			is returned.     OUTPUT: NONE    RETURN: 	2-element array giving the fit offset as [dx,dy].    PROCEDURE: 	pg_farfit is a wrapper for the routine correlate_points.  See the 	documentation for that routine for details on the fitting procedure    STATUS: 	Complete.    SEE ALSO: 	pg_edges correlate_points    MODIFICATION HISTORY:  	Written by:	Spitale, 4/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_farfit.html#pg_farfit", "pg_farfit", 'routine in <a href="com/pg/pg_farfit.html">pg_farfit.pro</a>', "pg_farfit.pro", "", "pg_farfit", "", "nsamplesshowbinmax_densityregionsigmaccmccbiasnosearchddbase_ptdmodel_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_fit.html", "pg_fit.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_fit.pro", "", "", " NAME: 	pg_fit    PURPOSE: 	Performs a simultaneous 1-,2-, or 3-parameter linear least-squares fit 	using the given coefficients.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dxy = pg_fit(cf, dtheta=dtheta)    ARGUMENTS:   INPUT: 	cf:	Array of pg_fit_coeff_struct as produced by pg_cvscan_coeff or 		pg_ptscan_coeff.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	dtheta:	Fit offset in theta.    RETURN: 	2-element array giving the fit offset as [dx,dy].    RESTRICTIONS: 	It is the caller's responsibility to ensure that all of the input 	coefficients were computed using with the same set of fixed parameters.    PROCEDURE: 	pg_fit extracts the fit coefficients from cf and inputs them to mbfit 	to perform a simultatneous least square fit using all of the 	coefficients.  See the documentation for that routine for more detail.    EXAMPLE: 	The following commands perform a simultaneous least square fit to 	a limb, ring and star field with all parameters free:  	cvscan_ptd = pg_cvscan(dd, [limb_ptd,ring_ptd], width=40, edge=20) 	ptscan_ptd = pg_ptscan(dd, [star_ptd], width=40, edge=20)  	cvscan_cf = pg_cvscan_coeff(cvscan_ptd, axis=center_ptd) 	ptscan_cf = pg_ptscan_coeff(ptscan_ptd, axis=center_ptd)  	dxy = pg_fit([cvscan_cf,ptscan_cf], dtheta=dtheta)  	In this example, center_ptd, limb_ptd, ring_ptd, and star_ptd are assumed 	to have been previously computed using the appropriate routines.  	Note that since this is a linear fit, the input systems may have been 	linearized and it may be necessary to iterate this procedure.     STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvscan_coeff, pg_ptscan, pg_ptscan_coeff, 	pg_cvchisq, pg_ptchisq, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_fit.html#pg_fit", "pg_fit", 'routine in <a href="com/pg/pg_fit.html">pg_fit.pro</a>', "pg_fit.pro", "", "pg_fit", "", "dthetacf", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_fit_coeff_struct__define.html", "pg_fit_coeff_struct__define.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_fit_coeff_struct__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_fit_coeff_struct__define.html#pg_fit_coeff_struct__define", "pg_fit_coeff_struct__define", 'routine in <a href="com/pg/pg_fit_coeff_struct__define.html">pg_fit_coeff_struct__define.pro</a>', "pg_fit_coeff_struct__define.pro", "", "pg_fit_coeff_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_footprint.html", "pg_footprint.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_footprint.pro", "", "", " NAME: 	pg_footprint    PURPOSE: 	Computes the footprint of a camera on a given body.    CATEGORY: 	NV/PG    CALLING SEQUENCE:        footprint_ptd = footprint(cd=cd, bx=bx)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	bx:	Array (n_objects, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	clip:	 If set, points are computed only within this many camera 		 fields of view.  	sample:	 Sampling rate; default is 1 pixel.    OUTPUT: NONE    RETURN: 	Array (n_objects) of POINT containing image points and 	the corresponding inertial vectors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_footprint.html#pg_footprint", "pg_footprint", 'routine in <a href="com/pg/pg_footprint.html">pg_footprint.pro</a>', "pg_footprint.pro", "", "pg_footprint", "", "cdbxddgdclipsample", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_arrays.html", "pg_get_arrays.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_arrays.pro", "", "", " NAME: 	pg_get_arrays    PURPOSE: 	Obtains a array descriptor for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_arrays(dd) 	result = pg_get_arrays(dd, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	ard:		Input array descriptors; used by some translators.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	arr_*:		All array override keywords are accepted.  See 			array_keywords.include.  			If name is specified, then only descriptors with 			those names are returned.  	verbatim:	If set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    RETURN: 	Array of array descriptors, 0 if an error occurs.    PROCEDURE: 	If /override, then a array descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_arrays.html#pg_get_arrays", "pg_get_arrays", 'routine in <a href="com/pg/pg_get_arrays.html">pg_get_arrays.pro</a>', "pg_get_arrays.pro", "", "pg_get_arrays", "", "odbxard_extraoverrideverbatimddtrs@arr__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_cameras.html", "pg_get_cameras.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_cameras.pro", "", "", " NAME: 	pg_get_cameras    PURPOSE: 	Obtains a camera descriptor for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_cameras(dd) 	result = pg_get_cameras(dd, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:		Input camera descriptors; used by some translators.  	gd:		Generic descriptor containing the above descriptors. 			Note this keyword is inherited from the CORE keywords 			list.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	cam_*:		All camera override keywords are accepted.  See 			camera_keywords.include.  			If cam_name is specified, then only descriptors with 			those names are returned.  	verbatim:	If set, the descriptors requested using cam_name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.  	default_orient:		Default orientation matrix to use if camera 				orientation is not available.  If not specified, 				the identity matrix is used.    RETURN: 	Array of camera descriptors, 0 if an error occurs.    PROCEDURE: 	If /override, then a camera descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except cam_name) can still be overridden by specifying 	them as keyword parameters.  If cam_name is specified, then 	only descriptors corresponding to those names will be returned.     MODIFICATION HISTORY:  	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_cameras.html#pg_get_cameras", "pg_get_cameras", 'routine in <a href="com/pg/pg_get_cameras.html">pg_get_cameras.pro</a>', "pg_get_cameras.pro", "", "pg_get_cameras", "", "cdodpd_extraoverrideverbatimdefault_orientno_defaultddtrs@cam__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_celestial_sphere.html", "pg_get_celestial_sphere.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_celestial_sphere.pro", "", "", " NAME: 	pg_get_celestial_sphere    PURPOSE: 	Obtains a globe descriptor describing the celestial sphere.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_celestial_sphere()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	radius:	 Radius to use for the globe.  Default is 1d30.    OUTPUT: NONE    RETURN: 	Globe descriptor with inertial body descriptor and very large radii.     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_celestial_sphere.html#pg_get_celestial_sphere", "pg_get_celestial_sphere", 'routine in <a href="com/pg/pg_get_celestial_sphere.html">pg_get_celestial_sphere.pro</a>', "pg_get_celestial_sphere.pro", "", "pg_get_celestial_sphere", "", "radius", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_maps.html", "pg_get_maps.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_maps.pro", "", "", " NAME: 	pg_get_maps    PURPOSE: 	Obtains a map descriptor for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_maps(dd) 	result = pg_get_maps(dd, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	md:		Input map descriptors; used by some translators.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	map_*:		All map override keywords are accepted.  See 			map_keywords.include.  			If name is specified, then only descriptors with 			those names are returned.  			If /override and name is not specified, then 			the name is taken from the core descriptor.  	verbatim:	If set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    RETURN: 	Array of map descriptors, 0 if an error occurs.    PROCEDURE: 	If /override, then a map descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     MODIFICATION HISTORY:  	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_maps.html#pg_get_maps", "pg_get_maps", 'routine in <a href="com/pg/pg_get_maps.html">pg_get_maps.pro</a>', "pg_get_maps.pro", "", "pg_get_maps", "", "mdgbxdkxbx_extraoverrideverbatimddtrs@map__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_planets.html", "pg_get_planets.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_planets.pro", "", "", " NAME: 	pg_get_planets    PURPOSE: 	Obtains planet descriptors for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_planets(dd, od=od) 	result = pg_get_planets(dd, od=od, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	pd:		Input planet descriptors; used by some translators.  	od:		Observer descriptor, typically a camera descriptor. 			If given, then planet positions will be corrected 			for light travel time and stellar aberration relative 			to this observer unless /raw is set.  	sd:		Primary star descriptor; needed by some translators.  	gd:		Generic descriptors.  Can be used in place of od and sd.  	raw:		If set, no aberration corrections are performed.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	plt_*:		All planet override keywords are accepted.  See 			planet_keywords.include.  			If name is specified, then only descriptors with 			those names are returned.  	verbatim:	If set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.       Descriptor Select Keywords     --------------------------     Descriptor select keywords are combined with OR logic.  They are implemented     in this routine as described below after the translators have been called,     but they are also added to the translator keywords.  The purpose of sending     then to the translators as well is to give the translators an opportunity     to filter their outputs before potentially generating a huge array of     descriptors that would mostly be filtered out by this routine.  	fov/cov:	Select all planets that fall within this many fields of 			view (fov) (+/- 10%) from the center of view (cov). 			Default cov is the camera optic axis.  	pix:		Select all planets whose apparent size (in pixels) is 			greater than or equal to this value.  	radmax:		Select all planets whose radius is greater than or 			equal to this value.  	radmin:		Select all planets whose radius is less than or 			equal to this value.  	distmax:	Select all planets whose distance is greater than or 			equal to this value.  	distmin:	Select all planets whose distance is less than or 			equal to this value.  	nlarge:		Select n largest planets.  	nsmall:		Select n smallest planets.  	nclose:		Select n closst planets.  	nfar:		Select n farthest planets.    RETURN: 	Array of planet descriptors, 0 if an error occurs.    PROCEDURE: 	If /override, then a planet descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     MODIFICATION HISTORY:  	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_planets.html#pggp_select_planets", "pggp_select_planets", 'routine in <a href="com/pg/pg_get_planets.html">pg_get_planets.pro</a>', "pg_get_planets.pro", "", "pggp_select_planets", "", "odddpdselect", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_planets.html#pg_get_planets", "pg_get_planets", 'routine in <a href="com/pg/pg_get_planets.html">pg_get_planets.pro</a>', "pg_get_planets.pro", "", "pg_get_planets", "", "pdodsd_extraoverrideverbatimrawddtrs@plt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_rings.html", "pg_get_rings.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_rings.pro", "", "", " NAME: 	pg_get_rings    PURPOSE: 	Obtains ring descriptors for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_rings(dd, od=od) 	result = pg_get_rings(dd, od=od, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	rd:		Input ring descriptors; used by some translators.  	pd:		Planet descriptors for primary objects.  	od:		Observer descriptors.  	gd:		Generic descriptors.  Can be used in place of od.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	rng_*:		All ring override keywords are accepted.  See 			ring_keywords.include.  			If name is specified, then only descriptors with 			those names are returned.  	verbatim:	If set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    RETURN: 	Ring descriptors obtained from the translators, 0 if an error occurs.    PROCEDURE: 	If /override, then a ring descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_rings.html#pggr_select_rings", "pggr_select_rings", 'routine in <a href="com/pg/pg_get_rings.html">pg_get_rings.pro</a>', "pg_get_rings.pro", "", "pggr_select_rings", "", "odddrdselect", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_rings.html#pg_get_rings", "pg_get_rings", 'routine in <a href="com/pg/pg_get_rings.html">pg_get_rings.pro</a>', "pg_get_rings.pro", "", "pg_get_rings", "", "rdpdod_extraoverrideverbatimddtrs@rng__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_stars.html", "pg_get_stars.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_stars.pro", "", "", " NAME: 	pg_get_stars    PURPOSE: 	Obtain star descriptors for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_stars(dd, od=od) 	result = pg_get_stars(dd, od=od, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	sd:		Input star descriptors; used by some translators.  	od:		Observer descriptor, typically a camera descriptor. 			If given, then star positions will be corrected 			for stellar aberration (but not light-travel time, 			which is inherently accounted for in star catalogs) 			relative to this observer, unless /raw is set.  	gd:		Generic descriptors.  Can be used in place of od.  	raw:		If set, no aberration corrections are performed.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	str_*:		All star override keywords are accepted.  See 			star_keywords.include.  			If name is specified, then only descriptors with 			those names are returned.  	verbatim:	If set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.      Descriptor Select Keywords     --------------------------     Descriptor select keywords are combined with OR logic.  They are implemented     in this routine as described below after the translators have been called,     but they are also added to the translator keywords.  The purpose of sending     then to the translators as well is to give the translators an opportunity     to filter their outputs before potentially generating a huge array of     descriptors that would mostly be filtered out by this routine.  	fov/cov:	Select all stars that fall within this many fields of 			view (fov) (+/- 10%) from the center of view (cov). 			Default cov is the camera optic axis.  	pix:		Select all stars whose apparent size (in pixels) is 			greater than or equal to this value.  	radmax:		Select all stars whose radius is greater than or 			equal to this value.  	radmin:		Select all stars whose radius is less than or 			equal to this value.  	distmax:	Select all stars whose distance is greater than or 			equal to this value.  	distmin:	Select all stars whose distance is less than or 			equal to this value.  	nlarge:		Select n largest stars.  	nsmall:		Select n smallest stars.  	nclose:		Select n closst stars.  	nfar:		Select n farthest stars.  	faint:		Select stars with magnitudes less than or equal to 			this value.  	bright:		Select stars with magnitudes greater than or equal to 			this value.  	nbright:	Select this many brightest stars.    RETURN: 	Star descriptors obtained from the translators, 0 if an error occurs.    PROCEDURE: 	If /override, then a star descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_stars.html#pggs_select_stars", "pggs_select_stars", 'routine in <a href="com/pg/pg_get_stars.html">pg_get_stars.pro</a>', "pg_get_stars.pro", "", "pggs_select_stars", "", "odddsdselect", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_stars.html#pg_get_stars", "pg_get_stars", 'routine in <a href="com/pg/pg_get_stars.html">pg_get_stars.pro</a>', "pg_get_stars.pro", "", "pg_get_stars", "", "sdod_extraoverrideverbatimrawddtrs@str__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_stations.html", "pg_get_stations.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_stations.pro", "", "", " NAME: 	pg_get_stations    PURPOSE: 	Obtains a station descriptor for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_stations(dd) 	result = pg_get_stations(dd, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	std:		Input station descriptors; used by some translators.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	stn_*:		All station override keywords are accepted.  See 			station_keywords.include.  			If name is specified, then only descriptors with 			those names are returned.  	verbatim:	If set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    RETURN: 	Array of station descriptors, 0 if an error occurs.    PROCEDURE: 	If /override, then a station descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2009   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_stations.html#pg_get_stations", "pg_get_stations", 'routine in <a href="com/pg/pg_get_stations.html">pg_get_stations.pro</a>', "pg_get_stations.pro", "", "pg_get_stations", "", "odbxstd_extraoverrideverbatimddtrs@stn__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_grid.html", "pg_grid.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_grid.pro", "", "", " NAME: 	pg_grid    PURPOSE: 	Computes image points on a surface coordinate grid.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	grid_ptd = pg_grid(cd=cd, gbx=gbx) 	grid_ptd = pg_grid(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	gbx:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of GLOBE.  	dkx:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of DISK.  	bx:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of BODY.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	lat:	Array giving grid-line latitudes in radians.  	lon:	Array giving grid-line longitudes in radians.  	nlat:	Number of equally-spaced latitude lines to generate if keyword 		lat not given.  Default is 12.  	flat:	This reference latitude line will be one of the latitude lines generated 		if nlat is specified.  Default is zero.  	nlon:	Number of equally-spaced longitude lines to generate if keyword 		lon not given.  Default is 12.  	flon:	This reference longitude line will be one of the longitude lines generated 		if nlon is specified.  Default is zero.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.  	npoints: Number of points to compute in each latitude or longitude line, 		 per 2*pi radians; default is 360.  	slat:	Latitudes to compute on each longitude circle.  	slon:	Longitudes to compute on each latitude circle.     OUTPUT: 	lat:	Array giving grid-line latitudes in radians.  	lon:	Array giving grid-line longitudes in radians.    RETURN: 	Array of POINT containing image points and the corresponding inertial 	vectors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_grid.html#pg_grid", "pg_grid", 'routine in <a href="com/pg/pg_grid.html">pg_grid.pro</a>', "pg_grid.pro", "", "pg_grid", "", "cdgbxdkxbxddgdlatlonnlatnlonflatflonnpointsclipcullslatslon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_hide.html", "pg_hide.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_hide.pro", "", "", " NAME: 	pg_hide    PURPOSE: 	Hides the given points with respect to each given object and observer 	using the hide methods of the given bodies.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_hide, point_ptd, cd=cd, od=od, bx=bx    ARGUMENTS:   INPUT: 	point_ptd:	Array of POINT containing inertial vectors.    OUTPUT: 	hide_ptd:	Array (n_disks, n_timesteps) of POINT 			containing the hidden points.     KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	gbx:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of GLOBE.  	dkx:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of DISK.  	bx:	Array (n_bodies, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the observer from which points are hidden.  If no observer 		descriptor is given, the camera descriptor is used.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	reveal:	 Normally, objects whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.  	cat:	If set, the hide_ptd points are concatentated into a single 		POINT object.  	rm:	If set, points are flagged for being in front of or behind 		the body, rather then just behind it.  	assoc:	If set, points are only hidden wrt their associated body. 		This is typically much faster because the calcuations for 		each points array are carried out for a single body instead 		of all given bodies.  This is useful, for example, for hiding 		points that lie on the surface of a planet wrt to only that 		planet.    OUTPUT: NONE    RETURN: NONE    SIDE EFFECTS: 	The flags arrays in point_ptd are modified.    PROCEDURE: 	For each object in point_ptd, hidden points are computed and 	PTD_MASK_INVISIBLE in the POINT is set.  No points are 	removed from the array.    EXAMPLE: 	The following command hides all points which are behind a planet as 	seen by the camera:  	pg_hide, point_ptd, cd=cd, bx=pd  	In this call, pd is a planet descriptor, and cd is a camera descriptor.    STATUS: 	Complete    SEE ALSO: 	pg_hide_limb    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2017, generalized pg_hide_globe and pg_hide_disk   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_hide.html#pgh_select_by_assoc", "pgh_select_by_assoc", 'routine in <a href="com/pg/pg_hide.html">pg_hide.pro</a>', "pg_hide.pro", "", "pgh_select_by_assoc", "", "bxpoint_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_hide.html#pgh_select_by_bounding_box", "pgh_select_by_bounding_box", 'routine in <a href="com/pg/pg_hide.html">pg_hide.pro</a>', "pg_hide.pro", "", "pgh_select_by_bounding_box", "", "_cdbxpoint_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_hide.html#pg_hide", "pg_hide", 'routine in <a href="com/pg/pg_hide.html">pg_hide.pro</a>', "pg_hide.pro", "", "pg_hide", "", "cdodbxgbxdkxddgdrevealcompresscatrmassoc_point_ptdhide_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_image_sector.html", "pg_image_sector.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_image_sector.pro", "", "", " NAME: 	pg_image_sector   PURPOSE: 	Allows the user to select a rectangular image region, with an 	arbitrary tilt, by clicking and dragging.  A rectangle is selected 	using the left mouse button and a line of zero width is selected 	using the right moise button.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd = pg_image_sector()    ARGUMENTS:   INPUT:       NONE    OUTPUT: 	NONE     KEYWORDS:   INPUT:       win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.             p1:     Endpoint.  If given, p0 must also be given and is taken                    as the starting point for a line along which to scan.                    In this case, the user does not select the box manually.                    Scan width is one pixel unless 'width' is specified,                    and is centered on the line from p0 to p1.          width:     Width of box instead of letting the user select.          color:     Color to use for rectangle, default is !color.   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.         sample:	    Pixel grid sampling to use instead of 1.        corners:     If set, then p0 and p1 are taken as the corners of                    the box, and the user is not prompted to select one.         silent:     If set, messages are suppressed.     OUTPUT:          NONE   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.   ORIGINAL AUTHOR : J. Spitale ; 6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_image_sector.html#pg_image_sector", "pg_image_sector", 'routine in <a href="com/pg/pg_image_sector.html">pg_image_sector.pro</a>', "pg_image_sector.pro", "", "pg_image_sector", "", "samplewin_numwidthrestorep0p1xor_graphicscolorsilentcorners", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_image_sector.html#test", "test", 'routine in <a href="com/pg/pg_image_sector.html">pg_image_sector.pro</a>', "pg_image_sector.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb.html", "pg_limb.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb.pro", "", "", " NAME: 	pg_limb    PURPOSE: 	Computes image points on the limb of each given globe object.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	limb_ptd = pg_limb(cd=cd, gbx=gbx, ods=ods) 	limb_ptd = pg_limb(gd=gd, od=od)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	 Array (n_timesteps) of camera descriptors.  	gbx:	 Array (n_objects, n_timesteps) of descriptors of objects 		 which must be a subclass of GLOBE.  	od:	 Array (n_timesteps) of descriptors of objects 		 which must be a subclass of BODY.  These objects are used 		 as the observer from which limb is computed.  If no observer 		 descriptor is given, the camera descriptor is used.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	npoints: Number of points to compute.  Default is 1000.  	epsilon: Maximum angular error in the result.  Default is 1e-3.  	reveal:	 Normally, points computed for objects whose opaque flag 		 is set are made invisible.  /reveal suppresses this behavior.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.    OUTPUT: NONE    RETURN: 	Array (n_objects) of POINT containing image 	points and the corresponding inertial vectors.    PROCEDURE: 	By definition, the surface normal at a point on the limb of a body is 	perpendicular to a vector from the observer to that same point, so the 	dot product of the two vectors is zero.  This program uses an iterative 	scheme to find points onthe surface at which this dot product is less 	than epsilon.    EXAMPLE: 	The following command computes points on the planet which lie on the 	terminator:  	term_ptd = pg_limb,(cd=cd, gbx=pd, od=sd)  	In this call, pd is a planet descriptor, cd is a camera descriptor, 	and sd is a star descriptor (i.e., the sun).    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_limb.html#pg_limb", "pg_limb", 'routine in <a href="com/pg/pg_limb.html">pg_limb.pro</a>', "pg_limb.pro", "", "pg_limb", "", "cdodgbxddgdclipcullnpointsepsilonreveal", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb_sector.html", "pg_limb_sector.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb_sector.pro", "", "", " NAME: 	pg_limb_sector   PURPOSE: 	Allows the user to select an image sector along lines of constant  	azimuth and altitude above a planet by clicking and dragging.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_limb_sector(cd=cd, gbx=gbx, dkd=dkd)    ARGUMENTS:   INPUT:       NONE    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.            gbx:     Globe descriptor for the planet whose limb is to be                    scanned.             gd:     Generic descriptor containnig the above descriptors.        win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.         sample:     Sets the grid sampling in pixels.  Default is one.   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.          nodsk:     If set, skyplane disk image points will not be included                    in the output POINT.             cw:     If set, azimuths are assumed to increase in the clockwise                    direction.         silent:     If set, messages are suppressed.     OUTPUT:          dkd:      Disk desriptor in the skyplane, centered on the planet                    with 0 axis along the skyplane projection of the north                    pole.  For use with pg_profile_ring.           azimuths: Array giving azimuth at each sample.          altitudes: Array giving altitude at each sample.      limb_pts_body: Body coordinates of each limb points on planet surface.    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point, relative to the       returned disk descriptor, and the user fields 'nrad' and 'nlon'       giving the number of points in altitude and azimuth.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    MODIFICATION HISTORY : 	Spitale; 8/2006		original version   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_limb_sector.html#pg_limb_sector", "pg_limb_sector", 'routine in <a href="com/pg/pg_limb_sector.html">pg_limb_sector.pro</a>', "pg_limb_sector.pro", "", "pg_limb_sector", "", "cdgbxgdlonsamplewin_numrestorep0xor_graphicscolorsilentnodskdkdaltitudesazimuthslimb_pts_bodycw", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_altaz.html", "pg_limb_sector_altaz.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb_sector_altaz.pro", "", "", " NAME: 	pg_limb_sector_altaz   PURPOSE: 	Constructs a limb sector outline for use with pg_profile_ring given 	altitude and azimuth bounds.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_limb_sector_altaz(cd=cd, gbx=gbx, alt, az, dkd=dkd)    ARGUMENTS:   INPUT:       alt:	2-elements array giving the lower and upper altitude bounds 		for the sector.        az:	2-elements array giving the lower and upper azimuth bounds 		for the sector in radians, reliative to the skyplane 		projection of the planet's north pole.    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.            gbx:     Globe descriptor giving the planet about whose limb                    the scan will be extracted.             gd:     Generic descriptor containing the above descriptors.         sample:     Sets the grid sampling in pixels.  Default is one.            naz:     Total number of samples in the azimuthal direction.                    Determined by the 'sample' keyword by default.           nalt:     Total number of samples in the altitude direction.                    Determined by the 'sample' keyword by default.            alt:     Array giving the altitude of each point in the sector.             az:     Array giving the azimuth of each point in the sector.             cw:     If set, azimuths are assumed to increase in the clockwise                    direction.          nodsk:     If set, skyplane disk image points will not be included                    in the output POINT.        graphic:     If set, the sector is computed in the planetographic                    sense, i.e., lines of constant azimuth extend along                    the local surface normal direction instead of the radial                    direction.     OUTPUT:           dkd:     Disk descriptor in the skyplane, centered on the planet                    with 0 axis along the skyplane projection of the north                    pole.  For use with pg_profile_ring.           azimuths: Array giving azimuth at each sample.          altitudes: Array giving altitude at each sample.      limb_pts_body: Body coordinates of each limb points on planet surface.     RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT objects       also contains the disk coordinate for each point, relative to the       returned disk descriptor, and the user fields 'nrad' and 'nlon'       giving the number of points in altitude and azimuth.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : 	Spitale; 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_altaz.html#pg_limb_sector_altaz", "pg_limb_sector_altaz", 'routine in <a href="com/pg/pg_limb_sector_altaz.html">pg_limb_sector_altaz.pro</a>', "pg_limb_sector_altaz.pro", "", "pg_limb_sector_altaz", "", "cdgbxgddkdsamplenodskaltitudesazimuthslimb_pts_bodycwnaznaltgraphicalt_az", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_linear.html", "pg_limb_sector_linear.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb_sector_linear.pro", "", "", " NAME: 	pg_limb_sector_linear   PURPOSE: 	Constructs a limb sector outline for use with pg_profile_image, given 	altitude and length bounds.  The sector is rectangular, being tangent 	to the limb at a given azimuth.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd = pg_limb_sector_line(cd=cd, gbx=gbx, alt, rim, az0)    ARGUMENTS:   INPUT:       alt:	2-elements array giving the lower and upper altitude bounds 		for the sector.        rim:	2-element array giving the image-coordinate cylidrical coordinates 		of the the ends of the sector.        az0:	Azimuth of the sector tangent point.    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.            gbx:     Globe descriptor giving the planet about whose limb                    the scan will be extracted.             gd:     Generic descriptor containig the above descriptors.         sample:     Sets the grid sampling in pixels.  Default is one.           nrim:     Total number of samples in the scan direction.                    Determined by the 'sample' keyword by default.           nalt:     Total number of samples in the altitude direction.                    Determined by the 'sample' keyword by default.        graphic:     If set, the sector is computed in the planetographic                    sense, i.e., lines of constant azimuth extend along                    the local surface normal direction instead of the radial                    direction.     OUTPUT:              rims: Array giving azimuth at each sample.          altitudes: Array giving altitude at each sample.    RETURN:       POINT object containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the user fields 'nl' and 'nw' giving the number of points       in altitude and r.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : 	Spitale; 1/2009   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_linear.html#pg_limb_sector_linear", "pg_limb_sector_linear", 'routine in <a href="com/pg/pg_limb_sector_linear.html">pg_limb_sector_linear.pro</a>', "pg_limb_sector_linear.pro", "", "pg_limb_sector_linear", "", "cdgbxgdsamplealtitudesrimsnrimnaltgraphicalt_rimaz0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_oblique.html", "pg_limb_sector_oblique.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb_sector_oblique.pro", "", "", " NAME:			***incomplete*** 	pg_limb_sector_oblique   PURPOSE: 	Allows the user to select an image sector along lines of constant  	azimuth and altitude above a planet by clicking and dragging.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_limb_sector(cd=cd, gbx=gbx, dkd=dkd)    ARGUMENTS:   INPUT:       NONE    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.            gbx:     Globe descriptor for the planet whose limb is to be                    scanned.             gd:     Generic descriptor containnig the above descriptors.        win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.         sample:     Sets the grid sampling in pixels.  Default is one.   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.     OUTPUT:          dkd:      Disk desriptor in the skyplane, centered on the planet                    with 0 axis along the skyplane projection of the north                    pole.  For use with pg_profile_ring.           azimuths: Array giving azimuth at each sample.          altitudes: Array giving altitude at each sample.      limb_pts_body: Body coordinates of each limb points on planet surface.    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point, relative to the       returned disk descriptor, and the user fields 'nrad' and 'nlon'       giving the number of points in altitude and azimuth.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    MODIFICATION HISTORY : 	Spitale; 1/2007		original version   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_oblique.html#pg_limb_sector_oblique", "pg_limb_sector_oblique", 'routine in <a href="com/pg/pg_limb_sector_oblique.html">pg_limb_sector_oblique.pro</a>', "pg_limb_sector_oblique.pro", "", "pg_limb_sector_oblique", "", "cdgbxgdlonsamplewin_numrestorep0p1widthxor_graphicscolorsilentnodskdkdaltitudesazimuthslimb_pts_bodycw", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_linearize_image.html", "pg_linearize_image.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_linearize_image.pro", "", "", " NAME: 	pg_linearize_image    PURPOSE: 	Reprojects an image onto a linear scale.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_linearize_image(dd, new_cd, cd=cd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing image to be reprojected.    OUTPUT: 	new_cd:	Camera descriptor corresponding to the reprojected image.    KEYWORDS:   INPUT: 	cd:	Camera descriptor describing the image to be reprojected.  	gd:	Generic descriptor containing the above descriptor.  	scale:	2-element array giving the camera scale (radians/pixel) 		in each direction for the reprojected image.  If not given, the 		scale of the input image is used.  	oaxis:	2-element array giving the image coordinates of the optic axis 		in the reprojected image.  If not given, the center of 		the reprojected image is used.  	size:	2-element array giving the size of the reprojected image.  If 		not given, the size of the input image is used.  	pc_xsize: X-Size of each image piece.  Default is 200 pixels.  	pc_xsize: Y-Size of each image piece.  Default is 200 pixels.  	fcp:	Focal coordinates of known reseau locations.  	scp:	Image coordinates in input image of detected reseau marks 		corresponding to those given by nmp.  	interp:	Type of interpolation to use.  Options are: 		'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.    OUTPUT: 	image:	The output image, which is also placed in the data descriptor.    RETURN: 	Data descriptor containing the reprojected image.    PROCEDURE: 	The input image is divided into pieces and tranformed one piece at 	a time.  There are two modes of operation: If nmp and scp are 	given, then the image is transformed using them as control points. 	Otherwise, the image is transformed using whatever camera transformation 	is specified in the camera descriptor.    STATUS: 	Control-point scheme not yet implemented.    SEE ALSO: 	pg_resfit, pg_resloc    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_linearize_image.html#pg_linearize_image", "pg_linearize_image", 'routine in <a href="com/pg/pg_linearize_image.html">pg_linearize_image.pro</a>', "pg_linearize_image.pro", "", "pg_linearize_image", "", "cdgdfcpscpscaleoaxissizepc_xsizepc_ysizeimageinterpddnew_cd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_load_maps.html", "pg_load_maps.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_load_maps.pro", "", "", " NAME: 	pg_load_maps    PURPOSE: 	Loads maps and descriptors from a map directory.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	ddmap = pg_load_maps(md=md)    ARGUMENTS:   INPUT: 	dir :   Top directory for map library.  If not set, the directory 		is obtained from the PG_MAPS environment varable.    OUTPUT: NONE    KEYWORDS:   INPUT: 	bx:	Body descriptors indicating which maps to load.     OUTPUT: 	md:	Map descriptor for each map.    ENVIRONMENT VARIABLES: 	PG_MAPS: 		Sets the map directory; overrides the dir keyword.  Maps are 		organized into subdirectories named for each body.    RETURN: 	Data descriptor containing the rendered image.    PROCEDURE:     EXAMPLE:    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_load_maps.html#pg_load_maps", "pg_load_maps", 'routine in <a href="com/pg/pg_load_maps.html">pg_load_maps.pro</a>', "pg_load_maps.pro", "", "pg_load_maps", "", "mdbxdddir", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_map.html", "pg_map.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_map.pro", "", "", " NAME: 	pg_map    PURPOSE: 	Generates map projections.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_map(dd, md=md, cd=cd, gbx=gbx, sund=sund) 	result = pg_map(dd, gd=gd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing image to be projected.   KEYWORDS:   INPUT: 	md:	Map descriptor describing the projection.  	cd:	Camera descriptor describing the image to be projected.  	bx:	Subclass of BODY giving the body to be projected.  Can be 		GLOBE or RING.  Only bodies whose names match that in the 		map descriptor are mapped.  	gbx:	Globe descriptor describing the body to be projected. 		This argument is kept for compatibility with earlier 		code.  It is recommended that you use the 'bx' argument 		instead.  	dkx:	Disk descriptor describing the body to be projected. 		This argument is kept for compatibility with earlier 		code.  It is recommended that you use the 'bx' argument 		instead.  	sund:	Star descriptor for the sun.  If given, points behind the 		terminator are excluded.  	gd:	Generic descriptor.  If given, the above descriptor inputs 		are taken from the corresponding fields of this structure 		instead of from those keywords.  	hide_fn:	String giving the name of a function whose purpose 			is to exclude hidden points from the map.  The only 			function currently packaged is 'pm_hide_ring', which 			takes a ring descriptor as data (see next keyword).  	hide_data_p:	Pointer to data for the hide function.  	aux_names:	Array (naux) giving udata names for additional data 			descriptor planes to reproject.  The dimensions of these 			planes must be the same as the image.  	pc_xsize, pc_ysize:	The map is generated in pieces of size pc_xsize 				x pc_ysize.   Default is 100 x 100 pixels.  	bounds:		Projection bounds specified as [lat0, lat1, lon0, lon1].  	edge:	Minimum proximity to image edge.  Default is 0.  	roi:	Subscripts in the output map specifying the map region 		to project, instead of the whole thing.  	interp:	Type of interpolation, see image_interp_cam.  	arg_interp:	Interpolation argument, see image_interp_cam.  	offset:	Offset in [lat,lon] to apply to map coordinates before 		projecting.  	smooth:	If set, the input image is smoothed before reprojection.  	test_factor:	If set, a test map, reduced in size by this factor, 			is projected to determine the roi.  For maps with 			large blank areas, this may speed up the projection 			greatly.     OUTPUT: 	map:	For convenience, the generated map is returned here as 		well as in the returned data descriptor.    RETURN: 	Data descriptor containing the output map.  The instrument field is set 	to 'MAP'.  User data arrays are created for the reprojected aux_names 	arrays.    STATUS: 	Complete    SEE ALSO: 	pg_mosaic    MODIFICATION HISTORY:  	Written by:	Spitale, 1998 	Modified:	Daiana DiNino; 7, 2011 : test_factor   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_map.html#pg_map", "pg_map", 'routine in <a href="com/pg/pg_map.html">pg_map.pro</a>', "pg_map.pro", "", "pg_map", "", "mdcdbxgbxdkxsundgdhide_fnhide_data_pmapaux_namespc_xsizepc_ysizeboundsinterparg_interpoffsetedgewind_fnwind_datasmoothroitest_factordd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_mask.html", "pg_mask.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_mask.pro", "", "", " NAME: 	pg_mask    PURPOSE: 	Uses the given geometry to compute an image mask for all objects 	in a scene.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	mask = pg_mask(cd=cd, gbx=gbx, dkx=dkx, bx=bx, sund=sund) 	mask = pg_mask(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptors.  	dkx:	Disk descriptors.  	bx:	Body descriptors (i.e. point sources).  	sund:	Star descriptor giving the sun.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	fgbx,fdkx,fbx:	Fractonal amount to increase the radii of each 			descriptor type.  	dgbx,ddkx,dbx:	Absolute amount, in physical units (e.g. meters), to 			increase the radii of each descriptor type.  	pgbx,pdkx,pbx:	Absolute amount, in mask pixels, to increase the radii 			of each descriptor type.  	nodd;    If set, no data descriptor is created.  	np:      Number of points to use in computing curves.  Default is 1000.    OUTPUT: 	limb_ptd:	POINT giving the computed limb points.  	term_ptd:	POINT giving the computed terminator points.  	disk_ptd:	POINT giving the computed disk points.  	body_ptd:	POINT giving the computed body points.    RETURN: 	Data descriptor containing a byte image in which pixels corresponding 	to objects are set to 1.    STATUS: 	Complete.    SEE ALSO: 	pg_spikes    MODIFICATION HISTORY:  	Written by:	Spitale, 4/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_mask.html#pgmsk_grow", "pgmsk_grow", 'routine in <a href="com/pg/pg_mask.html">pg_mask.pro</a>', "pg_mask.pro", "", "pgmsk_grow", "", "maskdr", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_mask.html#pg_mask", "pg_mask", 'routine in <a href="com/pg/pg_mask.html">pg_mask.pro</a>', "pg_mask.pro", "", "pg_mask", "", "maskddgdcdgbxdkxbxsundfgbxfdkxfbxdgbxddkxdbxpgbxpdkxpbxlimb_ptdterm_ptdbody_ptddisk_ptdnoddnp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_mask_points.html", "pg_mask_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_mask_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_mask_points.html#pg_mask_points", "pg_mask_points", 'routine in <a href="com/pg/pg_mask_points.html">pg_mask_points.pro</a>', "pg_mask_points.pro", "", "pg_mask_points", "", "mask", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_measure.html", "pg_measure.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_measure.pro", "", "", " NAME: 	pg_measure    PURPOSE: 	Allows the user to measure quantities between two points in an 	image using the mouse in the current graphics window.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_measure, dd    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing the image.  Multiple data 		descriptors may be given and the pixel values for each will 		be displayed.  However, descriptors for only one of the data 		descriptors may be given.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	cd:	Camera descriptor.  Must be included for planet and ring 		coordinate, RA/DEC, and photometric output.  A map descriptor 		may be substitued for this argument, in which case ring 		coordinates, RA/DEC, and photometric data are not output.  	gbx:	Object descriptors, subclass of 'GLOBE'.  Must be included for 		planet coordinate output.  	dkx:	Object descriptors, subclass of 'DISK'.  Must be included for 		ring coordinate output.  	sund:	Star descriptor specifying the state of the sun.  	gd:	Generic descriptor.  If given, the above object descriptors are 		taken from this structure.  	radec:	If set, right ascension and declination differences with 		respect to the inertial coordinate system are output for 		each selected pair.  	xy:	If set, this is taken as the first point, and the user selects 		only the second point.  	fn:	Names of functions to be called whenever a point is selected. 		Each function is called as follows:  		value = call_function(fn, p, image, gd=gd, $                                                format=_format, label=label)  		p is the image coords of the selected point, image is the 		input image and gd is a generic descriptor containing the 		object descriptors.  format and label are outputs used to label 		the returned value.  These functions are apended to the set of 		default functions.  	silent:	If set, no string is printed, although the 'string' output 		keyword remains valid.     OUTPUT: 	string:	The string that's printed.  If /silent is specified, this 		string is valid, but not printed.  	values: Array (nfn,2,npoints) giving the numerical results in the order 		that they appear in the output.  	p:	Array (2,2) giving the selected points.    RETURN: 	NONE    STATUS: 	Ring photometry is not yet implemented.    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_xy_test", "_pgm_xy_test", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_xy_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_xy", "_pgm_xy", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_xy", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_dn_test", "_pgm_dn_test", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_dn_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm__dn", "_pgm__dn", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm__dn", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_dn", "_pgm_dn", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_dn", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_radec_test", "_pgm_radec_test", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_radec_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_radec", "_pgm_radec", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_radec", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_globe_test", "_pgm_globe_test", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_globe_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_globe", "_pgm_globe", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_globe", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_disk_test", "_pgm_disk_test", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_disk_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_disk", "_pgm_disk", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_disk", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_eqplane_test", "_pgm_eqplane_test", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_eqplane_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_eqplane", "_pgm_eqplane", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_eqplane", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#____pgm_eqplane", "____pgm_eqplane", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "____pgm_eqplane", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_map_test", "_pgm_map_test", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_map_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#_pgm_map", "_pgm_map", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_map", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#pgm_table", "pgm_table", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "pgm_table", "", "label_padvalue_padnamename_pvalue_plabel_pformat_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_measure.html#pg_measure", "pg_measure", 'routine in <a href="com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "pg_measure", "", "cdgbxdkxsundsdgdfnradecxystringsilentvaluespdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_mosaic.html", "pg_mosaic.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_mosaic.pro", "", "", " NAME: 	pg_mosaic    PURPOSE: 	Combines two or more maps into one.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_mosaic(dds)    ARGUMENTS:   INPUT: 	dds:	Array of data descriptors containing the maps to be combined. 		Maps must all be of the same size and data type.    OUTPUT: 	mosaic:	The mosaic image array.    KEYWORDS:   INPUT: 	combine_fn:	Name of function to be called to combine the maps. 			Default is 'median'.  	wt_fns:		Names of functions to be called to weight the maps.  	data:		Data to be passed to combine_fn.  	weight:		Array of weights, one for each input dd.         pc_xsize:	x size of mosaic work pieces.  Smaller pieces save 			memory, but increase run time.         pc_ysize:	y size of mosaic work pieces.     OUTPUT: 	mosaic:		Image array giving the output mosiac.    RETURN: 	Data descriptor containing the mosaic.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_mosaic.html#pg_mosaic", "pg_mosaic", 'routine in <a href="com/pg/pg_mosaic.html">pg_mosaic.pro</a>', "pg_mosaic.pro", "", "pg_mosaic", "", "combine_fnwt_fnsdatamosaicweightpc_xsizepc_ysizescalesdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_move.html", "pg_move.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_move.pro", "", "", " NAME: 	pg_move    PURPOSE: 	Translates and rotates the given points.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_move, object_ptd, dxy, dtheta, axis_ptd=axis_ptd    ARGUMENTS:   INPUT: 	object_ptd:	Array (n_objects) of POINT containing the 			image points to be moved.  	dxy:		2-element array specifying the translation as [dx,dy].  	dtheta:		Rotation angle in radians.    OUTPUT: 	object_ptd:	The input points are be modified on return.    KEYWORDS:   INPUT: 	axis_ptd:	POINT containing a single image point 			to be used as the axis of rotation.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pg_drag    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_move.html#pg_move", "pg_move", 'routine in <a href="com/pg/pg_move.html">pg_move.pro</a>', "pg_move.pro", "", "pg_move", "", "axis_ptdobject_ptddxydtheta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_nearest_points.html", "pg_nearest_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_nearest_points.pro", "", "", " NAME: 	pg_nearest_points    PURPOSE: 	xx    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_nearest_points.html#pg_nearest_points", "pg_nearest_points", 'routine in <a href="com/pg/pg_nearest_points.html">pg_nearest_points.pro</a>', "pg_nearest_points.pro", "", "pg_nearest_points", "", "object_ptd_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_northangle.html", "pg_northangle.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_northangle.pro", "", "", " NAME: 	pg_northangle    PURPOSE: 	Computes the angle between the image-coordinate y-axis and the 	projected z-axis of the given body.  Increasing angle corresponds to 	clockwise rotation in the image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	northangle = pg_northangle(cd=cd, bx=bx) 	northangle = pg_northangle(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	bx:	Array (n_objects, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.    OUTPUT: NONE    RETURN: 	Array (n_objects) of double giving the northangles in radians.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_northangle.html#pg_northangle", "pg_northangle", 'routine in <a href="com/pg/pg_northangle.html">pg_northangle.pro</a>', "pg_northangle.pro", "", "pg_northangle", "", "cdbxddgd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_photom.html", "pg_photom.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_photom.pro", "", "", " NAME: 	pg_photom    PURPOSE: 	Photometric image correction for disk or globe objects.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_photom(dd, cd=cd, gbx=gbx)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing image to correct.     OUTPUT: 	NONE   KEYWORDS:   INPUT: 	cd:	Camera descriptor  	gbx:	Globe descriptor  	dkx:	Disk descriptor  	sund:	Sun descriptor  	gd:	Generic descriptor.  If present, cd, dkx, and gbx are taken 		from here if contained.   	outline_ptd:	POINT with image points outlining the 			region of the image to correct.  To correct the entire 			planet, this input could be generated using pg_limb(). 			If this keyword is not given, the entire image is used.  	refl_fn:	String naming reflectance function to use.  Default is 			'pht_minneart'.  	refl_parms:	Array of parameters for the photometric function named 			by the 'refl_fn' keyword.  	phase_fn:	String naming phase function to use.  Default is none.  	phase_parms:	Array of parameters for the photometric function named 			by the 'phase_fn' keyword.  	overwrite:	If set, the output descriptor is the input descriptor 			with the relevant fields modified.    OUTPUT: 	emm_out:	Image emission angles.  	inc_out:	Image incidence angles.  	phase_out:	Image phase angles.    RETURN: 	Data descriptor containing the corrected image.  The photometric angles 	emm, inc, and phase are placed in the user data arrays with the tags 	'EMM', 'INC', and 'PHASE' respectively.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_photom.html#pg_photom", "pg_photom", 'routine in <a href="com/pg/pg_photom.html">pg_photom.pro</a>', "pg_photom.pro", "", "pg_photom", "", "outline_ptdcdgbxdkxsundgdrefl_fnphase_fnrefl_parmphase_parmemm_outinc_outphase_outoverwritedd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_photom_disk.html", "pg_photom_disk.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_photom_disk.pro", "", "", " NAME: 	pg_photom_disk    PURPOSE: 	Photometric image correction for disk objects.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_photom_globe(dd, cd=cd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing image to correct.     OUTPUT: 	NONE   KEYWORDS:   INPUT: 	cd:	Camera descriptor  	dkx:	Disk descriptor  	sund:	Sun descriptor  	gd:	Generic descriptor.  If present, cd and dkx are taken from 		here if contained.   	outline_ptd:	POINT with image points outlining the 			region of the image to correct.  To correct the entire 			disk, this input could be generated using pg_ring(). 			If this keyword is not given, the entire image is used. 			If two arrays are given, they are taken as the inner 			and outer boundaries.  	refl_fn:	String naming reflectance function to use.  Default is 			'pht_minneart'.  	refl_parms:	Array of parameters for the photometric function named 			by the 'refl_fn' keyword.  	phase_fn:	String naming phase function to use.  Default is none.  	phase_parms:	Array of parameters for the photometric function named 			by the 'phase_fn' keyword.  	overwrite:	If set, the output descriptor is the input descriptor 			with the relevant fields modified.    OUTPUT: 	emm_out:	Image emission angles.  	inc_out:	Image incidence angles.  	phase_out:	Image phase angles.    RETURN: 	New data descriptor containing the corrected image.  The photometric 	angles emm, inc, and phase are placed in the user data arrays with 	the tags'EMM', 'INC', and 'PHASE' respectively.  Unless /overwrite is 	set, the nw descriptor is a clone of the input descriptor, with the 	relevant fields modified.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002 (pg_photom) 	 Spitale, 6/2004:	changed to pg_photom_disk   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_photom_disk.html#pg_photom_disk", "pg_photom_disk", 'routine in <a href="com/pg/pg_photom_disk.html">pg_photom_disk.pro</a>', "pg_photom_disk.pro", "", "pg_photom_disk", "", "outline_ptdcddkxsundgdrefl_fnphase_fnrefl_parmphase_parmemm_outinc_outphase_outoverwritedd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_photom_globe.html", "pg_photom_globe.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_photom_globe.pro", "", "", " NAME: 	pg_photom_globe    PURPOSE: 	Photometric image correction for globe objects.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_photom_globe(dd, cd=cd, gbx=gbx)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing image to correct.     OUTPUT: 	NONE   KEYWORDS:   INPUT: 	cd:	Camera descriptor  	gbx:	Globe descriptor  	sund:	Sun descriptor  	gd:	Generic descriptor.  If present, cd and gbx are taken from 		here if contained.   	outline_ptd:	POINT with image points outlining the 			region of the image to correct.  To correct the entire 			planet, this input could be generated using pg_limb(). 			If this keyword is not given, the entire image is used.  	refl_fn:	String naming reflectance function to use.  Default is 			'pht_refl_minneart'.  	refl_parms:	Array of parameters for the photometric function named 			by the 'refl_fn' keyword.  	phase_fn:	String naming phase function to use.  Default is none.  	phase_parms:	Array of parameters for the photometric function named 			by the 'phase_fn' keyword.  	overwrite:	If set, the output descriptor is the input descriptor 			with the relevant fields modified.    OUTPUT: 	emm_out:	Image emission angles.  	inc_out:	Image incidence angles.  	phase_out:	Image phase angles.    RETURN: 	New data descriptor containing the corrected image.  The photometric 	angles emm, inc, and phase are placed in the user data arrays with 	the tags'EMM', 'INC', and 'PHASE' respectively.  Unless /overwrite is 	set, the nw descriptor is a clone of the input descriptor, with the 	relevant fields modified.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002 (pg_photom) 	 Spitale, 6/2004:	changed to pg_photom_globe   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_photom_globe.html#pg_photom_globe", "pg_photom_globe", 'routine in <a href="com/pg/pg_photom_globe.html">pg_photom_globe.pro</a>', "pg_photom_globe.pro", "", "pg_photom_globe", "", "outline_ptdcdgbxsundgdrefl_fnphase_fnrefl_parmphase_parmemm_outinc_outphase_outoverwritedd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_profile_image.html", "pg_profile_image.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_profile_image.pro", "", "", " NAME: 	pg_profile_image    PURPOSE: 	Generates a dn profile along a line in an image.   CATEGORY: 	NV/PG    CALLING SEQUENCE:     result = pg_profile_image(dd, cd=cd, outline_ptd)    ARGUMENTS:   INPUT: 	  dd:	Data descriptor.   outline_ptd:   POINT giving the outline of the region to plot,                as produced by the pg_image_sector.    OUTPUT:         NONE   KEYWORDS:   INPUT: 	  cd:	Camera descriptor.  Needed for sinc interpolation. (to get PSF)           gd:   Optional generic descriptor containing cd.       interp:   Type of interpolation to use.  Options are:                'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.           bg:	Uniform value to subtract from profile.   arg_interp:   Arguments to pass to the interpolation function.     OUTPUT:     profile:   The profile.        sigma:   Array giving the standard deviation at each point in the 		profile.      distance:  Array giving the distance, in pixels, along the profile.     image_pts:  Image point for each point along the profile.    RETURN: 	Two data descriptors: the first contains the profile; the second contains 	the profile sigma.    MODIFICATION HISTORY:        Written by:     Spitale, 6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_profile_image.html#pg_profile_image", "pg_profile_image", 'routine in <a href="com/pg/pg_profile_image.html">pg_profile_image.pro</a>', "pg_profile_image.pro", "", "pg_profile_image", "", "cdgddistanceinterparg_interpsigmaprofileimage_ptsbgddoutline_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_profile_image.html#test", "test", 'routine in <a href="com/pg/pg_profile_image.html">pg_profile_image.pro</a>', "pg_profile_image.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_profile_ring.html", "pg_profile_ring.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_profile_ring.pro", "", "", " NAME: 	pg_profile_ring    PURPOSE: 	Generates radial or longitudinal ring profiles from the given image 	using an image outline.   CATEGORY: 	NV/PG    CALLING SEQUENCE:     result = pg_profile_ring(dd, cd=cd, dkx=dkx, outline_ptd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.         outline_ptd:    POINT giving the outline of the sector to plot,                       as produced by the pg_ring_sector.    OUTPUT:         NONE   KEYWORDS:   INPUT: 	  cd:	Camera descriptor.          dkx:   Disk descriptor.           gd:   Generic descriptor, if used, cd and dkx taken from it unless                overriden by cd and dkx arguments.    azimuthal:   If set, the plot is longitudinal instead of radial.         bin:    If set, pixels in sector are binned according to                radius or longitude rather than dn averaged at equal                radius or longitude spacing      interp:    Type of interpolation to use: 'nearest', 'bilinear', 'cubic',                or 'sinc'.  'sinc' is the default.           bg:	Uniform value to subtract from profile.   arg_interp:   Arguments to pass to the interpolation function.    OUTPUT:     profile:   The profile.      dsk_pts:	Array of disk coordinates corresponding to each value in the 		returned dn profile.      im_pts:	Array of image coordinates corresponding to each value in the 		returned dn profile.        sigma:   Array giving the standard deviation at each point in the 		profile.        width:   Array giving the width of the scan, in pixels along the                averaging direction, at each point in the profile.           nn:   Number of image samples averaged into each profile point.   RETURN: 	Two data descriptors: the first contains the profile; the second contains 	the profile sigma.    PROCEDURE: 	The image points of the sector outline are first calculated.  If        /outline is selected then this is output.  If not, then the        /azimuthal keyword determines if this is a radius or longitude        profile.  The radius and longitude spacing for profile is then is        determined. If n_lon or n_rad is given, then these are used.  If not,        then the outline is used to determine the spacing in radius and        longitude so that the maximum spacing is a pixel.  If oversamp is        given then the number of samples is multiplied by this factor.        Then the image is sampled with this radius x longitude grid and        the dn interpolated with the routine image_interp at each point.        The dn's are then averaged along the requested profile direction.        If /bin keyword is selected then the image is not interpolated but        rather each pixel is binned in a histogram with the calculated        spacing.    EXAMPLE:      lon = [175.,177.]      rad = [65000000.,138000000.]      outline_ptd = pg_ring_sector(cd=cd, dkx=rd, rad=rad, lon=lon)      pg_draw, outline_ptd       profile = pg_profile_ring(dd, cd=cd, dkx=rd, $                                           outline_ptd, dsk_pts=dsk_pts)      window, /free, xs=500, ys=300      plot, dsk_pts[*,0], profile    MODIFICATION HISTORY:        Written by:     Vance Haemmerle & Spitale, 6/1998 	Modified to use outline_ptd instead of (rad,lon): Spitale 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_profile_ring.html#pg_profile_ring", "pg_profile_ring", 'routine in <a href="com/pg/pg_profile_ring.html">pg_profile_ring.pro</a>', "pg_profile_ring.pro", "", "pg_profile_ring", "", "cddkxgdazimuthalsigmawidthnnbindsk_ptsim_ptsinterparg_interpprofilebgddoutline_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptassoc.html", "pg_ptassoc.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptassoc.pro", "", "", " NAME: 	pg_ptassoc    PURPOSE: 	Associates points between two arrays by searching for the most 	frequent offset between the two.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	assoc_scan_ptd = pg_ptassoc(scan_ptd, model_ptd, assoc_model_ptd)    ARGUMENTS:   INPUT: 	scan_ptd:	POINT(s) containing first array, typically 			an array of candidate points detected in an image.  	model_ptd:	POINT(s) containing the second array, typically 			an array of computed model points.    OUTPUT: 	assoc_model_ptd:	POINT containing the output model points. 			Each of these points is associated with a point 			in the returned array.  If this argument is not 			present, the model_ptd array is overwritten with 			the output model points.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	POINT containing an associated scan point for each output 	model point in assoc_model_ptd.    PROCEDURE: 	Points are associated by searching for the most frequent offset 	between scan points and model points.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvscan_coeff, pg_ptscan, pg_ptscan_coeff, 	pg_cvchisq, pg_ptchisq, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptassoc.html#pg_ptassoc", "pg_ptassoc", 'routine in <a href="com/pg/pg_ptassoc.html">pg_ptassoc.pro</a>', "pg_ptassoc.pro", "", "pg_ptassoc", "", "radiusdxymaxcountscan_ptdmodel_ptdassoc_model_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptchisq.html", "pg_ptchisq.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptchisq.pro", "", "", " NAME: 	pg_ptchisq    PURPOSE: 	Computes chi-squared value for given point fit parameters.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	chisq = pg_ptchisq(dxy, dtheta, scan_ptd, axis_ptd=axis_ptd)    ARGUMENTS:   INPUT: 	dxy:		2-element vector giving the translation as [dx,dy].  	dtheta:		Rotation in radians.  	scan_ptd:	Array (n_points) of POINT output from 			pg_ptscan containing scanned image points as well as 			other necessary scan data.    OUTPUT: NONE    KEYWORDS:   INPUT: 	axis_ptd:	POINT containing a single image  point 			to be used as the axis of rotation.  	fix:		Array specifying which parameters to fix as 			[dx,dy,dtheta].    OUTPUT: NONE    RETURN: 	Single chi-square values for totality of points.    RESTRICTIONS: 	The caller is responsible for ensuring that the input parameters are 	consistent with those used with other programs like pg_fit.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, 	pg_ptchisq, pg_fit, pg_threshold    MODIFICATION HISTORY:  	Written by:	Haemmerle, 12/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptchisq.html#pg_ptchisq", "pg_ptchisq", 'routine in <a href="com/pg/pg_ptchisq.html">pg_ptchisq.pro</a>', "pg_ptchisq.pro", "", "pg_ptchisq", "", "axis_ptdfixdxydthetascan_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptcntrd.html", "pg_ptcntrd.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptcntrd.pro", "", "", " NAME: 	pg_ptcntrd    PURPOSE: 	Attempts to find points of highest correlation with a given model 	centered near given features in an image, then returns the centroid.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_ptcntrd(dd, object_ptd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor  	object_ptd: 	Array (n_pts) of POINT giving the points. 			Only the image coordinates of the points need to be 			specified.    OUTPUT:        NONE   KEYWORDS:   INPUT:        model:          Point spread model to be used in correlation.  If                        not given a default gaussian is used.         width:          Width to search around expected point location.  If                        not given, a default width of 20 pixels is used.         edge:           Distance from edge from which to ignore points.  If                        not given, an edge distance of 0 is used.         ccmin:          If given, points are discarded if the correlation                        is below this value.         gdmax:          If given, points are discarded if the gradiant of                        the correlation function is higher than this value.    OUTPUT: NONE    RETURN: 	An array of type POINT giving the detected position for        each object.  The correlation coeff values for each detection is        saved in the data portion of POINT with tag 'scan_cc'.        The x and y offset from the given position is also saved.    SIDE EFFECTS: 	xx    RESTRICTIONS: 	Currently does not work for multiple time steps.    PROCEDURE: 	For each visible object, a section of the image of size width +        the size of the model is extracted and sent to routine ptloc to        find the pixel offset with the highest correlation with the given        model. Then call astrolib routine cntrd to return centroid.    EXAMPLE: 	To find stellar positions with a correlation higher than 0.6...         star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, /rm        ptscan_ptd=pg_ptscan(dd, star_ptd, edge=30, width=40, ccmin=0.6)   SEE ALSO: 	ptscan, pg_ptscan   STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 5/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptcntrd.html#pg_ptcntrd", "pg_ptcntrd", 'routine in <a href="com/pg/pg_ptcntrd.html">pg_ptcntrd.pro</a>', "pg_ptcntrd.pro", "", "pg_ptcntrd", "", "modelwidthedgeccmingdmaxddobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptfarscan.html", "pg_ptfarscan.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptfarscan.pro", "", "", " NAME: 	pg_ptfarscan    PURPOSE: 	Attempts to find all occurrences of a model in an image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_ptfarscan(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor    OUTPUT:        NONE   KEYWORDS:   INPUT:        model:          Point spread model to be used in correlation.  If                        not given a default gaussian is used.  	wmod:		x, ysize of default gaussian model.  	wpsf:		Half width of default gaussian psf model.         edge:           Distance from edge from which to ignore points.  If                        not given, an edge distance of 0 is used.         gdmax:		If given, the maximum gradiant of correlation coefficient 			to accept.         ccmin:          Minimum correlation to consider in search.  Default 			is 0.8.         gdmax:          If given, points where the gradient of the                        correlation function is higher than this value 			are not considered in the search.  	sky:		If set, it is assumed that the image contains only 			point sources and sky.  Any object more than nsig 			standard deviations above the image mean are 			selected as candidates.  	nsig:		For use with the /sky option, standard deviation 			threshold for detecting point sources.  	nmax:		Max. number of point sources to return.  If more 			are found, nsig is raised until thiws is satisified.  	smooth:		If given, the input image is smoothed using 			this width before any further processing.  	median:		If given, the input image is filtered using 			a median filter of this width before any further 			processing.  	mask:		If set, an attempt is made to mask out extended 			objects before performing the scan  	extend:		If nonzero, star masks are extended by this 			many pixels in all directions.  	name:		Name to use for the returned POINT objects.    OUTPUT: NONE    RETURN: 	An array of type POINT giving the detected position for        each object.  The correlation coeff value for each detection is        saved in the data portion of POINT with tag 'scan_cc'.    SEE ALSO: 	pg_ptscan   STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale 2/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptfarscan.html#pg_ptfarscan", "pg_ptfarscan", 'routine in <a href="com/pg/pg_ptfarscan.html">pg_ptfarscan.pro</a>', "pg_ptfarscan.pro", "", "pg_ptfarscan", "", "namemodeledgeccmingdmaxsmoothwmodwpsfskynsigmedianmaskextendnmaxchifitdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptscan.html", "pg_ptscan.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptscan.pro", "", "", " NAME: 	pg_ptscan    PURPOSE: 	Attempts to find points of highest correlation with a given model 	centered near given features in an image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_ptscan(dd, object_ptd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor  	object_ptd: 	Array (n_pts) of POINT giving the points. 			Only the image coordinates of the points need to be 			specified.    OUTPUT:        NONE   KEYWORDS:   INPUT:        model:          Point spread model to be used in correlation.  If                        not given a default gaussian is used.  	wmod:		x, ysize of default gaussian model.  	wpsf:		Half-width of default gaussian psf model.         width:          Width to search around expected point location.  If                        not given, a default width of 20 pixels is used.  	radius:		Width outside of which to exclude detections whose 			offset varies too far from the most frequent offset. 			Detections with offsets outside this radius receive 			correlation coefficients of zero.         edge:           Distance from edge from which to ignore points.  If                        not given, an edge distance of 0 is used.         ccmin:          If given, points are discarded if the correlation                        is below this value.  	chisqmax:	Max chisq between the model and the image.         gdmax:          If given, points are discarded if the gradiant of                        the correlation function is higher than this value.  	smooth:		If given, the input image is smoothed using 			this width before any further processing.  	median:		If given, the input image is filtered using 			a median filter of this width before any further 			processing.    OUTPUT: NONE    RETURN: 	An array of type POINT giving the detected position for        each object.  The correlation coeff value for each detection is        saved in the data portion of POINT with tag 'scan_cc'.        The x and y offset from the given position is also saved.    RESTRICTIONS: 	Currently does not work for multiple time steps, only considers 	one point per given POINT.    PROCEDURE: 	For each visible object, a section of the image of size width +        the size of the model is extracted and sent to routine ptloc to        find the pixel offset with the highest correlation with the given        model.    EXAMPLE: 	To find stellar positions with a correlation higher than 0.6...         star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, /rm        ptscan_ptd=pg_ptscan(dd, star_ptd, edge=30, width=40, ccmin=0.6)   SEE ALSO: 	pg_ptfarscan   STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 5/1998 	Modified:	Spitale 9/2002 -- added twice model width to search 			width.   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptscan.html#pg_ptscan", "pg_ptscan", 'routine in <a href="com/pg/pg_ptscan.html">pg_ptscan.pro</a>', "pg_ptscan.pro", "", "pg_ptscan", "", "modelradiuswidthedgeccmingdmaxsmoothshowwmodwpsfmedianchisqmaxcc_outroundspikeddobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptscan_coeff.html", "pg_ptscan_coeff.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptscan_coeff.pro", "", "", " NAME: 	pg_ptscan_coeff    PURPOSE: 	Computes linear least-squares coefficients for a fit to the image 	coordinate offset which matches a point to a feature in an image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_ptscan_coeff(pts_ptd)    ARGUMENTS:   INPUT:        pts_ptd:        Array (n_pts) of POINT output from                        pg_ptscan containing image points as well as                        other necessary data.;    OUTPUT: NONE    KEYWORDS:   INPUT:        axis_ptd:       POINT containing a single image point                        to be used as the axis of rotation in the fit for                        every point.         fix:            Array specifying which parameters to fix in the                        fit as [dx,dy,dtheta].;    OUTPUT: NONE   RETURN:        Array (n_pts) of pg_fit_coeff_struct containing coefficients for        the least-square fit to be input to pg_fit.    PROCEDURE:        pg_ptscan_coeff extracts the scan data from the given        scan_ptd structure and uses ipt_coeff to compute the coefficients.        See the documentation for that routine for details.    EXAMPLE:        The following command uses data from pg_ptscan to compute        least square coefficients for a fit such that only dx and dtheta        will be allowed to vary:         optic_ptd = pnt_create_descriptors(points=cam_oaxis(cd))        ptscan_cf = pg_ptscan_coeff(pts_ptd, axis=optic_ptd, fix=[1])         In this call, pts_ptd is a POINT containing the point data        from pg_ptscan and optic_ptd is a POINT giving the optic axis        of the camera as computed by cam_oaxis.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 5/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptscan_coeff.html#pg_ptscan_coeff", "pg_ptscan_coeff", 'routine in <a href="com/pg/pg_ptscan_coeff.html">pg_ptscan_coeff.pro</a>', "pg_ptscan_coeff.pro", "", "pg_ptscan_coeff", "", "axis_ptdfixmodel_ptdpts_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_arrays.html", "pg_put_arrays.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_arrays.pro", "", "", " NAME: 	pg_put_arrays    PURPOSE: 	Outputs array descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_arrays, dd, ard=ard    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	ard:	Star descriptors to output.  	arr_*:		All star override keywords are accepted.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	CameStarra descriptors are passed to the translators.  Any star 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_cameras, pg_put_maps    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_arrays.html#pg_put_arrays", "pg_put_arrays", 'routine in <a href="com/pg/pg_put_arrays.html">pg_put_arrays.pro</a>', "pg_put_arrays.pro", "", "pg_put_arrays", "", "ardodsddtrs@arr__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_cameras.html", "pg_put_cameras.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_cameras.pro", "", "", " NAME: 	pg_put_cameras    PURPOSE: 	Outputs camera descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_cameras, dd, cd=cd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	cd:	Camera descriptors to output.  	cam_*:		All camera override keywords are accepted.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	Camera descriptors are passed to the translators.  Any camera 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_stars, pg_put_maps    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_cameras.html#pg_put_cameras", "pg_put_cameras", 'routine in <a href="com/pg/pg_put_cameras.html">pg_put_cameras.pro</a>', "pg_put_cameras.pro", "", "pg_put_cameras", "", "cdddtrs@cam__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_maps.html", "pg_put_maps.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_maps.pro", "", "", " NAME: 	pg_put_maps    PURPOSE: 	Outputs map descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_maps, dd, md=md    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	md:	Map descriptors to output.  	map_*:		All map override keywords are accepted.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	Map descriptors are passed to the translators.  Any map 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_stars, pg_put_cameras    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_maps.html#pg_put_maps", "pg_put_maps", 'routine in <a href="com/pg/pg_put_maps.html">pg_put_maps.pro</a>', "pg_put_maps.pro", "", "pg_put_maps", "", "mdddtrs@map__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_planets.html", "pg_put_planets.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_planets.pro", "", "", " NAME: 	pg_put_planets    PURPOSE: 	Outputs planet descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_planets, dd, pd=pd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	pd:	Planet descriptors to output.  	plt_*:		All planet override keywords are accepted.  	raw:		If set, no aberration corrections are performed.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	Planet descriptors are passed to the translators.  Any planet 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_cameras, pg_put_rings, pg_put_stars, pg_put_maps    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_planets.html#pg_put_planets", "pg_put_planets", 'routine in <a href="com/pg/pg_put_planets.html">pg_put_planets.pro</a>', "pg_put_planets.pro", "", "pg_put_planets", "", "pdodsrawddtrs@plt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_rings.html", "pg_put_rings.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_rings.pro", "", "", " NAME: 	pg_put_rings    PURPOSE: 	Outputs ring descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_rings, dd, rd=rd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	rd:	Ring descriptors to output.  	rng_*:		All ring override keywords are accepted.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	Ring descriptors are passed to the translators.  Any ring 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_cameras, pg_put_stars, pg_put_maps    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_rings.html#pg_put_rings", "pg_put_rings", 'routine in <a href="com/pg/pg_put_rings.html">pg_put_rings.pro</a>', "pg_put_rings.pro", "", "pg_put_rings", "", "rdodsddtrs@rng__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_stars.html", "pg_put_stars.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_stars.pro", "", "", " NAME: 	pg_put_stars    PURPOSE: 	Outputs star descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_stars, dd, sd=sd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	sd:	Star descriptors to output.  	str_*:		All star override keywords are accepted.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	CameStarra descriptors are passed to the translators.  Any star 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_cameras, pg_put_maps    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_stars.html#pg_put_stars", "pg_put_stars", 'routine in <a href="com/pg/pg_put_stars.html">pg_put_stars.pro</a>', "pg_put_stars.pro", "", "pg_put_stars", "", "sdodsddtrs@str__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_stations.html", "pg_put_stations.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_stations.pro", "", "", " NAME: 	pg_put_stations    PURPOSE: 	Outputs station descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_stations, dd, std=std    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	std:	Star descriptors to output.  	stn_*:		All star override keywords are accepted.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	CameStarra descriptors are passed to the translators.  Any star 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_cameras, pg_put_maps    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_stations.html#pg_put_stations", "pg_put_stations", 'routine in <a href="com/pg/pg_put_stations.html">pg_put_stations.pro</a>', "pg_put_stations.pro", "", "pg_put_stations", "", "stdodsddtrs@stn__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_range.html", "pg_range.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_range.pro", "", "", " NAME: 	pg_range    PURPOSE: 	Computes distance between the centers of two bodies.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	range = pg_center(bx1, bx2)    ARGUMENTS:   INPUT: 	bx1:	Array (n_objects, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	bx2:	Array (n_objects, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.    OUTPUT: NONE    RETURN: 	Array (n_objects) doubles giving the ranges.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_range.html#pg_range", "pg_range", 'routine in <a href="com/pg/pg_range.html">pg_range.pro</a>', "pg_range.pro", "", "pg_range", "", "bx1bx2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ray.html", "pg_ray.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ray.pro", "", "", " NAME: 	pg_ray    PURPOSE: 	Computes image points on each specified ray.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	ray_ptd = pg_ray(cd=cd, r=r, v=v)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	 Array (nt) of camera descriptors.  	bx:	 Array (nt) of body descriptors to be used for transforming 		 the points instead of the camera descriptor.  Use this 		 input if cd is a map.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	r:	 Array (nv,3,nt) of inertial vectors giving the starting 		 point for each ray.  	v:	 Array (nv,3,nt) of inertial unit vectors giving the direction 		 for each ray.  	len:	 Array (nv,nt) giving the length for each ray.  Lengths 		 default to 1 if not given.  	npoints: Number of points to compute per ray.  Default is 1000.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.  	cat:	 If set, all points for each descriptor are concatenated 		 into a single array of nv*npoints points.  	dispersion: If set, points will be randomly dispersed in a cone 	            of this opening angle about the ray.    OUTPUT: NONE    RETURN: 	Array (nt) of POINT each containing image points (2,nv,npoints) and 	the corresponding inertial vectors (nv,3,npoints).     STATUS:     MODIFICATION HISTORY:  	Written by:	Spitale, 9/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ray.html#pgr_density_uniform", "pgr_density_uniform", 'routine in <a href="com/pg/pg_ray.html">pg_ray.pro</a>', "pg_ray.pro", "", "pgr_density_uniform", "", "npnvlen", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_ray.html#pg_ray", "pg_ray", 'routine in <a href="com/pg/pg_ray.html">pg_ray.pro</a>', "pg_ray.pro", "", "pg_ray", "", "rvlencdbxddgdclipcullnpointscatdensity_fndispersion", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_reflection.html", "pg_reflection.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_reflection.pro", "", "", " NAME: 	pg_reflection    PURPOSE: 	Computes image coordinates of given inertial vectors projected onto 	surface of the given disks and globes with respect to the given 	observer.  Returns only the closest reflection point for each objoect 	point.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_reflection, object_ptd, cd=cd, ods=ods, dkx=dkx, gbx=gbx    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	gbx:	Array (n_globes, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.  	dkx:	Array (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of DISK.  	bx:	Array (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the sun descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	  All other keywords are passed directly to pg_reflection_globe 	  and pg_reflection_disk and are documented with those programs.    OUTPUT: NONE    RETURN: 	Array (n_disks,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be replaced by a new program that merges pg_reflection_globe and 	pg_reflection_disk.  The API for the new routine may be slightly different.    SEE ALSO: 	pg_reflection_disk, pg_reflection_globe, pg_reflection_points    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_reflection.html#pg_reflection", "pg_reflection", 'routine in <a href="com/pg/pg_reflection.html">pg_reflection.pro</a>', "pg_reflection.pro", "", "pg_reflection", "", "cdoddkxgbxbxddgdrevealclipnocullallobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_reflection_disk.html", "pg_reflection_disk.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_reflection_disk.pro", "", "", " NAME: 	pg_reflection_disk    PURPOSE: 	Computes image coordinates of given inertial vectors reflected onto 	surface of the given disk with respect to the given observer.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_reflection_disk(object_ptd, cd=cd, ods=ods, dkx=dkx)    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	dkx:	Array (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of DISK.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the camera descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	reveal:	 Normally, disks whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.  	clip:	 If set reflection points are cropped to within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.  	all:	 If set, all points are returned, even if invalid.    OUTPUT: NONE    RETURN: NONE 	Array (n_disks,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be obsolete.  This program will be merged with pg_shadow_globe 	to make a more general program, which will replace pg_shadow.    SEE ALSO: 	pg_reflection, pg_reflection_globe    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_reflection_disk.html#pg_reflection_disk", "pg_reflection_disk", 'routine in <a href="com/pg/pg_reflection_disk.html">pg_reflection_disk.pro</a>', "pg_reflection_disk.pro", "", "pg_reflection_disk", "", "cdoddkxddgdnocullall_ptdrevealclipcullallobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_reflection_globe.html", "pg_reflection_globe.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_reflection_globe.pro", "", "", " NAME: 	pg_reflection_globe    PURPOSE: 	Computes image coordinates of the given inertial vectors projected onto 	surface of the given globe with respect to the given observer.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_reflection_globe(object_ptd, cd=cd, od=od, gbx=gbx)    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	gbx:	Array (n_globes, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the sun descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	reveal:	 Normally, disks whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.  	clip:	 If set reflection points are cropped to within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.  	all:	 If set, all points are returned, even if invalid.  	nosolve: If set, reflection points are not computed.    OUTPUT: NONE    RETURN: 	Array (n_globes,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be obsolete.  This program will be merged with pg_reflection_disk 	to make a more general program, which will replace pg_reflection.    SEE ALSO: 	pg_reflection, pg_reflection_disk, pg_reflection_points    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_reflection_globe.html#pg_reflection_globe", "pg_reflection_globe", 'routine in <a href="com/pg/pg_reflection_globe.html">pg_reflection_globe.pro</a>', "pg_reflection_globe.pro", "", "pg_reflection_globe", "", "cdodgbxddgdnocullrevealclipcullallnosolveobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_render.html", "pg_render.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_render.pro", "", "", " NAME: 	pg_render    PURPOSE: 	Performs rendering on an array of bodies.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_render(cd=cd, bx=bx, sund=sund, ddmap=dd_render, md=md)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	      Camera descriptor.  	bx:	      Array of object descriptors; must be a subclass of BODY.  	sund:         Star descriptor for the Sun.  	md:           Array of map descriptors for each ddmap.  	gd:		Generic descriptor.  If given, the descriptor inputs 			are taken from this structure if not explicitly given.  	dd:		Data descriptor containing a generic descriptor to use 			if gd not given.  	ddmap:        Array of data descriptors containing the body maps, 	              one for each body.  If not given, maps are loaded using 		      pg_load_maps.  	sample:       Amount by which to subsample pixels.  	pc_size:      To save memory, the projection is performed in pieces 	              of this size.  Default is 65536.  	limit_source: If set, secondary vectors originating on a given 	              body are not considered for targets that are the 	              same body.  Default is on.  	standoff:     If given, secondary vectors are advanced by this distance 	              before tracing in order to avoid hitting target bodies 	              through round-off error.  	nodd:         If set, no data descrptor is produced.  The return value 	              is zero and the rendering is returned via the IMAGE 	              keyword.  	psf:          If set, the rendering is convolved with a point-spread 	              function.  If /psf, then the PSF is obtained via cd; if 	              psf is a 2D array, then is is used as the PSF.  	npsf:         Width of psf array to use if PSF is obtained via cd. 	              Default is 10.  	penumbra:     If set, lighting rays are traced to random points on 	              each secondary body rather then the center.  	no_secondary: If set, no secondary ray tracing is performed, 	              resulting in no shadows.  	image_ptd:    POINT or array with image points 	              specifying the grid to trace.  If not set, the entire 	              image described by cd is used.  The array can have 	              dimensions of (2,np) or (2,nx,ny).  If the latter, 	              the output map will have dimensions (nx,ny).  Note 	              that a PSF cannot be applied if nx and ny are not known.  	mask_width:   Width of trace mask.  Default is 512.  If set to zero, 	              no masking is performed.  	no_maps:      If set, maps are not loaded.  	pht_min:      Minimum value to assign to photometric output.     OUTPUT: 	map:	       2-D array containing the rendered scene.    RETURN: 	Data descriptor containing the rendered image.    PROCEDURE:     EXAMPLE:    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_render.html#pg_render", "pg_render", 'routine in <a href="com/pg/pg_render.html">pg_render.pro</a>', "pg_render.pro", "", "pg_render", "", "cdsundbxddmapmdddgdsamplepc_sizeshowpht_minno_phtmapstandofflimit_sourcenoddpsfnpsfpenumbrano_secondaryimage_ptdmask_widthno_maps", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_renderfit.html", "pg_renderfit.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_renderfit.pro", "", "", " NAME: 	pg_renderfit    PURPOSE: 	Searches for the offset (dx,dy) that gives the best agreement between 	two uncorrelated sets of image points.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dxy = pg_renderfit(dd, cd=cd, sund=sund, bx=bx)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd: 		Camera descriptor.  	sund:		Sun descriptor.  	bx:		Array of body descriptors describing objects in the scene.  	show:		If specified, some graphics are displayed illustrating 			aspects of the search.     OUTPUT: NONE    RETURN: 	2-element array giving the fit offset as [dx,dy].    PROCEDURE: 	pg_renderfit finds the offset that gives the best correlation between 	the given image and a simulated image.    STATUS: 	Some bugs.  One problem is that the current search grid wraps pixels 	instead of truncating them.  This causes problems for images where 	a large body is not entirly within the FOV.    NOTES: 	This could be improved by iterating, starting with a broader, more 	coarsely sampled scene.    SEE ALSO: 	pg_farfit    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_renderfit.html#pg_renderfit", "pg_renderfit", 'routine in <a href="com/pg/pg_renderfit.html">pg_renderfit.pro</a>', "pg_renderfit.pro", "", "pg_renderfit", "", "cdsundbxshowfovdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_repoint.html", "pg_repoint.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_repoint.pro", "", "", " NAME: 	pg_repoint    PURPOSE: 	Modifies the camera orientation matrix based on the given image 	coordinate translation and rotation.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_repoint, cd=cd, dxy, dtheta, axis_ptd=axis_ptd 	pg_repoint, gd=gd, dxy, dtheta, axis_ptd=axis_ptd    ARGUMENTS:   INPUT: 	dxy:		Array (2,1,nt) or (2,1) specifying the 			translation as [dx,dy] in pixels.  	dtheta:		Array (nt) specfying the rotation angle in radians.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	 Array (nt) of camera descriptors.  	gd:	 Generic descriptor.  If given, the cd input is taken from the 		 cd field of this structure instead of from that keyword.  	axis_ptd: POINT containing a single image point 		 to be used as the axis of rotation.  Default is the camera 		 optic axis.  	bore_cd:  Array (nt) of camera descriptors from which to copy the 		  new orientation instead of using dxy, dtheta, and axis_ptd.  	bore_rot: If given, the orientation from bore_cd will be rotated 		  using this rotation matrix (3,3) before being copied.  	bore_dxy: Boresight offset in pixels.  	absolute: If set, the dxy argument represents and abosolute image 		  position rather than an offset.    OUTPUT: 	cd:	 If given, the camera descriptor is modified with a new 		 orientation matrix.  	gd:	 If given in this way, the camera descriptor contained in the 		 generic descriptor is modified with a new orientation matrix.    RETURN: NONE    SIDE EFFECTS: 	pg_repoint adds its name to the task list of each given camera 	descriptor.    STATUS: 	Complete    SEE ALSO: 	pg_fit, pg_drag    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_repoint.html#pg_repoint", "pg_repoint", 'routine in <a href="com/pg/pg_repoint.html">pg_repoint.pro</a>', "pg_repoint.pro", "", "pg_repoint", "", "cdgdaxis_ptdbore_cdbore_rotbore_dxyabsolute_dxy_dtheta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_repos.html", "pg_repos.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_repos.pro", "", "", " NAME: 	pg_repos    PURPOSE: 	Modifies the body position based on the given offset and observer.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_repos, bx=bx, dv 	pg_repos, bx=bx, dv, od=od    ARGUMENTS:   INPUT: 	dv:		Array (nv,3,nt) specifying the translation vector. 			The components are assumed to be given wrt to the 			inertial frame unless od is given.  In that case 			dv is interpreted as a vector in the body frame of od.  			For convenience, if dv is given in the nonstandard form 			of a 3-element array, it is reinterpreted as a column 			vector (1,3).  			If ref_bx is given, then dv is interpreted as a distance 			and the direction is constructed from one of the directional 			keywords below.    OUTPUT: NONE    KEYWORDS:   INPUT: 	 bx:	   Array (nt) of body descriptors to translate.  	 od:	   Observer descriptor; specifies the body frame for the 		   translation vector.    	 gd:	   Generic descriptor.  If given, the descriptor inputs 		   are taken from this structure if not explicitly given.  	 dd:	   Data descriptor containing a generic descriptor to use 		   if gd not given.  	 ref_bx:   Body descriptor giving reference position for directional 		   keywords.  	toward:    Body should be translated toward ref_bx (default).  	away:      Body should be translated away from ref_bx.  	at:        Body should be placed at the position of ref_bx.  	along:     Index of bx axis along which to translate.     OUTPUT: 	NONE.    RETURN: NONE    SIDE EFFECTS: 	pg_repos modifies bx and adds its name to the task list of each given 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2007   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_repos.html#pg_repos", "pg_repos", 'routine in <a href="com/pg/pg_repos.html">pg_repos.pro</a>', "pg_repos.pro", "", "pg_repos", "", "bxodref_bxddgdtowardawayatalong_dv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_resfit.html", "pg_resfit.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_resfit.pro", "", "", " NAME: 	pg_resfit    PURPOSE: 	Computes polynomial coefficients for a camera distortion model by 	comparing detected reseaus with the known focal plane locations.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_resfit, scan_ptd, foc_ptd, n, cd=cd    ARGUMENTS:   INPUT: 	scan_ptd:	POINT containing image coordinates of 			the scanned reseau candidates as output by pg_resloc.  	foc_ptd:		POINT containing the known focal 			coordinates of the reseau marks.  	n:		Order of polynomial to fit.  Default is 4.    OUTPUT: 	NONE    KEYWORDS:   INPUT:        cd:		Camera descriptor to be modified.         gd:		Generic descriptor containing the camera descriptor 			to be modified.         range:		Range to use in associating candidate reseaus 			with known reseaus. default is 10 pixels.  	assoc:		If set, the program returns after generating 			the scan_sub array, but before fitting the polynomial 			coefficients.  	nom_ptd:		If given, this POINT contains image 			coordinates of nominal reseau locations corresponding 			to each point in foc_ptd.  The positions of each mark 			for which there is no scan_ptd match is computed 			as the nominal position plus an offset determined 			by looking at the differences between neighboring 			scanned marks and their corresponding nominal positions.  	use_nom:	If set, scan_ptd will be ignored and nom_ptd will be used 			instead.    OUTPUT: 	res_ptd:		POINT containing the new image 			coordinates of the known reseau marks.  	fcp:		POINT returning the focal points from 			foc_ptd that were able to be associated with a scanned 			reseau.  	scp:		POINT returning the scanned points from 			scan_ptd that were able to be associated with a 			known location.   RETURN: 	NONE    PROCEDURE: 	First, candidate reseaus are associated with nominal reseaus by 	choosing the candidate with the highest correlation coefficient 	within a given number of pixels surrounding each known reseau.  	Next, coefficients for a polynomial of order n are derived using a 	least-squares fit.    STATUS: 	Complete    SEE ALSO: 	pg_resloc, pg_linearize_image, pg_blemish    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_resfit.html#pgrf_associate_marks", "pgrf_associate_marks", 'routine in <a href="com/pg/pg_resfit.html">pg_resfit.pro</a>', "pg_resfit.pro", "", "pgrf_associate_marks", "", "scan_ptsfoc_ptsccrange", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_resfit.html#pgrf_get_matches", "pgrf_get_matches", 'routine in <a href="com/pg/pg_resfit.html">pg_resfit.pro</a>', "pg_resfit.pro", "", "pgrf_get_matches", "", "nom_ptdfpspscan_subfoc_ptsscan_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_resfit.html#pg_resfit", "pg_resfit", 'routine in <a href="com/pg/pg_resfit.html">pg_resfit.pro</a>', "pg_resfit.pro", "", "pg_resfit", "", "cdgdrangenom_ptdres_ptdscpfcpassocuse_nomscan_ptdfoc_ptdn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_residuals.html", "pg_residuals.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_residuals.pro", "", "", " NAME: 	pg_residuals    PURPOSE: 	Computes residuals value for given curve- or point-fit parameters.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	chisq = pg_residuals(scan_ptd)    ARGUMENTS:   INPUT: 	scan_ptd:	Array (n_curves) of POINT output from 			pg_cvscan or pg_ptscan containing scan data.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2,n_curves) of residuals.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_residuals.html#pg_residuals", "pg_residuals", 'routine in <a href="com/pg/pg_residuals.html">pg_residuals.pro</a>', "pg_residuals.pro", "", "pg_residuals", "", "scan_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_resloc.html", "pg_resloc.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_resloc.pro", "", "", " NAME: 	pg_resloc    PURPOSE: 	Scans an image for candidate reseau marks.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_resloc(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing the image to scan.    OUTPUT: 	NONE    KEYWORDS:   INPUT:         edge:  Distance from edge within which points are ignored.         ccmin:  Minimum correlation coefficient to accept.  Default is 0.8 .         gdmax:  Maximum gradiant of correlation coefficient to accept. 		Default is 0.25         model:  2-D array giving a model of the reseau image.  Default model 		is an inverted Gaussian.  	nom_ptd:	If given, reseau marks are searched for only within the 		given radius about each nominal point.  	radius:	Radius about no_ptd to search.  Default is ten pixels.    OUTPUT: 	NONE    RETURN: 	Points structure containing the image coordinates of each candidiate 	reseau mark and the corresponding correlation coefficients.  If not 	marks are found, zero is returned.    PROCEDURE: 	A correlation map is computed across image.  Candidates reseau marks 	are identified as local maxima in the correlation map by accepting 	points where the correlation is above the specified threshold and 	where the gradient of the correlation map is below the specified 	threshold.    STATUS: 	Complete    SEE ALSO: 	pg_resfit, modloc    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_resloc.html#pg_resloc", "pg_resloc", 'routine in <a href="com/pg/pg_resloc.html">pg_resloc.pro</a>', "pg_resloc.pro", "", "pg_resloc", "", "edgemodelccmingdmaxnom_ptdradiusdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_retarg.html", "pg_retarg.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_retarg.pro", "", "", " NAME: 	pg_retarg    PURPOSE: 	Modifies the camera orientation such that the optic axis points 	along a given vector, or toward a specified body.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_retarg, cd=cd, bx=bx    ARGUMENTS:   INPUT: 	v:	Inertial vector giving new optic axis direction.    OUTPUT: NONE    KEYWORDS:   INPUT: 	 cd:	 Camera descriptor to repoint.  	 bx:	 Body descriptor at which to point.  	 gd:	 Generic descriptor.  If given, the descriptor inputs 		 are taken from this structure if not explicitly given.  	 dd:	 Data descriptor containing a generic descriptor to use 		 if gd not given.  	 toward: Camera should be pointed toward bx (default).  	 away:   Camera should be pointed away from bx.  	along:   Index of bx axis along which to point.     OUTPUT: 	NONE.    RETURN: NONE    SIDE EFFECTS: 	pg_retarg modifies cd and adds its name to the task list of each given 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2007   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_retarg.html#pg_retarg", "pg_retarg", 'routine in <a href="com/pg/pg_retarg.html">pg_retarg.pro</a>', "pg_retarg.pro", "", "pg_retarg", "", "cdbxref_bxddgdtowardawayalongv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector.html", "pg_ring_sector.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector.pro", "", "", " NAME: 	pg_ring_sector   PURPOSE: 	Allows the user to select a ring sector by clicking and dragging. 	With the left button, the sector is defined along lines of constant 	radius and longitude.  With the right button, the sides of the sector 	are perpendicular to the projected radial direction.   CATEGORY:        NV/PG   CALLING SEQUENCE:      rad=pg_ring_sector(cd=cd, dkx=dkx)    ARGUMENTS:   INPUT:       NONE    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.  	   dkx:     Disk descriptor describing the ring.             gd:     Generic descriptor containing the above descriptors.        win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.          slope:     This keyword allows the longitude to vary from the                    nominal direction as a function of radius as:                    lon = slope*(rad - rad0).         sample:     Sets the grid sampling in pixels.  Default is one.   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.          nodsk:     If set, image points will not be included in the output                    POINT.         silent:     If set, messages are suppressed.        rad,lon:     If set, these values are used as bounds for the ring                    the ring sector instead of pronpting the user.     OUTPUT:        button:     Code of the detected button.    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point and the user fields       'nrad' and 'nlon' giving the number of points in radius and longitude.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    MODIFICATION HISTORY : 	J. Spitale ; 5/2005 -- Original pg_ring_sector renamed 	                       pg_ring_sector_rad; this program created.   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ring_sector.html#pg_ring_sector", "pg_ring_sector", 'routine in <a href="com/pg/pg_ring_sector.html">pg_ring_sector.pro</a>', "pg_ring_sector.pro", "", "pg_ring_sector", "", "cddkxgdradlonsamplewin_numrestoreslopep0buttonxor_graphicscolorsilentnodsk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box.html", "pg_ring_sector_box.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_box.pro", "", "", " NAME: 	pg_ring_sector_box   PURPOSE: 	Allows the user to select a box to use with pg_profile_ring.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd = pg_ring_sector_box()      outline_ptd = pg_ring_sector_box(corners)    ARGUMENTS:   INPUT:       corners:	    Array of image points giving the corners of the box. 		    If not given, the user is prompted to select a box.    OUTPUT: 	NONE     KEYWORDS:   INPUT:       win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.         silent:     If set, messages are suppressed.         sample:     Grid sampling, default is 1.     OUTPUT:        button:     Code of the detected button.    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : J. Spitale ; 6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box.html#pg_ring_sector_box", "pg_ring_sector_box", 'routine in <a href="com/pg/pg_ring_sector_box.html">pg_ring_sector_box.pro</a>', "pg_ring_sector_box.pro", "", "pg_ring_sector_box", "", "samplewin_numrestorebuttonp0xor_graphicscolorsilentp", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box.html#test", "test", 'routine in <a href="com/pg/pg_ring_sector_box.html">pg_ring_sector_box.pro</a>', "pg_ring_sector_box.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box_oblique.html", "pg_ring_sector_box_oblique.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_box_oblique.pro", "", "", " NAME: 	pg_ring_sector_box_oblique   PURPOSE: 	Allows the user to select an oblique box to use with pg_profile_ring.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_ring_sector_box_oblique()      outline_ptd=pg_ring_sector_box_oblique(corners)    ARGUMENTS:   INPUT:       corners:	    Array of image points giving the four corners of the box. 		    If not given, the user is prompted to select a box.     OUTPUT: 	NONE     KEYWORDS:   INPUT:       win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.          slope:     This keyword allows the longitude to vary from the                    perpendicular direction as a function of radius as:                    lon = slope*(rad - rad0).   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.      noverbose:     If set, messages are suppressed.         sample:     Grid sampling, default is 1.     OUTPUT:          NONE    RETURN:       POINT object containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point and the user fields       'nrad' and 'nlon' giving the number of points in radius and longitude.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : J. Spitale ; 9/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box_oblique.html#pg_ring_sector_box_oblique", "pg_ring_sector_box_oblique", 'routine in <a href="com/pg/pg_ring_sector_box_oblique.html">pg_ring_sector_box_oblique.pro</a>', "pg_ring_sector_box_oblique.pro", "", "pg_ring_sector_box_oblique", "", "lonsamplewin_numrestorep0xor_graphicscolornoverbosep", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box_oblique.html#test", "test", 'routine in <a href="com/pg/pg_ring_sector_box_oblique.html">pg_ring_sector_box_oblique.pro</a>', "pg_ring_sector_box_oblique.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box_ortho.html", "pg_ring_sector_box_ortho.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_box_ortho.pro", "", "", " NAME: 	pg_ring_sector_box_ortho   PURPOSE: 	Allows the user to select a box to use with pg_profile_ring.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd = pg_ring_sector_box_ortho()      outline_ptd = pg_ring_sector_box_ortho(corners)    ARGUMENTS:   INPUT:       corners:	    Array of image points giving the corners of the box. 		    If not given, the user is prompted to select a box.    OUTPUT: 	NONE     KEYWORDS:   INPUT:       win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.         silent:     If set, messages are suppressed.         sample:     Grid sampling, default is 1.     OUTPUT:          NONE    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : J. Spitale ; 6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box_ortho.html#pg_ring_sector_box_ortho", "pg_ring_sector_box_ortho", 'routine in <a href="com/pg/pg_ring_sector_box_ortho.html">pg_ring_sector_box_ortho.pro</a>', "pg_ring_sector_box_ortho.pro", "", "pg_ring_sector_box_ortho", "", "samplewin_numrestorep0xor_graphicscolorsilentp", "          -1", "");
  
  libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box_ortho.html#test", "test", 'routine in <a href="com/pg/pg_ring_sector_box_ortho.html">pg_ring_sector_box_ortho.pro</a>', "pg_ring_sector_box_ortho.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_oblique.html", "pg_ring_sector_oblique.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_oblique.pro", "", "", " NAME: 	pg_ring_sector_oblique   PURPOSE: 	Allows the user to select a ring sector by clicking and dragging. 	The top and bottom of the sector are defined along lines of constant 	radius, while the sides are perpendicular to the image-projected 	radial direction.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_ring_sector_oblique(cd=cd, dkx=dkx)    ARGUMENTS:   INPUT:       NONE    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.  	   dkx:     Disk descriptor describing the ring.             gd:     Generic descriptor containnig the above descriptors.        win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.          slope:     This keyword allows the longitude to vary from the                    perpendicular direction as a function of radius as:                    lon = slope*(rad - rad0).   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.         silent:     If set, messages are suppressed.         sample:     Grid sampling, default is 1.          nodsk:     If set, image points will not be included in the output                    POINT.    OUTPUT:          NONE    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point and the user fields       'nrad' and 'nlon' giving the number of points in radius and longitude.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : J. Spitale ; 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_oblique.html#pg_ring_sector_oblique", "pg_ring_sector_oblique", 'routine in <a href="com/pg/pg_ring_sector_oblique.html">pg_ring_sector_oblique.pro</a>', "pg_ring_sector_oblique.pro", "", "pg_ring_sector_oblique", "", "cddkxgdlonsamplewin_numrestoreslopep0xor_graphicscolorsilentnodsk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_perp.html", "pg_ring_sector_perp.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_perp.pro", "", "", " NAME: 	pg_ring_sector_perp   PURPOSE: 	Allows the user to select a ring sector by clicking and dragging. 	The top and bottom of the sector are defined along lines of constant 	radius, while the sides are perpendicular to the image-projected 	radial direction.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_ring_sector_perp(cd=cd, dkx=dkx)    ARGUMENTS:   INPUT:             p:     Corners of the sector.  If not given, the user selects                    them by hand.    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.  	   dkx:     Disk descriptor describing the ring.             gd:     Generic descriptor containnig the above descriptors.        win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.         sample:     Sets the grid sampling in pixels.  Default is one.          slope:     This keyword allows the longitude to vary from the                    perpendicular direction as a function of radius as:                    lon = slope*(rad - rad0).   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.          nodsk:     If set, image points will not be included in the output                    POINT.         silent:     If set, messages are suppressed.     OUTPUT:          NONE    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point and the user fields       'nrad' and 'nlon' giving the number of points in radius and longitude.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : J. Spitale ; 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_perp.html#pg_ring_sector_perp", "pg_ring_sector_perp", 'routine in <a href="com/pg/pg_ring_sector_perp.html">pg_ring_sector_perp.pro</a>', "pg_ring_sector_perp.pro", "", "pg_ring_sector_perp", "", "cddkxgdlonsamplewin_numrestoreslopep0xor_graphicscolorsilentnodskp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_rad.html", "pg_ring_sector_rad.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_rad.pro", "", "", " NAME: 	pg_ring_sector_rad   PURPOSE: 	Allows the user to select a ring sector by clicking and dragging. 	The sector is defined along lines of constant radius and longitude.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_ring_sector_rad(cd=cd, dkx=dkx)    ARGUMENTS:   INPUT:       NONE    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.  	   dkx:     Disk descriptor describing the ring.             gd:     Generic descriptor containing the above descriptors.        win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.         sample:     Sets the grid sampling in pixels.  Default is one.          slope:     This keyword allows the longitude to vary as a function                    of radius as: lon = slope*(rad - rad0).   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.         silent:     If set, messages are suppressed.          nodsk:     If set, image points will not be included in the output                    POINT.     OUTPUT:          NONE    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point and the user fields       'nrad' and 'nlon' giving the number of points in radius and longitude.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : pg_ring_sector -- J. Spitale ; 8/94  Modified: Haemmerle, 6/98  renamed -- Spitale; 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_rad.html#pg_ring_sector_rad", "pg_ring_sector_rad", 'routine in <a href="com/pg/pg_ring_sector_rad.html">pg_ring_sector_rad.pro</a>', "pg_ring_sector_rad.pro", "", "pg_ring_sector_rad", "", "cddkxgdlonsamplewin_numrestoreslopep0xor_graphicscolorsilentnodsk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_radlon.html", "pg_ring_sector_radlon.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_radlon.pro", "", "", " NAME: 	pg_ring_sector_radlon   PURPOSE: 	Constructs a ring sector outline for use with pg_profile_ring given 	radius and longitude bounds.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd = pg_ring_sector_radlon(cd=cd, dkx=dkx, rad, lon)    ARGUMENTS:   INPUT:       rad:	2-element array giving the lower and upper radial bounds 		for the sector.        lon:	2-elements array giving the lower and upper longitude bounds 		for the sector in radians.    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.  	   dkx:     Disk descriptor describing the ring.             gd:     Generic descriptor containnig the above descriptors.         sample:     Sets the grid sampling in pixels.  Default is one.           nlon:     Total number of samples in the longitude direction.                    Determined by the 'sample' keyword by default.           nrad:     Total number of samples in the radial direction.                    Determined by the 'sample' keyword by default.          slope:     This keyword allows the longitude to vary as a function                    of radius as: lon = slope*(rad - rad0).          nodsk:     If set, image points will not be included in the output                    POINT.    OUTPUT:          NONE    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point and the user fields       'nrad' and 'nlon' giving the number of points in radius and longitude.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : 	Spitale; 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_radlon.html#pg_ring_sector_radlon", "pg_ring_sector_radlon", 'routine in <a href="com/pg/pg_ring_sector_radlon.html">pg_ring_sector_radlon.pro</a>', "pg_ring_sector_radlon.pro", "", "pg_ring_sector_radlon", "", "cddkxgdsampleslopenodsknlonnradradlon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_rm_points.html", "pg_rm_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_rm_points.pro", "", "", " NAME: 	pg_rm_points    PURPOSE: 	xx    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_rm_points.html#pg_rm_points", "pg_rm_points", 'routine in <a href="com/pg/pg_rm_points.html">pg_rm_points.pro</a>', "pg_rm_points.pro", "", "pg_rm_points", "", "radiusptdxptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_select.html", "pg_select.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_select.pro", "", "", " NAME: 	pg_select    PURPOSE: 	Allows the user to select objects in an image using the mouse.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	region = pg_select(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing the image.    OUTPUT: NONE    KEYWORDS:   INPUT: 	silent: 	If set, turns off the notification that cursor 			movement is required.  	psym: 		Plotting symbol to use for plotting points.  	one:		If set, the routine will exit after selecting one point.  	number:		If set, points will be labeled with numbers.  	region:		If set, the user selects a region in the image. 			This is the default.  	points:		If set, the user selects points.    OUTPUT: 	cancelled:	Set if routine is caused to return by the cancel button.    RETURN: 	Array of subscripts of all image points which lie within the selected 	region.    STATUS: 	Complete    SEE ALSO: 	pg_trim    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_select.html#pg_select", "pg_select", 'routine in <a href="com/pg/pg_select.html">pg_select.pro</a>', "pg_select.pro", "", "pg_select", "", "silentregionpointsdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_select_bodies.html", "pg_select_bodies.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_select_bodies.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_select_bodies.html#pg_select_bodies", "pg_select_bodies", 'routine in <a href="com/pg/pg_select_bodies.html">pg_select_bodies.pro</a>', "pg_select_bodies.pro", "", "pg_select_bodies", "", "odddbxselect", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_select_points.html", "pg_select_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_select_points.pro", "", "", " NAME: 	pg_select_points    PURPOSE: 	Allows the user to select points in an image using the mouse.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	region = pg_select_points(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing the image.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noverbose: 	If set, turns off the notification that cursor 			movement is required.  	psym: 		Plotting symbol to use for the points.  	one:		If set, the routine will exit after selecting one point.  	number:		If set, each point will be labeled with a number.  	color:		Color to use for graphics overlays.  	ptd_output:	If set, a POINT object is returned instead 			of a points array.  	p0:		Initial point, instead of user selection.    OUTPUT: 	cancelled:	Set if routine is caused to return by the cancel button.    RETURN: 	Array of image points (2,n).    EXAMPLE:    To print the coordinates of each point as the user selects them, use:     can=0 & while(NOT can) do print, pg_select_points(dd, /one, /nov, can=can)    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_select_points.html#pg_select_points", "pg_select_points", 'routine in <a href="com/pg/pg_select_points.html">pg_select_points.pro</a>', "pg_select_points.pro", "", "pg_select_points", "", "psymnoverbosecolorp0onenumbercancelledptd_outputdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_select_region.html", "pg_select_region.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_select_region.pro", "", "", " NAME: 	pg_select_region    PURPOSE: 	Allows the user to select regions in an image using the mouse.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	region = pg_select_region(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing an image.    OUTPUT: NONE    KEYWORDS:   INPUT: 	silent: 	If set, turns off the notification that cursor 			movement is required.  	color:		Color to use for graphics overlays.   	p0:		First point of line.  If set, then the routine 			immediately begins to drag from that point until a 			button is released.  	select_button:	Index of button to use as the select button instead 			of the left button (1).  	end_button:	Index of button to use as the end button instead 			of the right button (4).  	cancel_button:	Index of mouse button to be used as a cancel 			button instead of left+middle, (3).  	points:		If set, the selected points are returned instead 			of enclosed indices.  	autoclose:	If set, the region is automaticaly closed when the 			end button is pressed.  	box:		If set, a rectanguar region is selected.     OUTPUT: NONE    RETURN: 	Array of subscripts of all image points which lie within the selected 	region.  -1 is returned if the cancel button is pressed.    STATUS: 	Complete    SEE ALSO: 	pg_trim    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_select_region.html#pg_select_region", "pg_select_region", 'routine in <a href="com/pg/pg_select_region.html">pg_select_region.pro</a>', "pg_select_region.pro", "", "pg_select_region", "", "colorselect_buttoncancel_buttonend_buttonsilentp0autoclosepointsnoclosedataboximage_ptsdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shadow.html", "pg_shadow.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shadow.pro", "", "", " NAME: 	pg_shadow    PURPOSE: 	Computes image coordinates of given inertial vectors projected onto 	surface of the given disks and globes with respect to the given 	observer.  Returns only the closest shadow point for each objoect 	point.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_shadow, object_ptd, cd=cd, ods=ods, dkx=dkx, gbx=gbx    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	gbx:	Array (n_globes, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.  	dkx:	Array (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of DISK.  	bx:	Array (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the sun descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	  All other keywords are passed directly to pg_shadow_globe 	  and pg_shadow_disk and are documented with those programs.    OUTPUT: NONE    RETURN: 	Array (n_disks,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be replaced by a new program that merges pg_shadow_globe and 	pg_shadow_disk.  The API for the new routine may be slightly different.    SEE ALSO: 	pg_shadow_disk, pg_shadow_globe, pg_shadow_points    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_shadow.html#pg_shadow", "pg_shadow", 'routine in <a href="com/pg/pg_shadow.html">pg_shadow.pro</a>', "pg_shadow.pro", "", "pg_shadow", "", "cdoddkxgbxbxddgdrevealclipnocullallbothbackshadowepsilonnosolveobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shadow_disk.html", "pg_shadow_disk.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shadow_disk.pro", "", "", " NAME: 	pg_shadow_disk    PURPOSE: 	Computes image coordinates of given inertial vectors projected onto 	surface of the given disk with respect to the given observer.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_shadow_disk(object_ptd, cd=cd, ods=ods, dkx=dkx)    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	dkx:	Array (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of DISK.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the sun descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	reveal:	 Normally, disks whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.  	clip:	 If set shadow points are cropped to within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.     backshadow:	 If set, only backshadows (shadows cast between the object and  		 observer) are returned.  	both:	 If set, both shadows and backshadows are returned.  	all:	 If set, all points are returned, even if invalid.  	epsilon: If set, shadow points that are closer than this amount 		 to the source point will be excluded.    OUTPUT: NONE    RETURN: 	Array (n_disks,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be obsolete.  This program will be merged with pg_shadow_globe 	to make a more general program, which will replace pg_shadow.    SEE ALSO: 	pg_shadow, pg_shadow_globe, pg_shadow_points    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_shadow_disk.html#pg_shadow_disk", "pg_shadow_disk", 'routine in <a href="com/pg/pg_shadow_disk.html">pg_shadow_disk.pro</a>', "pg_shadow_disk.pro", "", "pg_shadow_disk", "", "cdoddkxgbxddgdnocullbothrevealclipcullbackshadowallepsilonobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shadow_globe.html", "pg_shadow_globe.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shadow_globe.pro", "", "", " NAME: 	pg_shadow_globe    PURPOSE: 	Computes image coordinates of the given inertial vectors projected onto 	surface of the given globe with respect to the given observer.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_shadow_globe(object_ptd, cd=cd, od=od, gbx=gbx)    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	gbx:	Array (n_globes, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the sun descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	reveal:	 Normally, disks whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.  	clip:	 If set shadow points are cropped to within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.     backshadow:	 If set, only backshadows (shadows cast between the object and  		 observer) are returned.  	both:	 If set, both shadows and backshadows are returned.  	all:	 If set, all points are returned, even if invalid.  	epsilon: If set, shadow points that are closer than this amount 		 to the source point will be excluded.  	nosolve: If set, shadow points are not computed.    OUTPUT: NONE    RETURN: 	Array (n_globes,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be obsolete.  This program will be merged with pg_shadow_disk 	to make a more general program, which will replace pg_shadow.    SEE ALSO: 	pg_shadow, pg_shadow_disk, pg_shadow_points    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_shadow_globe.html#pg_shadow_globe", "pg_shadow_globe", 'routine in <a href="com/pg/pg_shadow_globe.html">pg_shadow_globe.pro</a>', "pg_shadow_globe.pro", "", "pg_shadow_globe", "", "cdodgbxddgdnocullbothrevealclipcullbackshadowallepsilonnosolveobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shadow_points.html", "pg_shadow_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shadow_points.pro", "", "", " NAME: 	pg_shadow_points    PURPOSE: 	Determines whether each given point is shadowed by the given object.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_shadow_points, object_ptd, cd=cd, od=od, bx=bx    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors 			to shadow.    OUTPUT: 	shadow_ptd:	Array of POINT containing the shadowed 			points.    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	bx:	Array (nbx, n_timesteps) of descriptors of objects 		which must be a subclass of BODY describing the shadowing 		bodies.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the sun descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the cd and bx inputs 		are taken from the corresponding fields of this structure 		instead of from those keywords.  	clip:	 If set shadow points are cropped to within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.     backshadow:	 If set, only backshadows (shadows cast between the object and  		 observer) are considered.  	both:	 If set, both shadows and backshadows are returned.  	edge:	 If set, only points near the edge of the shadow are returned.    OUTPUT: NONE    RETURN: NONE    SIDE EFFECTS: 	Shadowed points are flagged as invisible.    STATUS:     SEE ALSO: 	pg_shadow, pg_shadow_globe, pg_shadow_disk    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_shadow_points.html#pg_shadow_points", "pg_shadow_points", 'routine in <a href="com/pg/pg_shadow_points.html">pg_shadow_points.pro</a>', "pg_shadow_points.pro", "", "pg_shadow_points", "", "cdodbxgdnoculledgenosolveclipcullbothbackshadowobject_ptdshadow_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shift.html", "pg_shift.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shift.pro", "", "", " NAME: 	pg_shift    PURPOSE: 	Shifts the given image by a non-integer offset and adjusts the camera 	pointing accordingly.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_shift, dd, cd=cd, dxy    ARGUMENTS:   INPUT: 	dd:	Array of data descriptors giving images to shift.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array of camera descripors, one for each input image.  	dxy:	Array (2,np) of shifts for each input image.  	gd:	Generic descriptor containing the camera and body 		descriptors or an array of generic descriptors, one for each 		input image.     OUTPUT: NONE    SIDE EFFECTS: 	The given data and camera descriptors are modified: the images are 	shifted and the camera descriptor optic axes are changed accordingly.    STATUS: 	xx    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_shift.html#pg_shift", "pg_shift", 'routine in <a href="com/pg/pg_shift.html">pg_shift.pro</a>', "pg_shift.pro", "", "pg_shift", "", "cdgddddxy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_spikes.html", "pg_spikes.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_spikes.pro", "", "", " NAME: 	pg_spikes    PURPOSE: 	Locates spurious features like cosmic-ray hits.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_spikes(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing the image to be despiked.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	nsig:		Number of standard deviations above the local 			mean data value to flag for removal.  Default is 2.  	grad:		Minimum data value gradient to use when searching 			for clusters of hot pixels.  Default is 5.  	umask:		Byte image of the same size as the input image 			in which nonzero pixel values indicate locations 			where spikes should not be flagged.  	extend:		Number of pixels away from masked pixels before 			locations may be flagged as spikes.  	scale:		Typical size of objects to be flagged.  Default is 10.  	edge:		Regions closer than this to the edge of the image 			will be ignored.  Default is 10.  	local:		Multiplier that determines the width of the region 			over which the local mean and standard deviation are 			taken.  That width is local * scale.  Default is 5.  	allpix:		If set, all pixels in the spike region are returned 			instead of of the centroids.    OUTPUT: 	NONE    RETURN: 	POINT containing the detected spike points.    PROCEDURE:  	Clusters of hot pixels of size 'scale' are identified by looking 	for regions bounded by large gradients.  Each cluster is then 	examined for pixels whose values are larger than nsig standard 	deviations above the local mean.    STATUS: 	Complete    SEE ALSO: 	pg_despike, pg_mask    EXAMPLE: 	dd = dat_read(filename) 	spike_ptd = pg_spikes(dd) 	dd1 = pg_despike(dd, spike_ptd)    MODIFICATION HISTORY:  	Written by:	Spitale, 4/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_spikes.html#pg_spikes", "pg_spikes", 'routine in <a href="com/pg/pg_spikes.html">pg_spikes.pro</a>', "pg_spikes.pro", "", "pg_spikes", "", "nsiggradmaskumaskextendscaleedgelocalnohotallpixdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_station.html", "pg_station.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_station.pro", "", "", " NAME: 	pg_station    PURPOSE: 	Computes image points for given station descriptors.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	station_ptd = pg_station(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	std:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of STATION.  	gbx:	Array (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of GLOBE.  	dkx:	Array (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of DISK.  	bx:	Array (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of BODY, instead of gbx or dkx.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.     OUTPUT: NONE    RETURN: 	Array (n_objects) of POINT containing image points and 	the corresponding inertial vectors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_station.html#pg_station", "pg_station", 'routine in <a href="com/pg/pg_station.html">pg_station.pro</a>', "pg_station.pro", "", "pg_station", "", "cdstdgbxdkxbxddgdclipcull", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_stereo_split.html", "pg_stereo_split.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_stereo_split.pro", "", "", " NAME: 	pg_stereo_split    PURPOSE: 	Produces two camera descriptors whose positions are offset 	in the +/-x image directions for computing stereo overlays.     CATEGORY: 	NV/PG    CALLING SEQUENCE: 	cds = pg_stereo_split(cd=cd)    ARGUMENTS:   NONE    KEYWORDS:   INPUT: 	cd:		Camera descriptor to be split.  	separation:	stereo separation for the new camera descriptors.    OUTPUT: 	NONE    RETURN: 	Array containing two camera descriptors.    STATUS: 	xx    MODIFICATION HISTORY:  	Written by:	Spitale; 7/29/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_stereo_split.html#pg_stereo_split", "pg_stereo_split", 'routine in <a href="com/pg/pg_stereo_split.html">pg_stereo_split.pro</a>', "pg_stereo_split.pro", "", "pg_stereo_split", "", "cdseparation", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_str_limit_mag.html", "pg_str_limit_mag.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_str_limit_mag.pro", "", "", " NAME: 	pg_str_limit_mag    PURPOSE: 	Removes stars whose visual magnitude falls outside the given minimum 	and maximum values.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_str_limit_mag(sd, max=max, min=min)    ARGUMENTS:   INPUT: 	sd:	Array of star descriptors.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	max:	Maximum visual magnitude.  	min:	Minimum visual magnitude.    OUTPUT: 	NONE    RETURN: 	Array of star descriptors whose visual magnitudes fall within the 	specified range.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Haemmerle, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_str_limit_mag.html#pg_str_limit_mag", "pg_str_limit_mag", 'routine in <a href="com/pg/pg_str_limit_mag.html">pg_str_limit_mag.pro</a>', "pg_str_limit_mag.pro", "", "pg_str_limit_mag", "", "maxminsds", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_strip.html", "pg_strip.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_strip.pro", "", "", " NAME:        pg_strip    PURPOSE: 	Plots the portion of an image between two chosen points.    CATEGORY:        COM/PG    CALLING SEQUENCE:        pg_strip, im    ARGUMENTS:   INPUT:        im:		The two-dimensional array from which the 			plotted strip will be extracted.    OUTPUT:        NONE    KEYWORDS:   INPUT:        width:		An odd integer giving the width in pixels of the 			extracted strip (default=5).  This width is rebinned 			to a single pixel for plotting.  	nw:		When set, each plot is done in a new window.  	nomarks:	Suppresses the marks that show the locations of 			the chosen points, which are difficult to 			entirely erase.  	xs:		Specifies the x-dimension of the window, in pixels. 			Default is 400.  	ys:		Specifies the y-dimension of the window, in pixels. 			Default is 300.    OUTPUT:        NONE    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Tiscareno, 7/00   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_strip.html#pg_strip", "pg_strip", 'routine in <a href="com/pg/pg_strip.html">pg_strip.pro</a>', "pg_strip.pro", "", "pg_strip", "", "widthnwnomarksdevicexsysim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_sub_body.html", "pg_sub_body.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_sub_body.pro", "", "", " NAME: 	pg_sub_body    PURPOSE: 	Computes surface coordinates of sub-body point.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	range = pg_sub_body(gbx=gbx, bx=bx, gd=gd)    KEYWORD:   INPUT: 	gbx:	Array (n_objects, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.  	bx:	Array (n_objects, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.    OUTPUT: NONE    RETURN: 	Array (n_objects,3) of surface coordinate vectors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_sub_body.html#pg_sub_body", "pg_sub_body", 'routine in <a href="com/pg/pg_sub_body.html">pg_sub_body.pro</a>', "pg_sub_body.pro", "", "pg_sub_body", "", "gbxbxddgd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_threshold.html", "pg_threshold.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_threshold.pro", "", "", " NAME: 	pg_threshold    PURPOSE: 	Excludes points whose associated data lie outside of specified 	thresholds by setting the PTD_MASK_INVISIBLE.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_threshold, object_ptd, tag=tag, max=max, min=min    ARGUMENTS:   INPUT: 	object_ptd:	Array (n_objects) of POINT giving the 			points to be thresholded.    OUTPUT: 	object_ptd:	Modified array of POINT.  PTD_MASK_INVISIBLE 			is set for all excluded points.    KEYWORDS:   INPUT: 	tag:		Tag name for user data array to threshold.  Default 			is 'scan_cc'.  	max:		Upper threshold - values greater than this will be 			excluded.  	min:		Lower threshold - values less than this will be 			excluded.  	relative:	If set, the max and min arguments will be taken as 			fractions of the maximum value in the array.    OUTPUT: NONE    RETURN: NONE    SIDE EFFECTS: 	The input argument object_ptd is modified.    RESTRICTIONS: 	xx    PROCEDURE: 	The thresholding is performed by cc_threshold.  See the documentation 	for that routine for details.    EXAMPLE: 	xx    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_threshold.html#pg_threshold", "pg_threshold", 'routine in <a href="com/pg/pg_threshold.html">pg_threshold.pro</a>', "pg_threshold.pro", "", "pg_threshold", "", "tagminmaxrelativescan_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_tiepoints.html", "pg_tiepoints.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_tiepoints.pro", "", "", " NAME:        pg_tiepoints    PURPOSE:        Computes tiepoint image offsets.    CATEGORY:        NV/PG    CALLING SEQUENCE:        tie_ptd = pg_tiepoints(cd=cd, bx=bx, body_pts=body_pts, ptd)    ARGUMENTS:   INPUT:    ptd:         POINT containing the image points.   KEYWORDS:   INPUT:          cd:	Camera descriptor.           bx:	Body descriptor; can be GLOBE or RING.          gbx:	Globe descriptor for each globe in image instead of 		specifying bx.          dkx:	Disk descriptor for each globe in image instead of 		specifying bx.  	  gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	  dd:	Data descriptor containing a generic descriptor to use 		if gd not given.     body_pts:	Array of np column vectors giving the body-frame coordinates 		for each tie point.  If not given, then the given geometry 		is used to compute it.     OUTPUT:    body_pts: 	Array of np column vectors giving the body-frame coordinates 		for each tie point.  If this keyword is given as an input, 		then no output is generated.   EXAMPLE:   1) Manually select a set of tiepoints in a set of images and fit      a pointing offset:  	ndd = n_elements(dd) 	for i=0, ndd-1 do ptd[i] = pg_select_points(dd[i], /ptd)  	body_pts = 0 	for i=0, ndd-1 do $ 	 begin &$ 	  tie_ptd = pg_tiepoints(cd=cd[i], bx=pd[i], ptd[i], body_pts=body_pts) &$ 	  tpcoeff = pg_ptscan_coeff(tie_ptd, fix=[2]) &$ 	  dxy = pg_fit(tpcoeff) &$ 	  pg_repoint, dxy, 0d, cd=cd[i] &$ 	 end       In the above example, the first image is used as a reference;      because body_pts is initially undefined, those points are computed      for the first image, but not subsequently.  Instead, the subsequent      images will have a nonzero offset stored in the tie_ptd structure,      which are then used by pg_ptscan_coeff to compute fit coefficients.    STATUS:        Complete    MODIFICATION HISTORY:        Written by:     Spitale, 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_tiepoints.html#pg_tiepoints", "pg_tiepoints", 'routine in <a href="com/pg/pg_tiepoints.html">pg_tiepoints.pro</a>', "pg_tiepoints.pro", "", "pg_tiepoints", "", "cdbxgbxdkxddgdbody_ptsdxyptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_trim.html", "pg_trim.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_trim.pro", "", "", " NAME: 	pg_trim    PURPOSE: 	For each given object, excludes points contained in the given region 	by setting the PTD_MASK_INVISIBLE.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_trim, dd, object_ptd, region    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing the image.  	object_ptd:	Array (n_objects) of POINT containing the 			image points to be trimmed.  	region:		Array of subscripts of image points to be trimmed.    OUTPUT: 	object_ptd:	The input points are be modified on return.    KEYWORDS:   INPUT: 	mask:		Mask to use instead of PTD_MASK_INVISIBLE.  	off:		If set, the masked flag bit will be turned off.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pg_select    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_trim.html#pg_trim", "pg_trim", 'routine in <a href="com/pg/pg_trim.html">pg_trim.pro</a>', "pg_trim.pro", "", "pg_trim", "", "maskoffddobject_ptdregion", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/phase_correction.html", "phase_correction.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "phase_correction.pro", "", "", " NAME:        phase_correction    PURPOSE: 	Assuming body gbx is a sphere, this routine computes the correction 	in pixels needed to obtain its true image center given a measurement 	of its center of light.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        dxy = phase_correction(cd, gbx, sund)    ARGUMENTS:   INPUT: 	cd:	Any subclass of DISK.  	gbx:	Any subclass of GLOBE.  	sund:	STAR descriptor representing the sun.    OUTPUT:  NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2) giving the phase correction offset.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/phase_correction.html#phase_correction", "phase_correction", 'routine in <a href="obj/tools/phase_correction.html">phase_correction.pro</a>', "phase_correction.pro", "", "phase_correction", "", "cdgbxsund", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/pht/pht_angles.html", "pht_angles.pro", '.pro file in <a href="obj/tools/pht/dir-overview.html">obj/tools/pht/ directory</a>', "pht_angles.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pht/pht_angles.html#pht_angles", "pht_angles", 'routine in <a href="obj/tools/pht/pht_angles.html">pht_angles.pro</a>', "pht_angles.pro", "", "pht_angles", "", "inertialemmincgvalidbody_ptsnorthimage_ptscdbxsund", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/pht/pht_lamb.html", "pht_lamb.pro", '.pro file in <a href="obj/tools/pht/dir-overview.html">obj/tools/pht/ directory</a>', "pht_lamb.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pht/pht_lamb.html#pht_lamb", "pht_lamb", 'routine in <a href="obj/tools/pht/pht_lamb.html">pht_lamb.pro</a>', "pht_lamb.pro", "", "pht_lamb", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/pht/pht_lunar.html", "pht_lunar.pro", '.pro file in <a href="obj/tools/pht/dir-overview.html">obj/tools/pht/ directory</a>', "pht_lunar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pht/pht_lunar.html#pht_lunar", "pht_lunar", 'routine in <a href="obj/tools/pht/pht_lunar.html">pht_lunar.pro</a>', "pht_lunar.pro", "", "pht_lunar", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/pht/pht_lunar_lambert.html", "pht_lunar_lambert.pro", '.pro file in <a href="obj/tools/pht/dir-overview.html">obj/tools/pht/ directory</a>', "pht_lunar_lambert.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pht/pht_lunar_lambert.html#pht_lunar_lambert", "pht_lunar_lambert", 'routine in <a href="obj/tools/pht/pht_lunar_lambert.html">pht_lunar_lambert.pro</a>', "pht_lunar_lambert.pro", "", "pht_lunar_lambert", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/pht/pht_minneart.html", "pht_minneart.pro", '.pro file in <a href="obj/tools/pht/dir-overview.html">obj/tools/pht/ directory</a>', "pht_minneart.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pht/pht_minneart.html#pht_minneart", "pht_minneart", 'routine in <a href="obj/tools/pht/pht_minneart.html">pht_minneart.pro</a>', "pht_minneart.pro", "", "pht_minneart", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/pht/pht_phase_corr.html", "pht_phase_corr.pro", '.pro file in <a href="obj/tools/pht/dir-overview.html">obj/tools/pht/ directory</a>', "pht_phase_corr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pht/pht_phase_corr.html#pht_phase_corr", "pht_phase_corr", 'routine in <a href="obj/tools/pht/pht_phase_corr.html">pht_phase_corr.pro</a>', "pht_phase_corr.pro", "", "pht_phase_corr", "", "fnparmgg1", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/pht/pht_phase_henyey_greenstein.html", "pht_phase_henyey_greenstein.pro", '.pro file in <a href="obj/tools/pht/dir-overview.html">obj/tools/pht/ directory</a>', "pht_phase_henyey_greenstein.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pht/pht_phase_henyey_greenstein.html#pht_phase_henyey_greenstein", "pht_phase_henyey_greenstein", 'routine in <a href="obj/tools/pht/pht_phase_henyey_greenstein.html">pht_phase_henyey_greenstein.pro</a>', "pht_phase_henyey_greenstein.pro", "", "pht_phase_henyey_greenstein", "", "gparm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/pht/pht_phase_isotropic.html", "pht_phase_isotropic.pro", '.pro file in <a href="obj/tools/pht/dir-overview.html">obj/tools/pht/ directory</a>', "pht_phase_isotropic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pht/pht_phase_isotropic.html#pht_phase_isotropic", "pht_phase_isotropic", 'routine in <a href="obj/tools/pht/pht_phase_isotropic.html">pht_phase_isotropic.pro</a>', "pht_phase_isotropic.pro", "", "pht_phase_isotropic", "", "gparm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/pht/pht_refl_corr.html", "pht_refl_corr.pro", '.pro file in <a href="obj/tools/pht/dir-overview.html">obj/tools/pht/ directory</a>', "pht_refl_corr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pht/pht_refl_corr.html#pht_refl_corr", "pht_refl_corr", 'routine in <a href="obj/tools/pht/pht_refl_corr.html">pht_refl_corr.pro</a>', "pht_refl_corr.pro", "", "pht_refl_corr", "", "fnparmmumu0mu1mu01", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/pht/pht_refl_lunar.html", "pht_refl_lunar.pro", '.pro file in <a href="obj/tools/pht/dir-overview.html">obj/tools/pht/ directory</a>', "pht_refl_lunar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pht/pht_refl_lunar.html#pht_refl_lunar", "pht_refl_lunar", 'routine in <a href="obj/tools/pht/pht_refl_lunar.html">pht_refl_lunar.pro</a>', "pht_refl_lunar.pro", "", "pht_refl_lunar", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/pht/pht_refl_lunar_lambert.html", "pht_refl_lunar_lambert.pro", '.pro file in <a href="obj/tools/pht/dir-overview.html">obj/tools/pht/ directory</a>', "pht_refl_lunar_lambert.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pht/pht_refl_lunar_lambert.html#pht_refl_lunar_lambert", "pht_refl_lunar_lambert", 'routine in <a href="obj/tools/pht/pht_refl_lunar_lambert.html">pht_refl_lunar_lambert.pro</a>', "pht_refl_lunar_lambert.pro", "", "pht_refl_lunar_lambert", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/pht/pht_refl_minneart.html", "pht_refl_minneart.pro", '.pro file in <a href="obj/tools/pht/dir-overview.html">obj/tools/pht/ directory</a>', "pht_refl_minneart.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pht/pht_refl_minneart.html#pht_refl_minneart", "pht_refl_minneart", 'routine in <a href="obj/tools/pht/pht_refl_minneart.html">pht_refl_minneart.pro</a>', "pht_refl_minneart.pro", "", "pht_refl_minneart", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/pixel_grid.html", "pixel_grid.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "pixel_grid.pro", "", "", " NAME:        pixel_grid    PURPOSE: 	Generates grid lines aligned with the image window.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        grid_pts = pixel_grid()    ARGUMENTS:   INPUT: NONE    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	spacing:	Distance in pixels between grid lines.  	np:	Number of points on each grid line.  	wnum:	Window number for determining grid size.  If not set, 		the current grapics window is used.    OUTPUT: NONE    RETURN:        Angle in radians.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pixel_grid.html#pixel_grid", "pixel_grid", 'routine in <a href="obj/tools/pixel_grid.html">pixel_grid.pro</a>', "pixel_grid.pro", "", "pixel_grid", "", "spacingnpwnum", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/plot_inertial.html", "plot_inertial.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "plot_inertial.pro", "", "", " NAME:        plot_inertial    PURPOSE:        Plots inertial vectors on a camera image.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        plot_inertial, cd, v, r    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	v:	Inertial vectors giving origins of vectors to plot.  If only one 		vector, this will be used as the origin for all of the plotted 		vectors.  	r:	Inertial vectors giving the vectors to plot, starting at 		the given origins.    OUTPUT:        NONE   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale; 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/plot_inertial.html#plot_inertial", "plot_inertial", 'routine in <a href="obj/tools/plot_inertial.html">plot_inertial.pro</a>', "plot_inertial.pro", "", "plot_inertial", "", "colorthicklabelscd_vr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/plt/plt_assign.html", "plt_assign.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_assign.pro", "", "", " NAME: 	plt_assign    PURPOSE: 	Replaces fields in a PLANET object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/PLT    CALLING SEQUENCE: 	plt_assign, pd, <keywords>=<values>    ARGUMENTS:   INPUT: 	pd:		PLANET object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	PLANET fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	plt_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/plt_assign.html#plt_assign", "plt_assign", 'routine in <a href="obj/plt/plt_assign.html">plt_assign.pro</a>', "plt_assign.pro", "", "plt_assign", "", "noeventxd@plt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/plt/plt_create_descriptors.html", "plt_create_descriptors.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_create_descriptors.pro", "", "", " NAME:        plt_create_descriptors    PURPOSE: 	Init method for the PLANET class.    CATEGORY:        NV/LIB/PLT    CALLING SEQUENCE:        pd = plt_create_descriptors(n)    ARGUMENTS:   INPUT:        n:      Number of planet descriptors.    OUTPUT:        NONE    KEYWORDS:   INPUT: 	pd:	Planet descriptor(s) to initialize, instead of creating new ones.  	gbd:	Globe descriptor(s) to pass to glb_create_descriptors.  	sld:	Solid descriptor(s) to pass to sld_create_descriptors.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.    OUTPUT: NONE   RETURN:        An array (n) of planet descriptors.   STATUS:        Completed.    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/plt_create_descriptors.html#plt_create_descriptors", "plt_create_descriptors", 'routine in <a href="obj/plt/plt_create_descriptors.html">plt_create_descriptors.pro</a>', "plt_create_descriptors.pro", "", "plt_create_descriptors", "", "crdbdsldgbdpdn@plt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/plt/plt_evolve.html", "plt_evolve.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_evolve.pro", "", "", " NAME: 	plt_evolve    PURPOSE: 	Computes new planet descriptors at the given time offsets from the 	given planet descriptors using the taylor series expansion 	corresponding to the derivatives contained in the given planet 	descriptor.    CATEGORY: 	NV/LIB/PLT    CALLING SEQUENCE: 	pdt = plt_evolve(px, dt)    ARGUMENTS:   INPUT: 	px:	 Any subclass of PLANET.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, derivatives will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN: 	Array (npd,ndt) of newly allocated descriptors, of class PLANET, 	evolved by time dt, where npd is the number of px, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/plt_evolve.html#plt_evolve", "plt_evolve", 'routine in <a href="obj/plt/plt_evolve.html">plt_evolve.pro</a>', "plt_evolve.pro", "", "plt_evolve", "", "nodvcopypddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/plt/plt_query.html", "plt_query.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_query.pro", "", "", " NAME: 	plt_query    PURPOSE: 	Returns the fields associated with a PLANET object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/PLT    CALLING SEQUENCE: 	plt_query, pd, <keywords>=<values>    ARGUMENTS:   INPUT: 	pd:	PLANET object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	PLANET object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/plt_query.html#plt_query", "plt_query", 'routine in <a href="obj/plt/plt_query.html">plt_query.pro</a>', "plt_query.pro", "", "plt_query", "", "conditioncatnoeventxd@plt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/plt/plt_replicate.html", "plt_replicate.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_replicate.pro", "", "", " NAME: 	plt_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/PLT    CALLING SEQUENCE: 	pds = plt_replicate(pd, dim)    ARGUMENTS:   INPUT: 	pd:	 Planet descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/plt_replicate.html#plt_replicate", "plt_replicate", 'routine in <a href="obj/plt/plt_replicate.html">plt_replicate.pro</a>', "plt_replicate.pro", "", "plt_replicate", "", "pddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_apply_condition.html", "pnt_apply_condition.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_apply_condition.pro", "", "", " NAME: 	pnt_apply_condition    PURPOSE: 	Selects point in POINT structures based on a given condition structure.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	indices = _pnt_apply_condition(_ps, condition)    ARGUMENTS:   INPUT: 	ptd:		Points object.  	condition:	Condition structure to compare against the flags 			contained in _ps.  			The condition structure is organized as follows: 			  field	   values 			  ----------------------------------------------------- 			  mask:	   PTD_MASK_INVISIBLE, etc. (see pnt_include.pro) 			  state:   PTD_TRUE, PTD_FALSE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Condition structure corresponding to the given keyword.    STATUS: 	Complete    SEE ALSO: pnt_points, pnt_vectors, pnt_data    MODIFICATION HISTORY:   	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_apply_condition.html#pnt_apply_condition", "pnt_apply_condition", 'routine in <a href="obj/pnt/pnt_apply_condition.html">pnt_apply_condition.pro</a>', "pnt_apply_condition.pro", "", "pnt_apply_condition", "", "ptdcondition", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_assign.html", "pnt_assign.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_assign.pro", "", "", " NAME: 	pnt_assign    PURPOSE: 	Replaces fields in a POINT object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_assign, ptd, <keywords>=<values>    ARGUMENTS:   INPUT: 	ptd:		POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	POINT fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_assign_*     MODIFICATION HISTORY:  	Written by:	Spitale		12/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_assign.html#pnt_assign", "pnt_assign", 'routine in <a href="obj/pnt/pnt_assign.html">pnt_assign.pro</a>', "pnt_assign.pro", "", "pnt_assign", "", "noeventxd@pnt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_assoc_xd.html", "pnt_assoc_xd.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_assoc_xd.pro", "", "", " NAME: 	pnt_assoc_xd    PURPOSE: 	Returns the associated descriptor for a CORE object.    CATEGORY: 	NV/SYS/PNT    CALLING SEQUENCE: 	assoc_xd = pnt_assoc_xd(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The associated descriptor for the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_assoc_xd     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_assoc_xd.html#pnt_assoc_xd", "pnt_assoc_xd", 'routine in <a href="obj/pnt/pnt_assoc_xd.html">pnt_assoc_xd.pro</a>', "pnt_assoc_xd.pro", "", "pnt_assoc_xd", "", "noeventptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_compress.html", "pnt_compress.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_compress.pro", "", "", " NAME: 	pnt_compress    PURPOSE: 	Compresses many POINT objects into one.  Arrays are concatenated 	in the nv/np directions unless /nt is specified.  Point-by-point data 	arrays must be identical.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	new_ptd = pnt_compress(ptd)    ARGUMENTS:   INPUT: 	ptd:	Array of POINT objects.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nt:		If given, arrays are concatenated in the nt dimension. 			this requires that all input arrays have the same number 			of points (nv/np), and only one element in the nt 			direction.  	pptd:		If given, this points object is used to store the 			result, rather than allocating a new one.    OUTPUT: NONE    RETURN: 	POINT object containing the concatenated data.     MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_compress   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_compress.html#pnt_compress", "pnt_compress", 'routine in <a href="obj/pnt/pnt_compress.html">pnt_compress.pro</a>', "pnt_compress.pro", "", "pnt_compress", "", "ntpptdptd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_condition.html", "pnt_condition.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_condition.pro", "", "", " NAME: 	pnt_condition    PURPOSE: 	Returns predefined condition structures for various common situations.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	condition = pnt_condition(</visible | /invisible | /select|...>)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	condition:	If a condition structure is given as in input, it 			is returned.     *** The following keywords are defined in pnt_condition_keywords.include ***  	visible:	Returns a condition structure corresponding to 			points whose visible flag is not set.  	invisible:	Returns a condition structure corresponding to 			points whose visible flag is set.  	selected:	Returns a condition structure corresponding to 			points whose select flag is set.  	unselected:	Returns a condition structure corresponding to 			points whose select flag is not set.    OUTPUT: NONE    RETURN: 	Condition structure corresponding to the given keyword.    STATUS: 	Complete    SEE ALSO: pnt_points, pnt_vectors, pnt_data    MODIFICATION HISTORY:   	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_condition.html#pnt_condition_set", "pnt_condition_set", 'routine in <a href="obj/pnt/pnt_condition.html">pnt_condition.pro</a>', "pnt_condition.pro", "", "pnt_condition_set", "", "statemaskflag", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_condition.html#pnt_condition_unset", "pnt_condition_unset", 'routine in <a href="obj/pnt/pnt_condition.html">pnt_condition.pro</a>', "pnt_condition.pro", "", "pnt_condition_unset", "", "statemaskflag", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_condition.html#pnt_condition", "pnt_condition", 'routine in <a href="obj/pnt/pnt_condition.html">pnt_condition.pro</a>', "pnt_condition.pro", "", "pnt_condition", "", "condition@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_create_descriptors.html", "pnt_create_descriptors.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_create_descriptors.pro", "", "", " NAME: 	pnt_create_descriptors    PURPOSE: 	Creates and initializes a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	ps = pnt_create_descriptors()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	name:		Data set name.  	desc:		Data set description.  	input:		Description of input data used to produce these points.  	points:		Image points.  	vectors:	Inertial vectors.  	flags:		Point-by-point flag array.  	data:		Point-by-point data array.  	tags:		Tags for point-by-point data.      OUTPUT: NONE    RETURN: 	Newly created and initialized POINT object.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_create_descriptors.html#pnt_create_descriptors", "pnt_create_descriptors", 'routine in <a href="obj/pnt/pnt_create_descriptors.html">pnt_create_descriptors.pro</a>', "pnt_create_descriptors.pro", "", "pnt_create_descriptors", "", "crdptdn@pnt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_cull.html", "pnt_cull.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_cull.pro", "", "", " NAME: 	pnt_cull    PURPOSE: 	Cleans out an array of POINT objects by removing invisible points 	and/or empty POINT objects.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	new_ptd = pnt_cull(ptd)    ARGUMENTS:   INPUT: 	ptd:	Array of POINT objects.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  If this 			case, pnt_cull removes objects for which the specified 			conditions return no points.  	nofree:		If set, invalid POINT object are not freed.    OUTPUT: NONE    RETURN: 	Array POINT objects, or 0 if all were empty.     MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_cull   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_cull.html#pnt_cull", "pnt_cull", 'routine in <a href="obj/pnt/pnt_cull.html">pnt_cull.pro</a>', "pnt_cull.pro", "", "pnt_cull", "", "nofreecondition_ptd@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_data.html", "pnt_data.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_data.pro", "", "", " NAME: 	pnt_data    PURPOSE: 	Returns the point-by-point data associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	data = pnt_data(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.  If multiple POINT object are given, 		and /cat is not specified, only pointers to the arrays are 		returned, and conditions and tags are not applied.    OUTPUT: NONE    KEYWORDS:   INPUT: 	tags:	If given, data arrays are returned only for these tags, 		and are arranged in this order.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	sample:		Sampling interval in the nv direction.  Default is 1.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The point-by-point data associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_data     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_data.html#pnt_data", "pnt_data", 'routine in <a href="obj/pnt/pnt_data.html">pnt_data.pro</a>', "pnt_data.pro", "", "pnt_data", "", "tagssamplecatconditionnoeventptd0@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_desc.html", "pnt_desc.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_desc.pro", "", "", " NAME: 	pnt_desc    PURPOSE: 	Returns the description associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	desc = pnt_desc(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The description associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_desc     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_desc.html#pnt_desc", "pnt_desc", 'routine in <a href="obj/pnt/pnt_desc.html">pnt_desc.pro</a>', "pnt_desc.pro", "", "pnt_desc", "", "noeventptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_explode.html", "pnt_explode.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_explode.pro", "", "", " NAME: 	pnt_explode    PURPOSE: 	Explodes a POINT object into single-point objects.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	xptd = pnt_explode(ptd)    ARGUMENTS:   INPUT: 	ptd:		POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	n:	If given, new objects will have nv = n instead of nv = 1. 		nv must be divisible by n.    OUTPUT: NONE    RETURN: 	Array (nv/n x nt) of POINT objects, each containing a n points.    STATUS: 	Complete      MODIFICATION HISTORY:  	Adapted from pgs_explode:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_explode.html#pnt_explode", "pnt_explode", 'routine in <a href="obj/pnt/pnt_explode.html">pnt_explode.pro</a>', "pnt_explode.pro", "", "pnt_explode", "", "nptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_explode.html#__pnt_explode", "__pnt_explode", 'routine in <a href="obj/pnt/pnt_explode.html">pnt_explode.pro</a>', "pnt_explode.pro", "", "__pnt_explode", "", "nptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_flags.html", "pnt_flags.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_flags.pro", "", "", " NAME: 	pnt_flags    PURPOSE: 	Returns the flags associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	flags = pnt_flags(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.  If multiple POINT objects are given, 		and /cat is not speciied, only pointers to the arrays are 		returned, and conditions and tags are not applied.    OUTPUT: NONE    KEYWORDS:   INPUT: 	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	sample:		Sampling interval in the nv direction.  Default is 1.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The flags associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_flags     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_flags.html#pnt_flags", "pnt_flags", 'routine in <a href="obj/pnt/pnt_flags.html">pnt_flags.pro</a>', "pnt_flags.pro", "", "pnt_flags", "", "samplecatconditionnoeventptd0@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_include.html", "pnt_include.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_include.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_input.html", "pnt_input.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_input.pro", "", "", " NAME: 	pnt_input    PURPOSE: 	Returns the input description associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	input = pnt_input(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The input description associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_input     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_input.html#pnt_input", "pnt_input", 'routine in <a href="obj/pnt/pnt_input.html">pnt_input.pro</a>', "pnt_input.pro", "", "pnt_input", "", "noeventptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_nt.html", "pnt_nt.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_nt.pro", "", "", " NAME: 	pnt_nt    PURPOSE: 	Returns the nt dimension of a POINT object.    CATEGORY: 	nt/SYS/PS    CALLING SEQUENCE: 	nt = pnt_nt(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The nt dimensions of the POINT object.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_nt.html#pnt_nt", "pnt_nt", 'routine in <a href="obj/pnt/pnt_nt.html">pnt_nt.pro</a>', "pnt_nt.pro", "", "pnt_nt", "", "conditionnoeventptd@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_nv.html", "pnt_nv.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_nv.pro", "", "", " NAME: 	pnt_nv    PURPOSE: 	Returns the nv dimension of a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	nv = pnt_nv(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The nv dimensions of the POINT object.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_nv.html#pnt_nv", "pnt_nv", 'routine in <a href="obj/pnt/pnt_nv.html">pnt_nv.pro</a>', "pnt_nv.pro", "", "pnt_nv", "", "conditionnoeventptd@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_offset.html", "pnt_offset.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_offset.pro", "", "", " NAME: 	pnt_offset    PURPOSE: 	Offsets points in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_offset, ptd, offset    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	offset:		Offset to apply.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE.     MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_offset   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_offset.html#pnt_offset", "pnt_offset", 'routine in <a href="obj/pnt/pnt_offset.html">pnt_offset.pro</a>', "pnt_offset.pro", "", "pnt_offset", "", "noeventptdoffset", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_points.html", "pnt_points.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_points.pro", "", "", " NAME: 	pnt_points    PURPOSE: 	Returns the points associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	points = pnt_points(ptd)    ARGUMENTS: 	ptd:	POINT object.  If multiple POINT objects are given, 		and /cat is not speciied, only pointers to the arrays are 		returned, and conditions and tags are not applied.     OUTPUT: NONE    KEYWORDS:   INPUT: 	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from multiple input objects are 			concatenated.  	sample:		Sampling interval in the nv direction.  Default is 1.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: 	segments:	Subscripts in the output array denoting segments in the 			(assumed) continuous curve due to the point selection 			conditions.    RETURN: 	The points associated with the POINT object, or zero.    STATUS: 	Complete    SEE ALSO: 	pnt_set_points     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_points.html#pnt_points", "pnt_points", 'routine in <a href="obj/pnt/pnt_points.html">pnt_points.pro</a>', "pnt_points.pro", "", "pnt_points", "", "segmentssamplecatconditionnoeventptd0@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_query.html", "pnt_query.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_query.pro", "", "", " NAME: 	pnt_query    PURPOSE: 	Returns the fields associated with a POINT object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_query, ptd, <keywords>=<values>    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	POINT object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 12/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_query.html#pnt_query", "pnt_query", 'routine in <a href="obj/pnt/pnt_query.html">pnt_query.pro</a>', "pnt_query.pro", "", "pnt_query", "", "conditioncatnoeventxd@pnt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_read.html", "pnt_read.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_read.pro", "", "", " NAME:  	pnt_read    PURPOSE:  	Reads a POINT file.    CATEGORY:  	NV/OBJ/PNT    CALLING SEQUENCE:  	ptd = pnt_read(filename)    ARGUMENTS:   INPUT:  	filename: Name of the file to read.    OUTPUT: NONE    KEYWORDS:   INPUT:  	bin:		If set, a binary POINT file is read;  			not currently implemented.   	visible:	If set, only visible points are returned.   	no_ptd:		If set, POINT objects are not created.    OUTPUT:  	name: 		Array names.   	desc:  		Array descriptions.   	flags:  	Array flags   	points:  	Point arrays.   	vectors: 	Vector arrays.    RETURN:  	Normally, this routine returns a POINT containing  	the points from the file.  If no_ptd is set, then 0 is returned  	instead.    SEE ALSO: 	pnt_write    MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_read_ps   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_read.html#pnt_read_0", "pnt_read_0", 'routine in <a href="obj/pnt/pnt_read.html">pnt_read.pro</a>', "pnt_read.pro", "", "pnt_read_0", "", "visiblenamedescflagspointsvectorscommentfilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_read.html#psrpnt_get_next", "psrpnt_get_next", 'routine in <a href="obj/pnt/pnt_read.html">pnt_read.pro</a>', "pnt_read.pro", "", "psrpnt_get_next", "", "stopstatusnbinbufunittoken", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_read.html#pnt_read_1", "pnt_read_1", 'routine in <a href="obj/pnt/pnt_read.html">pnt_read.pro</a>', "pnt_read.pro", "", "pnt_read_1", "", "visiblenamedescflagspointsvectorscommentversiondatatagsfilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_read.html#pnt_read_2", "pnt_read_2", 'routine in <a href="obj/pnt/pnt_read.html">pnt_read.pro</a>', "pnt_read.pro", "", "pnt_read_2", "", "visiblenamedescflagspointsvectorscommentversiondatatagsfilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_read.html#pnt_read", "pnt_read", 'routine in <a href="obj/pnt/pnt_read.html">pnt_read.pro</a>', "pnt_read.pro", "", "pnt_read", "", "binnamedescflagspointsvectorscommentdatatagsfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_scale.html", "pnt_scale.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_scale.pro", "", "", " NAME: 	pnt_scale    PURPOSE: 	Scales points in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_scale, ptd, scale    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	scale:		Scale to apply.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE.     MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_scale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_scale.html#pnt_scale", "pnt_scale", 'routine in <a href="obj/pnt/pnt_scale.html">pnt_scale.pro</a>', "pnt_scale.pro", "", "pnt_scale", "", "noeventptdscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_assoc_xd.html", "pnt_set_assoc_xd.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_assoc_xd.pro", "", "", " NAME: 	pnt_set_assoc_xd    PURPOSE: 	Replaces the assoc_xd field in a CORE object.    CATEGORY: 	NV/SYS/PNT    CALLING SEQUENCE: 	pnt_set_assoc_xd, ptd, assoc_xd    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	assoc_xd:	New assoc_xd.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_assoc_xd     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_assoc_xd.html#pnt_set_assoc_xd", "pnt_set_assoc_xd", 'routine in <a href="obj/pnt/pnt_set_assoc_xd.html">pnt_set_assoc_xd.pro</a>', "pnt_set_assoc_xd.pro", "", "pnt_set_assoc_xd", "", "noeventptdassoc_xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_data.html", "pnt_set_data.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_data.pro", "", "", " NAME: 	pnt_set_data    PURPOSE: 	Replaces the point-by-point data in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_data, ptd, data    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	data:		New point-by-point data array.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.  	tags:	If given, data arrays are replaced only for these tags, and in 		this order.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_data     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_data.html#pnt_set_data", "pnt_set_data", 'routine in <a href="obj/pnt/pnt_set_data.html">pnt_set_data.pro</a>', "pnt_set_data.pro", "", "pnt_set_data", "", "tagsnoeventptdnew_data", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_desc.html", "pnt_set_desc.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_desc.pro", "", "", " NAME: 	pnt_set_desc    PURPOSE: 	Replaces the description field in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_desc, ptd, desc    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	desc:		New description.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_desc     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_desc.html#pnt_set_desc", "pnt_set_desc", 'routine in <a href="obj/pnt/pnt_set_desc.html">pnt_set_desc.pro</a>', "pnt_set_desc.pro", "", "pnt_set_desc", "", "noeventptddesc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_flags.html", "pnt_set_flags.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_flags.pro", "", "", " NAME: 	pnt_set_flags    PURPOSE: 	Replaces the flags in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_flags, ptd, flags    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	flags:		New flags array.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_flags     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_flags.html#pnt_set_flags", "pnt_set_flags", 'routine in <a href="obj/pnt/pnt_set_flags.html">pnt_set_flags.pro</a>', "pnt_set_flags.pro", "", "pnt_set_flags", "", "noeventptdflags", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_input.html", "pnt_set_input.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_input.pro", "", "", " NAME: 	pnt_set_input    PURPOSE: 	Replaces the input description field in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_input, ptd, input    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	input:		New input description.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_input     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_input.html#pnt_set_input", "pnt_set_input", 'routine in <a href="obj/pnt/pnt_set_input.html">pnt_set_input.pro</a>', "pnt_set_input.pro", "", "pnt_set_input", "", "noeventptdinput", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_points.html", "pnt_set_points.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_points.pro", "", "", " NAME: 	pnt_set_points    PURPOSE: 	Replaces the points in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_points, ptd, points    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	points:		New points array.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_points     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_points.html#pnt_set_points", "pnt_set_points", 'routine in <a href="obj/pnt/pnt_set_points.html">pnt_set_points.pro</a>', "pnt_set_points.pro", "", "pnt_set_points", "", "noeventptdpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_tags.html", "pnt_set_tags.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_tags.pro", "", "", " NAME: 	pnt_set_tags    PURPOSE: 	Replaces the tags in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_tags, ptd, tags    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	tags:		New tags array.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_tags     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_tags.html#pnt_set_tags", "pnt_set_tags", 'routine in <a href="obj/pnt/pnt_set_tags.html">pnt_set_tags.pro</a>', "pnt_set_tags.pro", "", "pnt_set_tags", "", "noeventptdtags", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_vectors.html", "pnt_set_vectors.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_vectors.pro", "", "", " NAME: 	pnt_set_vectors    PURPOSE: 	Replaces the vectors in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_vectors, ptd, vectors    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	vectors:	New vectors array.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_vectors     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_vectors.html#pnt_set_vectors", "pnt_set_vectors", 'routine in <a href="obj/pnt/pnt_set_vectors.html">pnt_set_vectors.pro</a>', "pnt_set_vectors.pro", "", "pnt_set_vectors", "", "noeventptdvectors", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_tags.html", "pnt_tags.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_tags.pro", "", "", " NAME: 	pnt_tags    PURPOSE: 	Returns the tags associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	tags = pnt_tags(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The tags associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_tags     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_tags.html#pnt_tags", "pnt_tags", 'routine in <a href="obj/pnt/pnt_tags.html">pnt_tags.pro</a>', "pnt_tags.pro", "", "pnt_tags", "", "noeventptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_template.html", "pnt_template.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_template.pro", "", "", " NAME: 	pnt_template    PURPOSE: 	Creates a new POINT using an existing one as a template.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	ptd = pnt_template(ptd0)    ARGUMENTS:   INPUT: 	ptd0:		POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	New POINT with array fields left blank.    STATUS: 	Complete      MODIFICATION HISTORY:  	Written:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_template.html#pnt_template", "pnt_template", 'routine in <a href="obj/pnt/pnt_template.html">pnt_template.pro</a>', "pnt_template.pro", "", "pnt_template", "", "ptd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_test.html", "pnt_test.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_test.pro", "", "", " NAME: 	pnt_test    PURPOSE: 	Assesses the validity of a single POINT object.  This function 	differs from pnt_valid in that it simply returns true or false, rather 	than a list of validity flags.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	test = pnt_test(ptd)    ARGUMENTS:   INPUT: 	ptd:	Array of POINT objects.    OUTPUT: NONE    KEYWORDS:   INPUT: 	generic:	If set, a generic input is test to determine whether 			it is a POINT object.  Its validity is not tested.    OUTPUT: NONE    RETURN: 	1 if the given POINT object is valid and contains points, 0 otherwise.    STATUS: 	Complete    SEE ALSO: 	pnt_test    MODIFICATION HISTORY:   Spitale, 12/2015; 	Adapted from pgs_test   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_test.html#pnt_test", "pnt_test", 'routine in <a href="obj/pnt/pnt_test.html">pnt_test.pro</a>', "pnt_test.pro", "", "pnt_test", "", "genericnoeventptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_threshold.html", "pnt_threshold.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_threshold.pro", "", "", " NAME: 	pnt_threshold    PURPOSE: 	Flags points whose given indicator falls below or above a given 	threshold.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_threshold, ptd, indicators, threshold, /above 	pnt_threshold, ptd, indicators, threshold, /below    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	indicators:	Values to be tested against the threshold.  One for 			each point in ptd.  	threshold:	Threshold value.    OUTPUT: NONE    KEYWORDS:   INPUT: 	above:	If set, values above the theshold are allowed.  	below:	If set, values below the theshold are allowed.    OUTPUT: NONE    RETURN: NONE.     MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_threshold   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_threshold.html#pnt_threshold", "pnt_threshold", 'routine in <a href="obj/pnt/pnt_threshold.html">pnt_threshold.pro</a>', "pnt_threshold.pro", "", "pnt_threshold", "", "abovebelowptdindicatorsthreshold", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_uncompress.html", "pnt_uncompress.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_uncompress.pro", "", "", " NAME: 	pnt_uncompress    PURPOSE: 	Explodes a compressed POINT object back into an array of POINT objects 	using the original POINT objects as a template.  The 	compressed POINT object is freed.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	new_ptd = pnt_uncompress(pptd, ptd)    ARGUMENTS:   INPUT: 	pptd:	Compressed POINT object.  	ptd:	Array of original POINT objects to use as a template. 		Must be in the same order as when compressed.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nn:		If given, it is assumed that there are nn elements 			in the compressed array for each element in the 			original input arrays.    OUTPUT: NONE    RETURN: 	Array of POINT objects containing the uncompressed data.     MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_uncompress   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_uncompress.html#pnt_uncompress", "pnt_uncompress", 'routine in <a href="obj/pnt/pnt_uncompress.html">pnt_uncompress.pro</a>', "pnt_uncompress.pro", "", "pnt_uncompress", "", "nnpptdptd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_valid.html", "pnt_valid.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_valid.pro", "", "", " NAME: 	pnt_valid    PURPOSE: 	Assesses the validity of POINT objects.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	valid = pnt_valid(ptd)    ARGUMENTS:   INPUT: 	ptd:	Array of POINT objects.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array of flags, one for each input PS.  1 indicates that the PS 	contains points.    STATUS: 	Complete    SEE ALSO: 	pnt_test    MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_valid   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_valid.html#pnt_valid", "pnt_valid", 'routine in <a href="obj/pnt/pnt_valid.html">pnt_valid.pro</a>', "pnt_valid.pro", "", "pnt_valid", "", "noeventptd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_vectors.html", "pnt_vectors.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_vectors.pro", "", "", " NAME: 	pnt_vectors    PURPOSE: 	Returns the vectors associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	vectors = pnt_vectors(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.  If multiple POINT objects are given, 		and /cat is not speciied, only pointers to the arrays are 		returned, and conditions and tags are not applied.     OUTPUT: NONE    KEYWORDS:   INPUT: 	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT objects, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	sample:		Sampling interval in the nv direction.  Default is 1.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The vectors associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_vectors     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_vectors.html#pnt_vectors", "pnt_vectors", 'routine in <a href="obj/pnt/pnt_vectors.html">pnt_vectors.pro</a>', "pnt_vectors.pro", "", "pnt_vectors", "", "samplecatconditionnoeventptd0@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_write.html", "pnt_write.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_write.pro", "", "", " NAME:  	pnt_write    PURPOSE:  	Writes a POINT object to a file.    CATEGORY:  	NV/OBJ/PNT    CALLING SEQUENCE:  	pnt_write, filename, ptd    ARGUMENTS:   INPUT:  	filename:	Name of the file to write.  	ptd:		POINT object to write.    OUTPUT: NONE    KEYWORDS:   INPUT:  	bin:	If set, a binary POINT object file is written;  		not currently implemented.    OUTPUT: NONE    RETURN: NONE    SEE ALSO: 	pnt_read    MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_write_ps   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_write.html#pnt_write", "pnt_write", 'routine in <a href="obj/pnt/pnt_write.html">pnt_write.pro</a>', "pnt_write.pro", "", "pnt_write", "", "binnoeventfilenameptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/project_map.html", "project_map.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "project_map.pro", "", "", " NAME:        project_map    PURPOSE:        Reprojects images.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = project_map(image, md=md, cd=cd, bx=bx, sund=sund, $                             pc_xsize, pc_ysize, $                             hide_fn=hide_fn, hide_data_p=hide_data_p)   ARGUMENTS:   INPUT:           image:     Array (xsize,ysize,nplanes) giving the image(s) to 		      reproject.         pc_xsize:     x size of map workspace         pc_ysize:     y size of map workspace  	bounds:	      Projection bounds specified as [lat0, lat1, lon0, lon1].     OUTPUT:        NONE   KEYWORDS:   INPUT: 	md:	Map descriptor.  	cd:	Camera descriptor.  	bx:	Body descriptor.  If two descriptors given, then the 		first is used with the cd input and the second is used with 		the map input.  	sund:	Star descriptor for the sun.  If not given, the dark side 		is mapped.  If two descriptors given, then the 		first is used with the cd input and the second is used with 		the map input.  	hide_fn:	Array of hide functions, e.g. 'pm_hide_ring'  	hide_data_p:	Array of hide data pointers, e.g. nv_ptr_new(rd)  	offset:	Offset in [lat,lon] to apply to map coordinates before 		projecting.  	interp:	Type of interpolation, see image_interp_cam.  	arg_interp:	Interpolation argument, see image_interp_cam.  	roi:	Subscripts in the output map specifying the map region 		to project, instead of the whole thing.  	edge:	Number of pixels to exclude from edge of the input image.  	smooth:	If set, the input image is smoothed before reprojection.   OUTPUT: 	NONE    RETURN:        Array (xsize,ysize,nplanes) giving the reprojected image(s).    MODIFICATION HISTORY:        Written by:     Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/project_map.html#pm_hide_ring", "pm_hide_ring", 'routine in <a href="obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_hide_ring", "", "rdmap_image_ptscam_image_ptssurface_ptsbody_ptspos_cam", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/project_map.html#pm_hide_globe", "pm_hide_globe", 'routine in <a href="obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_hide_globe", "", "xdmap_image_ptscam_image_ptssurface_ptsbody_ptspos_cam", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/project_map.html#pm_rm_globe", "pm_rm_globe", 'routine in <a href="obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_rm_globe", "", "xdmap_image_ptscam_image_ptssurface_ptsbody_ptspos_cam", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/project_map.html#pm_rm_globe", "pm_rm_globe", 'routine in <a href="obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_rm_globe", "", "xdmap_image_ptscam_image_ptssurface_ptsbody_ptspos_cam", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/project_map.html#pm_bounds", "pm_bounds", 'routine in <a href="obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_bounds", "", "boundssurface_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/project_map.html#pm_hide_points_limb", "pm_hide_points_limb", 'routine in <a href="obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_hide_points_limb", "", "bxpos_cambody_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/project_map.html#pm_wind_zonal", "pm_wind_zonal", 'routine in <a href="obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_wind_zonal", "", "bxmap_ptswind_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/project_map.html#pm_wind_kepler", "pm_wind_kepler", 'routine in <a href="obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_wind_kepler", "", "bxmap_ptswind_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/project_map.html#project_map", "project_map", 'routine in <a href="obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "project_map", "", "mdcdbxsundboundshitvaluehide_fnhide_data_proiinterparg_interpoffsetwind_fnwind_dataedgesmoothimage_pc_xsize_pc_ysize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/radec_angle.html", "radec_angle.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "radec_angle.pro", "", "", " NAME:        radec_angle    PURPOSE: 	Computes angles between vectors specified in the radec system.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        angle = radec_angle(radec1, radec2)    ARGUMENTS:   INPUT: 	radec1:	Array (nv,3,nt) giving the radec representation of the 		first vector.  	radec2:	Array (nv,3,nt) giving the radec representation of the 		second vector.    OUTPUT:  NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,nt) of angles between the input vectors.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/radec_angle.html#radec_angle", "radec_angle", 'routine in <a href="obj/tools/radec_angle.html">radec_angle.pro</a>', "radec_angle.pro", "", "radec_angle", "", "radec1radec2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/radec_grid.html", "radec_grid.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "radec_grid.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/radec_grid.html#radec_grid", "radec_grid", 'routine in <a href="obj/tools/radec_grid.html">radec_grid.pro</a>', "radec_grid.pro", "", "radec_grid", "", "nnpcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/radec_image_bounds.html", "radec_image_bounds.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "radec_image_bounds.pro", "", "", " NAME:        radec_image_bounds    PURPOSE: 	Determines radec coordinate ranges visible in an image described 	by a given camera descriptor.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        radec_image_bounds, cd, $ 	        ramin=ramin, ramax=ramax, decmin=decmin, decmax=decmax    ARGUMENTS:   INPUT: 	cd:	Camera descripor.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	corners:	Array(2,2) giving corers of image region to consider.  	slop:	Number of pixels by which to expand the image in each 		direction.     OUTPUT: 	ramin:	Minimum RA in image.  	ramax:	Maximum RA in image.  	decmin:	Minimum DEC in image.  	decmax:	Maximum DEC in image.  	border_pts_im:	Array (2,np) of points along the edge of the image.  	status:	-1 if no globe in the image, 0 otherwise.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/radec_image_bounds.html#radec_image_bounds", "radec_image_bounds", 'routine in <a href="obj/tools/radec_image_bounds.html">radec_image_bounds.pro</a>', "radec_image_bounds.pro", "", "radec_image_bounds", "", "slopborder_pts_imraminramaxdecmindecmaxcornersstatuscd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/radec_to_image.html", "radec_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "radec_to_image.pro", "", "", " NAME:        radec_to_image    PURPOSE:        Transforms points in polar ra/dec coords w.r.t the inertial frame 	to image coords.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = radec_to_image(cd, p)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera descriptors.  	p:	Array (nv x 3 x nt) of radec points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: 	body_pts:	Body coordinates of output points.    RETURN:        Array (2 x nv x nt) of image points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale 3/2002  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/radec_to_image.html#radec_to_image", "radec_to_image", 'routine in <a href="obj/tools/composite/radec_to_image.html">radec_to_image.pro</a>', "radec_to_image.pro", "", "radec_to_image", "", "body_ptscdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/radec_to_orient.html", "radec_to_orient.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "radec_to_orient.pro", "", "", " NAME:        radec_to_orient    PURPOSE: 	Computes orientation matrices such that the optic axis (axis 1) 	points in the direction of the given radec and the image y direction 	(axis 2) points toward celestial north (inertial [0,0,1]).    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        M = radec_to_orient(radec)    ARGUMENTS:   INPUT: 	radec:	Array (nt) giving the radec representations of the 		pointing vectors.    OUTPUT:  NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (3,3,nt) of orientation matrices.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/radec_to_orient.html#radec_to_orient", "radec_to_orient", 'routine in <a href="obj/tools/radec_to_orient.html">radec_to_orient.pro</a>', "radec_to_orient.pro", "", "radec_to_orient", "", "radec", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/radec_twist_to_cd.html", "radec_twist_to_cd.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "radec_twist_to_cd.pro", "", "", " NAME:        radec_twist_to_cd    PURPOSE:        Computes a camera orietation matrix from thegiven Euler angles.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        radec_twist_to_cd, ra, dec, twist, cd=cd    ARGUMENTS:   INPUT:        ra:	Right ascension relative to the inertial frame.  	dec:	Declination relative to the inertial frame.  	twist:	Twist angle relative to the inertial frame.    OUTPUT:        NONE    KEYOWRDS:   INPUT: 	cd:	Array (nt) of initial camera descriptors.  This 		argument must contain a valid camera descriptor 		upon calling this routine.    OUTPUT: 	cd:	Array (nt) of camera descriptors with new 		orientations.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/radec_twist_to_cd.html#radec_twist_to_cd", "radec_twist_to_cd", 'routine in <a href="obj/tools/radec_twist_to_cd.html">radec_twist_to_cd.pro</a>', "radec_twist_to_cd.pro", "", "radec_twist_to_cd", "", "cdradectwist", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/ray_points.html", "ray_points.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "ray_points.pro", "", "", " NAME:        ray_points    PURPOSE:        Computes points along rays.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        ray_pts = ray_points(r, v, np, dp)    ARGUMENTS:   INPUT:        r:	Array (nt) of inertial ray origins.         v:	Array (nt) of inertial ray directions, of unit length.  	np:	Number of points to compute on each ray.  	dp:	Point spacing.    OUTPUT:        NONE    KEYOWRDS:   INPUT: 	cd:	Optional array (nt) of camera descriptors.    OUTPUT: NONE   RETURN: 	If no camera descriptor is given, an array (np,3,nt) of inertial 	position vectors is returned.  If cd is given, an array (2,np,nt) 	of image points is returned.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/ray_points.html#ray_points", "ray_points", 'routine in <a href="obj/tools/ray_points.html">ray_points.pro</a>', "ray_points.pro", "", "ray_points", "", "cdrvnpdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/ray_sub_point_graphic.html", "ray_sub_point_graphic.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "ray_sub_point_graphic.pro", "", "", " NAME: 	ray_sub_point_graphic    PURPOSE: 	Iterates to find the point on the surface of the globe where the 	given ray is closest to the surface.   CATEGORY: 	NV/LIB/TOOLS    CALLING SEQUENCE:     result = ray_sub_point_graphic(gbx, v, r)    ARGUMENTS:   INPUT: 	gbx:	Any subclass of GLOBE.  	v:	Array (nv,3) giving the ray origins in the BODY frame.  	r:	Array (nv,3) giving the ray directions in the BODY frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	normal:	Array (nv,3) of surface normals at each closest 	approach.    RETURN: 	Array (nv,3) of closest approach poitns in the BODY frame.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/ray_sub_point_graphic.html#ray_sub_point_graphic", "ray_sub_point_graphic", 'routine in <a href="obj/tools/ray_sub_point_graphic.html">ray_sub_point_graphic.pro</a>', "ray_sub_point_graphic.pro", "", "ray_sub_point_graphic", "", "vvnormalpdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/raytrace.html", "raytrace.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "raytrace.pro", "", "", " NAME: 	raytace    PURPOSE: 	Traces rays from a camera to a set of objects.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	raytrace, image_pts, cd=cd, bx=bx		; For primary rays 		hit_matrix=hit_matrix, $ 		hit_indices=hit_indices, $ 		range_matrix=range_matrix, hit_list=hit_list  	raytrace, bx=bx, sbx=sbx, $			; For secondary rays 		hit_matrix=hit_matrix, $ 		hit_indices=hit_indices, $ 		range_matrix=range_matrix, hit_list=hit_list    ARGUMENTS:   INPUT: 	image_pts:  Array (2,np) of image points relative to cd.  These 	            points will be turned into rays to be traced from the 	            position of the camera.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	       Camera descriptor.  	bx:	       Array of object descriptors; must be a subclass of BODY.  	sbx:           Body descriptor for secondary ray tracing.  If set, 	               image_pts and cd are not used; instead, secondary rays 	               are traced from the given hit_matrix points to sbx.  	hit_matrix:    Body-frame points from prior call, to be used as 	               source points for secondary rays.  	hit_indices:   Body index for each secondary ray.  	limit_source : If set, secondary vectors originating on a given 	               body are not considered for targets that are the 	               same body.  Default is off.  	standoff:      If given, secondary vectors are advanced by this distance 	               before tracing in order to avoid hitting target bodies 	               through round-off error.  Default is 1 unit.  	penumbra:      If set, lighting rays are traced to random points on 	               each secondary body rather then the center.      OUTPUT: 	hit_list:     Array (nhit) giving indices of all bx that have ray 	              intersections.  	hit_indices:  Array (nray) of body indices corresponding to the first 	              intersection for each ray.  	hit_matrix:   Array (nray,3,nhit) of body-frame points for nearest 	              ray intersections.  	range_matrix: Array (nhit,nray) giving distance to the near-side 	              ray intersection for each body in the hit_matrix.  	far_matrix:   Array (nray,3,nhit) of body-frame points for all 	              far-side intersections with bodies in the hit_list.  	near_matrix:   Array (nray,3,nhit) of body-frame points for all 	               near-side intersections with bodies in the hit_list.    RETURN: NONE    PROCEDURE:     EXAMPLE:    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/raytrace.html#raytrace", "raytrace", 'routine in <a href="obj/tools/raytrace.html">raytrace.pro</a>', "raytrace.pro", "", "raytrace", "", "cdbxsbxhit_matrixshowpenumbrahit_indicesrange_matrixhit_listfar_matrixnear_matrixbackstandofflimit_sourceimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/remove_lines.html", "remove_lines.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "remove_lines.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/remove_lines.html#remove_lines", "remove_lines", 'routine in <a href="obj/tools/remove_lines.html">remove_lines.pro</a>', "remove_lines.pro", "", "remove_lines", "", "slopptdlines", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/render.html", "render.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "render.pro", "", "", " NAME: 	render    PURPOSE: 	Performs rendering on an array of bodies.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	map = render(cd=cd, bx=bx, sund=sund)     ARGUMENTS:   INPUT: NONE 	image_pts:    Array of the image points defining the grid to be traced.    OUTPUT: NONE 	image_pts:    Array of the image points giving the grid that was traced.    KEYWORDS:   INPUT: 	cd:	      Camera descriptor.  	bx:	      Array of object descriptors; must be a subclass of BODY.  	sund:         Star descriptor for the Sun.  	md:           Array of map descriptors, one for each body.  	ddmap:        Array of data descriptors containing the body maps, 	              one for each body.  	sample:       Amount by which to subsample pixels.  	pc_size:      To save memory, the projection is performed in pieces 	              of this size.  Default is 65536.  	penumbra:     If set, lighting rays are traced to random points on 	              each secondary body rather then the center.  	no_secondary: If set, no secondary ray tracing is performed, so 	              resulting in no shadows.     OUTPUT:     RETURN: 	2D array containing the rendered image.    PROCEDURE:     EXAMPLE:    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/render.html#map_smoothing_width", "map_smoothing_width", 'routine in <a href="obj/tools/render.html">render.pro</a>', "render.pro", "", "map_smoothing_width", "", "datai", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/render.html#rdr_photometry", "rdr_photometry", 'routine in <a href="obj/tools/render.html">render.pro</a>', "render.pro", "", "rdr_photometry", "", "no_phtdatacdsundbxbody_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/render.html#rdr_map", "rdr_map", 'routine in <a href="obj/tools/render.html">render.pro</a>', "render.pro", "", "rdr_map", "", "datapiecebxmdddmapbody_ptsphotii", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/render.html#rdr_piece", "rdr_piece", 'routine in <a href="obj/tools/render.html">render.pro</a>', "render.pro", "", "rdr_piece", "", "dataimage_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/render.html#render", "render", 'routine in <a href="obj/tools/render.html">render.pro</a>', "render.pro", "", "render", "", "cdsundbxddmapmdsamplepc_sizeshowpht_minno_phtstandofflimit_sourcepenumbrano_secondaryimage_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/render.html#test", "test", 'routine in <a href="obj/tools/render.html">render.pro</a>', "render.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/reproject_image.html", "reproject_image.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "reproject_image.pro", "", "", " NAME:        reproject_image    PURPOSE:        xx    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = project_map(image, md=md, cd=cd, gbx=gbx, $                             pc_xsize, pc_ysize, $                             hide_fn=hide_fn, hide_data_p=hide_data_p)    ARGUMENTS:   INPUT:           image:     Image of body.         pc_xsize:     x size of map workspace         pc_ysize:     y size of map workspace     OUTPUT:        NONE   KEYWORDS:   INPUT:              md:     Map descriptor.               cd:     Camera descriptor.              gbx:     Globe descriptor.          hide_fn:     Array of hide functions, e.g. 'pm_hide_ring'      hide_data_p:     Array of hide data pointers, e.g. nv_ptr_new(rd)              map:     Input map.  If given, the new map will be projected OVER                      this map.  This input map must be consistent with the                      given map desciptor.   OUTPUT: 	NONE    RETURN:        The reprojected image.   MODIFICATION HISTORY:        Written by:     Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/reproject_image.html#reproject_image", "reproject_image", 'routine in <a href="obj/tools/reproject_image.html">reproject_image.pro</a>', "reproject_image.pro", "", "reproject_image", "", "cdnew_cdsizeinterparg_interpimagepc_xsizepc_ysize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("grim/rim.html", "rim.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "rim.pro", "", "", " NAME: 	rim    PURPOSE: 	Prints the headers, or specific header values, for the specified files.    CATEGORY: 	NV/GR    CALLING SEQUENCE: 	rim, files    ARGUMENTS:   INPUT: 	files:	List of filenames and file specifications.  Only files whose 		filetypes can be detected are loaded.  An array of 		data descriptors may also be specified.    OUTPUT: NONE    KEYWORDS:   INPUT: 	keywords:	String array giving keywords for which values are 			desired.  Results are filetype-dependent.  If keywords 			are specfied, the results are printed as a table.    OUTPUT: NONE    RETURN: 	NONE    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/rim.html#rim", "rim", 'routine in <a href="grim/rim.html">rim.pro</a>', "rim.pro", "", "rim", "", "keywordsfiles", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/ringplane_radial_bounds.html", "ringplane_radial_bounds.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "ringplane_radial_bounds.pro", "", "", " NAME:        ringplane_radial_bounds    PURPOSE: 	Finds ringplane radial bounds by projecting the camera FOV on 	the ringplane.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = ringplane_radial_bounds(cd, dkx)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	dkx:	Any subclass of DISK.    OUTPUT:  NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2) giving the minimum and maximum disk radii visible 	to the camera.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/ringplane_radial_bounds.html#ringplane_radial_bounds", "ringplane_radial_bounds", 'routine in <a href="obj/tools/ringplane_radial_bounds.html">ringplane_radial_bounds.pro</a>', "ringplane_radial_bounds.pro", "", "ringplane_radial_bounds", "", "cddkx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_assign.html", "rng_assign.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_assign.pro", "", "", " NAME: 	rng_assign    PURPOSE: 	Replaces fields in a RING object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/RNG    CALLING SEQUENCE: 	rng_assign, rd, <keywords>=<values>    ARGUMENTS:   INPUT: 	rd:		RING object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	RING fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	rng_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_assign.html#rng_assign", "rng_assign", 'routine in <a href="obj/rng/rng_assign.html">rng_assign.pro</a>', "rng_assign.pro", "", "rng_assign", "", "noeventxd@rng__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_create_descriptors.html", "rng_create_descriptors.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_create_descriptors.pro", "", "", " NAME:        rng_create_descriptors    PURPOSE: 	Init method for the RING class.    CATEGORY:        NV/LIB/RNG    CALLING SEQUENCE:        rd = rng_create_descriptors(n)    ARGUMENTS:   INPUT:        n:      Number of ring descriptors.    OUTPUT:        NONE    KEYWORDS:   INPUT: 	rd:	Ring descriptor(s) to initialize, instead of creating new 		ones.  	dkd:	Disk descriptor(s) to pass to dsk_create_descriptors.  	sld:	Solid descriptor(s) to pass to sld_create_descriptors.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	primary:	Array (n) of primary descriptors.  	desc:	Array (n) of description strings.    OUTPUT: NONE   RETURN:        An array (n) of ring descriptors.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_create_descriptors.html#rng_create_descriptors", "rng_create_descriptors", 'routine in <a href="obj/rng/rng_create_descriptors.html">rng_create_descriptors.pro</a>', "rng_create_descriptors.pro", "", "rng_create_descriptors", "", "crdbdslddkdrdn@rng__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_desc.html", "rng_desc.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_desc.pro", "", "", " NAME: 	rng_desc    PURPOSE: 	Returns the description string for each given ring descriptor.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	desc = rng_desc(rd)    ARGUMENTS:   INPUT: 	rd:	 Array (nt) of RING descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Description string associated with each given ring descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_desc.html#rng_desc", "rng_desc", 'routine in <a href="obj/rng/rng_desc.html">rng_desc.pro</a>', "rng_desc.pro", "", "rng_desc", "", "noeventrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_evolve.html", "rng_evolve.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_evolve.pro", "", "", " NAME: 	rng_evolve    PURPOSE: 	Computes new ring descriptors at the given time offsets from the 	given ring descriptors using the taylor series expansion 	corresponding to the derivatives contained in the given ring 	descriptor.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	rdt = rng_evolve(rd, dt)    ARGUMENTS:   INPUT: 	rd:	 Any subclass of RING.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, derivatives will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN: 	Array (nrd,ndt) of newly allocated descriptors, of class RING, 	evolved by time dt, where nrd is the number of rd, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_evolve.html#rng_evolve", "rng_evolve", 'routine in <a href="obj/rng/rng_evolve.html">rng_evolve.pro</a>', "rng_evolve.pro", "", "rng_evolve", "", "nodvcopyrddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_primary.html", "rng_primary.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_primary.pro", "", "", " NAME: 	rng_primary    PURPOSE: 	Returns the primary string for each given ring descriptor.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	primary = rng_primary(rd)    ARGUMENTS:   INPUT: 	rd:	 Array (nt) of RING descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Primary string associated with each given ring descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_primary.html#rng_primary", "rng_primary", 'routine in <a href="obj/rng/rng_primary.html">rng_primary.pro</a>', "rng_primary.pro", "", "rng_primary", "", "noeventrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_query.html", "rng_query.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_query.pro", "", "", " NAME: 	rng_query    PURPOSE: 	Returns the fields associated with a RING object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/RNG    CALLING SEQUENCE: 	rng_query, rd, <keywords>=<values>    ARGUMENTS:   INPUT: 	rd:	RING object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	RING object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_query.html#rng_query", "rng_query", 'routine in <a href="obj/rng/rng_query.html">rng_query.pro</a>', "rng_query.pro", "", "rng_query", "", "conditioncatnoeventxd@rng__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_replicate.html", "rng_replicate.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_replicate.pro", "", "", " NAME: 	rng_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	rds = rng_replicate(rd, dim)    ARGUMENTS:   INPUT: 	rd:	 Ring descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_replicate.html#rng_replicate", "rng_replicate", 'routine in <a href="obj/rng/rng_replicate.html">rng_replicate.pro</a>', "rng_replicate.pro", "", "rng_replicate", "", "rddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_set_desc.html", "rng_set_desc.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_set_desc.pro", "", "", " NAME: 	rng_set_desc    PURPOSE: 	Replaces the description string in each given ring descriptor.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	rng_set_desc, rd, desc    ARGUMENTS:   INPUT: 	rd:	Array (nt) of STATION descriptors.  	desc:	Array (nt) of description strings.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_set_desc.html#rng_set_desc", "rng_set_desc", 'routine in <a href="obj/rng/rng_set_desc.html">rng_set_desc.pro</a>', "rng_set_desc.pro", "", "rng_set_desc", "", "noeventrddesc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_set_primary.html", "rng_set_primary.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_set_primary.pro", "", "", " NAME: 	rng_set_primary    PURPOSE: 	Replaces the primary string in each given ring descriptor.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	rng_set_primary, rd, primary    ARGUMENTS:   INPUT: 	rd:	Array (nt) of STATION descriptor.  	primary:	Array (nt) of primary strings.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_set_primary.html#rng_set_primary", "rng_set_primary", 'routine in <a href="obj/rng/rng_set_primary.html">rng_set_primary.pro</a>', "rng_set_primary.pro", "", "rng_set_primary", "", "noeventrdxd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/set_image_origin.html", "set_image_origin.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "set_image_origin.pro", "", "", " NAME:        set_image_origin    PURPOSE: 	Sets the origin of a map or camera image.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        set_image_origin, xd, origin    ARGUMENTS:   INPUT: 	xd:      Camera or map descriptor  	origin: origin argument as in map_set_origin     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	NONE.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/set_image_origin.html#set_image_origin", "set_image_origin", 'routine in <a href="obj/tools/composite/set_image_origin.html">set_image_origin.pro</a>', "set_image_origin.pro", "", "set_image_origin", "", "cdorigin", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/set_image_size.html", "set_image_size.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "set_image_size.pro", "", "", " NAME:        set_image_size    PURPOSE: 	Sets the size of a map or camera image.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        set_image_size, xd, size    ARGUMENTS:   INPUT: 	xd:      Camera or map descriptor  	size: 	 Size argument as in map_set_size     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	NONE.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/set_image_size.html#set_image_size", "set_image_size", 'routine in <a href="obj/tools/composite/set_image_size.html">set_image_size.pro</a>', "set_image_size.pro", "", "set_image_size", "", "cdsize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_albedo.html", "sld_albedo.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_albedo.pro", "", "", " NAME: 	sld_albedo    PURPOSE:        Returns the bond albedo for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	mass = sld_albedo(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of albedos associated with each given solid descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_albedo.html#sld_albedo", "sld_albedo", 'routine in <a href="obj/sld/sld_albedo.html">sld_albedo.pro</a>', "sld_albedo.pro", "", "sld_albedo", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_assign.html", "sld_assign.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_assign.pro", "", "", " NAME: 	sld_assign    PURPOSE: 	Replaces fields in a SOLID object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/SLD    CALLING SEQUENCE: 	sld_assign, sld, <keywords>=<values>    ARGUMENTS:   INPUT: 	sld:		SOLID object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	SOLID fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	sld_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_assign.html#sld_assign", "sld_assign", 'routine in <a href="obj/sld/sld_assign.html">sld_assign.pro</a>', "sld_assign.pro", "", "sld_assign", "", "noeventxd@sld__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_create_descriptors.html", "sld_create_descriptors.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_create_descriptors.pro", "", "", " NAME: 	sld_create_descriptors    PURPOSE: 	Init method for the SOLID class.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld = sld_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	Number of descriptors to create.    OUTPUT: NONE    KEYWORDS (in addition to those accepted by all superclasses):   INPUT: 	sld:	Globe descriptor(s) to initialize, instead of creating a new one.  	bd:	Body descriptor(s) instead of using bod_create_descriptors.  	crd:	Core descriptor(s) instead of using cor_create_descriptors.  	opacity: Array (n) of opacities for each body.  	GM:	Array (n) of masses x gravitiational constant.  	mass:	Array (n) of masses.  	phase_fn: Array (n) of phase function names.  	phase_parm:	Array (npht,n) of phase function parameters.  	refl_fn: Array (n) of reflection function names.  	refl_parm:	Array (npht,n) of reflection function parameters.  	albedo:	Array (n) of bond albedos.     OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized solid descriptors, depending 	on the presence of the bd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_create_descriptors.html#sld_create_descriptors", "sld_create_descriptors", 'routine in <a href="obj/sld/sld_create_descriptors.html">sld_create_descriptors.pro</a>', "sld_create_descriptors.pro", "", "sld_create_descriptors", "", "crdbdsldn@sld__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_evolve.html", "sld_evolve.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_evolve.pro", "", "", " NAME: 	sld_evolve    PURPOSE:        Computes new solid descriptors at the given time offsets from        the given solid descriptors using the taylor series expansion        corresponding to the derivatives contained in the given solid        descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sldt = sld_evolve(sld, dt)    ARGUMENTS:   INPUT: 	sld:	 Array (nsld) of any subclass of SOLID descriptors.  	dt:	 Array (ndt) of time offsets.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, velocities will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN:        Array (ngd,ndt) of newly allocated solid descriptors evolved        by time dt, where ngd is the number of sld, and ndt is the        number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_evolve.html#sld_evolve", "sld_evolve", 'routine in <a href="obj/sld/sld_evolve.html">sld_evolve.pro</a>', "sld_evolve.pro", "", "sld_evolve", "", "nodvcopyslddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_gm.html", "sld_gm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_gm.pro", "", "", " NAME: 	sld_gm    PURPOSE:        Returns the GM value for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	gm = sld_gm(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of GM values associated with each given solid descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_gm.html#sld_gm", "sld_gm", 'routine in <a href="obj/sld/sld_gm.html">sld_gm.pro</a>', "sld_gm.pro", "", "sld_gm", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_mass.html", "sld_mass.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_mass.pro", "", "", " NAME: 	sld_mass    PURPOSE:        Returns the mass for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	mass = sld_mass(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of mass values associated with each given solid 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_mass.html#sld_mass", "sld_mass", 'routine in <a href="obj/sld/sld_mass.html">sld_mass.pro</a>', "sld_mass.pro", "", "sld_mass", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_npht.html", "sld_npht.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_npht.pro", "", "", " NAME: 	sld_npht    PURPOSE: 	Returns an integer indicating the maximum number of parameters 	allowed in the refl_parm and phase-parm fields of the solid 	descriptor.  This number can be adjusted using the environment 	variable 'SLD_NPHT'.  The default is 4.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	npht = sld_npht()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    ENVIRONMENT VARIABLES: 	SLD_NPHT:	Sets the npht value.    RETURN: 	Current npht value.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_npht.html#sld_npht", "sld_npht", 'routine in <a href="obj/sld/sld_npht.html">sld_npht.pro</a>', "sld_npht.pro", "", "sld_npht", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_opacity.html", "sld_opacity.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_opacity.pro", "", "", " NAME: 	sld_opacity    PURPOSE: 	Returns the opacity for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	opacity = sld_opacity(sld)    ARGUMENTS:   INPUT: NONE 	sld:	 Any subclass of SOLID.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Opacity value associated with each given solid descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_opacity.html#sld_opacity", "sld_opacity", 'routine in <a href="obj/sld/sld_opacity.html">sld_opacity.pro</a>', "sld_opacity.pro", "", "sld_opacity", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_phase.html", "sld_phase.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_phase.pro", "", "", " NAME: 	sld_phase    PURPOSE: 	Computes a phase function.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	phase = sld_phase(sld, mu, mu0)    ARGUMENTS:   INPUT: 	sld:	 Globe descriptor.  	mu:	 Cosine of the emission angle.  	mu0:	 Cosine of the incidence angle.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Phase function value for the given mu and mu0 parameters.    PROCEDURE: 	The function indicated by the phase_fn field of the solid descriptor 	is called and its return value is passed through to the caller of 	sld_phase.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_phase.html#sld_phase", "sld_phase", 'routine in <a href="obj/sld/sld_phase.html">sld_phase.pro</a>', "sld_phase.pro", "", "sld_phase", "", "sldmumu0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_phase_fn.html", "sld_phase_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_phase_fn.pro", "", "", " NAME: 	sld_phase_fn    PURPOSE:        Returns the name of the phase function for each given solid 	descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	mass = sld_phase_fn(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of phase function names associated with each given solid 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_phase_fn.html#sld_phase_fn", "sld_phase_fn", 'routine in <a href="obj/sld/sld_phase_fn.html">sld_phase_fn.pro</a>', "sld_phase_fn.pro", "", "sld_phase_fn", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_phase_parm.html", "sld_phase_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_phase_parm.pro", "", "", " NAME: 	sld_phase_parm    PURPOSE:        Returns the phase function parameters for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	mass = sld_phase_parm(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (npht,nt) of phase function parameters associated with each 	given solid descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_phase_parm.html#sld_phase_parm", "sld_phase_parm", 'routine in <a href="obj/sld/sld_phase_parm.html">sld_phase_parm.pro</a>', "sld_phase_parm.pro", "", "sld_phase_parm", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_query.html", "sld_query.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_query.pro", "", "", " NAME: 	sld_query    PURPOSE: 	Returns the fields associated with a CAMERA object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	sld_query, sld, <keywords>=<values>    ARGUMENTS:   INPUT: 	sld:	CAMERA object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	CAMERA object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_query.html#sld_query", "sld_query", 'routine in <a href="obj/sld/sld_query.html">sld_query.pro</a>', "sld_query.pro", "", "sld_query", "", "conditioncatnoeventxd@sld__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_refl.html", "sld_refl.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_refl.pro", "", "", " NAME: 	sld_refl    PURPOSE: 	Computes a reflection function.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	refl = sld_refl(sld, mu, mu0)    ARGUMENTS:   INPUT: 	sld:	 Globe descriptor.  	mu:	 Cosine of the emission angle.  	mu0:	 Cosine of the incidence angle.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Refletion function value for the given mu and mu0 parameters.    PROCEDURE: 	The function indicated by the refl_fn field of the solid descriptor 	is called and its return value is passed through to the caller of 	sld_phase.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_refl.html#sld_refl", "sld_refl", 'routine in <a href="obj/sld/sld_refl.html">sld_refl.pro</a>', "sld_refl.pro", "", "sld_refl", "", "sldmumu0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_refl_fn.html", "sld_refl_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_refl_fn.pro", "", "", " NAME: 	sld_refl_fn    PURPOSE:        Returns the name of the reflection function for each given solid 	descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	mass = sld_refl_fn(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of reflection function names associated with each given 	solid descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_refl_fn.html#sld_refl_fn", "sld_refl_fn", 'routine in <a href="obj/sld/sld_refl_fn.html">sld_refl_fn.pro</a>', "sld_refl_fn.pro", "", "sld_refl_fn", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_refl_parm.html", "sld_refl_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_refl_parm.pro", "", "", " NAME: 	sld_refl_parm    PURPOSE:        Returns the reflection function parameters for each given solid 	descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	mass = sld_refl_parm(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (npht,nt) of reflection function parameters associated with 	each given solid descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_refl_parm.html#sld_refl_parm", "sld_refl_parm", 'routine in <a href="obj/sld/sld_refl_parm.html">sld_refl_parm.pro</a>', "sld_refl_parm.pro", "", "sld_refl_parm", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_albedo.html", "sld_set_albedo.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_albedo.pro", "", "", " NAME: 	sld_set_albedo    PURPOSE:        Replaces the bond albedo for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_albedo, sld, albedo    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.  	albedo:	 Array (nt) of new bond albedos.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_albedo.html#sld_set_albedo", "sld_set_albedo", 'routine in <a href="obj/sld/sld_set_albedo.html">sld_set_albedo.pro</a>', "sld_set_albedo.pro", "", "sld_set_albedo", "", "noeventsldalbedo", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_gm.html", "sld_set_gm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_gm.pro", "", "", " NAME: 	sld_set_gm    PURPOSE:        Replaces the GM value for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_gm, sld, gm    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.  	gm:	 Array (nt) of new GM values.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_gm.html#sld_set_gm", "sld_set_gm", 'routine in <a href="obj/sld/sld_set_gm.html">sld_set_gm.pro</a>', "sld_set_gm.pro", "", "sld_set_gm", "", "nosynchnoeventsldgm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_mass.html", "sld_set_mass.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_mass.pro", "", "", " NAME: 	sld_set_mass    PURPOSE:        Replaces the mass for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_mass, sld, mass    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.  	j:	 Array (nj,nt) of new masses.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_mass.html#sld_set_mass", "sld_set_mass", 'routine in <a href="obj/sld/sld_set_mass.html">sld_set_mass.pro</a>', "sld_set_mass.pro", "", "sld_set_mass", "", "nosynchnoeventsldmass", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_opacity.html", "sld_set_opacity.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_opacity.pro", "", "", " NAME: 	sld_set_opacity    PURPOSE: 	Replaces the opacity of each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_opacity, sld, opacity    ARGUMENTS:   INPUT: 	sld:	 Any subclass of SOLID.  	opacity:	 New opacity value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_opacity.html#sld_set_opacity", "sld_set_opacity", 'routine in <a href="obj/sld/sld_set_opacity.html">sld_set_opacity.pro</a>', "sld_set_opacity.pro", "", "sld_set_opacity", "", "noeventsldopacity", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_phase_fn.html", "sld_set_phase_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_phase_fn.pro", "", "", " NAME: 	sld_set_phase_fn    PURPOSE:        Replaces the phase function for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_phase_fn, sld, phase_fn    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.  	phase_fn: Array (nt) of new phase functions.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_phase_fn.html#sld_set_phase_fn", "sld_set_phase_fn", 'routine in <a href="obj/sld/sld_set_phase_fn.html">sld_set_phase_fn.pro</a>', "sld_set_phase_fn.pro", "", "sld_set_phase_fn", "", "noeventsldphase_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_phase_parm.html", "sld_set_phase_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_phase_parm.pro", "", "", " NAME: 	sld_set_phase_parm    PURPOSE:        Replaces the phase function parameters for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_phase_parm, sld, phase_parm    ARGUMENTS:   INPUT: 	sld:		Array (nt) of any subclass of SOLID descriptors.  	phase_parm:	Array (nt) of new phase function parameters.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_phase_parm.html#sld_set_phase_parm", "sld_set_phase_parm", 'routine in <a href="obj/sld/sld_set_phase_parm.html">sld_set_phase_parm.pro</a>', "sld_set_phase_parm.pro", "", "sld_set_phase_parm", "", "noeventsldphase_parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_refl_fn.html", "sld_set_refl_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_refl_fn.pro", "", "", " NAME: 	sld_set_refl_fn    PURPOSE:        Replaces the reflection function for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_refl_fn, sld, refl_fn    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.  	refl_fn: Array (nt) of new reflection functions.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_refl_fn.html#sld_set_refl_fn", "sld_set_refl_fn", 'routine in <a href="obj/sld/sld_set_refl_fn.html">sld_set_refl_fn.pro</a>', "sld_set_refl_fn.pro", "", "sld_set_refl_fn", "", "noeventsldrefl_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_refl_parm.html", "sld_set_refl_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_refl_parm.pro", "", "", " NAME: 	sld_set_refl_parm    PURPOSE:        Replaces the reflection function parameters for each given solid 	descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_refl_parm, sld, refl_parm    ARGUMENTS:   INPUT: 	sld:		Array (nt) of any subclass of SOLID descriptors.  	refl_parm:	Array (nt) of new reflection function parameters.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_refl_parm.html#sld_set_refl_parm", "sld_set_refl_parm", 'routine in <a href="obj/sld/sld_set_refl_parm.html">sld_set_refl_parm.pro</a>', "sld_set_refl_parm.pro", "", "sld_set_refl_parm", "", "noeventsldrefl_parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/smear_psf.html", "smear_psf.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "smear_psf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/smear_psf.html#smear_psf", "smear_psf", 'routine in <a href="obj/tools/smear_psf.html">smear_psf.pro</a>', "smear_psf.pro", "", "smear_psf", "", "cdbxwidth", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/smooth_on_curve.html", "smooth_on_curve.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "smooth_on_curve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/smooth_on_curve.html#smooth_on_curve", "smooth_on_curve", 'routine in <a href="obj/tools/smooth_on_curve.html">smooth_on_curve.pro</a>', "smooth_on_curve.pro", "", "smooth_on_curve", "", "cdimagepwidth", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/smooth_on_curve.html#_smooth_on_curve", "_smooth_on_curve", 'routine in <a href="obj/tools/smooth_on_curve.html">smooth_on_curve.pro</a>', "smooth_on_curve.pro", "", "_smooth_on_curve", "", "imagepwidth", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/stellab.html", "stellab.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "stellab.pro", "", "", " NAME:        stellab    PURPOSE: 	Corrects body positions for stellar aberration on objects for which the 	correction has not already been performed..    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        stellab, obs_bx, targ_bx    ARGUMENTS:   INPUT: 	obs_bx:		Array (nt) of any subclass of BODY describing 			the observer.  	targ_bx:	Array (nt) of any subclass of BODY describing 			the target.  The position of this body is modified.    OUTPUT:  NONE    KEYWORDS:   INPUT: 	c:		Speed of light.  	invert:		If set, the inverse correction is performed.    OUTPUT: NONE    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/stellab.html#stellab", "stellab", 'routine in <a href="obj/tools/stellab.html">stellab.pro</a>', "stellab.pro", "", "stellab", "", "cfastinvertobs_bx_targ_bx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/stellab_pos.html", "stellab_pos.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "stellab_pos.pro", "", "", " NAME:        stellab_pos    PURPOSE: 	Corrects positions for stellar aberration.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        new_pos = stellab_pos(pos, vel)    ARGUMENTS:   INPUT: 	pos:	Array (nv,3) of target inertial position vectors to be 		corrected.  	vel:	Array (nv,3) of observer inertial velocity vectors. 		Note observer is assumed to be at the origin.    OUTPUT:  NONE    KEYWORDS:   INPUT: 	c:	Speed of light.    OUTPUT: 	axis:	Array (nv,3) of rotation axes corresponding to each 		correction.  	theta:	Array (nv) of rotation angles corresponding to each 		correction.    RETURN: 	Array (nv,3) of corrected position vectors.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/stellab_pos.html#stellab_pos", "stellab_pos", 'routine in <a href="obj/tools/stellab_pos.html">stellab_pos.pro</a>', "stellab_pos.pro", "", "stellab_pos", "", "caxisthetafastposvel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/stellab_radec.html", "stellab_radec.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "stellab_radec.pro", "", "", " NAME:        stellab_radec    PURPOSE: 	Corrects positions given in the radec system for stellar 	aberration.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        new_radec = stellab_radec(radec, vel)    ARGUMENTS:   INPUT: 	radec:	Array (nv,3) of target inertial position vectors to be 		corrected, given in the radec system.  	vel:	Array (nv,3) of observer inertial velocity vectors. 		Note observer is assumed to be at the origin.    OUTPUT:  NONE    KEYWORDS:   INPUT: 	c:	Speed of light.    OUTPUT: NONE    RETURN: 	Array (nv,3) of corrected position vectors in the radec system.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/stellab_radec.html#stellab_radec", "stellab_radec", 'routine in <a href="obj/tools/stellab_radec.html">stellab_radec.pro</a>', "stellab_radec.pro", "", "stellab_radec", "", "cradecvel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/stereo_split.html", "stereo_split.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "stereo_split.pro", "", "", " NAME:        stereo_split    PURPOSE:        Splits a given camera descriptor into a stereo pair.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        cds = stereo_split(cd, sep=sep)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.    OUTPUT: NONE    KEYOWRDS:   INPUT:        sep:	Separation distance of output descriptors.    OUTPUT: NONE   RETURN: 	Array (2) giving the left and right camera descriptors. 	Each descriptor is cloned from the input descripor, and has 	been translated +/- sep/2 in the camara body 0-axis direction.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/stereo_split.html#stereo_split", "stereo_split", 'routine in <a href="obj/tools/stereo_split.html">stereo_split.pro</a>', "stereo_split.pro", "", "stereo_split", "", "sepcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_assign.html", "stn_assign.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_assign.pro", "", "", " NAME: 	stn_assign    PURPOSE: 	Replaces fields in a STATION object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	stn_assign, std, <keywords>=<values>    ARGUMENTS:   INPUT: 	std:		STATION object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	STATION fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	stn_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_assign.html#stn_assign", "stn_assign", 'routine in <a href="obj/stn/stn_assign.html">stn_assign.pro</a>', "stn_assign.pro", "", "stn_assign", "", "noeventxd@stn__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_create_descriptors.html", "stn_create_descriptors.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_create_descriptors.pro", "", "", " NAME:        stn_create_descriptors    PURPOSE: 	Init method for the STATION class.    CATEGORY:        NV/LIB/STN    CALLING SEQUENCE:        std = stn_create_descriptors(n)    ARGUMENTS:   INPUT:        n:      Number of station descriptors.    OUTPUT:        NONE    KEYWORDS:   INPUT: 	std:	Station descriptor(s) to initialize, instead of creating new 		ones.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	primary:	Array (n) of primary descriptors.    OUTPUT: NONE   RETURN:        An array (n) of station descriptors.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_create_descriptors.html#stn_create_descriptors", "stn_create_descriptors", 'routine in <a href="obj/stn/stn_create_descriptors.html">stn_create_descriptors.pro</a>', "stn_create_descriptors.pro", "", "stn_create_descriptors", "", "crdbdstdn@stn__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_evolve.html", "stn_evolve.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_evolve.pro", "", "", " NAME: 	stn_evolve    PURPOSE: 	Computes new station descriptors at the given time offsets from the 	given station descriptors using the taylor series expansion 	corresponding to the derivatives contained in the given station 	descriptor.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	sdt = stn_evolve(stx, dt)    ARGUMENTS:   INPUT: 	stx:	 Any subclass of STATION.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, derivatives will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN: 	Array (nstd,ndt) of newly allocated descriptors, of class STATION, 	evolved by time dt, where nstd is the number of stx, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_evolve.html#stn_evolve", "stn_evolve", 'routine in <a href="obj/stn/stn_evolve.html">stn_evolve.pro</a>', "stn_evolve.pro", "", "stn_evolve", "", "nodvcopystddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_primary.html", "stn_primary.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_primary.pro", "", "", " NAME: 	stn_primary    PURPOSE: 	Returns the primary string for each given station descriptor.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	primary = stn_primary(std)    ARGUMENTS:   INPUT: 	std:	 Array (nt) of STATION descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Primary descriptor associated with each given station descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_primary.html#stn_primary", "stn_primary", 'routine in <a href="obj/stn/stn_primary.html">stn_primary.pro</a>', "stn_primary.pro", "", "stn_primary", "", "noeventstd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_query.html", "stn_query.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_query.pro", "", "", " NAME: 	stn_query    PURPOSE: 	Returns the fields associated with a STATION object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	stn_query, std, <keywords>=<values>    ARGUMENTS:   INPUT: 	std:	STATION object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	STATION object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_query.html#stn_query", "stn_query", 'routine in <a href="obj/stn/stn_query.html">stn_query.pro</a>', "stn_query.pro", "", "stn_query", "", "conditioncatnoeventxd@stn__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_replicate.html", "stn_replicate.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_replicate.pro", "", "", " NAME: 	stn_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	stds = str_replicate(std, dim)    ARGUMENTS:   INPUT: 	std:	 Station descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_replicate.html#stn_replicate", "stn_replicate", 'routine in <a href="obj/stn/stn_replicate.html">stn_replicate.pro</a>', "stn_replicate.pro", "", "stn_replicate", "", "stddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_set_primary.html", "stn_set_primary.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_set_primary.pro", "", "", " NAME: 	stn_set_primary    PURPOSE: 	Replaces the primary string in each given station descriptor.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	stn_set_primary, std, primary    ARGUMENTS:   INPUT: 	std:	Array (nt) of STATION descriptors.  	primary:	Array (nt) of primary descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_set_primary.html#stn_set_primary", "stn_set_primary", 'routine in <a href="obj/stn/stn_set_primary.html">stn_set_primary.pro</a>', "stn_set_primary.pro", "", "stn_set_primary", "", "noeventstdprimary", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_set_surface_pt.html", "stn_set_surface_pt.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_set_surface_pt.pro", "", "", " NAME: 	stn_set_surface_pt    PURPOSE: 	Replaces the surface_pt vector in each given station descriptor.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	stn_set_surface_pt, std, surface_pt    ARGUMENTS:   INPUT: 	std:	Array (nt) of STATION descriptors.  	surface_pt:	Array (1,3,nt) of surface_pt vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_set_surface_pt.html#stn_set_surface_pt", "stn_set_surface_pt", 'routine in <a href="obj/stn/stn_set_surface_pt.html">stn_set_surface_pt.pro</a>', "stn_set_surface_pt.pro", "", "stn_set_surface_pt", "", "noeventstdsurface_pt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_surface_pt.html", "stn_surface_pt.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_surface_pt.pro", "", "", " NAME: 	stn_surface_pt    PURPOSE: 	Returns the surface_pt vector for each given station descriptor.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	surface_pt = stn_surface_pt(std)    ARGUMENTS:   INPUT: 	std:	 Array (nt) of STATION descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (1,3,nt) of surface_pt vectors associated with each given 	station descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_surface_pt.html#stn_surface_pt", "stn_surface_pt", 'routine in <a href="obj/stn/stn_surface_pt.html">stn_surface_pt.pro</a>', "stn_surface_pt.pro", "", "stn_surface_pt", "", "noeventstd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/str/str_assign.html", "str_assign.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_assign.pro", "", "", " NAME: 	str_assign    PURPOSE: 	Replaces fields in a STAR object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/STR    CALLING SEQUENCE: 	str_assign, sd, <keywords>=<values>    ARGUMENTS:   INPUT: 	sd:		STAR object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	STAR fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	str_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_assign.html#str_assign", "str_assign", 'routine in <a href="obj/str/str_assign.html">str_assign.pro</a>', "str_assign.pro", "", "str_assign", "", "noeventxd@str__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/str/str_create_descriptors.html", "str_create_descriptors.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_create_descriptors.pro", "", "", " NAME:        str_create_descriptors    PURPOSE: 	Init method for the STAR class.    CATEGORY:        NV/LIB/STR    CALLING SEQUENCE:        sd = str_create_descriptors(n)    ARGUMENTS:   INPUT:        n:      Number of star descriptors.    OUTPUT:        NONE    KEYWORDS:   INPUT: 	sd:	Star descriptor(s) to initialize, instead of creating new ones.  	gbd:	Globe descriptor(s) to pass to glb_create_descriptors.  	sld:	Solid descriptor(s) to pass to sld_create_descriptors.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	lum:	Array (n) of luminosity values.  	sp:	Array (n) of spectral class strings.    OUTPUT: NONE   RETURN:        An array (n) of star descriptors.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 5/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_create_descriptors.html#str_create_descriptors", "str_create_descriptors", 'routine in <a href="obj/str/str_create_descriptors.html">str_create_descriptors.pro</a>', "str_create_descriptors.pro", "", "str_create_descriptors", "", "crdbdsldgbdsdn@str__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/str/str_evolve.html", "str_evolve.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_evolve.pro", "", "", " NAME: 	str_evolve    PURPOSE: 	Computes new star descriptors at the given time offsets from the 	given star descriptors using the taylor series expansion 	corresponding to the derivatives contained in the given star 	descriptor.    CATEGORY: 	NV/LIB/STR    CALLING SEQUENCE: 	sdt = str_evolve(sx, dt)    ARGUMENTS:   INPUT: 	sx:	 Any subclass of STAR.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, derivatives will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN: 	Array (nsd,ndt) of newly allocated descriptors, of class STAR, 	evolved by time dt, where nsd is the number of sx, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_evolve.html#str_evolve", "str_evolve", 'routine in <a href="obj/str/str_evolve.html">str_evolve.pro</a>', "str_evolve.pro", "", "str_evolve", "", "nodvcopysddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/str/str_get_mag.html", "str_get_mag.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_get_mag.pro", "", "", " NAME:        str_get_mag    PURPOSE:        Calculates the visual magnitude for each given star descriptor.    CATEGORY:        NV/LIB/STR    CALLING SEQUENCE:        result = str_get_mag(sd)    ARGUMENTS:   INPUT:        sd:    Array (nt) of star descriptors.    OUTPUT:        NONE    KEYWORDS:   INPUT: 	od:	Observer descriptor.  If not given, the absolute magnitude is 		returned.    OUTPUT: NONE   RETURN:        An array (nt) of magnitues.   PROCEDURE:        Calls str_body to get the position vector.  The position is assumed        to be in meters and the Luminosity (sds.lum) is in J/sec.  Absolute        visual magnitude is calculated by using the formula for the Sun.        Mv = 4.83 - 2.5 log (L/Lsun)        where Lsun = 3.826e+26 J/sec        Visual magnitude is corrected by using the distance modulus.        m = Mv + 5 log (dist/pc) - 5        where pc = 3.085678e+16 m  (parsec)   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 5/1998 	Modified by:	Haemmerle, 12/2000  	Adapted by:	Spitale, 5/2016        Modified by:    Haemmerle, 7/2017    ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_get_mag.html#str_get_mag", "str_get_mag", 'routine in <a href="obj/str/str_get_mag.html">str_get_mag.pro</a>', "str_get_mag.pro", "", "str_get_mag", "", "odsd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/str/str_limit_mag.html", "str_limit_mag.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_limit_mag.pro", "", "", " NAME:        str_limit_mag    PURPOSE:        Returns subscripts of stars with magnitudes within the min, max range.    CATEGORY:        NV/LIB/STR    CALLING SEQUENCE:        result = str_limit_mag(sd, min=min, max=max)    ARGUMENTS:   INPUT:        sd:    Array of star descriptors.    OUTPUT:        NONE    KEYWORDS:   INPUT:        min:    Minimum threshold for magnitude.         max:    Maximum threshold for magnitude.    OUTPUT:          NONE   RETURN:        An array of subscripts into sd for stars fitting 	min <=  magnitude <= max.    SEE ALSO: 	pg_str_limit_mag   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 5/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_limit_mag.html#str_limit_mag", "str_limit_mag", 'routine in <a href="obj/str/str_limit_mag.html">str_limit_mag.pro</a>', "str_limit_mag.pro", "", "str_limit_mag", "", "minmaxsd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/str/str_lum.html", "str_lum.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_lum.pro", "", "", " NAME:        str_lum    PURPOSE:        Returns a luminosity for each given star descriptor.    CATEGORY:        NV/LIB/STR    CALLING SEQUENCE:        result = str_lum(sd)    ARGUMENTS:   INPUT:        sd:    Array (nt) of star descriptors    OUTPUT:        NONE    KEYWORDS:          NONE   RETURN:        An array (nt) of luminosities.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 5/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_lum.html#str_lum", "str_lum", 'routine in <a href="obj/str/str_lum.html">str_lum.pro</a>', "str_lum.pro", "", "str_lum", "", "noeventsd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/str/str_query.html", "str_query.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_query.pro", "", "", " NAME: 	str_query    PURPOSE: 	Returns the fields associated with a STAR object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/STR    CALLING SEQUENCE: 	str_query, sd, <keywords>=<values>    ARGUMENTS:   INPUT: 	sd:	STAR object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	STAR object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_query.html#str_query", "str_query", 'routine in <a href="obj/str/str_query.html">str_query.pro</a>', "str_query.pro", "", "str_query", "", "conditioncatnoeventxd@str__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/str/str_replicate.html", "str_replicate.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_replicate.pro", "", "", " NAME: 	str_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/STR    CALLING SEQUENCE: 	sds = str_replicate(sd, dim)    ARGUMENTS:   INPUT: 	sd:	 Star descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_replicate.html#str_replicate", "str_replicate", 'routine in <a href="obj/str/str_replicate.html">str_replicate.pro</a>', "str_replicate.pro", "", "str_replicate", "", "sddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/str/str_set_lum.html", "str_set_lum.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_set_lum.pro", "", "", " NAME: 	str_set_lum    PURPOSE: 	Replaces the luminosities for each given star descriptor.    CATEGORY: 	NV/LIB/STR    CALLING SEQUENCE: 	str_set_lum, sd, lum    ARGUMENTS:   INPUT: 	sd:	 Array (nt) of any subclass of STAR.  	lum:	 Array (nt) of new luminosity values.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_set_lum.html#str_set_lum", "str_set_lum", 'routine in <a href="obj/str/str_set_lum.html">str_set_lum.pro</a>', "str_set_lum.pro", "", "str_set_lum", "", "noeventsdlum", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/str/str_set_sp.html", "str_set_sp.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_set_sp.pro", "", "", " NAME: 	str_set_sp    PURPOSE: 	Replaces the spectra class for each given star descriptor.    CATEGORY: 	NV/LIB/STR    CALLING SEQUENCE: 	str_set_sp, sd, sp    ARGUMENTS:   INPUT: 	sd:	 Array (nt) of any subclass of STAR.  	sp:	 Array (nt) of new sp strings.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_set_sp.html#str_set_sp", "str_set_sp", 'routine in <a href="obj/str/str_set_sp.html">str_set_sp.pro</a>', "str_set_sp.pro", "", "str_set_sp", "", "noeventsdsp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/str/str_sp.html", "str_sp.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_sp.pro", "", "", " NAME:        str_sp    PURPOSE:        Returns a spectral type for each given star descriptor.    CATEGORY:        NV/LIB/STR    CALLING SEQUENCE:        result = str_sp(sd)    ARGUMENTS:   INPUT:        sd:    Array (t) of star descriptors    OUTPUT:        NONE    KEYWORDS:          NONE   RETURN:        An array (nt) of spectral types which is a three character string.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 5/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_sp.html#str_sp", "str_sp", 'routine in <a href="obj/str/str_sp.html">str_sp.pro</a>', "str_sp.pro", "", "str_sp", "", "noeventsd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/sub_latlon.html", "sub_latlon.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "sub_latlon.pro", "", "", " NAME: 	sub_latlon    PURPOSE: 	Computes sub-observer latitude and longitude on a globe.   CATEGORY: 	NV/LIB/TOOLS    CALLING SEQUENCE:     result = sub_latlon(gbx, v, sublat, sublon)    ARGUMENTS:   INPUT: 	gbx:	Array (nt) of any subclass of GLOBE.  	v:	Array (nv,3,nt) giving the observer position in the BODY frame.    OUTPUT: 	sublat:	Array (nv,nt) of latitude of sub-observer point on gbx.  	sublon:	Array (nv,nt) of longitude of sub-observer point on gbx.    KEYWORDS:   INPUT: 	graphic:   If set, use planetographic coordinates.    OUTPUT: 	body_pt:	Array (nv,3,nt) giving the sub-observer point in 			BODY coordinates.  	surf_pt:	Array (nv,3,nt) giving the sub-observer point in 			SURFACE coordinates.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/sub_latlon.html#sub_latlon", "sub_latlon", 'routine in <a href="obj/tools/sub_latlon.html">sub_latlon.pro</a>', "sub_latlon.pro", "", "sub_latlon", "", "body_ptsurf_ptgraphicgbxvsublatsublon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_hide_points.html", "surface_hide_points.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_hide_points.pro", "", "", " NAME: 	surface_hide_points    PURPOSE: 	Hides points with respect to surface objects.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE: 	sub = surface_hide_points(bx, v, r)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY descriptors with 		the expected surface parameters.  	v:	Array (nv,3,nt) giving viewer positions in the BODY frame.  	r:	Array (nv,3,nt) giving points to hide in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Subscripts of the points in p that are hidden by the object.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_hide_points.html#surface_hide_points", "surface_hide_points", 'routine in <a href="obj/tools/composite/surface_hide_points.html">surface_hide_points.pro</a>', "surface_hide_points.pro", "", "surface_hide_points", "", "bxvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_image_bounds.html", "surface_image_bounds.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_image_bounds.pro", "", "", " NAME:        surface_image_bounds    PURPOSE: 	Computes latitude / longitude ranges visible in an image.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        surface_image_bounds, cd, bx, $ 	            latmin=latmin, latmax=latmax, lonmin=lonmin, lonmax=lonmax    ARGUMENTS:   INPUT: 	cd:      Camera descriptor  	bx:      Object descriptor (subclass of BODY)     OUTPUT: NONE    KEYWORDS:    INPUT: 	slop:	Amount, in pixels, by which to expand the image size 		considered in the calcultaion.     OUTPUT: 	border_pts_im:	Image points on the border of the image defined by cd.  	latmin:	Minimum latitude covered in image  	latmax:	Maximum latitude covered in image  	lonmin:	Minimum longitude covered in image  	lonmax:	Maximum longitude covered in image    RETURN: NONE    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_image_bounds.html#surface_image_bounds", "surface_image_bounds", 'routine in <a href="obj/tools/composite/surface_image_bounds.html">surface_image_bounds.pro</a>', "surface_image_bounds.pro", "", "surface_image_bounds", "", "slopborder_pts_imlatminlatmaxlonminlonmaxstatuscdbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_intersect.html", "surface_intersect.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_intersect.pro", "", "", " NAME: 	surface_intersect    PURPOSE: 	Computes the intersection of rays with surface objects.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE: 	int_pts = surface_intersect(bx, v, r)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY descriptors with 		the expected surface parameters.  	v:	Array (nv,3,nt) giving ray origins in the BODY frame.  	r:	Array (nv,3,nt) giving ray directions in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2*nv,3,nt) of points in the BODY frame, where 	int_pts[0:nv-1,*,*] correspond to the near-side intersections 	and int_pts[nv:2*nv-1,*,1] correspond to the far side.  Zero 	vector is returned for points with no solution.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_intersect.html#surface_intersect", "surface_intersect", 'routine in <a href="obj/tools/composite/surface_intersect.html">surface_intersect.pro</a>', "surface_intersect.pro", "", "surface_intersect", "", "hitnearfarbxvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/surface_normal.html", "surface_normal.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "surface_normal.pro", "", "", " NAME: 	surface_normal    PURPOSE: 	Computes the normal at points on a surface.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE: 	norm_pts = surface_normal(bx, r)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY descriptors with 		the expected surface parameters.  	v:	Array (nv,3,nt) giving observer positions in the BODY frame.  	r:	Array (nv,3,nt) giving surface positions in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: 	frame_bd:  Frame descriptor, if required for bx.  	north:     Passed to dsk_surface_normal.  Causes surface normal 	           to point north regardless of observer position.    OUTPUT: NONE    RETURN: 	Array (nv, 3, nt) of surface unit normals in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/surface_normal.html#surface_normal", "surface_normal", 'routine in <a href="obj/tools/surface_normal.html">surface_normal.pro</a>', "surface_normal.pro", "", "surface_normal", "", "frame_bdnorthbxvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_normal.html", "surface_normal.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_normal.pro", "", "", " NAME: 	surface_normal    PURPOSE: 	Computes the normal at points on a surface.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE: 	norm_pts = surface_normal(bx, v, r)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY descriptors with 		the expected surface parameters.  	v:	Array (nv,3,nt) giving observer positions in the BODY frame.  	r:	Array (nv,3,nt) giving surface positions in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: 	north:     Passed to dsk_surface_normal.  Causes surface normal 	           to point north regardless of observer position.    OUTPUT: NONE    RETURN: 	Array (nv, 3, nt) of surface unit normals in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_normal.html#surface_normal", "surface_normal", 'routine in <a href="obj/tools/composite/surface_normal.html">surface_normal.pro</a>', "surface_normal.pro", "", "surface_normal", "", "northbxvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_body.html", "surface_to_body.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_to_body.pro", "", "", " NAME:        surface_to_body    PURPOSE:        Transforms points in any surface coordinate system to body 	coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = surface_to_body(bx, surface_pts)    ARGUMENTS:   INPUT: 	bx:      Array of nt object descriptors (subclass of BODY).  	surface_pts:       Array (nv x 3 x nt) of surface points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of body coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_body.html#surface_to_body", "surface_to_body", 'routine in <a href="obj/tools/composite/surface_to_body.html">surface_to_body.pro</a>', "surface_to_body.pro", "", "surface_to_body", "", "bxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/surface_to_degrees.html", "surface_to_degrees.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "surface_to_degrees.pro", "", "", " NAME:        surface_to_degrees    PURPOSE:        Converts angular part of surface vectors from radians to degrees    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = surface_to_degrees(v)    ARGUMENTS:   INPUT:               v:       An array of surface vectors (nv,3,nt).    OUTPUT:        NONE   RETURN:        Array of vectors (nv,3,nt)   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale		11/12/01  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/surface_to_degrees.html#surface_to_degrees", "surface_to_degrees", 'routine in <a href="obj/tools/surface_to_degrees.html">surface_to_degrees.pro</a>', "surface_to_degrees.pro", "", "surface_to_degrees", "", "v", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_image.html", "surface_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_to_image.pro", "", "", " NAME:        surface_to_image    PURPOSE:        Transforms points in any surface coordinate system to image 	coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = surface_to_image(cd, bx, surface_pts)    ARGUMENTS:   INPUT: 	cd:      Array of nt camera or map descriptors.  	bx:      Array of nt object descriptors (subclass of BODY).  	surface_pts:       Array (nv x 3 x nt) of surface points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (2 x nv x nt) of image points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_image.html#surface_to_image", "surface_to_image", 'routine in <a href="obj/tools/composite/surface_to_image.html">surface_to_image.pro</a>', "surface_to_image.pro", "", "surface_to_image", "", "body_ptsvalidcdbxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_map.html", "surface_to_map.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_to_map.pro", "", "", " NAME:        surface_to_map    PURPOSE:        Transforms points in any surface coordinate system to map 	coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = surface_to_map(md, bx, surface_pts)    ARGUMENTS:   INPUT: 	md:      Array of nt map descriptors.  	bx:      Array of nt object descriptors (subclass of BODY.  	surface_pts:       Array (nv x 3 x nt) of surface points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (2 x nv x nt) of map coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_map.html#surface_to_map", "surface_to_map", 'routine in <a href="obj/tools/composite/surface_to_map.html">surface_to_map.pro</a>', "surface_to_map.pro", "", "surface_to_map", "", "mdbxsurface_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/synth_image.html", "synth_image.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "synth_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/synth_image.html#synth_image", "synth_image", 'routine in <a href="obj/tools/synth_image.html">synth_image.pro</a>', "synth_image.pro", "", "synth_image", "", "rdcdpdsund", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/ta_to_az.html", "ta_to_az.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "ta_to_az.pro", "", "", " NAME:        ta_to_az    PURPOSE: 	Computes azimuths relative to a given observer descriptor.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = ta_to_az(ta, dkx, od)    ARGUMENTS:   INPUT: 	ta:	Longitude.  	dkx:	Disk descriptor.  	od:	Object descriptor (subclass of BODY) describing the observer.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        An array of azimuths.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/ta_to_az.html#ta_to_az", "ta_to_az", 'routine in <a href="obj/tools/composite/ta_to_az.html">ta_to_az.pro</a>', "ta_to_az.pro", "", "ta_to_az", "", "tadkxod", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/target_altaz.html", "target_altaz.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "target_altaz.pro", "", "", " NAME: 	target_altaz    PURPOSE: 	Computes altitude/azimuth of a target relative to a point on or near the 	surface of a globe.   CATEGORY: 	NV/LIB/TOOLS    CALLING SEQUENCE:     result = target_altaz(bx, gbx, lat, lon, alt)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY giving the target.  	gbx:	Array (nt) of any subclass of GLOBE.  	lat:	Latitude of observer wrt gbx.  	lon:	Longitude of observer wrt gbx.  	alt:	Altitude of observer wrt gbx.    OUTPUT:         NONE   KEYWORDS:   INPUT: 	  cd:	Camera descriptor.           gd:   Optional generic descriptor containing cd.    OUTPUT:     profile:   The profile.        sigma:   Array giving the standard deviation at each point in the 		profile.      distance:  Array giving the distance, in pixels, along the profile.    RETURN: 	Vector from observer to target in the altaz system.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/target_altaz.html#target_altaz", "target_altaz", 'routine in <a href="obj/tools/target_altaz.html">target_altaz.pro</a>', "target_altaz.pro", "", "target_altaz", "", "bxpdlatlonalt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/dat/tr_keyword_value.html", "tr_keyword_value.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "tr_keyword_value.pro", "", "", " NAME: 	tr_keyword_value    PURPOSE: 	Looks up a keyword in the data descriptor-stored keyword/value pairs.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	value = tr_keyword_value(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  If an array, only the first element is 			considered.  	keyword:	Keyword to look up.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Value string associated with the given keyword.  Note that transient 	keyword/value pairs take precedence.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/tr_keyword_value.html#trkv_match", "trkv_match", 'routine in <a href="obj/dat/tr_keyword_value.html">tr_keyword_value.pro</a>', "tr_keyword_value.pro", "", "trkv_match", "", "valuekvikeyword", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dat/tr_keyword_value.html#trkv_parse", "trkv_parse", 'routine in <a href="obj/dat/tr_keyword_value.html">tr_keyword_value.pro</a>', "tr_keyword_value.pro", "", "trkv_parse", "", "value", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/dat/tr_keyword_value.html#tr_keyword_value", "tr_keyword_value", 'routine in <a href="obj/dat/tr_keyword_value.html">tr_keyword_value.pro</a>', "tr_keyword_value.pro", "", "tr_keyword_value", "", "ddkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/tvxmap.html", "tvxmap.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "tvxmap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/tvxmap.html#tvxmap", "tvxmap", 'routine in <a href="obj/tools/tvxmap.html">tvxmap.pro</a>', "tvxmap.pro", "", "tvxmap", "", "colorfndatamaxminradiusweightbinoffset_xmap_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/warp_cp.html", "warp_cp.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "warp_cp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/warp_cp.html#wcp_add_quad", "wcp_add_quad", 'routine in <a href="obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_add_quad", "", "triijquadnquadqtrip0", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/warp_cp.html#wcp_longest_side", "wcp_longest_side", 'routine in <a href="obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_longest_side", "", "p0tripq", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/warp_cp.html#wcp_requadrangulate", "wcp_requadrangulate", 'routine in <a href="obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_requadrangulate", "", "p0triqtri", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/warp_cp.html#wcp_map_quad_coords", "wcp_map_quad_coords", 'routine in <a href="obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_map_quad_coords", "", "x0y0p0p1quadx1y1", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/warp_cp.html#wcp_map_quad", "wcp_map_quad", 'routine in <a href="obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_map_quad", "", "cdinterpimagep0p1quadtriqtrisize", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/warp_cp.html#wcp_map_tri_coords", "wcp_map_tri_coords", 'routine in <a href="obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_map_tri_coords", "", "x0y0p0p1trix1y1", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/warp_cp.html#wcp_map_tri", "wcp_map_tri", 'routine in <a href="obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_map_tri", "", "cdimagep0p1trisize", "          -1", "");
  
  libdata[libdataItem++] = new Array("obj/tools/warp_cp.html#warp_cp", "warp_cp", 'routine in <a href="obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "warp_cp", "", "cdsizequadinterpimagep0p1", "          -1", "");
  
  

