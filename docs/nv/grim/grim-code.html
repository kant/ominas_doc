<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 14:17:37 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>grim.pro (OMINAS Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="grim.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	GRIM</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	General-purpose GRaphical Interface for oMinas.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	</span>
<span class="comments">;	grim, arg1, arg2</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;  INPUT:</span>
<span class="comments">;	arg1, arg2:	</span>
<span class="comments">;		Grim accepts up to two arguments, which can appear in either </span>
<span class="comments">;		order.  Possible arguments are:</span>
<span class="comments">;</span>
<span class="comments">; 			data descriptors (object)</span>
<span class="comments">;			file specification (string)</span>
<span class="comments">; 			grnum (scalar)</span>
<span class="comments">; 			plot (1d array)</span>
<span class="comments">; 			image (2d array)</span>
<span class="comments">; 			cube (3d array)</span>
<span class="comments">;</span>
<span class="comments">;	Plots are displayed as graphs whose abscissa are the array index, unless</span>
<span class="comments">;	an abscissa is present in the data descriptor.  Many functions are not </span>
<span class="comments">;	available in this mode.  </span>
<span class="comments">;</span>
<span class="comments">;	Cubes are handled as multiple image planes unless /rgb is used </span>
<span class="comments">;	(see below).  All grim planes will contain the same data array,</span>
<span class="comments">;	but display only data ranges corresponding to one channel of the cube.</span>
<span class="comments">;	For /rgb (assuming the cube has three channels), the data are placed </span>
<span class="comments">;	on a single image plane with each cube channel assigned the R, G, or B </span>
<span class="comments">;	color channel.</span>
<span class="comments">;	</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;  INPUT:</span>
<span class="comments">;	Descriptor Keywords</span>
<span class="comments">;	-------------------</span>
<span class="comments">;	The following inputs replace objects already maintained by GRIM.  For </span>
<span class="comments">;	the case of a single plane, all given descriptors are placed in that </span>
<span class="comments">;	plane.  In that case, only one cd, od, or sund are allowed.  For a cube,</span>
<span class="comments">;	cd and od must have either one element, or the same number of elements </span>
<span class="comments">;	as the number of channels in the cube, and are assigned one-to-one to </span>
<span class="comments">;	the grim planes.  In this case, all other decriptors are assigned to all </span>
<span class="comments">;	planes.  For multiple images, descriptors are assigned to planes by </span>
<span class="comments">;	matching their generic decsriptor dd fields (or assoc_dd if given) to </span>
<span class="comments">;	the data descriptor for each plane.  </span>
<span class="comments">;</span>
<span class="comments">;	 cd:	Replaces the current camera descriptor.  This may also be </span>
<span class="comments">;		a map descriptor, in which case some of GRIM's functions </span>
<span class="comments">;		will not be available.  When using a map descriptor instead </span>
<span class="comments">;		of a camera descriptor, you can specify a camera descriptor </span>
<span class="comments">;		as the observer descriptor (see the 'od' keyword below) and </span>
<span class="comments">;		some additional geometry functions will be available.</span>
<span class="comments">;</span>
<span class="comments">;	 od:	Replaces the current observer descriptor.  The observer</span>
<span class="comments">;		descriptor is used to allow some geometry objects (limb,</span>
<span class="comments">;		terminator) to be computed when using a map descriptor instead</span>
<span class="comments">;		of a camera descriptor.</span>
<span class="comments">;</span>
<span class="comments">;	 sund:	Replaces the current sun descriptor.</span>
<span class="comments">;</span>
<span class="comments">;	 pd:	Adds/replaces planet descriptors.</span>
<span class="comments">;</span>
<span class="comments">;	 rd:	Adds/replaces ring descriptors.</span>
<span class="comments">;</span>
<span class="comments">;	 sd:	Adds/replaces star descriptors.</span>
<span class="comments">;</span>
<span class="comments">;	 std:	Adds/replaces station descriptors</span>
<span class="comments">;</span>
<span class="comments">;	 ard:	Adds/replaces array descriptors</span>
<span class="comments">;</span>
<span class="comments">;	 gd:	Generic descriptor containing some or all of the above </span>
<span class="comments">;		descriptors.</span>
<span class="comments">;</span>
<span class="comments">;	 assoc_dd: </span>
<span class="comments">;		If given, use these data descriptors to assign descriptors to </span>
<span class="comments">;		planes instead of matching the data descriptors from their</span>
<span class="comments">;		generic descriptors.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;	Descriptor Select Keywords</span>
<span class="comments">;	--------------------------</span>
<span class="comments">;	Descriptor select keywords (see pg_get_*) are specified using the</span>
<span class="comments">;	standard prefix corresponding to the descriptor type.  For example, </span>
<span class="comments">;	the fov keyword to pg_get_planets would be given to grim as plt_fov.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;	Initial Colormap Keywords</span>
<span class="comments">;	-------------------------</span>
<span class="comments">;	The colormap structure (see colormap_descriptor__define) can be</span>
<span class="comments">;	be initialized via keywords prefied with 'cmd_', e.g., 'cmd_shade'.</span>
<span class="comments">;	In addition, the following keywords apply to the initial color map:</span>
<span class="comments">;</span>
<span class="comments">;	*auto_stretch:</span>
<span class="comments">;		If set, the color table for each plane is automatically</span>
<span class="comments">;		stretched.  This is identical to using the 'Auto' button</span>
<span class="comments">;		on on the grim color tool.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;	Translator Keywords</span>
<span class="comments">;	-------------------</span>
<span class="comments">;	The following keywords are passed directly to the translators, which</span>
<span class="comments">;	are responsible for interpreting their meanings.</span>
<span class="comments">;</span>
<span class="comments">;	*cam_trs:</span>
<span class="comments">;		String giving translator keywords for the camera descriptors.</span>
<span class="comments">;</span>
<span class="comments">;	*sun_trs: </span>
<span class="comments">;		String giving translator keywords for the sun descriptors.</span>
<span class="comments">;</span>
<span class="comments">;	*plt_trs: </span>
<span class="comments">;		String giving translator keywords for the planet descriptors.</span>
<span class="comments">;</span>
<span class="comments">; 	*rng_trs: </span>
<span class="comments">;		String giving translator keywords for the ring descriptors.</span>
<span class="comments">;</span>
<span class="comments">; 	*str_trs: </span>
<span class="comments">;		String giving translator keywords for the star descriptors.</span>
<span class="comments">;</span>
<span class="comments">; 	*stn_trs: </span>
<span class="comments">;		String giving translator keywords for the stations descriptors.</span>
<span class="comments">;</span>
<span class="comments">; 	*arr_trs: </span>
<span class="comments">;		String giving translator keywords for the array descriptors.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;	TVIM Keywords</span>
<span class="comments">;	-------------</span>
<span class="comments">;	The following keywords set the initial viewing parameters and are</span>
<span class="comments">;	simply passed to TVIM.  </span>
<span class="comments">;</span>
<span class="comments">;	*xsize:	Size of the graphics window in the x direction.  Defaults to</span>
<span class="comments">;		400 pixels.</span>
<span class="comments">;</span>
<span class="comments">;	*ysize:	Size of the graphics window in the y direction.  Defaults to</span>
<span class="comments">;		400 pixels.</span>
<span class="comments">;</span>
<span class="comments">;	*zoom:	Initial zoom to be applied to the image.  If not given, grim</span>
<span class="comments">;		computes an initial zoom such that the entire image fits on the</span>
<span class="comments">;		screen.</span>
<span class="comments">;</span>
<span class="comments">;	*rotate:	</span>
<span class="comments">;		Initial rotate value to be applied to the image (as in the IDL</span>
<span class="comments">;		ROTATE routine).  If not given, 0 is assumed.</span>
<span class="comments">;</span>
<span class="comments">;	*order:	Initial display order to be applied to the image.</span>
<span class="comments">;</span>
<span class="comments">;	*offset:	</span>
<span class="comments">;		Initial offset (dx,dy) to be applied to the image.</span>
<span class="comments">;	</span>
<span class="comments">;	 doffset: </span>
<span class="comments">;		Change the offset viewing parameter by this amount.</span>
<span class="comments">;</span>
<span class="comments">;	 default: </span>
<span class="comments">;		If set, use default tvim properties (zoom=[1,1], offset=[0,0]</span>
<span class="comments">;               order=0 [bottom-up])</span>
<span class="comments">;</span>
<span class="comments">;	 previous: </span>
<span class="comments">;		If set, restore last-used tvim viewing parameters.</span>
<span class="comments">;</span>
<span class="comments">;	 restore: </span>
<span class="comments">;		If set, use saved tvim viewing paramters.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;	Customization Keywords</span>
<span class="comments">;	----------------------</span>
<span class="comments">;	*menu_extensions:</span>
<span class="comments">;		Array of strings giving the names of functions that return</span>
<span class="comments">;		menu definitions, as defined by cw_pdmenu.  These menus are </span>
<span class="comments">;		added to the built-in GRIM menus between the Overlays menu</span>
<span class="comments">;		and the Help menu.  The default is 'grim_default_menus'.  If</span>
<span class="comments">;		the first character in the first menu function is '+', then</span>
<span class="comments">;		grim_default_menus is retained an the new menu are appended</span>
<span class="comments">;		after that menu.  Otherwise, 'grim_default_menus' is replaced.</span>
<span class="comments">;</span>
<span class="comments">;	*button_extensions:</span>
<span class="comments">;		Array of strings giving the names of definition functions</span>
<span class="comments">;		for custom cursor modes to be added after the built-in</span>
<span class="comments">;		cursor modes.  The definition function takes one argument </span>
<span class="comments">;		(see arg_extensions below) and returns a grim_user_mode_struct.</span>
<span class="comments">;</span>
<span class="comments">;	*arg_extensions:</span>
<span class="comments">;		Argument to be provided to the button extension definition</span>
<span class="comments">;		function above. </span>
<span class="comments">;</span>
<span class="comments">;	*menu_fname:	</span>
<span class="comments">;		Name of a file containing additional menus to add to</span>
<span class="comments">;		the grim widget.  The file syntax follows that for cw_pdmenu.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;	Other Keywords</span>
<span class="comments">;	--------------</span>
<span class="comments">;	*extensions:</span>
<span class="comments">;		String array giving extensions to try for each input file.</span>
<span class="comments">;		see dat_read.</span>
<span class="comments">;</span>
<span class="comments">;	*new:	If set, a new grim instance is created and all keywords apply</span>
<span class="comments">;		to that instance.</span>
<span class="comments">;</span>
<span class="comments">;	 erase:	If set, erase the current image before doing anything else.</span>
<span class="comments">;</span>
<span class="comments">;	*mode_init:</span>
<span class="comments">;		Initial cursor mode.  See below.</span>
<span class="comments">;</span>
<span class="comments">;	*mode_args:</span>
<span class="comments">;		Array giving arguments for the cursor modes initialization</span>
<span class="comments">;		functions.  If a string, then syntax is NAME:ARG, where NAME </span>
<span class="comments">;		is the name of the cursor mode, and ARG is the argument for </span>
<span class="comments">;		that mode.  For example:</span>
<span class="comments">;</span>
<span class="comments">;			mode_args='READOUT:myreadout_fn'</span>
<span class="comments">;</span>
<span class="comments">;		would cause the function 'myreadout_fn' to be added to </span>
<span class="comments">;		the list of functions called by pg_cursor and pg_measure</span>
<span class="comments">;		via the readout cursor mode.  If not a string, the argument </span>
<span class="comments">;		is passed to the initialization function with no processing.</span>
<span class="comments">;</span>
<span class="comments">;	*retain:	</span>
<span class="comments">;		Retain settings for backing store (see "backing store" in </span>
<span class="comments">;		the IDL reference guide).  Defaults to 2.</span>
<span class="comments">;</span>
<span class="comments">;	*clip:	Controls the number of fields of view in which overlays are </span>
<span class="comments">;		computed.</span>
<span class="comments">;</span>
<span class="comments">;	*fov:	Controls the number of fields of view in which to request</span>
<span class="comments">;		planet, ring and star descriptors.  Values are as follows:</span>
<span class="comments">;</span>
<span class="comments">; 			 0 : get all descriptors</span>
<span class="comments">;                  	&lt;0 : relative to viewport</span>
<span class="comments">;                 	>0 : relative to image / optic axis</span>
<span class="comments">;</span>
<span class="comments">;		Note that fov > 0 is the same as setting the fov descriptor</span>
<span class="comments">;		select keywords (see above).  Default is 0, but stars operate</span>
<span class="comments">;		best when fov > 0.</span>
<span class="comments">;</span>
<span class="comments">;	*hide:	If set, overlays are hidden w.r.t shadows and obstructions.</span>
<span class="comments">; 		Default is on. </span>
<span class="comments">;</span>
<span class="comments">;	 no_erase: </span>
<span class="comments">;		If set, GRIM does not erase the draw window.  When called.</span>
<span class="comments">;</span>
<span class="comments">;	*rgb:	If set, grim interprets a 3-plane cube as a 3-channel image</span>
<span class="comments">;               to be displayed on a single plane.</span>
<span class="comments">;</span>
<span class="comments">;	*channel: </span>
<span class="comments">;		Array of bitmasks specifying the color channel in which to </span>
<span class="comments">;		display each given image: 1b, 2b, or 4b.</span>
<span class="comments">;</span>
<span class="comments">;	*visibility: </span>
<span class="comments">;		Initial visibility setting for planes:</span>
<span class="comments">;</span>
<span class="comments">;                	0: Only the current plane is drawn.</span>
<span class="comments">;                	1: All planes are drawn.</span>
<span class="comments">;</span>
<span class="comments">;                Default is 0.</span>
<span class="comments">;</span>
<span class="comments">;	*max:	Maximum data value to scale to when displaying images.  </span>
<span class="comments">;		Values larger than this are set to the maximum color table </span>
<span class="comments">;		index.  If not set, the maximum value in the data set is used.  </span>
<span class="comments">;		In cases where the data array is being subsampled, this value </span>
<span class="comments">;		may not be known, resulting in varying image scaling as more </span>
<span class="comments">;		and more data values are sampled.  That problem may be</span>
<span class="comments">;		eliminated via this keyword.</span>
<span class="comments">;</span>
<span class="comments">;	 exit:	If set, GRIM immediately exits.  This can be used to kill an</span>
<span class="comments">;		existing GRIM window.</span>
<span class="comments">;</span>
<span class="comments">;	 modal:	If set, grim is run as a modal widget, i.e., there is no command</span>
<span class="comments">;		prompt.</span>
<span class="comments">;</span>
<span class="comments">;	*frame:	If set, the initial view is set such that all members of the </span>
<span class="comments">;		named overlay types are are visible.  If /frame, then all</span>
<span class="comments">;		overlays are framed.  Note that object types that rely on the</span>
<span class="comments">;		view to determine which objects to compute (e.g., stars) </span>
<span class="comments">;		cannot be framed in this way.  </span>
<span class="comments">;</span>
<span class="comments">;	 refresh_callbacks: </span>
<span class="comments">;		Array of strings giving the names of procedures to be </span>
<span class="comments">;		called after each refresh.  See CALLBACK PROCEDURES</span>
<span class="comments">;		below.  Refresh callbacks receive only the data argument.</span>
<span class="comments">;</span>
<span class="comments">;	 refresh_callback_data_ps: </span>
<span class="comments">;		Array of pointers (one per callback) to data for the refresh </span>
<span class="comments">;		callback procedures specified using the refresh_callbacks </span>
<span class="comments">;		keyword.  See CALLBACK PROCEDURES below.  </span>
<span class="comments">;</span>
<span class="comments">;	 plane_callbacks: </span>
<span class="comments">;		Array of strings giving the names of procedures to be </span>
<span class="comments">;		called after each plane change.  See CALLBACK PROCEDURES</span>
<span class="comments">;		below.  Plane callbacks receive only the data argument.</span>
<span class="comments">;</span>
<span class="comments">;	 plane_callback_data_ps: </span>
<span class="comments">;		Array of pointers (one per callback) to data for the plane </span>
<span class="comments">;		callback procedures specified using the plane_callbacks </span>
<span class="comments">;		keyword.  See CALLBACK PROCEDURES below.  </span>
<span class="comments">;</span>
<span class="comments">;	*nhist:	History setting to be applied to data decriptor (see </span>
<span class="comments">;		ominas_data__define).  GRIM uses data descriptor history to </span>
<span class="comments">;		undo changes to the data array.  If nhist is not set, or is </span>
<span class="comments">;		equal to 1, the undo menu option will not function.</span>
<span class="comments">;</span>
<span class="comments">;	*maintain: </span>
<span class="comments">;		If given, this maintainance setting is applied to the data</span>
<span class="comments">;		descriptor (see ominas_data__define).</span>
<span class="comments">;</span>
<span class="comments">;	*compress: </span>
<span class="comments">;		Compression setting to be applied to data decriptor (see </span>
<span class="comments">;		ominas_data__define).  </span>
<span class="comments">;</span>
<span class="comments">;	*filter:</span>
<span class="comments">;		Initial filter to use when loading or browsing files.</span>
<span class="comments">;</span>
<span class="comments">;	*load_path: </span>
<span class="comments">;		Initial path for the file loading dialog.</span>
<span class="comments">;</span>
<span class="comments">;	*save_path: </span>
<span class="comments">;		Initial path for the file saving dialog.</span>
<span class="comments">;</span>
<span class="comments">;	*path:	Sets both load_path and save_path to this value.</span>
<span class="comments">;</span>
<span class="comments">;	*workdir: </span>
<span class="comments">;		Default directory for saving user points, masks, tie </span>
<span class="comments">;		points, curves</span>
<span class="comments">;</span>
<span class="comments">;	 user_psym: </span>
<span class="comments">;		Default plotting symbol for user overlays.  </span>
<span class="comments">;</span>
<span class="comments">;	 grnum:	Identifies a specific GRIM window by number.  Grim numbers are</span>
<span class="comments">;		displayed in the status bar, e.g.: grim &lt;grnum>.</span>
<span class="comments">;</span>
<span class="comments">;	 pn:	Directs GRIM to change to the plane correspondng to this plane </span>
<span class="comments">;		number.</span>
<span class="comments">;</span>
<span class="comments">;	*cursor_swap: </span>
<span class="comments">;		If set, cursor bitmaps are byte-order swapped.</span>
<span class="comments">;</span>
<span class="comments">;	*loadct: </span>
<span class="comments">;		Index of color table to load.</span>
<span class="comments">;</span>
<span class="comments">;	*beta:	If set beta features are enabled.</span>
<span class="comments">;</span>
<span class="comments">;	*npoints: </span>
<span class="comments">;		Number of point to compute for various overlays.  Default is 1000.</span>
<span class="comments">;</span>
<span class="comments">; 	*plane_syncing: Turns plane syncing on (1) or off(0).  Default is 0.</span>
<span class="comments">;</span>
<span class="comments">; 	*tiepoint_syncing: Turns tiepoint syncing on (1) or off(0).  Default is 0.</span>
<span class="comments">;</span>
<span class="comments">; 	*curve_syncing: Turns curve syncing on (1) or off(0).  Default is 0.</span>
<span class="comments">;</span>
<span class="comments">; 	 position: </span>
<span class="comments">;		Sets the plot position; see the POSITION grahics keyword.</span>
<span class="comments">;</span>
<span class="comments">; 	 color:	Sets the line color index for plots.  One element per plane.</span>
<span class="comments">;</span>
<span class="comments">; 	 xrange: </span>
<span class="comments">;		Sets the X-axis range for plots.</span>
<span class="comments">;</span>
<span class="comments">; 	 yrange: </span>
<span class="comments">;		Sets the Y-axis range for plots.</span>
<span class="comments">;</span>
<span class="comments">;	 thick:	Sets the line thickness for plots.  One element per plane.</span>
<span class="comments">;</span>
<span class="comments">;	 title:	For plots, sets the plot title for plots; one element per plane.</span>
<span class="comments">;		For images, sets the base default title.</span>
<span class="comments">;</span>
<span class="comments">;	 xtitle: </span>
<span class="comments">;		Sets the X-axis label for plots.  One element per plane.</span>
<span class="comments">;</span>
<span class="comments">;	 ytitle: </span>
<span class="comments">;		Sets the Y-axis label for plots.  One element per plane.</span>
<span class="comments">;</span>
<span class="comments">;	 psym:	Sets the plotting symbol for plots.  One element per plane.</span>
<span class="comments">;</span>
<span class="comments">;	 nsum:	See OPLOT.  One element per plane.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;	*overlays: </span>
<span class="comments">;		List of initial overlays to compute on startup.  Each element</span>
<span class="comments">;		is of the form:</span>
<span class="comments">;</span>
<span class="comments">;                          type[:name1,name2,...]</span>
<span class="comments">;</span>
<span class="comments">;		where 'type' is one of {limb, terminator, planet_center, </span>
<span class="comments">;		star, ring, planet_grid, array, station} and the names </span>
<span class="comments">;		identify the name of the desired object.  Note that grim </span>
<span class="comments">;		will load more objects than named if required by another </span>
<span class="comments">;		startup overlay.  For example:</span>
<span class="comments">;</span>
<span class="comments">;                         overlays='ring:a_ring'</span>
<span class="comments">;</span>
<span class="comments">;		will cause only one ring descriptor to load, whereas</span>
<span class="comments">;</span>
<span class="comments">;                         overlays=['limb:saturn', 'ring:a_ring']</span>
<span class="comments">;</span>
<span class="comments">;		will cause all of Saturn's rings to load because they are</span>
<span class="comments">;		required in computing the limb points (for hiding).</span>
<span class="comments">;</span>
<span class="comments">;		Different results may be obtained using translator keywords, </span>
<span class="comments">;		because those keywords are evaluated at the translator level.  </span>
<span class="comments">;		For example:</span>
<span class="comments">;</span>
<span class="comments">;			overlays='ring:fn54'</span>
<span class="comments">;</span>
<span class="comments">;		may result in no ring, while:</span>
<span class="comments">;</span>
<span class="comments">;			overlays='ring', trs_rd='name=fn54'</span>
<span class="comments">;</span>
<span class="comments">;		would be more likely to yield a ring.  In the former example,</span>
<span class="comments">;		the specified name is compared against whatever default ring</span>
<span class="comments">;		descriptors are returned by the tranlators, while in the latter</span>
<span class="comments">;		case, the 'name' translator keyword is compared against all</span>
<span class="comments">;		rings available to the translator.</span>
<span class="comments">; </span>
<span class="comments">;</span>
<span class="comments">;	*delay_overlays:</span>
<span class="comments">;		If set, initial overlays (see 'overlays' above) are not computed </span>
<span class="comments">;		until the first time they are accessed.  This option can greatly</span>
<span class="comments">;		improve performance in cases where a large number of image planes</span>
<span class="comments">;		are loaded with initial overlays, particularly if it is not</span>
<span class="comments">;		expected that all planes will necesarily be viewed or otherwise</span>
<span class="comments">;		accessed.  Typically this option will cause overlays to be</span>
<span class="comments">;		computed only for the initially visible planes, with other</span>
<span class="comments">;		planes loading overlays only as they are made visible.  However, </span>
<span class="comments">;		there may be other cirumstances that can cause initial overlays </span>
<span class="comments">;		to be loaded without actually viewing a plane.</span>
<span class="comments">; </span>
<span class="comments">;	*activate: </span>
<span class="comments">;		If set, inital overlay are activated.</span>
<span class="comments">;</span>
<span class="comments">;	*ndd: 	Sets the global ndd value in the OMINAS sate structure, which</span>
<span class="comments">;		controls the maximum number of data descriptors with maintain == 1 </span>
<span class="comments">;		to keep in memory at any given time</span>
<span class="comments">;</span>
<span class="comments">;	*render_sample:</span>
<span class="comments">;		Over-sampling value for rendering.  See pg_render.</span>
<span class="comments">;</span>
<span class="comments">;	*render_pht_min:</span>
<span class="comments">;		Minimum value to assign to photometric output in renderings.</span>
<span class="comments">;		See pg_render.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;	Incomplete Keywords</span>
<span class="comments">;	-------------------</span>
<span class="comments">;	*rendering:</span>
<span class="comments">;		If set, perform a rendering on the initial descriptor set.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; RESOURCE FILE:</span>
<span class="comments">;	The keywords marked above with an asterisk may be overridden using </span>
<span class="comments">;	the file $HOME/.ominas/grimrc.  Keyword=value pairs may be entered, one per</span>
<span class="comments">;	line, using the same syntax as if the keyword were entered on the IDL </span>
<span class="comments">;	command line to invoke grim.  Lines beginning with '#' are ignored.</span>
<span class="comments">;	Keywords entered in the resource file override the default values, and</span>
<span class="comments">;	are themselves overridden by keywords entered on the command line.</span>
<span class="comments">;</span>
<span class="comments">; SHELL INTERFACE</span>
<span class="comments">;	The 'grim' alias may be used to start grim from the shell prompt</span>
<span class="comments">;	via the XIDL interface.  The shell interface accepts all keywords </span>
<span class="comments">;	marked above with an asterisk.  See grim.bat.</span>
<span class="comments">;</span>
<span class="comments">;	Example (assuming the grim alias described in grim.bat): </span>
<span class="comments">;</span>
<span class="comments">;	 % grim -beta data/*.img overlay=planet_center,limb:JUPITER</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ENVIRONMENT VARIABLES:</span>
<span class="comments">;	Grim currently defines no environment variables..</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;	 grim_block:</span>
<span class="comments">;		Keeps track of most recent grim instance and which ones are </span>
<span class="comments">;		selected.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;	Grim operates directly on the memory images of the descriptors that </span>
<span class="comments">;	it is given.  Therefore, those descriptors are modified during </span>
<span class="comments">;	a session.  This architecture allows data to be operated on concurrently</span>
<span class="comments">;	through grim and from the command line; see ingrid.pro for details.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; LAYOUT:</span>
<span class="comments">;	The philosphy that drives GRIM's layout is that the maximum possible </span>
<span class="comments">;	screen space should be devoted to displaying the data.  This policy </span>
<span class="comments">;	allows for many GRIM windows to be used simultaneously without being </span>
<span class="comments">;	obscured by crazy control panels full of buttons, gadgets, widgets, </span>
<span class="comments">;	doodads, whirly-gigs, and what-nots.  The grim layout consists of the </span>
<span class="comments">;	following items:</span>
<span class="comments">;</span>
<span class="comments">;	 Title bar:</span>
<span class="comments">;		The title bar displays the grim window number (grnum),</span>
<span class="comments">;		the current plane number (pn), the total number of planes, the </span>
<span class="comments">;		name field of the data descriptor for the current plane, the</span>
<span class="comments">;		default title (if given; see the title keyword above), and </span>
<span class="comments">;		a string indicating which RGB channels are associated with the</span>
<span class="comments">;		current plane.</span>
<span class="comments">;</span>
<span class="comments">;	 Menu bar: </span>
<span class="comments">;		Most of grim's functionality is accessed through the </span>
<span class="comments">;		system of pulldown menus at the top.  Individual menu</span>
<span class="comments">;		items are described in their own sections.</span>
<span class="comments">;</span>
<span class="comments">;	 Shortcut buttons: </span>
<span class="comments">;		Some commonly used menu options are duplicated as shortcut </span>
<span class="comments">;		buttons arranged horizontally just beneath the menu bar.  The</span>
<span class="comments">;		function of each button is displayed in the status bar (see </span>
<span class="comments">;		below) when the mouse cursor is hovered ove the button.</span>
<span class="comments">;</span>
<span class="comments">;	 Cursor mode buttons: </span>
<span class="comments">;		Cursor mode shortcut buttons are arranged vertically along the </span>
<span class="comments">;		left side of the GRIM window, and as provided as shortcuts</span>
<span class="comments">;		for the corresponding options in the Mode menu.  The following </span>
<span class="comments">;		modes are available:</span>
<span class="comments">;</span>
<span class="comments">;		Activate: </span>
<span class="comments">;			In activate mode, overlay objects may be activated</span>
<span class="comments">;			or deactivated by clicking and/or dragging using the</span>
<span class="comments">;			left or right mouse buttons respectively.  This</span>
<span class="comments">;			activation mechanism allows the user to select which</span>
<span class="comments">;			among a certain type of objects should be used in a</span>
<span class="comments">;			given menu selection.  A left click on an overlay</span>
<span class="comments">;			activates that overlay and a right click deactivates</span>
<span class="comments">;			it.  A double click activates or deactivates all</span>
<span class="comments">;			overlays associated with a given descriptor, or all</span>
<span class="comments">;			stars.  Active overlays appear in the colors selected</span>
<span class="comments">;			in the 'Overlay Settings' menu selection.  Inactive</span>
<span class="comments">;			overlays appear in cyan.  A descriptor is active</span>
<span class="comments">;			whenever any of its overlays are active.</span>
<span class="comments">;</span>
<span class="comments">;		Zoom:	The zoom button puts grim in a zoom cursor mode, wherein</span>
<span class="comments">;			the image zoom and offset are controlled by selecting</span>
<span class="comments">;			a box in the image.  When the box is created using the</span>
<span class="comments">;			left mouse button, zoom and offset are changed so that </span>
<span class="comments">;			the contents of the box best fill the current graphics</span>
<span class="comments">;			window.  When the right button is used, the contents of</span>
<span class="comments">;			the current graphics window are shrunken so as to best</span>
<span class="comments">;			fill the box.  In other words, the left button zooms in</span>
<span class="comments">;			and the right button zooms out.</span>
<span class="comments">;</span>
<span class="comments">;		Pan: 	The pan button puts grim in a pan cursor mode, wherein the </span>
<span class="comments">;			image offset is controlled by selecting an offset vector</span>
<span class="comments">;			using the left mouse button.  The middle button may be</span>
<span class="comments">;			used to center the image on a selected point.</span>
<span class="comments">;</span>
<span class="comments">;		Pixel Readout:	</span>
<span class="comments">;			In pixel readout mode, a text window appears </span>
<span class="comments">;			and displays data about the pixel selected </span>
<span class="comments">;			using the left mouse button.  </span>
<span class="comments">;</span>
<span class="comments">;		Tiepoint: </span>
<span class="comments">;			In tiepoint mode, tiepoints are added using the</span>
<span class="comments">;			left mouse button and deleted using the right button.</span>
<span class="comments">;			Tiepoints appear as crosses identified by numbers.</span>
<span class="comments">;			The use of tiepoints is determined by the particular </span>
<span class="comments">;			option selected by the user.</span>
<span class="comments">;</span>
<span class="comments">;		Curve: </span>
<span class="comments">;			In curve mode, curves are added using the</span>
<span class="comments">;			left mouse button and deleted using the right button.</span>
<span class="comments">;			Curves appear as red lines identified by numbers at</span>
<span class="comments">;			each end.  The use of curves is determined by the </span>
<span class="comments">;			particular option selected by the user.</span>
<span class="comments">;</span>
<span class="comments">;		Mask: </span>
<span class="comments">;			GRIM maintains a mask for each plane whose use is</span>
<span class="comments">;			appication-dependent.  Mask mode allows pixels in the</span>
<span class="comments">;			mask to be toggled on and off.</span>
<span class="comments">;</span>
<span class="comments">;		Magnify: </span>
<span class="comments">;			In magnify mode, image pixels in the graphics</span>
<span class="comments">;			window may be magnifed using either the right or left</span>
<span class="comments">;			mouse buttons.  The left button magnifies the displayed</span>
<span class="comments">;			pixels, directly from the graphics window.  The right</span>
<span class="comments">;			button magnifies the data itself, without the overlays.</span>
<span class="comments">;</span>
<span class="comments">;		XY Zoom: </span>
<span class="comments">;			Same as 'zoom' above, except the aspect ratio is</span>
<span class="comments">;			set by the proportions of the selected box.</span>
<span class="comments">;</span>
<span class="comments">;		Remove overlays: </span>
<span class="comments">;			Allows the user to remove overlay arrays.</span>
<span class="comments">;</span>
<span class="comments">;		Trim overlays: </span>
<span class="comments">;			Allows the user to trim points from overlay arrays.</span>
<span class="comments">;</span>
<span class="comments">;		Select within overlays: </span>
<span class="comments">;			Allows the user to select points within overlay arrays.</span>
<span class="comments">;</span>
<span class="comments">;		Define Region: </span>
<span class="comments">;			Allows the user to define GRIM's region of interest.</span>
<span class="comments">;</span>
<span class="comments">;		Smooth:</span>
<span class="comments">;			Allows the user to select a smoothing box to be applied</span>
<span class="comments">;			to the data array.</span>
<span class="comments">;</span>
<span class="comments">;		Select Plane:</span>
<span class="comments">;			Allows the user to change planes using the pointer.  </span>
<span class="comments">;			This option is only useful in cases where multiple</span>
<span class="comments">;			planes are displayed.</span>
<span class="comments">;</span>
<span class="comments">;		Drag Image:</span>
<span class="comments">;			Allows the user to reposition the current plane by </span>
<span class="comments">;			clicking and dragging.</span>
<span class="comments">;</span>
<span class="comments">;		Navigate:</span>
<span class="comments">;			Allows the user to modify the camera position and </span>
<span class="comments">;			orientation usng the mouse.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;	 Graphics window: </span>
<span class="comments">;		The graphics window displays the data associated with the </span>
<span class="comments">;		given data descriptor using the current zoom, offset, and </span>
<span class="comments">;		display order.  The edges of an image are indicated by a dotted </span>
<span class="comments">;		line.  The camera optic axis is indicated by a large red cross.</span>
<span class="comments">;</span>
<span class="comments">;	 Pixel readout: </span>
<span class="comments">;		The cursor position and corresponding data value are are </span>
<span class="comments">;		displayed beneath the graphics window, next to the message line.</span>
<span class="comments">;</span>
<span class="comments">;	 Message line: </span>
<span class="comments">;		The message line displays short messages pertaining GRIM's</span>
<span class="comments">;		 current state, or displayng button functions.</span>
<span class="comments">;</span>
<span class="comments">; CALLBACK PROCEDURES:</span>
<span class="comments">;	GRIM callback procedures are called with one or two arguments:</span>
<span class="comments">;       the first argument is a pointer to data that was provided</span>
<span class="comments">;	when the callback was added.  The second argument, if present, depends </span>
<span class="comments">;	on the applicatation.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; RESOURCE NAMES</span>
<span class="comments">;	The following X-windows resource names apply to grim:</span>
<span class="comments">;	 grim_base:		top level base</span>
<span class="comments">;	 grim_mbar:		menu bar</span>
<span class="comments">;	 grim_shortcuts_base:	base containing shortcut buttons</span>
<span class="comments">;	 grim_modes_base:	base containing modes buttons</span>
<span class="comments">;	 grim_draw:		grim draw widget</span>
<span class="comments">;	 grim_label:		grim bottom label widget</span>
<span class="comments">;</span>
<span class="comments">;	To turn off the confusing higlight box around the modes buttons, </span>
<span class="comments">;	put the following line in your ~/.Xdefaults file:</span>
<span class="comments">;</span>
<span class="comments">;	 Idl*grim_modes_base*highlightThickness:	0</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; OPERATION:</span>
<span class="comments">;	GRIM displays 1-, 2-, and 3-dimensional data sets.  1-dimensional </span>
<span class="comments">;	data arrays are displayed as plots.  In that case, the abscissa is </span>
<span class="comments">;	the sample number unless the data descriptor contains an abscissa.  </span>
<span class="comments">;	2- and 3-dimensional arrays are displaye as image planes.  The only </span>
<span class="comments">;	difference between images and cubes in GRIM is that images planes </span>
<span class="comments">;	each have their own data descriptor, while cubes are represented by </span>
<span class="comments">;	multiple image planes that share a common data descriptor; each plane </span>
<span class="comments">;	in a cube corresponds to a unique offset in the data array stored in </span>
<span class="comments">;	the common data descriptor.  Some functionality is not available when</span>
<span class="comments">;	working with plots.  In that case, those options do not appear in the </span>
<span class="comments">;	menus.</span>
<span class="comments">;</span>
<span class="comments">;	GRIM requests only the data samples needed for the current viewing </span>
<span class="comments">;	parameters.  Therefore, GRIM can display data sets of arbitrary size</span>
<span class="comments">;	when used with a file reader that supports subsampling.  However, note </span>
<span class="comments">;	that specific menu options may request the entire data array, depending </span>
<span class="comments">;	on the application.  </span>
<span class="comments">;</span>
<span class="comments">;	Each GRIM window may contain any number of planes as well as </span>
<span class="comments">;	associated geometric data (i.e. object descriptors) and overlay arrays </span>
<span class="comments">;	for displaying various geometric objects -- limbs, rings, stars, etc.  </span>
<span class="comments">;	An array of user overlay points is maintained to be used for application-</span>
<span class="comments">;	specific purposes.  Generally, a set of overlay points or a descriptor </span>
<span class="comments">;	must be activated in order to be used as input to a menu item; see </span>
<span class="comments">;	activate mode above.  </span>
<span class="comments">;</span>
<span class="comments">;	There are exclusive and non-exclusive mechanisms for selecting grim</span>
<span class="comments">;	windows.  Grim windows may be non-exclusively selected using the select</span>
<span class="comments">;	mode button mentioned above (upper-left corner).  The exclusive</span>
<span class="comments">;	selection mechanism consists of a "primary" GRIM window, indicated by </span>
<span class="comments">;	a red outline in the graphics window.  The primary selection is </span>
<span class="comments">;	changed by pressing any mode or shortcut button, or by clicking in </span>
<span class="comments">;	the graphics area of the desired grim window.  The meaning of the</span>
<span class="comments">;	various selections depends on the application.</span>
<span class="comments">;</span>
<span class="comments">;	The functions of the left and right mouse buttons are determined by the</span>
<span class="comments">;	cursor mode; some cursor modes define modifier keys to broaden the number</span>
<span class="comments">;	of functions available in that mode.  The middle mouse button toggles</span>
<span class="comments">;	the activation state of overlay arrays, or pans the image if no overlay</span>
<span class="comments">;	appears beneath the cursor.  The mouse wheel cycles among cursor modes, </span>
<span class="comments">;	or zooms about the cursor position if the control key is held down.</span>
<span class="comments">;</span>
<span class="comments">;	Objects maintained by GRIM are accessible via the INGRID interface,</span>
<span class="comments">;	for example:</span>
<span class="comments">;</span>
<span class="comments">;		IDL> ingrid, dd=dd, cd=cd, pd=pd, limb_ptd=limb_ptd</span>
<span class="comments">;</span>
<span class="comments">;	returns the data desciptor, camera descriptor, planet descriptors,</span>
<span class="comments">;	and limb points associated with the current plane.  </span>
<span class="comments">;</span>
<span class="comments">;	GRIM registers event handlers for all of its objects, so the window</span>
<span class="comments">;	is updated any time an object is modifed, whether by GRIM or by some</span>
<span class="comments">;	other program, or from the command line.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;	(1) To create a new grim instance with no data:</span>
<span class="comments">;</span>
<span class="comments">;		IDL> grim, /new</span>
<span class="comments">;</span>
<span class="comments">;	(2) To create a new grim instance with data from a file of name</span>
<span class="comments">;	    "filename":</span>
<span class="comments">;</span>
<span class="comments">;		IDL> dd = dat_read(filename)</span>
<span class="comments">;		IDL> grim, dd</span>
<span class="comments">;</span>
<span class="comments">;		   or</span>
<span class="comments">;</span>
<span class="comments">;		IDL> grim, filename</span>
<span class="comments">;</span>
<span class="comments">;	(3) To give an existing grim instance a new camera descriptor:</span>
<span class="comments">;</span>
<span class="comments">;		IDL> grim, cd=cd</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KNOWN BUGS:</span>
<span class="comments">;	Window resizing is not precise.  GRIM tries to resize to the selected</span>
<span class="comments">;	size, but typically overshoots.  This is probably platform-dependent.</span>
<span class="comments">;</span>
<span class="comments">;	Objects inherited by rendering planes do not respond to events.</span>
<span class="comments">;</span>
<span class="comments">;	Image shifting:</span>
<span class="comments">;	 -  Descriptors not updated if shift performed form another window</span>
<span class="comments">;	    because the there's no way for the irst window to know to</span>
<span class="comments">;	    update its descriptors</span>
<span class="comments">;        - fix wrap-around; clip instead</span>
<span class="comments">;</span>
<span class="comments">;	Plane->Coregister does not update descriptors</span>
<span class="comments">;</span>
<span class="comments">;	Navigate mode gets weird when you do certain modifer key presses</span>
<span class="comments">;	   --> maybe a conflict with &lt;ctrl> wheel zoom action</span>
<span class="comments">;</span>
<span class="comments">;	Crashes occur with File->Close</span>
<span class="comments">;</span>
<span class="comments">;	/no_erase is not enabled for images, just plots.  Probably should fix </span>
<span class="comments">;	that.</span>
<span class="comments">;</span>
<span class="comments">;	Initial visibility setting does not seem to work until applied</span>
<span class="comments">;	using plane settings window.</span>
<span class="comments">;</span>
<span class="comments">;	/frame causes a crash if there are no initial overlays.</span>
<span class="comments">;</span>
<span class="comments">;	It's not clear whether the symsize keyword is actually used.</span>
<span class="comments">;</span>
<span class="comments">;	pn keyword does not function.</span>
<span class="comments">;</span>
<span class="comments">;	Crash when tiepoint syncing is on and tiepoint selected with</span>
<span class="comments">;	multiple planes.</span>
<span class="comments">;</span>
<span class="comments">;	Title keyword does not properly map multiple elements to multiple</span>
<span class="comments">;	planes.</span>
<span class="comments">;</span>
<span class="comments">;	Nsum keyword does not properly map multiple elements to multiple</span>
<span class="comments">;	planes.</span>
<span class="comments">;</span>
<span class="comments">;	Plane syncing appears to be incomplete and I don't remember what it</span>
<span class="comments">;	was supposed to be.  I'm sure it was awesome, though.</span>
<span class="comments">;</span>
<span class="comments">;	Not sure what slave_overlays keyword does, or was supposed to do.</span>
<span class="comments">;</span>
<span class="comments">;	Overlays on rendered planes do not respond to events</span>
<span class="comments">;</span>
<span class="comments">;	Menu toggles don't update propoerly in some circumsumstances.</span>
<span class="comments">;</span>
<span class="comments">;	grim_message sometimes pops up messages from nv_message, which can</span>
<span class="comments">;	be pretty obnxious.  This probably has to do with the calls to</span>
<span class="comments">;	grim_message in grim_compute.include</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; STATUS:</span>
<span class="comments">;	Incomplete.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;	ingrid, gr_draw</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>

@grim_bitmaps_include.pro
@grim_util_include.pro
@grim_planes_include.pro
@grim_data_include.pro
@grim_user_include.pro
@grim_compute_include.pro
@grim_overlays_include.pro
@grim_descriptors_include.pro
@grim_image_include.pro

<span class="comments">;=============================================================================</span>
<span class="comments">; grim_constants</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_constants:source"></a>pro grim_constants
@grim_constants.common

 MAG_SIZE_DEVICE = 101				<span class="comments">; must be odd</span>
 MAG_SIZE_DATA = 21				<span class="comments">; must be odd</span>

 MAG_SIZE_DEVICE = 201				<span class="comments">; must be odd</span>
 MAG_SIZE_DATA = 41				<span class="comments">; must be odd</span>


 CONTEXT_SIZE = 100
 AXES_SIZE = 125

 SCALE_WIDTH = 10

 MARK_FRESH = 1b
 MARK_STALE = 2b
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_resize</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_resize:source"></a>pro grim_resize, grim_data, base_xsize, base_ysize, init=init

 <span class="comments">;-------------------------</span>
 <span class="comments">; get current info</span>
 <span class="comments">;-------------------------</span>
 base_geom = widget_info(grim_data.base, /geom) 
 sub_base_geom = widget_info(grim_data.sub_base, /geom) 
 modes_base_geom = widget_info(grim_data.modes_base, /geom) 
 draw_geom = widget_info(grim_data.draw, /geom) 
 shortcuts_base_geom = widget_info(grim_data.shortcuts_base, /geom) 
 label_geom = widget_info(grim_data.label, /geom) 
 xy_label_geom = widget_info(grim_data.xy_label, /geom) 
 mbar_geom = widget_info(grim_data.mbar, /geom) 

 mbar_height = widget_get_mbar_height()

 <span class="comments">;-------------------------</span>
 <span class="comments">; set  sizes</span>
 <span class="comments">;-------------------------</span>
 if(NOT keyword_set(base_xsize)) then $
                  base_xsize = base_geom.xsize + 2*base_geom.margin
 if(NOT keyword_set(base_ysize)) then $
                  base_ysize = base_geom.ysize + 2*base_geom.margin

 sub_base_xsize = sub_base_geom.xsize + 2*sub_base_geom.margin
 sub_base_ysize = sub_base_geom.ysize + 2*sub_base_geom.margin

 modes_base_xsize = modes_base_geom.xsize + 2*modes_base_geom.margin
 modes_base_ysize = modes_base_geom.ysize + 2*modes_base_geom.margin

 shortcuts_base_ysize = shortcuts_base_geom.ysize + 2*shortcuts_base_geom.margin

 label_xsize = label_geom.xsize + 2*label_geom.margin
 label_ysize = label_geom.ysize + 2*label_geom.margin

 draw_xsize = base_xsize - modes_base_xsize
 draw_ysize = base_ysize - label_ysize - mbar_height - shortcuts_base_ysize

 widget_control, grim_data.draw_base, $
	scr_xsize=draw_xsize, scr_ysize=draw_ysize
 widget_control, grim_data.draw, $
	scr_xsize=draw_xsize, scr_ysize=draw_ysize
<span class="comments">; widget_control, grim_data.modes_base, $</span>
<span class="comments">;	scr_xsize=modes_base_xsize</span>
<span class="comments">;	scr_ysize=base_ysize - label_ysize - mbar_height - shortcuts_base_ysize</span>
 widget_control, grim_data.label, scr_xsize=base_xsize - xy_label_geom.xsize




<span class="comments">; draw_geom = widget_info(grim_data.draw, /geom) </span>
<span class="comments">; draw_xsize = draw_geom.xsize</span>
<span class="comments">; draw_ysize = draw_geom.ysize</span>

 <span class="comments">;-------------------------</span>
 <span class="comments">; modify pixmap</span>
 <span class="comments">;-------------------------</span>
 pixmap = grim_data.pixmap

 wnum = !d.window
 window, /free, /pixmap, xsize=draw_xsize, ysize=draw_ysize
 grim_data.pixmap = !d.window

 if(pixmap NE -1) then $
  begin
   device, copy=[0,0, draw_xsize-1,draw_ysize-1, 0,0, wnum]
   wdelete, pixmap
  end
 wset, wnum


 <span class="comments">;-------------------------</span>
 <span class="comments">; modify redraw pixmap</span>
 <span class="comments">;-------------------------</span>
 redraw_pixmap = grim_data.redraw_pixmap

 wnum = !d.window
 window, /free, /pixmap, xsize=draw_xsize, ysize=draw_ysize
 grim_data.redraw_pixmap = !d.window

 if(redraw_pixmap NE -1) then $
  begin
   device, copy=[0,0, draw_xsize-1,draw_ysize-1, 0,0, wnum]
   wdelete, redraw_pixmap
  end
 wset, wnum


 <span class="comments">;-------------------------</span>
 <span class="comments">; modify overlay pixmap</span>
 <span class="comments">;-------------------------</span>
 overlay_pixmap = grim_data.overlay_pixmap

 wnum = !d.window
 window, /free, /pixmap, xsize=draw_xsize, ysize=draw_ysize
 grim_data.overlay_pixmap = !d.window

 if(overlay_pixmap NE -1) then $
  begin
   device, copy=[0,0, draw_xsize-1,draw_ysize-1, 0,0, wnum]
   wdelete, overlay_pixmap
  end
 wset, wnum



 <span class="comments">;-------------------------</span>
 <span class="comments">; modify guideline pixmap</span>
 <span class="comments">;-------------------------</span>
 if(keyword_set(grim_data.guideline_pixmaps[0])) then $
                                     wdelete, grim_data.guideline_pixmaps[0]
 window, /free, xsize=draw_xsize, ysize=1, /pixmap
 grim_data.guideline_pixmaps[0] = !d.window


 if(keyword_set(grim_data.guideline_pixmaps[1])) then $
                                     wdelete, grim_data.guideline_pixmaps[1]
 window, /free, xsize=1, ysize=draw_ysize, /pixmap
 grim_data.guideline_pixmaps[1] = !d.window
 wset, wnum


 grim_data.base_xsize = base_geom.xsize
 grim_data.base_ysize = base_geom.ysize


 grim_set_data, grim_data, grim_data.base
 if(NOT keyword_set(init)) then grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_set_tracking</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_set_tracking:source"></a>pro grim_set_tracking, grim_data

 widget_control, grim_data.draw, draw_motion_events=grim_data.tracking
 widget_control, grim_data.context_draw, draw_motion_events=grim_data.tracking
 if(NOT grim_data.tracking) then $
       widget_control, grim_data.xy_label, set_value='Tracking off' $
 else widget_control, grim_data.xy_label, set_value='Tracking on'

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_test_motion_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_test_motion_event:source"></a>function grim_test_motion_event, event

 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then return, 1

 if(struct EQ 'WIDGET_DRAW') then if(event.type EQ 2) then return, 1

 return, 0
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_set_ct</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_set_ct:source"></a>pro grim_set_ct, grim_data
common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr

 tvlct, *grim_data.tv_rp, *grim_data.tv_gp, *grim_data.tv_bp
 r_curr = *grim_data.tv_rp
 g_curr = *grim_data.tv_gp
 b_curr = *grim_data.tv_bp
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_set_mode</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_set_mode:source"></a>pro grim_set_mode, grim_data, mode, new=new, init=init, data_p=data_p

 if(keyword_set(mode)) then grim_data.mode = mode $
 else mode = grim_data.mode

 if(keyword_set(new)) then grim_set_primary, grim_data.base

 if(keyword_set(new) OR keyword_set(init)) then $
  begin
   wid = grim_data.modes_base
   repeat $
    begin
     wid = widget_info(wid+1, find_by_uname='mode')
     if(keyword_set(wid)) then $
      begin
       widget_control, wid, get_uvalue=name
       if(size(name, /type) NE 7) then name = name.name
       if(name EQ mode) then widget_control, wid, sensitive=0 $
       else widget_control, wid, sensitive=1
      end
    endrep until(wid EQ 0)
  end

 if(keyword_set(data_p)) then grim_data.mode_data_p = data_p

 swap = grim_get_cursor_swap(grim_data)

 cursor_modes = *grim_data.cursor_modes_p
 data_p = 0
 if(keyword_set(cursor_modes)) then $
  begin
   names = cursor_modes.name
   w = where(names EQ mode)
   if(w[0] NE -1) then $
    begin
     data_p = cursor_modes[w].data_p
     grim_data.mode_data_p = data_p
    end
  end

 call_procedure, mode + '_mode', grim_data, data_p


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_write_ptd</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_write_ptd:source"></a>pro grim_write_ptd, grim_data, filename

 xoff = 0.5
 yoff = 2.0
 bits_per_pixel = 8

 <span class="comments">;--------------------------------------------------------------</span>
 <span class="comments">; set coord. sys and get clipped, scaled image</span>
 <span class="comments">;--------------------------------------------------------------</span>
 grim_wset, grim_data, grim_data.wnum, get_info=tvd
 grim_refresh, grim_data, tvimage=_tvimage, $
                                    /no_back, /no_context, /no_callback

 <span class="comments">;--------------------------------------------------------------</span>
 <span class="comments">; find device coords of image corners</span>
 <span class="comments">;--------------------------------------------------------------</span>
 s = size(grim_image(grim_data, plane=plane))
 xsize = s[1]
 ysize = s[2]

 p = fix(convert_coord(0d,0d, /data, /to_device, /double))
 q = fix(convert_coord(double(xsize-1),double(ysize-1), /data, /to_device)) - 1

 x0 = min([p[0], q[0]])
 x1 = max([p[0], q[0]])
 y0 = min([p[1], q[1]])
 y1 = max([p[1], q[1]])

 if(tvd.order) then $
  begin
   yy0 = y0
   yy1 = y1
   y0 = !d.y_size-1 - yy1
   y1 = !d.y_size-1 - yy0
  end

 x0 = x0 > 0
 x1 = x1 &lt; !d.x_size-1
 y0 = y0 > 0
 y1 = y1 &lt; !d.y_size-1

 <span class="comments">;--------------------------------------------------------------</span>
 <span class="comments">; trim image, allowing a bit of safety</span>
 <span class="comments">;--------------------------------------------------------------</span>
 xs = x1-x0-2
 ys = y1-y0-2
 _tvimage = _tvimage[0:xs, 0:ys]

 x1 = x0 + xs
 y1 = y0 + ys

 <span class="comments">;--------------------------------------------------------------</span>
 <span class="comments">; insert into image to plot</span>
 <span class="comments">;--------------------------------------------------------------</span>
 type = size(_tvimage, /type)
 tvimage = make_array(!d.x_size, !d.y_size, type=type)
 tvimage[x0:x1, y0:y1] = _tvimage

 <span class="comments">;--------------------------------------------------------------</span>
 <span class="comments">; determine aspect ratio --</span>
 <span class="comments">;  Currently, the overlays are not properly drawn if any edge</span>
 <span class="comments">;  of the image is visible in the graphics window.</span>
 <span class="comments">;--------------------------------------------------------------</span>
 aspect = double(!d.x_size)/double(!d.y_size)
 if(aspect GE 1.0) then $
  begin
   xsize = 7.5
   ysize = xsize / aspect
  end $
 else $
  begin
   ysize = 7.5
   xsize = ysize * aspect
  end

 <span class="comments">;--------------------------------------------------------------</span>
 <span class="comments">; Without this step, the overlays may be drawn incorrectly</span>
 <span class="comments">; the first time in a session.  I don't know why.</span>
 <span class="comments">;--------------------------------------------------------------</span>
 set_plot, 'PS'
 device, /color, filename=filename, bits_per_pixel=bits_per_pixel, $
         xsize=xsize, ysize=ysize, /inches, xoffset=xoff, yoffset=yoff
 device, /close
 set_plot, 'X'


 <span class="comments">;--------------------------------------------------------------</span>
 <span class="comments">; write the PS file </span>
 <span class="comments">;--------------------------------------------------------------</span>
 set_plot, 'PS'
 device, /color, filename=filename, bits_per_pixel=bits_per_pixel, $
         xsize=xsize, ysize=ysize, /inches, xoffset=xoff, yoffset=yoff

 ctmod, top=top
 tv, tvimage, order=tvd.order, top=top
 grim_refresh, grim_data, tvimage=tvimage, $
           /no_image, /no_callback, /no_wset, /no_coord, /no_context, /no_back

 device, /close
 set_plot, 'X'

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_write</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_write:source"></a>pro grim_write, grim_data, filename, filetype=filetype

 widget_control, /hourglass
 plane = grim_get_plane(grim_data)

 if(NOT keyword_set(filename)) then return

 split_filename, filename, dir, name
 if(NOT keyword_set(name)) then return

 <span class="comments">;---------------------------------------------</span>
 <span class="comments">; prompt before overwriting existing file</span>
 <span class="comments">;---------------------------------------------</span>
 ff = file_search(filename)
 if(keyword_set(ff)) then $
  begin
   ans = dialog_message('Overwrite ' + filename + '?', /question)
   if(ans NE 'Yes') then return
  end


 grim_suspend_events

 <span class="comments">;---------------------------------------------</span>
 <span class="comments">; output descriptors</span>
 <span class="comments">;---------------------------------------------</span>
 if(keyword_set(*plane.cd_p)) then $
  case grim_test_map(grim_data) of
    0 : $
	begin
	 pg_put_cameras, plane.dd, cd=*plane.cd_p
	 od = *plane.cd_p
	end
    1 : $
	begin
	 pg_put_maps, plane.dd, md=*plane.cd_p
	 od = *plane.od_p
	end
  endcase

 if(keyword_set(*plane.pd_p)) then $
            pg_put_planets, plane.dd, pd=*plane.pd_p, od=od

 if(keyword_set(*plane.rd_p)) then $
              pg_put_rings, plane.dd, rd=*plane.rd_p, od=od

 if(keyword_set(*plane.sd_p)) then $
              pg_put_stars, plane.dd, sd=*plane.sd_p, od=od

<span class="comments">; if(keyword_set(*plane.std_p)) then $ </span>
 <span class="comments">;             pg_put_stations, plane.dd, std=*plane.std_p, od=od ;no such function</span>

 if(keyword_set(*plane.ard_p)) then $
              pg_put_arrays, plane.dd, ard=*plane.ard_p, od=od

 if(keyword_set(*plane.ard_p)) then $
              pg_put_stations, plane.dd, ard=*plane.ard_p, od=od

 if(keyword_set(*plane.sund_p)) then $
              pg_put_stars, plane.dd, sd=*plane.sund_p, od=od

 grim_resume_events

 <span class="comments">;---------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;---------------------------------------------</span>
 dat_write, filename, plane.dd, filetype=filetype

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_get_save_filename</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_get_save_filename:source"></a>function grim_get_save_filename, grim_data, filetype=filetype

 plane = grim_get_plane(grim_data)
 name = dat_filename(plane.dd)
 split_filename, name, dir, _name

 if(keyword_set(plane.save_path)) then path = plane.save_path
 if(NOT keyword_set(path)) then path = dir
 if(NOT keyword_set(path)) then path = './'


 types = strupcase(dat_detect_filetype(/all))
 w = where(strupcase(dat_filetype(plane.dd)) EQ types)

 if(w[0] NE -1) then $
   types = [types[w[0]], rm_list_item(types, w[0], only='')]

 filename = pickfiles(/one, get_path=get_path, $
               title='Select filename for saving', path=path, default=name, $
               options=['Filetype:',types], sel=filetype)

 return, filename
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_kill_notify</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_kill_notify:source"></a>pro grim_kill_notify, top
@grim_block.include

 grim_data = grim_get_data(top, /dead)

 if(grim_data.pixmap NE -1) then wdelete, grim_data.pixmap
 if(grim_data.redraw_pixmap NE -1) then wdelete, grim_data.redraw_pixmap
 if(grim_data.overlay_pixmap NE -1) then wdelete, grim_data.overlay_pixmap

 for i=0, grim_data.n_planes-1 do $
  begin
   plane = grim_get_plane(grim_data, pn=i)

   nv_notify_unregister, plane.dd, 'grim_descriptor_notify'
   if(keyword_set(*plane.cd_p)) then nv_notify_unregister, *plane.cd_p, 'grim_descriptor_notify'
   if(keyword_set(*plane.pd_p)) then nv_notify_unregister, *plane.pd_p, 'grim_descriptor_notify'
   if(keyword_set(*plane.rd_p)) then nv_notify_unregister, *plane.rd_p, 'grim_descriptor_notify'
   if(keyword_set(*plane.sd_p)) then nv_notify_unregister, *plane.sd_p, 'grim_descriptor_notify'
   if(keyword_set(*plane.std_p)) then nv_notify_unregister, *plane.std_p, 'grim_descriptor_notify'
   if(keyword_set(*plane.ard_p)) then nv_notify_unregister, *plane.ard_p, 'grim_descriptor_notify'
   if(keyword_set(*plane.sund_p)) then nv_notify_unregister, *plane.sund_p, 'grim_descriptor_notify'

   nv_ptr_free, [plane.cd_p, plane.pd_p, plane.rd_p, plane.sd_p, plane.std_p, plane.ard_p, plane.sund_p, $
             plane.od_p, plane.active_xd_p, plane.active_overlays_ptdp,$
             grim_get_overlay_ptdp(grim_data, plane=plane, 'limb'), $
             grim_get_overlay_ptdp(grim_data, plane=plane, 'ring'), $
             grim_get_overlay_ptdp(grim_data, plane=plane, 'terminator'), $
             grim_get_overlay_ptdp(grim_data, plane=plane, 'star'), $
             grim_get_overlay_ptdp(grim_data, plane=plane, 'station'), $
             grim_get_overlay_ptdp(grim_data, plane=plane, 'array'), $
             grim_get_overlay_ptdp(grim_data, plane=plane, 'planet_grid'), $
             grim_get_overlay_ptdp(grim_data, plane=plane, 'ring_grid'), $
             grim_get_overlay_ptdp(grim_data, plane=plane, 'planet_center'), $
             plane.user_ptd_tlp]
  end

 nv_ptr_free, [grim_data.rf_callbacks_p, grim_data.rf_callbacks_data_pp, $
           grim_data.planes_p, grim_data.pl_flags_p, $
           grim_data.menu_ids_p, grim_data.menu_desc_p]

 grim_grnum_destroy, grim_data.grnum

 w = where(_all_tops EQ top)
 _all_tops = rm_list_item(_all_tops, w[0], only=0)
 if(keyword_set(_all_tops[0])) then $
                    grim_set_primary, _all_tops[n_elements(_all_tops)-1]

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_load_files</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_load_files:source"></a>pro grim_load_files, grim_data, filenames, load_path=load_path

 plane = grim_get_plane(grim_data)
 filter = plane.filter

 <span class="comments">;------------------------------------</span>
 <span class="comments">; load each file onto a new plane</span>
 <span class="comments">;------------------------------------</span>
 nfiles = n_elements(filenames)

 first = 1
 for i=0, nfiles-1 do $
  begin
   dd = dat_read(filenames[i], nhist=grim_data.nhist, $
            maintain=grim_data.maintain, compress=grim_data.compress, extensions=grim_data.extensions)
   if(keyword_set(dd)) then $
    begin
     grim_add_planes, grim_data, dd, pn=pn, filter=filter

     if(first) then $
      begin
       first = 0
       grim_data.pn = pn[0]
      end

     plane = grim_get_plane(grim_data, pn=pn)
     plane.load_path = load_path

     grim_set_plane, grim_data, plane, pn=pn

     nv_notify_register, dd, 'grim_descriptor_notify', scalar_data=grim_data.base
   end
  end


 grim_set_data, grim_data, grim_data.base

 <span class="comments">;------------------------------------</span>
 <span class="comments">; set initial zoom and display image</span>
 <span class="comments">;------------------------------------</span>
 dim = dat_dim(dd)
 geom = widget_info(grim_data.draw, /geom)

 zoom = double(geom.xsize) / double(dim[0])
 offset = [0d,0d]

 grim_wset, grim_data, grim_data.wnum, get_info=tvd
 grim_refresh, grim_data, zoom=zoom, offset=offset, order=tvd.order
 grim_wset, grim_data, /save

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_deactivate_all</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_deactivate_all:source"></a>pro grim_deactivate_all, grim_data, plane

 grim_deactivate_all_overlays, grim_data, plane
 grim_deactivate_all_xds, plane

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_activate_all</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_activate_all:source"></a>pro grim_activate_all, grim_data, plane

 grim_activate_all_overlays, grim_data, plane
 grim_activate_all_xds, plane

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_modify_colors</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_modify_colors:source"></a>pro grim_modify_colors, grim_data

 ctmod, top=top
 grim_colortool

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_edit_header</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_edit_header:source"></a>pro grim_edit_header, grim_data

 plane = grim_get_plane(grim_data)
 widget_control, grim_data.draw, /hourglass

 if(NOT widget_info(grim_data.header_text, /valid)) then $
  begin
   header = dat_header(plane.dd)   
   grim_data.header_text = $
               textedit(header, base=base, resource='grim_header', ysize=40)
   grim_data.header_base = base
   grim_set_data, grim_data
   grim_refresh, grim_data, /no_image, /no_objects
  end $
 else widget_control, grim_data.header_base, /map

<span class="comments">; hide button</span>

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_edit_notes</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_edit_notes:source"></a>pro grim_edit_notes, grim_data, plane=plane

 widget_control, grim_data.draw, /hourglass

 if(NOT widget_info(grim_data.notes_text, /valid)) then $
  begin
   grim_data.notes_text = $
          textedit(*plane.notes_p, base=base, /editable, resource='grim_notes')
   grim_data.notes_base = base
   grim_set_data, grim_data
   grim_refresh, grim_data, /no_image, /no_objects
  end $
 else widget_control, grim_data.notes_base, /map

<span class="comments">; hide button</span>

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_user_ptd_fname</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_user_ptd_fname:source"></a>function grim_user_ptd_fname, grim_data, plane, basename=basename

 if(NOT keyword_set(basename)) then $
  begin
   basename = cor_name(plane.dd)
   if(NOT keyword_set(basename)) then basename = 'grim-' + strtrim(plane.pn,2)
  end

 return, grim_data.workdir + '/' + basename + '.user_ptd'
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_write_user_points</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_write_user_points:source"></a>pro grim_write_user_points, grim_data, plane, fname=_fname

 if(NOT keyword_set(_fname)) then $
             fname = grim_user_ptd_fname(grim_data, plane) $
 else fname = _fname

 user_ptd = grim_get_user_ptd(plane=plane)

 w = where(pnt_valid(user_ptd))
 if(w[0] NE -1) then pnt_write, fname, user_ptd $
 else $
  begin
   ff = file_search(fname)
   if(keyword_set(ff)) then file_delete, fname, /quiet
  end

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mask_fname</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mask_fname:source"></a>function grim_mask_fname, grim_data, plane, basename=basename
 if(NOT keyword_set(basename)) then basename = cor_name(plane.dd)
 return, grim_data.workdir + '/' + basename + '.mask'
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_write_mask</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_write_mask:source"></a>pro grim_write_mask, grim_data, plane, fname=fname

 if(NOT keyword_set(fname)) then $
                fname = grim_mask_fname(grim_data, plane)

 mask = *plane.mask_p
 if(mask[0] EQ -1) then return

 if(mask[0] NE -1) then write_mask, fname, mask, dim=dat_dim(plane.dd) $
 else $
  begin
   ff = file_search(fname)
   if(keyword_set(ff)) then file_delete, fname, /quiet
  end

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_read_user_points</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_read_user_points:source"></a>pro grim_read_user_points, grim_data, plane

 fname = grim_user_ptd_fname(grim_data, plane)

 ff = (file_search(fname))[0]
 if(keyword_set(ff)) then user_ptd = pnt_read(ff) $
 else user_ptd = 0

 w = where(pnt_valid(user_ptd))
 if(w[0] NE -1) then $
  begin
   n = n_elements(user_ptd)
   tags = strarr(n)

   for i=0, n-1 do $
    begin
     tag = cor_name(user_ptd[i])
     tags[i] = tag
    end

   for i=0, n-1 do $
    begin
     w = where(tags EQ tags[i])
     if(w[0] NE -1) then $
      begin
       grim_add_user_points, user_ptd[w], [tags[i]], plane=plane, /no_refresh
       tags[w] = ''
      end
    end


  end

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_read_mask</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_read_mask:source"></a>pro grim_read_mask, grim_data, plane, fname=fname

 if(NOT keyword_set(fname)) then fname = grim_mask_fname(grim_data, plane)

 ff = (file_search(fname))[0]
 if(keyword_set(ff)) then mask = read_mask(ff, sub=sub) $
 else mask = -1

 if(mask[0] NE -1) then grim_add_mask, grim_data, sub, plane=plane, /replace, /sub

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_jumpto</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_jumpto:source"></a>function grim_jumpto, grim_data, id

 if(keyword_set(id)) then $
  begin
   widget_control, id, get_value=pns
   if(pns[0] EQ '') then return, 0
   widget_control, grim_data.jumpto_text, set_value=''
   w = str_isnum(pns)
   if(w[0] EQ -1) then return, 0
  end $
 else $
  begin
   done = 0
   repeat $
    begin
     pns = dialog_input('Plane number:')
     if(NOT keyword_set(pns)) then return, 0
     w = str_isnum(pns)
     if(w[0] NE -1) then done = 1
    endrep until(done)
  end

 pn = (long(pns))[0]
 grim_jump_to_plane, grim_data, pn, valid=valid

 return, valid
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_recenter</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_recenter:source"></a>pro grim_recenter, grim_data, p

 cx = !d.x_size/2
 cy = !d.y_size/2
 q = convert_coord(double(cx), double(cy), /device, /to_data)

 grim_refresh, grim_data, doffset=(p-q)[0:1]

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_zoom</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_zoom:source"></a>function grim_zoom, grim_data

 done = 0
 repeat $
  begin
   zs = dialog_input('New zoom:')
   if(NOT keyword_set(zs)) then return, 0
   w = str_isfloat(zs)
   if(w[0] NE -1) then done = 1
  endrep until(done)

 zoom = double(zs)
 return, zoom
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_zoom_to_cursor</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_zoom_to_cursor:source"></a>function grim_zoom_to_cursor, zz, relative=relative, zoom=zoom

 tvim, get_info=tvd, /silent
 if(keyword_set(relative)) then zoom = tvd.zoom*zz $
 else zoom = zz

 zf = zoom / tvd.zoom

 cursor, x, y, /nowait, /data
 device_cc = transpose([transpose([0,0]), transpose([!d.x_size-1, !d.y_size-1])])
 data_cc = (convert_coord(double(device_cc[0,*]), double(device_cc[1,*]), /device, /to_data))[0:1,*]
 data_size = abs(data_cc[*,0] - data_cc[*,1])

 new_data_size = data_size/zf

 ff = [(x-tvd.offset[0])/(data_size[0]-1), (y-tvd.offset[1])/(data_size[1]-1)]
 offset = [x-new_data_size[0]*ff[0], y-new_data_size[1]*ff[1]] + 1

 return, offset
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_modes_list</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_modes_list:source"></a>function grim_modes_list, grim_data

 base = grim_data.modes_base
 repeat $
  begin
   id = widget_info(base, /child)
   repeat $
    begin
     widget_control, id, get_uvalue=name
     if(size(name, /type) EQ 8) then name = name.name
     modes = append_array(modes, name)
     id = widget_info(id, /sibling)
    endrep until(id EQ 0)
   base = widget_info(base, /sibling)
  endrep until(base EQ 0)

 return, modes
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_interrupt_begin</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_interrupt_begin:source"></a>pro grim_interrupt_begin, grim_data, plane=plane
common grim_interrupt_block, base

 if(NOT keyword__set(plane)) then plane = grim_get_plane(grim_data)

 <span class="comments">;------------------------------------------</span>
 <span class="comments">; save the current state</span>
 <span class="comments">;------------------------------------------</span>
<span class="comments">; data = ...</span>

 <span class="comments">;------------------------------------------</span>
 <span class="comments">; open the interrupt dialog</span>
 <span class="comments">;------------------------------------------</span>
 _base = dialog_interrupt(callback='grim_interrupt_callback', data=data)
 if(_base NE -1) then base = _base

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_interrupt_end</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_interrupt_end:source"></a>pro grim_interrupt_end, grim_data, plane=plane
common grim_interrupt_block, base

 if(NOT keyword__set(plane)) then plane = grim_get_plane(grim_data)

 <span class="comments">;------------------------------------------</span>
 <span class="comments">; destroy the interrupt dialog</span>
 <span class="comments">;------------------------------------------</span>
 widget_control, base, /destroy


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_toggle_context</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_toggle_context:source"></a>pro grim_toggle_context, grim_data

 <span class="comments">;----------------------------</span>
 <span class="comments">; toggle the mapping state</span>
 <span class="comments">;----------------------------</span>
 if(grim_data.context_mapped) then grim_data.context_mapped = 0 $
 else grim_data.context_mapped = 1
 grim_set_data, grim_data, grim_data.base

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; if mapped, copy the image onto the window</span>
 <span class="comments">;------------------------------------------------------</span>
 if(grim_data.context_mapped) then $
  begin
   grim_refresh, grim_data, /no_main
   grim_show_context_image, grim_data
  end

 <span class="comments">;----------------------------</span>
 <span class="comments">; set the new mapping state</span>
 <span class="comments">;----------------------------</span>
 widget_control, grim_data.context_base, map=grim_data.context_mapped

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_toggle_axes</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_toggle_axes:source"></a>pro grim_toggle_axes, grim_data

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; toggle axes flag</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 grim_data.axes_flag = NOT grim_data.axes_flag

 <span class="comments">;----------------------------</span>
 <span class="comments">; set the new mapping state</span>
 <span class="comments">;----------------------------</span>
 widget_control, grim_data.axes_base, map=grim_data.axes_flag

 grim_set_data, grim_data, grim_data.base

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; if mapped, copy the image onto the window</span>
 <span class="comments">;------------------------------------------------------</span>
 if(grim_data.axes_flag) then grim_show_axes, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_render</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_render:source"></a>pro grim_render, grim_data, plane=plane

 if(grim_data.type EQ 'plot') then return

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; make sure relevant descriptors are loaded</span>
 <span class="comments">;---------------------------------------------------------</span>
<span class="comments">; grim_load_descriptors, grim_data, name, plane=plane, $</span>
<span class="comments">;       cd=cd, pd=pd, rd=rd, sund=sund, sd=sd, ard=ard, std=std, od=od, $</span>
<span class="comments">;       gd=gd</span>
 grim_load_descriptors, grim_data, 'limb', plane=plane


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; render</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 widget_control, /hourglass


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Create new plane unless the current one is a rendering</span>
 <span class="comments">;  The new plane will include a transformation that allows</span>
 <span class="comments">;  the rendering to appear in the correct location in the</span>
 <span class="comments">;  display relative to the data coordinate system.</span>
 <span class="comments">;---------------------------------------------------------</span>
 if(NOT plane.rendering) then $
  begin
   new_plane = grim_clone_plane(grim_data, plane=plane)
   new_plane.rendering = 1
   new_plane.dd = nv_clone(plane.dd)

   dat_set_sampling_fn, new_plane.dd, 'grim_render_sampling_fn', /noevent

   dat_set_dim_fn, new_plane.dd, 'grim_render_dim_fn'
   dat_set_dim_data, new_plane.dd, dat_dim(plane.dd)

   nv_notify_register, new_plane.dd, 'grim_descriptor_notify', scalar_data=grim_data.base

   grim_set_plane, grim_data, new_plane

   grim_jump_to_plane, grim_data, new_plane.pn
   grim_refresh, grim_data, /no_image
  end $
 else new_plane = plane


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; set up grid</span>
 <span class="comments">;---------------------------------------------------------</span>
 nv_suspend_events

 device_pts = gridgen([!d.x_size,!d.y_size])
 image_pts = (convert_coord(device_pts, /device, /to_data))[0:1,*]
 image_pts = reform(image_pts, 2, !d.x_size,!d.y_size, /over)

 dat_set_sampling_data, new_plane.dd, image_pts
 grim_set_plane, grim_data, new_plane
 grim_set_data, grim_data, grim_data.base


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; perform rendering</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_render_image, grim_data, plane=new_plane, image_pts=image_pts

 nv_resume_events

 grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_erase_guideline</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_erase_guideline:source"></a>pro grim_erase_guideline, grim_data

 x = grim_data.guideline_save_xy[0]
 y = grim_data.guideline_save_xy[1]

 if(x LT 0) then return

 device, copy=[0,0, !d.x_size,1, 0,y, grim_data.guideline_pixmaps[0]]
 device, copy=[0,0, 1,!d.y_size, x,0, grim_data.guideline_pixmaps[1]]

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_draw_guideline</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_draw_guideline:source"></a>pro grim_draw_guideline, grim_data, x, y

 <span class="comments">;--------------------------------------</span>
 <span class="comments">; save window regions</span>
 <span class="comments">;--------------------------------------</span>
 wnum = !d.window
 wset, grim_data.guideline_pixmaps[0]
 device, copy=[0,y, !d.x_size,1, 0,0, wnum]
 wset, grim_data.guideline_pixmaps[1]
 device, copy=[x,0, 1,!d.y_size, 0,0, wnum]
 wset, wnum
 grim_data.guideline_save_xy = [x,y]

 <span class="comments">;--------------------------------------</span>
 <span class="comments">; draw guidelines</span>
 <span class="comments">;--------------------------------------</span>
 line = 0
 color = ctred()
 plots, [0,!d.x_size], [y, y], line=line, /device, col=color
 plots, [x, x], [0,!d.y_size], line=line, /device, col=color

 grim_set_data, grim_data, grim_data.base
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_repeat</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_repeat:source"></a>pro grim_repeat, grim_data

 if(keyword_set(grim_data.repeat_fn)) then $
             call_procedure, grim_data.repeat_fn, *grim_data.repeat_event_p

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_exit</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_exit:source"></a>pro grim_exit, grim_data

  if(NOT keyword_set(grim_data)) then grim_data = grim_get_data()
  if(NOT keyword_set(grim_data)) then return
  widget_control, grim_data.base, /destroy

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_undo</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_undo:source"></a>pro grim_undo, grim_data, plane
 dat_undo, plane.dd
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_redo</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_redo:source"></a>pro grim_redo, grim_data, plane
 dat_redo, plane.dd
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_interrupt_callback</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_interrupt_callback:source"></a>pro grim_interrupt_callback, data
 if(NOT keyword__set(plane)) then plane = grim_get_plane(grim_data)

 <span class="comments">;------------------------------------------</span>
 <span class="comments">; restore the old state</span>
 <span class="comments">;------------------------------------------</span>
<span class="comments">;...</span>

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_sampling_fn</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_sampling_fn:source"></a>function grim_sampling_fn, dd, source_image_pts_sample, data

 grim_data = grim_get_data()
 pos = cor_udata(dd, 'IMAGE_POS')
 if(NOT keyword_set(pos)) then return, source_image_pts_sample

 w = where(pos NE 0)
 if(w[0] EQ -1) then return, source_image_pts_sample

 xdim = dat_dim(dd)
 dim = size(source_image_pts_sample, /dim)
 n = n_elements(source_image_pts_sample)

 if(dim[0] NE 2) then $
         source_image_pts_sample = w_to_xy(xdim, source_image_pts_sample)
 n = n_elements(source_image_pts_sample)/2

 return, source_image_pts_sample - pos[0:1]#make_array(n, val=1d)
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_render_dim_fn</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_render_dim_fn:source"></a>function grim_render_dim_fn, dd, dim_orig
 return, dim_orig
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_render_sampling_fn</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_render_sampling_fn:source"></a>function grim_render_sampling_fn, dd, source_image_pts_sample, source_image_pts_grid

 rdim = dat_dim(dd, /true)
 xdim = dat_dim(dd)

 dim = size(source_image_pts_sample, /dim)
 n = n_elements(source_image_pts_sample)

 if(dim[0] NE 2) then $
         source_image_pts_sample = w_to_xy(xdim, source_image_pts_sample)
 n = n_elements(source_image_pts_sample)/2

 render_image_pts_grid = gridgen(rdim, /rec, /double)

 xx = interpol(render_image_pts_grid[0,*,0], source_image_pts_grid[0,*,0], source_image_pts_sample[0,*])
 yy = interpol(render_image_pts_grid[1,0,*], source_image_pts_grid[1,0,*], source_image_pts_sample[1,*])

 render_image_pts_sample = round([xx,yy])
 w = where((render_image_pts_sample[0,*] LT 0) $
              OR render_image_pts_sample[0,*] GE rdim[0] $)
              OR render_image_pts_sample[1,*] LT 0 $
              OR render_image_pts_sample[1,*] GE rdim[1])

 samples = xy_to_w(rdim, render_image_pts_sample)

<span class="comments">; w = where((samples LT 0) OR (samples GT n))</span>

 if(w[0] NE -1) then samples[w] = -1

 return, samples
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_draw_vectors</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_draw_vectors:source"></a>pro grim_draw_vectors, cd, curves_ptd, points_ptd

 if(obj_valid(curves_ptd)) then $
  begin
   p = inertial_to_image_pos(cd, pnt_vectors(curves_ptd, /visible))
   pg_draw, reform(p), psym=3, col=ctgreen()
  end

 if(obj_valid(points_ptd)) then $
  begin
   p = inertial_to_image_pos(cd, pnt_vectors(points_ptd, /visible))
   pg_draw, reform(p), psym=1, col=ctgreen()
  end

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_increment_mode</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_increment_mode:source"></a>pro grim_increment_mode, grim_data, dm

 modes = grim_modes_list(grim_data)
 nmodes = n_elements(modes)
 w = where(modes EQ grim_data.mode)
 ww = (w + dm)
 if(ww[0] LT 0) then ww = ww + nmodes 
 ww = ww mod nmodes
 grim_set_mode, grim_data, modes[ww[0]], /new

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_event:source"></a>pro grim_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;-----------------------------------</span>
 <span class="comments">; for now, assume a resize event</span>
 <span class="comments">;-----------------------------------</span>
 grim_resize, grim_data, event.x, event.y

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_update_guideline</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_update_guideline:source"></a>pro grim_update_guideline, grim_data, plane, x, y

 if(grim_data.guideline_flag) then $
  begin
   grim_erase_guideline, grim_data
   grim_draw_guideline, grim_data, x, y
  end

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_update_xy_label</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_update_xy_label:source"></a>pro grim_update_xy_label, grim_data, plane, x, y

 p = (convert_coord(double(x), double(y), /device, /to_data))[0:1]
 xx = str_pad(strtrim(p[0],2), 6)
 yy = str_pad(strtrim(p[1],2), 6)

 dn = ''
 dim = dat_dim(plane.dd)
 if(n_elements(dim) EQ 1) then dim = [dim, 1]

 <span class="comments">;- - - - - - - - - -  - - - </span>
 <span class="comments">; plot</span>
 <span class="comments">;- - - - - - - - - -  - - - </span>
 if(grim_data.type EQ 'plot') then $
  begin
   if((p[0] GE 0) AND (p[0] LT dim[1])) then $
 			     dn = dat_data(plane.dd, sample=[1,p[0]], /nd)
  end $
 <span class="comments">;- - - - - - - - - -  - - - </span>
 <span class="comments">; image</span>
 <span class="comments">;- - - - - - - - - -  - - - </span>
 else $
  begin
   p = round(p)
   if((p[0] GE 0) AND (p[0] LT dim[0]) AND $
      (p[1] GE 0) AND (p[1] LT dim[1])) then $
               dn = grim_get_image(grim_data, plane=plane, sample=p, /nd)
  end

 if(size(dn, /type) EQ 1) then dn = fix(dn)
 dn = strtrim(string(dn, format='(g10.4)'),2)
 widget_control, grim_data.xy_label, $
 			     set_value='(' + xx + ',' + yy + '): ' + dn

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_scroll</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_scroll:source"></a>pro grim_scroll, grim_data, plane, clicks, modifiers

 <span class="comments">;- - - - - - - - - - - - - - - - -</span>
 <span class="comments">; No modifier -- change mde </span>
 <span class="comments">;- - - - - - - - - - - - - - - - -</span>
 if(NOT keyword_set(modifiers)) then $
  begin
   dm = - clicks
   grim_increment_mode, grim_data, dm
   grim_set_data, grim_data<span class="comments">;, event.top</span>
  end $
 <span class="comments">;- - - - - - - - - - - - - - - - -</span>
 <span class="comments">; Ctrl -- change zoom </span>
 <span class="comments">;- - - - - - - - - - - - - - - - -</span>
 else if(modifiers EQ 2) then $
  begin
   dm = double(clicks)
   factor = 2d^dm
   offset = grim_zoom_to_cursor(factor, /relative, zoom=zoom)
   grim_refresh, grim_data, zoom=zoom, offset=offset
  end 

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_middle</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_middle:source"></a>pro grim_middle, grim_data, plane, id, x, y, press, clicks, modifiers, output_wnum

 if(press NE 2) then return

 if(grim_data.type EQ 'plot') then $
  begin
   xx = convert_coord(/data, /to_device,$
              [transpose(double(plane.xrange)), transpose(double(plane.yrange))])
   edge = [xx[0]+2, !d.x_size-xx[3]-1, xx[1]+2, !d.y_size-xx[4]-1]
   tvpan, wnum=input_wnum, /notvim, edge=edge, $
        	    p0=[x,y], cursor=60, hour=id, $
        	    output=output_wnum, col=ctred(), doffset=doffset
   grim_wset, grim_data, output_wnum
   grim_refresh, grim_data, doffset=doffset
  end $
 else $
  begin
   stat = grim_activate_by_point(/invert, grim_data, plane, [x,y], clicks=clicks)
   if(stat NE -1) then grim_refresh, grim_data, /noglass, /no_image $
   else $
    begin
     tvpan, wnum=input_wnum, /noplot, edge=3, $
        	    p0=[x,y], cursor=60, hour=id, $
        	    output=output_wnum, col=ctred()
     grim_wset, grim_data, output_wnum
     grim_refresh, grim_data
    end
  end 
 grim_set_mode, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_draw_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_draw_event:source"></a>pro grim_draw_event, event

 widget_control, event.id, get_value=value
 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 widget_control, event.id, get_value=input_wnum
 output_wnum = grim_data.wnum

 struct = tag_names(event, /struct)
 
 if(NOT grim_test_motion_event(event)) then grim_set_primary, grim_data.base


 <span class="comments">;======================================</span>
 <span class="comments">; motion event </span>
 <span class="comments">;======================================</span>
 if(struct EQ 'WIDGET_DRAW') then if(event.type EQ 2) then $
  begin
   grim_update_xy_label, grim_data, plane, event.x, event.y
   grim_update_guideline, grim_data, plane, event.x, event.y
  end


 <span class="comments">;===================================</span>
 <span class="comments">; middle button and scroll wheel</span>
 <span class="comments">;===================================</span>
 case struct of
  'WIDGET_DRAW' : $
   case event.type of
    <span class="comments">;- - - - - - - - - - - - - - - - -</span>
    <span class="comments">; scroll wheel -- zoom / mode</span>
    <span class="comments">;- - - - - - - - - - - - - - - - -</span>
    7 : grim_scroll, grim_data, plane, event.clicks, event.modifiers

    <span class="comments">;- - - - - - - - - - - - - - - - -</span>
    <span class="comments">; middle button -- pan / activate</span>
    <span class="comments">;- - - - - - - - - - - - - - - - -</span>
    0 : grim_middle, grim_data, plane, $
           event.id, event.x, event.y, $
           event.press, event.clicks, event.modifiers, output_wnum

    else : 
   endcase

  else : 
 endcase


 <span class="comments">;===================================</span>
 <span class="comments">; cursor modes</span>
 <span class="comments">;===================================</span>
 data = 0
 if(keyword_set(grim_data.mode_data_p)) then data = *grim_data.mode_data_p
 call_procedure, grim_data.mode + '_mouse_event', event, data
 *grim_data.mode_data_p = data


 grim_wset, grim_data, grim_data.wnum
 grim_set_mode, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; FILE MENU</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_load_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Allows user to load images into new image planes.  The user is </span>
<span class="comments">;	prompted for filenames and dat_read is used to read each image.</span>
<span class="comments">;	Multiple images may be selected and a new plane is created for</span>
<span class="comments">;	each image.  On X-windows systems, multiple files may be selected </span>
<span class="comments">;	either by dragging across the filenames or by holding down the </span>
<span class="comments">;	control key to toggle the selected files.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_load_help_event:source"></a>pro grim_menu_file_load_help_event, event
 text = ''
 nv_help, 'grim_menu_file_load_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_load_event:source"></a>pro grim_menu_file_load_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)
 grim_message, /clear
 
 widget_control, grim_data.base, /hourglass

 <span class="comments">;--------------------------</span>
 <span class="comments">; select file</span>
 <span class="comments">;--------------------------</span>
 if(keyword__set(plane.load_path)) then path = plane.load_path
 filenames = pickfiles(get_path=get_path, path=path, $
                        filter=plane.filter, title='Select images to load')
 if(NOT keyword__set(filenames[0])) then return

 <span class="comments">;----------------------------------</span>
 <span class="comments">; load each file into a new plane</span>
 <span class="comments">;----------------------------------</span>
 widget_control, grim_data.base, /hourglass
 grim_load_files, grim_data, filenames, load_path=get_path

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_browse_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Allows user to load images into new image planes using the brim </span>
<span class="comments">;	browser.  Images are selected using the left mouse button and</span>
<span class="comments">;	each image is loaded on a new plane.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 10/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_browse_help_event:source"></a>pro grim_menu_file_browse_help_event, event
 text = ''
 nv_help, 'grim_menu_file_browse_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_browse_file_left_event:source"></a>pro grim_browse_file_left_event, base, i, id, status=status

 status = -1
 grim_data = grim_get_data(base)


 status = 0
end
<span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<a id="grim_menu_file_browse_event:source"></a>pro grim_menu_file_browse_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)
 grim_message, /clear

 widget_control, grim_data.base, /hourglass

 <span class="comments">;----------------------------------</span>
 <span class="comments">; load images into brim</span>
 <span class="comments">;----------------------------------</span>
 if(keyword__set(plane.load_path)) then path = plane.load_path
 grim_wset, grim_data, grim_data.wnum, get_info=tvd

 brim, filenames, path=plane.load_path, get_path=get_path, ids=filenames, $
      left_fn='grim_browse_file_left_event', fn_data=event.top, /modal, $
      select=select, title='Select images to load', order=tvd.order, $
      filter=plane.filter, /enable
 if(NOT keyword__set(select)) then return
 if(select[0] EQ '') then return

 <span class="comments">;----------------------------------</span>
 <span class="comments">; load each file into a new plane</span>
 <span class="comments">;----------------------------------</span>
 widget_control, grim_data.base, /hourglass
 grim_load_files, grim_data, select, load_path=get_path

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_save_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Allows user to save the current image plane and geometry.  If there </span>
<span class="comments">;	is no current filename for the current plane, then the user is </span>
<span class="comments">;	prompted for one.  All descriptors are written through the translators</span>
<span class="comments">;	and then dat_write is used to write the data file.  Specific behavior </span>
<span class="comments">;	is governed by OMINAS' configuration.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_save_help_event:source"></a>pro grim_menu_file_save_help_event, event
 text = ''
 nv_help, 'grim_menu_file_save_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_save_event:source"></a>pro grim_menu_file_save_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 plane = grim_get_plane(grim_data)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; prompt for filename if necessary</span>
 <span class="comments">;------------------------------------------------------</span>
 filename = dat_filename(plane.dd)
 if(NOT keyword_set(filename)) then $
        filename = grim_get_save_filename(grim_data, filetype=filetype)
 if(NOT keyword_set(filename)) then return


 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 grim_write, grim_data, filename, filetype=filetype

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_save_as_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Same as 'Save' above, except always prompts for a filename. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_save_as_help_event:source"></a>pro grim_menu_file_save_as_help_event, event
 text = ''
 nv_help, 'grim_menu_file_save_as_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_save_as_event:source"></a>pro grim_menu_file_save_as_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 plane = grim_get_plane(grim_data)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; prompt for filename </span>
 <span class="comments">;------------------------------------------------------</span>
 filename = grim_get_save_filename(grim_data, filetype=filetype)
 if(NOT keyword_set(filename)) then return

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 grim_write, grim_data, filename, filetype=filetype

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_open_as_rgb_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Opens a new grim window with the current channal configuration </span>
<span class="comments">;	reduced to a 3-channel RGB cube.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 8/2016</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_open_as_rgb_help_event:source"></a>pro grim_menu_open_as_rgb_help_event, event
 text = ''
 nv_help, 'grim_menu_open_as_rgb_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_open_as_rgb_event:source"></a>pro grim_menu_open_as_rgb_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 widget_control, /hourglass
 grim_wset, grim_data, grim_data.wnum, get_info=tvd

 dim = dat_dim(plane.dd)
 cube = grim_scale_image(grim_data, r, g, b, plane=plane, $
                                 xrange=[0,dim[0]-1], yrange=[0,dim[1]-1])

<span class="comments">; look at render event to transfer overlays, etc</span>
<span class="comments">; dd = nv_clone(plane.dd)</span>
<span class="comments">; dat_set_data, dd, cube</span>
 dd = dat_create_descriptors(1, data=cube)
 dat_set_filetype, dd, dat_filetype(plane.dd)

 grim, /new, /rgb, dd, order=tvd.order, zoom=tvd.zoom[0], offset=tvd.offset, $
       xsize=!d.x_size, ysize=!d.y_size

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_save_user_ptd_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Writes user points for the current plane to a file called</span>
<span class="comments">;	[image name].user_ptd </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_save_user_ptd_help_event:source"></a>pro grim_menu_file_save_user_ptd_help_event, event
 text = ''
 nv_help, 'grim_menu_file_save_user_ptd_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_save_user_ptd_event:source"></a>pro grim_menu_file_save_user_ptd_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 plane = grim_get_plane(grim_data)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; get filename</span>
 <span class="comments">;------------------------------------------------------</span>
 fname = pickfiles(default=grim_user_ptd_fname(grim_data, plane), $
                            title='Select filename for saving', /one)

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 grim_write_user_points, grim_data, plane, fname=fname
 grim_print, grim_data, 'User points saved.'

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_save_all_user_ptd_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Writes user points for all planes to files called</span>
<span class="comments">;	[image name].user_ptd </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_save_all_user_ptd_help_event:source"></a>pro grim_menu_file_save_all_user_ptd_help_event, event
 text = ''
 nv_help, 'grim_menu_file_save_all_user_ptd_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_save_all_user_ptd_event:source"></a>pro grim_menu_file_save_all_user_ptd_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 planes = grim_get_plane(grim_data, /all)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 for i=0, n_elements(planes)-1 do $
                          grim_write_user_points, grim_data, planes[i], fname=fname
 grim_print, grim_data, 'All user points saved.'

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_load_user_ptd_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	loads user points for the current plane from a file called</span>
<span class="comments">;	[image name].user_ptd </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_load_user_ptd_help_event:source"></a>pro grim_menu_file_load_user_ptd_help_event, event
 text = ''
 nv_help, 'grim_menu_file_load_user_ptd_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_load_user_ptd_event:source"></a>pro grim_menu_file_load_user_ptd_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 plane = grim_get_plane(grim_data)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 grim_read_user_points, grim_data, plane
 grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_load_all_user_ptd_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Loads user points for all planes from files called</span>
<span class="comments">;	[image name].user_ptd </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_load_all_user_ptd_help_event:source"></a>pro grim_menu_file_load_all_user_ptd_help_event, event
 text = ''
 nv_help, 'grim_menu_file_load_all_user_ptd_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_load_all_user_ptd_event:source"></a>pro grim_menu_file_load_all_user_ptd_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 planes = grim_get_plane(grim_data, /all)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; read data</span>
 <span class="comments">;------------------------------------------------------</span>
 for i=0, n_elements(planes)-1 do $
                          grim_read_user_points, grim_data, planes[i]
 grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_save_tie_ptd_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Writes tie points for the current plane to a file called</span>
<span class="comments">;	[image name].tie_ptd </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_save_tie_ptd_help_event:source"></a>pro grim_menu_file_save_tie_ptd_help_event, event
 text = ''
 nv_help, 'grim_menu_file_save_tie_ptd_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_save_tie_ptd_event:source"></a>pro grim_menu_file_save_tie_ptd_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 plane = grim_get_plane(grim_data)
 grim_message, /clear


 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; get filename</span>
 <span class="comments">;------------------------------------------------------</span>
 fname = pickfiles(default=grim_indexed_array_fname(grim_data, plane, 'TIEPOINT'), $
                                            title='Select filename for saving', /one)

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 grim_write_indexed_arrays, grim_data, plane, 'TIEPOINT', fname=fname
 grim_print, grim_data, 'Tie points saved.'

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_save_all_tie_ptd_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Writes tie points for all planes to files called</span>
<span class="comments">;	[image name].tie_ptd </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_save_all_tie_ptd_help_event:source"></a>pro grim_menu_file_save_all_tie_ptd_help_event, event
 text = ''
 nv_help, 'grim_menu_file_save_all_tie_ptd_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_save_all_tie_ptd_event:source"></a>pro grim_menu_file_save_all_tie_ptd_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 planes = grim_get_plane(grim_data, /all)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 for i=0, n_elements(planes)-1 do $
                          grim_write_indexed_arrays, grim_data, planes[i], 'TIEPOINT'
 grim_print, grim_data, 'All tie points saved.'

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_load_tie_ptd_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	loads tie points for the current plane from a file called</span>
<span class="comments">;	[image name].tie_ptd </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_load_tie_ptd_help_event:source"></a>pro grim_menu_file_load_tie_ptd_help_event, event
 text = ''
 nv_help, 'grim_menu_file_load_tie_ptd_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_load_tie_ptd_event:source"></a>pro grim_menu_file_load_tie_ptd_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 plane = grim_get_plane(grim_data)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; get filename</span>
 <span class="comments">;------------------------------------------------------</span>
 fname = pickfiles(default=grim_indexed_array_fname(grim_data, plane, 'TIEPOINT'), $
                                         title='Select filename to load', /one)

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 grim_read_indexed_arrays, grim_data, plane, 'TIEPOINT', fname=fname
 grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_load_all_tie_ptd_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Loads tie points for all planes from files called</span>
<span class="comments">;	[image name].tie_ptd </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_load_all_tie_ptd_help_event:source"></a>pro grim_menu_file_load_all_tie_ptd_help_event, event
 text = ''
 nv_help, 'grim_menu_file_load_all_tie_ptd_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_load_all_tie_ptd_event:source"></a>pro grim_menu_file_load_all_tie_ptd_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 planes = grim_get_plane(grim_data, /all)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; read data</span>
 <span class="comments">;------------------------------------------------------</span>
 for i=0, n_elements(planes)-1 do $
                          grim_read_indexed_arrays, grim_data, planes[i], 'TIEPOINT'
 grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_save_curves_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Writes curves for the current plane to a file called</span>
<span class="comments">;	[image name].curve_ptd </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 12/2015</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_save_curves_help_event:source"></a>pro grim_menu_file_save_curves_help_event, event
 text = ''
 nv_help, 'grim_menu_file_save_curves_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_save_curves_event:source"></a>pro grim_menu_file_save_curves_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 plane = grim_get_plane(grim_data)
 grim_message, /clear


 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; get filename</span>
 <span class="comments">;------------------------------------------------------</span>
 fname = pickfiles(default=grim_indexed_array_fname(grim_data, plane, 'CURVE'), $
                                         title='Select filename for saving', /one)

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 grim_write_indexed_arrays, grim_data, plane, 'CURVE', fname=fname
 grim_print, grim_data, 'Curves saved.'

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_save_all_curves_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Writes curves for all planes to files called</span>
<span class="comments">;	[image name].curve_ptd </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 12/2015</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_save_all_curves_help_event:source"></a>pro grim_menu_file_save_all_curves_help_event, event
 text = ''
 nv_help, 'grim_menu_file_save_all_curves_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_save_all_curves_event:source"></a>pro grim_menu_file_save_all_curves_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 planes = grim_get_plane(grim_data, /all)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 for i=0, n_elements(planes)-1 do $
                          grim_write_indexed_arrays, grim_data, planes[i], 'CURVE'
 grim_print, grim_data, 'All curves saved.'

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_load_curves_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	loads curves for the current plane from a file called</span>
<span class="comments">;	[image name].curve_ptd </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 12/2015</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_load_curves_help_event:source"></a>pro grim_menu_file_load_curves_help_event, event
 text = ''
 nv_help, 'grim_menu_file_load_curves_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_load_curves_event:source"></a>pro grim_menu_file_load_curves_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 plane = grim_get_plane(grim_data)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; get filename</span>
 <span class="comments">;------------------------------------------------------</span>
 fname = pickfiles(default=grim_indexed_array_fname(grim_data, plane, 'CURVE'), $
                                            title='Select filename to load', /one)

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 grim_read_indexed_arrays, grim_data, plane, 'CURVE', fname=fname
 grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_load_all_curves_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Loads curves for all planes from files called</span>
<span class="comments">;	[image name].curve_ptd </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 12/2015</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_load_all_curves_help_event:source"></a>pro grim_menu_file_load_all_curves_help_event, event
 text = ''
 nv_help, 'grim_menu_file_load_all_curves_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_load_all_curves_event:source"></a>pro grim_menu_file_load_all_curves_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 planes = grim_get_plane(grim_data, /all)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; read data</span>
 <span class="comments">;------------------------------------------------------</span>
 for i=0, n_elements(planes)-1 do $
                          grim_read_indexed_arrays, grim_data, planes[i], 'CURVE'
 grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_save_mask_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Writes mask points for the current plane to a file called</span>
<span class="comments">;	[image name].mask </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 8/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_save_mask_help_event:source"></a>pro grim_menu_file_save_mask_help_event, event
 text = ''
 nv_help, 'grim_menu_file_save_mask_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_save_mask_event:source"></a>pro grim_menu_file_save_mask_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 plane = grim_get_plane(grim_data)
 grim_message, /clear


 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 grim_write_mask, grim_data, plane
 grim_print, grim_data, 'Mask saved.'

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_save_all_masks_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Writes mask points for all planes to files called</span>
<span class="comments">;	[image name].mask </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 8/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_save_all_masks_help_event:source"></a>pro grim_menu_file_save_all_masks_help_event, event
 text = ''
 nv_help, 'grim_menu_file_save_all_masks_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_save_all_masks_event:source"></a>pro grim_menu_file_save_all_masks_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 planes = grim_get_plane(grim_data, /all)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 for i=0, n_elements(planes)-1 do $
                          grim_write_mask, grim_data, planes[i]
 grim_print, grim_data, 'All masks saved.'

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_load_mask_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	loads mask points for the current plane from a file called</span>
<span class="comments">;	[image name].mask </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 8/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_load_mask_help_event:source"></a>pro grim_menu_file_load_mask_help_event, event
 text = ''
 nv_help, 'grim_menu_file_load_mask_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_load_mask_event:source"></a>pro grim_menu_file_load_mask_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 plane = grim_get_plane(grim_data)
 grim_message, /clear


 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write data</span>
 <span class="comments">;------------------------------------------------------</span>
 grim_read_mask, grim_data, plane
 grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_load_all_masks_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Loads mask points for all planes from files called</span>
<span class="comments">;	[image name].mask </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 8/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_load_all_masks_help_event:source"></a>pro grim_menu_file_load_all_masks_help_event, event
 text = ''
 nv_help, 'grim_menu_file_load_all_masks_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_load_all_masks_event:source"></a>pro grim_menu_file_load_all_masks_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 planes = grim_get_plane(grim_data, /all)
 grim_message, /clear

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; read data</span>
 <span class="comments">;------------------------------------------------------</span>
 for i=0, n_elements(planes)-1 do $
                          grim_read_mask, grim_data, planes[i]
 grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_save_ps_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Saves the current view as a postscript file. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 12/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_save_ps_help_event:source"></a>pro grim_menu_file_save_ps_help_event, event
 text = ''
 nv_help, 'grim_menu_file_save_ptd_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_save_ps_event:source"></a>pro grim_menu_file_save_ps_event, event



 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; prompt for filename </span>
 <span class="comments">;------------------------------------------------------</span>
 filename = pickfiles(get_path=get_path, $
                         title='Select filename for saving', path=path, /one)
 if(NOT keyword__set(filename)) then return

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; write postscript file</span>
 <span class="comments">;------------------------------------------------------</span>
 widget_control, grim_data.draw, /hourglass
 grim_write_ptd, grim_data, filename[0]

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_repeat_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Repeats the last menu option.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 8/2006</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_repeat_help_event:source"></a>pro grim_menu_repeat_help_event, event
 text = ''
 nv_help, 'grim_menu_file_repeat_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_repeat_event:source"></a>pro grim_menu_repeat_event, event

 grim_data = grim_get_data(event.top)
 grim_repeat, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_undo_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Undoes the last data modification.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 11/2006</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_undo_help_event:source"></a>pro grim_menu_undo_help_event, event
 text = ''
 nv_help, 'grim_menu_file_undo_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_undo_event:source"></a>pro grim_menu_undo_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)
 grim_undo, grim_data, plane
 
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_redo_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Redoes the last data modification.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 11/2006</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_redo_help_event:source"></a>pro grim_menu_redo_help_event, event
 text = ''
 nv_help, 'grim_menu_file_redo_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_redo_event:source"></a>pro grim_menu_redo_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)
 grim_redo, grim_data, plane

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_select_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Selects or unselects a grim window.  This functionality is for use</span>
<span class="comments">;	with functions that require input from more than one grim instance. </span>
<span class="comments">;	The selected state is red; unselected is gray.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; OPERATION:</span>
<span class="comments">;	This option toggles a given grim instance between selected </span>
<span class="comments">;	and unselected states, for use with functions that require </span>
<span class="comments">;	input from more than one grim instance.  When a given instance </span>
<span class="comments">;	is selected, this button displays an asterisk.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_select_help_event:source"></a>pro grim_select_help_event, event
 text = ''
 nv_help, 'grim_select_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_select_event:source"></a>pro grim_select_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then $
       grim_print, grim_data, 'Select/Deselect this grim window'
   return
  end $
 else if(NOT grim_test_motion_event(event)) then $
                                               grim_set_primary, grim_data.base

 grim_select, grim_data
 grim_set_data, grim_data, event.top

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_identify_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Causes grim to identify itself on the IDL command line.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; OPERATION:</span>
<span class="comments">;	This option causes grim to print a message on the IDL command line.</span>
<span class="comments">;	It is useful in cases where multiple grim instances are running in</span>
<span class="comments">;	multiple IDL sessions.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2009</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_identify_help_event:source"></a>pro grim_identify_help_event, event
 text = ''
 nv_help, 'grim_identify_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_identify_event:source"></a>pro grim_identify_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then $
       grim_print, grim_data, 'Identify this grim window'
   return
  end $
 else if(NOT grim_test_motion_event(event)) then $
                                               grim_set_primary, grim_data.base

 grim_identify, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_file_close_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Closes the current image plane.  All other image plane numbers </span>
<span class="comments">;	remain the same.  If there is only one image plane, the grim exits. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_file_close_help_event:source"></a>pro grim_menu_file_close_help_event, event
 text = ''
 nv_help, 'grim_menu_file_close_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_file_close_event:source"></a>pro grim_menu_file_close_event, event

 grim_data = grim_get_data(event.top)
 grim_rm_plane, grim_data, grim_data.pn

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; PLANE MENU</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_next_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Changes to the next-numbered image plane. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_next_help_event:source"></a>pro grim_menu_plane_next_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_next_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_next_event:source"></a>pro grim_menu_plane_next_event, event

 grim_data = grim_get_data(event.top)

 grim_next_plane, grim_data
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_previous_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Changes to the previous-numbered image plane. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_previous_help_event:source"></a>pro grim_menu_plane_previous_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_previous_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_previous_event:source"></a>pro grim_menu_plane_previous_event, event

 grim_data = grim_get_data(event.top)

 grim_previous_plane, grim_data
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_jump_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Prompts the user and jumps to a new plane. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 5/2005</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_jump_help_event:source"></a>pro grim_menu_plane_jump_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_jump_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_jump_event:source"></a>pro grim_menu_plane_jump_event, event

 grim_data = grim_get_data(event.top)

 valid = grim_jumpto(grim_data)
 if(valid) then grim_refresh, grim_data, /no_erase

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_browse_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Opens a brim browser showing all planes.  The left mouse button </span>
<span class="comments">;	may be used to jump among planes.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 10/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_browse_help_event:source"></a>pro grim_menu_plane_browse_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_browse_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_browse_plane_left_event:source"></a>pro grim_browse_plane_left_event, base, i, id, status=status

 status = -1
 grim_data = grim_get_data(base)
 if(NOT grim_exists(grim_data)) then return

 pn = id[0]

 grim_jump_to_plane, grim_data, pn, valid=valid
 if(valid) then $
  begin
   grim_refresh, grim_data, /no_erase
   status = 1
  end

end
<span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<a id="grim_browse_refresh_event:source"></a>pro grim_browse_refresh_event, data_p

 base = *data_p
 if(NOT widget_info(base, /valid_id)) then $
  begin
   grim_rm_refresh_callback, data_p
   return
  end

 grim_data = grim_get_data()
 plane = grim_get_plane(grim_data)

 widget_control, base, get_uvalue=brim_data

 planes = grim_get_plane(grim_data, /all)
 brim_select, brim_data, plane.pn, dd=planes.dd, id=planes.pn


end
<span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<a id="grim_menu_plane_browse_event:source"></a>pro grim_menu_plane_browse_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)
 planes = grim_get_plane(grim_data, /all, pn=pns)

 grim_wset, grim_data, grim_data.wnum, get_info=tvd
 brim, planes.dd, ids=pns, $
      left_fn='grim_browse_plane_left_event', fn_data=event.top, $
      select=grim_data.pn, /exclusive, order=tvd.order, /enable, base=base

 grim_add_refresh_callback, 'grim_browse_refresh_event', nv_ptr_new(base)

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_open_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Opens the image of the current plane in a new grim window.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 11/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_open_help_event:source"></a>pro grim_menu_plane_open_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_open_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_open_event:source"></a>pro grim_menu_plane_open_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 widget_control, /hourglass
 grim_wset, grim_data, grim_data.wnum, get_info=tvd
 grim, /new, plane.dd, order=tvd.order, zoom=tvd.zoom[0], offset=tvd.offset, $
       xsize=!d.x_size, ysize=!d.y_size

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_evolve_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Evolves the selected objects onto all other planes.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_evolve_help_event:source"></a>pro grim_menu_plane_evolve_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_evolve_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_evolve_event:source"></a>pro grim_menu_plane_evolve_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 widget_control, /hourglass

grim_print, grim_data, 'Not implemented!'

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_crop_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Crops the data to the current viewing parameters.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_crop_help_event:source"></a>pro grim_menu_plane_crop_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_crop_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_crop_event:source"></a>pro grim_menu_plane_crop_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 grim_crop_plane, grim_data, plane
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_reorder_time_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Rearranges all planes in time order.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_reorder_time_help_event:source"></a>pro grim_menu_plane_reorder_time_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_reorder_time_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_reorder_time_event:source"></a>pro grim_menu_plane_reorder_time_event, event

 widget_control, /hourglass

 grim_data = grim_get_data(event.top)
 planes = grim_get_plane(grim_data, /all)

 n = n_elements(planes)
 times = dblarr(n)
 for i=0, n-1 do $
  begin
   cd = *planes[i].cd_p
   if(NOT keyword__set(cd)) then grim_message, $
                   'You must first load camera descriptors for each plane.'
   times[i] = bod_time(cd)
  end

 s = sort(times)

 planes = planes[s]
 for i=0, n-1 do $
  begin
   planes[i].pn = i
   grim_set_plane, grim_data, planes[i], pn=i
  end

 grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_sequence_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Displays all planes in sequence using xinteranimate.  This option is</span>
<span class="comments">;	useful or blinking as well.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 8/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_sequence_help_event:source"></a>pro grim_menu_plane_sequence_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_sequence_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_sequence_event:source"></a>pro grim_menu_plane_sequence_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;--------------------------------------------</span>
 <span class="comments">; get valid planes</span>
 <span class="comments">;--------------------------------------------</span>
 planes = grim_get_plane(grim_data, /all)
 n = n_elements(planes)
 if(n LE 1) then return
 
 <span class="comments">;--------------------------------------------</span>
 <span class="comments">; set up images</span>
 <span class="comments">;--------------------------------------------</span>
 widget_control, /hourglass

 geom = widget_info(grim_data.draw, /geom)
 xinteranimate, set=[geom.xsize, geom.ysize, n]
 tvim, /noplot, /silent, $
           /new, /inherit, xsize=geom.xsize, ysize=geom.ysize, /pixmap
 pixmap = !d.window

<span class="comments">; for i=0, n-1 do $</span>
<span class="comments">;  begin</span>
<span class="comments">;grim_refresh, grim_data, plane=planes[i], wnum=pixmap, /no_title</span>
<span class="comments">;im = tvrd()</span>
<span class="comments">;write_gif, /mult, '~/test.gif', im</span>
<span class="comments">;  end</span>
<span class="comments">;write_gif, /close</span>
<span class="comments">;stop</span>

 for i=0, n-1 do $
  begin
   grim_print, grim_data, $
     'Loading plane ' + strtrim(i,2) + ' of ' + strtrim(n,2) + '...'

   wset, pixmap & erase & wset, grim_data.wnum

   grim_refresh, grim_data, plane=planes[i], wnum=pixmap, /no_title

   xinteranimate, frame=i, window=pixmap, /show
  end

 grim_print, grim_data, ''

 <span class="comments">;--------------------------------------------</span>
 <span class="comments">; run the movie</span>
 <span class="comments">;--------------------------------------------</span>
 wdelete, pixmap
 grim_wset, grim_data, grim_data.wnum

 xinteranimate
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_dump_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Dumps all planes to png files entitled [filename].png.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 8/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_dump_help_event:source"></a>pro grim_menu_plane_dump_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_dump_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_dump_event:source"></a>pro grim_menu_plane_dump_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;--------------------------------------------</span>
 <span class="comments">; get valid planes</span>
 <span class="comments">;--------------------------------------------</span>
 planes = grim_get_plane(grim_data, /all)
 n = n_elements(planes)
 if(n LE 1) then return
 
 <span class="comments">;--------------------------------------------</span>
 <span class="comments">; set up images</span>
 <span class="comments">;--------------------------------------------</span>
 widget_control, /hourglass

 geom = widget_info(grim_data.draw, /geom)
 xinteranimate, set=[geom.xsize, geom.ysize, n]
 tvim, /noplot, /silent, $
           /new, /inherit, xsize=geom.xsize, ysize=geom.ysize, /pixmap
 pixmap = !d.window


 for i=0, n-1 do $
  begin
   filename = cor_name(planes[i].dd)
   grim_refresh, grim_data, plane=planes[i], wnum=pixmap, /no_title
   wset, pixmap
   write_png, filename + '.png', tvrd()
  end

 wdelete, pixmap
 grim_wset, grim_data, grim_data.wnum

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_coregister_event </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Shifts the images on each plane so as to center the active object </span>
<span class="comments">;	at the same pixel on each plane. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 11/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_coregister_help_event:source"></a>pro grim_menu_plane_coregister_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_coregister_event ', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_coregister_event:source"></a>pro grim_menu_plane_coregister_event, event

 grim_data = grim_get_data(event.top)
 planes = grim_get_plane(grim_data, /all)
 n = n_elements(planes)

 widget_control, grim_data.draw, /hourglass


 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; make sure relevant descriptors are loaded</span>
 <span class="comments">;------------------------------------------------</span>
 for i=0, n-1 do $
   grim_load_descriptors, grim_data, class='camera', plane=planes[i], cd=cd
 if(NOT keyword_set(cd[0])) then return 


 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; build descriptor arrays</span>
 <span class="comments">;------------------------------------------------</span>
 cd = objarr(n)
 bx = objarr(n)
 dd = objarr(n)

 for i=0, n-1 do $
  if(keyword_set(*planes[i].active_xd_p)) then $
   begin
    dd[i] = planes[i].dd
    cd[i] = *planes[i].cd_p
    bx[i] = (*planes[i].active_xd_p)[0]
   end

 w = where(obj_valid(dd))
 if(w[0] EQ -1)then $
  begin
   grim_message, 'There are no active overlays.'
   return
  end

 dd = dd[w]
 cd = cd[w]
 bx = bx[w]

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; recenter image</span>
 <span class="comments">;------------------------------------------------</span>
 nv_suspend_events
 pg_coregister, dd, cd=cd, bx=bx
 nv_resume_events

 grim_refresh, grim_data
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_coadd_event </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Averages all planes.  Not implemented.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 5/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_coadd_help_event:source"></a>pro grim_menu_plane_coadd_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_coadd_event ', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_coadd_event:source"></a>pro grim_menu_plane_coadd_event, event

 grim_data = grim_get_data(event.top)
 planes = grim_get_plane(grim_data, /all)
 widget_control, grim_data.draw, /hourglass

 
<span class="comments">; grim_refresh, grim_data</span>
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_toggle_plane_syncing_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Toggles plane syncing on/off.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2016</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_toggle_plane_syncing_help_event:source"></a>pro grim_menu_plane_toggle_plane_syncing_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_toggle_plane_syncing_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_toggle_plane_syncing_event:source"></a>pro grim_menu_plane_toggle_plane_syncing_event, event

 widget_control, /hourglass

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)


 grim_data = grim_get_data(event.top)

 flag = grim_get_toggle_flag(grim_data, 'PLANE_SYNCING')
 flag = 1 - flag
 
 grim_set_toggle_flag, grim_data, 'PLANE_SYNCING', flag
 grim_update_menu_toggle, grim_data, $
                       'grim_menu_plane_toggle_plane_syncing_event', flag


<span class="comments">; grim_sync_planes, grim_data</span>
<span class="comments">; grim_refresh, grim_data, /use_pixmap</span>

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_highlight_event </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Toggles highlighting of the current plane image.  Useful when </span>
<span class="comments">;	multiple planes are visible simultaneously.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_highlight_help_event:source"></a>pro grim_menu_plane_highlight_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_highlight_event ', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_highlight_event:source"></a>pro grim_menu_plane_highlight_event, event

 grim_data = grim_get_data(event.top)

 flag = grim_get_toggle_flag(grim_data, 'PLANE_HIGHLIGHT')
 flag = 1 - flag

 grim_set_toggle_flag, grim_data, 'PLANE_HIGHLIGHT', flag
 grim_update_menu_toggle, grim_data, 'grim_menu_plane_highlight_event', flag


<span class="comments">; widget_control, grim_data.draw, /hourglass</span>
 
 grim_refresh, grim_data
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_copy_tiepoints_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Copies all tieppoints from the current plane to all other planes.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_copy_tiepoints_help_event:source"></a>pro grim_menu_plane_copy_tiepoints_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_copy_tiepoints_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_copy_tiepoints_event:source"></a>pro grim_menu_plane_copy_tiepoints_event, event

 widget_control, /hourglass

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)
 planes = grim_get_plane(grim_data, /all)

 n = n_elements(planes)
 pn = plane.pn

 for i=0, n-1 do if(i NE pn) then $
                        grim_copy_tiepoint, grim_data, plane, planes[i]

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_propagate_tiepoints_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Copies all tieppoints from the current plane to all other planes.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_propagate_tiepoints_help_event:source"></a>pro grim_menu_plane_propagate_tiepoints_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_propagate_tiepoints_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_propagate_tiepoints_event:source"></a>pro grim_menu_plane_propagate_tiepoints_event, event

 widget_control, /hourglass


 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)
 planes = grim_get_plane(grim_data, /all)

 nplanes = n_elements(planes)
 pn = plane.pn


 tie_pts = pnt_points(plane.tiepoints_ptd)
 if(NOT keyword_set(tie_pts)) then return
 npts = n_elements(tie_pts)/2
 ii = grim_get_tiepoint_indices(grim_data, plane=plane)

 grim_load_descriptors, grim_data, class='camera', plane=plane, cd=cd
 if(NOT keyword_set(cd[0])) then $ 
  begin
   grim_message, 'No camera descriptor!'
   return
  end
 grim_load_descriptors, grim_data, class='planet', plane=plane, pd=pd
 if(NOT keyword_set(pd[0])) then return

 cd = cd[0]

 pd0 = get_primary(cd, pd)
 name = cor_name(pd0)

 tie_pts = reform(tie_pts, 2, 1, npts, /over)

 dkd = make_array(npts, $
           val=orb_construct_descriptor(pd0, sma=1d8, GG=const_G))
 for i=0, npts-1 do $ 
   dkd[i] = image_to_orbit(cd, pd0, dkd[i], tie_pts[*,0,i], GG=const_G)
<span class="comments">;orb_set_ma, dkd, orb_anom_to_lon(dkd, orb_get_ma(dkd), pd0)</span>
<span class="comments">; for i=0, npts-1 do orb_print_elements_mks, dkd[i], pd0</span>

 for i=0, nplanes-1 do $
  if(planes[i].pn NE pn) then $
   begin
    grim_load_descriptors, grim_data, class='camera', plane=planes[i]
    cdi = (*planes[i].cd_p)[0]
    if(keyword_set(cdi)) then $
     begin
      grim_load_descriptors, grim_data, class='planet', plane=planes[i]
      w = where(cor_name(pd) EQ name)
      if(w[0] NE -1) then $
       begin
        pdi = (pd)[w[0]]

        dt = bod_time(pdi) - bod_time(pd0)
        dkdt = objarr(npts)
        r = dblarr(1,3,npts)
        for j=0, npts-1 do $
         begin
          dkdt[j] = orb_evolve(dkd[j], dt)
          bod_set_pos, dkdt[j], bod_pos(pdi)
          r[*,*,j] = orb_to_cartesian(dkdt[j], v=_v)
<span class="comments">;          r[*,*,j] = orb_to_cartesian_lt(cdi, dkdt[j], c=const_c, v=_v)</span>
         end

        if(npts GT 1) then r = transpose(r)
        p = reform(inertial_to_image_pos(cdi, r))
plots, p, psym=1, col=ctgreen()

        grim_copy_tiepoint, grim_data, plane, planes[i]
        planes[i] = grim_get_plane(grim_data, pn=planes[i].pn) 

        grim_replace_tiepoints, grim_data, ii, p, plane=planes[i]

        nv_free, dkdt
       end
     end

   end

 nv_free, dkd

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_toggle_tiepoint_syncing_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Toggles tiepoint syncing on/off.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 10/2012</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_toggle_tiepoint_syncing_help_event:source"></a>pro grim_menu_plane_toggle_tiepoint_syncing_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_toggle_tiepoint_syncing_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_toggle_tiepoint_syncing_event:source"></a>pro grim_menu_plane_toggle_tiepoint_syncing_event, event

 widget_control, /hourglass

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)


 grim_data = grim_get_data(event.top)

 flag = grim_get_toggle_flag(grim_data, 'TIEPOINT_SYNCING')
 flag = 1 - flag

 grim_set_toggle_flag, grim_data, 'TIEPOINT_SYNCING', flag
 grim_update_menu_toggle, grim_data, $
               'grim_menu_plane_toggle_tiepoint_syncing_event', flag


<span class="comments">; grim_sync_tiepoints, grim_data</span>
<span class="comments">; grim_refresh, grim_data, /use_pixmap</span>

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_clear_tiepoints_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Clears all tiepoints from the current plane.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 11/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_clear_tiepoints_help_event:source"></a>pro grim_menu_plane_clear_tiepoints_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_clear_tiepoints_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_clear_tiepoints_event:source"></a>pro grim_menu_plane_clear_tiepoints_event, event

 widget_control, /hourglass

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 grim_rm_tiepoint, grim_data, plane=plane, /all
 grim_refresh, grim_data, /use_pixmap

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_copy_curves_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Copies all curves from the current plane to all other planes.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_copy_curves_help_event:source"></a>pro grim_menu_plane_copy_curves_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_copy_curves_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_copy_curves_event:source"></a>pro grim_menu_plane_copy_curves_event, event

 widget_control, /hourglass

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)
 planes = grim_get_plane(grim_data, /all)

 n = n_elements(planes)
 pn = plane.pn

 for i=0, n-1 do if(i NE pn) then grim_copy_curve, grim_data, plane, planes[i]

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_toggle_curve_syncing_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Toggles curve syncing on/off.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 10/2012</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_toggle_curve_syncing_help_event:source"></a>pro grim_menu_plane_toggle_curve_syncing_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_toggle_curve_syncing_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_toggle_curve_syncing_event:source"></a>pro grim_menu_plane_toggle_curve_syncing_event, event

 widget_control, /hourglass

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)


 grim_data = grim_get_data(event.top)
 
 flag = grim_get_toggle_flag(grim_data, 'CURVE_SYNCING')
 flag = 1 - flag

 grim_set_toggle_flag, grim_data, 'CURVE_SYNCING', flag
 grim_update_menu_toggle, grim_data, $
                      'grim_menu_plane_toggle_curve_syncing_event', flag

<span class="comments">; grim_sync_curves, grim_data</span>
<span class="comments">; grim_refresh, grim_data, /use_pixmap</span>

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_clear_curves_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Clears all curves from the current plane.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 11/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_clear_curves_help_event:source"></a>pro grim_menu_plane_clear_curves_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_clear_curves_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_clear_curves_event:source"></a>pro grim_menu_plane_clear_curves_event, event

 widget_control, /hourglass

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 grim_rm_curve, grim_data, plane=plane, /all
 grim_refresh, grim_data, /use_pixmap

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_copy_mask_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Copies mask from the current plane to all other planes.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 8/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_copy_mask_help_event:source"></a>pro grim_menu_plane_copy_mask_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_copy_mask_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_copy_mask_event:source"></a>pro grim_menu_plane_copy_mask_event, event

 widget_control, /hourglass

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)
 planes = grim_get_plane(grim_data, /all)

 n = n_elements(planes)
 pn = plane.pn

 for i=0, n-1 do if(i NE pn) then grim_copy_mask, grim_data, plane, planes[i]
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_clear_mask_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Clears the mask from the current plane.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 8/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_clear_mask_help_event:source"></a>pro grim_menu_plane_clear_mask_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_clear_mask_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_clear_mask_event:source"></a>pro grim_menu_plane_clear_mask_event, event

 widget_control, /hourglass

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 grim_rm_mask, grim_data, plane=plane, /all
 grim_refresh, grim_data, /use_pixmap

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_plane_settings_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Allows the user modify settings for the loaded image planes.  </span>
<span class="comments">;	Each plane may displayed in any combination of the three color</span>
<span class="comments">;	channels.  Also, a plane may be made visible even when it is not</span>
<span class="comments">;	the current plane, instead of the default behavior, which is to </span>
<span class="comments">;	display the plane only whenit is current.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 8/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_plane_settings_help_event:source"></a>pro grim_menu_plane_settings_help_event, event
 text = ''
 nv_help, 'grim_menu_plane_settings_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_plane_settings_event:source"></a>pro grim_menu_plane_settings_event, event

 grim_data = grim_get_data(event.top)
 grim_plane_settings, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; DATA MENU</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_data_adjust_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	This option allows the user to adjust data values.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2014</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_data_adjust_help_event:source"></a>pro grim_menu_data_adjust_help_event, event
 text = ''
 nv_help, 'grim_menu_data_adjust_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_data_adjust_event:source"></a>pro grim_menu_data_adjust_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; adjust the data</span>
 <span class="comments">;------------------------------------------------</span>
 grim_logging, grim_data, /start
 pg_data_adjust, plane.dd
 grim_logging, grim_data, /stop

 
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; VIEW MENU</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_refresh_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Redraws the overlays on the graphics display. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_refresh_help_event:source"></a>pro grim_menu_view_refresh_help_event, event
 text = ''
 nv_help, 'grim_menu_view_refresh_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_refresh_event:source"></a>pro grim_menu_view_refresh_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass
 grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Prompts the user for a new zoom factor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 5/2005</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_help_event:source"></a>pro grim_menu_view_zoom_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_event:source"></a>pro grim_menu_view_zoom_event, event

 grim_data = grim_get_data(event.top)
 zoom = grim_zoom(grim_data)
 if(zoom NE 0) then grim_refresh, grim_data, zoom=zoom

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_double_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Doubles the current zoom, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_double_help_event:source"></a>pro grim_menu_view_zoom_double_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_double_event:source"></a>pro grim_menu_view_zoom_double_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(2d, /relative, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_half_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Halves the current zoom, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_half_help_event:source"></a>pro grim_menu_view_zoom_half_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_half_event:source"></a>pro grim_menu_view_zoom_half_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(0.5d, /relative, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_1_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 1, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_1_help_event:source"></a>pro grim_menu_view_zoom_1_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_1_event:source"></a>pro grim_menu_view_zoom_1_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(1d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_2_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 2, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_2_help_event:source"></a>pro grim_menu_view_zoom_2_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_2_event:source"></a>pro grim_menu_view_zoom_2_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(2d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_3_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 3, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_3_help_event:source"></a>pro grim_menu_view_zoom_3_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_3_event:source"></a>pro grim_menu_view_zoom_3_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(3d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_4_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 4, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_4_help_event:source"></a>pro grim_menu_view_zoom_4_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_4_event:source"></a>pro grim_menu_view_zoom_4_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(4d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_5_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 5, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_5_help_event:source"></a>pro grim_menu_view_zoom_5_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_5_event:source"></a>pro grim_menu_view_zoom_5_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(5d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_6_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 6, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_6_help_event:source"></a>pro grim_menu_view_zoom_6_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_6_event:source"></a>pro grim_menu_view_zoom_6_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(6d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_7_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 7, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_7_help_event:source"></a>pro grim_menu_view_zoom_7_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_7_event:source"></a>pro grim_menu_view_zoom_7_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(7d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_8_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 8, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_8_help_event:source"></a>pro grim_menu_view_zoom_8_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_8_event:source"></a>pro grim_menu_view_zoom_8_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(8d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_9_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 9, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_9_help_event:source"></a>pro grim_menu_view_zoom_9_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_9_event:source"></a>pro grim_menu_view_zoom_9_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(9d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_10_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 10, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_10_help_event:source"></a>pro grim_menu_view_zoom_10_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_10_event:source"></a>pro grim_menu_view_zoom_10_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(10d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_1_2_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 1/2, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_1_2_help_event:source"></a>pro grim_menu_view_zoom_1_2_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_1_2_event:source"></a>pro grim_menu_view_zoom_1_2_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(1d/2d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_1_3_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 1/3, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_1_3_help_event:source"></a>pro grim_menu_view_zoom_1_3_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_1_3_event:source"></a>pro grim_menu_view_zoom_1_3_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(1d/3d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_1_4_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 1/4, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_1_4_help_event:source"></a>pro grim_menu_view_zoom_1_4_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_1_4_event:source"></a>pro grim_menu_view_zoom_1_4_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(1d/4d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_1_5_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 1/5, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_1_5_help_event:source"></a>pro grim_menu_view_zoom_1_5_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_1_5_event:source"></a>pro grim_menu_view_zoom_1_5_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(1d/5d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_1_5_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 1/5, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_1_5_help_event:source"></a>pro grim_menu_view_zoom_1_5_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_1_5_event:source"></a>pro grim_menu_view_zoom_1_5_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(1d/5d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_1_6_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 1/6, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_1_6_help_event:source"></a>pro grim_menu_view_zoom_1_6_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_1_6_event:source"></a>pro grim_menu_view_zoom_1_6_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(1d/6d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_1_7_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 1/7, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_1_7_help_event:source"></a>pro grim_menu_view_zoom_1_7_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_1_7_event:source"></a>pro grim_menu_view_zoom_1_7_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(1d/7d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_1_8_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 1/8, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_1_8_help_event:source"></a>pro grim_menu_view_zoom_1_8_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_1_8_event:source"></a>pro grim_menu_view_zoom_1_8_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(1d/8d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_1_9_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 1/9, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_1_9_help_event:source"></a>pro grim_menu_view_zoom_1_9_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_1_9_event:source"></a>pro grim_menu_view_zoom_1_9_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(1d/9d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_zoom_1_10_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current zoom to 1/10, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_zoom_1_10_help_event:source"></a>pro grim_menu_view_zoom_1_10_help_event, event
 text = ''
 nv_help, 'grim_menu_view_zoom_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_zoom_1_10_event:source"></a>pro grim_menu_view_zoom_1_10_event, event

 grim_data = grim_get_data(event.top)
 offset = grim_zoom_to_cursor(1d/10d, zoom=zoom)
 grim_refresh, grim_data, zoom=zoom, offset=offset

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_rotate_0_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current rotate to 0, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_rotate_0_help_event:source"></a>pro grim_menu_view_rotate_0_help_event, event
 text = ''
 nv_help, 'grim_menu_view_rotate_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_rotate_0_event:source"></a>pro grim_menu_view_rotate_0_event, event

 grim_data = grim_get_data(event.top)
 grim_refresh, grim_data, rotate=0

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_rotate_1_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current rotate to 1, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_rotate_1_help_event:source"></a>pro grim_menu_view_rotate_1_help_event, event
 text = ''
 nv_help, 'grim_menu_view_rotate_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_rotate_1_event:source"></a>pro grim_menu_view_rotate_1_event, event

 grim_data = grim_get_data(event.top)
 grim_refresh, grim_data, rotate=1

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_rotate_2_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current rotate to 2, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_rotate_2_help_event:source"></a>pro grim_menu_view_rotate_2_help_event, event
 text = ''
 nv_help, 'grim_menu_view_rotate_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_rotate_2_event:source"></a>pro grim_menu_view_rotate_2_event, event

 grim_data = grim_get_data(event.top)
 grim_refresh, grim_data, rotate=2

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_rotate_3_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current rotate to 3, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_rotate_3_help_event:source"></a>pro grim_menu_view_rotate_3_help_event, event
 text = ''
 nv_help, 'grim_menu_view_rotate_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_rotate_3_event:source"></a>pro grim_menu_view_rotate_3_event, event

 grim_data = grim_get_data(event.top)
 grim_refresh, grim_data, rotate=3

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_rotate_4_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current rotate to 4, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_rotate_4_help_event:source"></a>pro grim_menu_view_rotate_4_help_event, event
 text = ''
 nv_help, 'grim_menu_view_rotate_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_rotate_4_event:source"></a>pro grim_menu_view_rotate_4_event, event

 grim_data = grim_get_data(event.top)
 grim_refresh, grim_data, rotate=4

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_rotate_5_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current rotate to 5, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_rotate_5_help_event:source"></a>pro grim_menu_view_rotate_5_help_event, event
 text = ''
 nv_help, 'grim_menu_view_rotate_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_rotate_5_event:source"></a>pro grim_menu_view_rotate_5_event, event

 grim_data = grim_get_data(event.top)
 grim_refresh, grim_data, rotate=5

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_rotate_6_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current rotate to 6, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_rotate_6_help_event:source"></a>pro grim_menu_view_rotate_6_help_event, event
 text = ''
 nv_help, 'grim_menu_view_rotate_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_rotate_6_event:source"></a>pro grim_menu_view_rotate_6_event, event

 grim_data = grim_get_data(event.top)
 grim_refresh, grim_data, rotate=6

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_rotate_7_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the current rotate to 7, centered at the mouse cursor. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2013</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_rotate_7_help_event:source"></a>pro grim_menu_view_rotate_7_help_event, event
 text = ''
 nv_help, 'grim_menu_view_rotate_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_rotate_7_event:source"></a>pro grim_menu_view_rotate_7_event, event

 grim_data = grim_get_data(event.top)
 grim_refresh, grim_data, rotate=7

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_recenter_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Recenters the view at the cursor position. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2008</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_recenter_help_event:source"></a>pro grim_menu_view_recenter_help_event, event
 text = ''
 nv_help, 'grim_menu_view_home_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_recenter_event:source"></a>pro grim_menu_view_recenter_event, event

 grim_data = grim_get_data(event.top)

 cursor, x, y, /device, /nowait

 p = convert_coord(double(x), double(y), /device, /to_data)
 grim_recenter, grim_data, p

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_apply_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Applys the current view to all planes. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2016</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_apply_help_event:source"></a>pro grim_menu_view_apply_help_event, event
 text = ''
 nv_help, 'grim_menu_view_home_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_apply_event:source"></a>pro grim_menu_view_apply_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 planes = grim_get_plane(grim_data, /all)
 nplanes = n_elements(planes)

 for i=0, nplanes-1 do if(planes[i].pn NE plane.pn) then $
  begin
   planes[i].xrange = plane.xrange
   planes[i].yrange = plane.yrange
   planes[i].position = plane.position
  end

 grim_set_data, grim_data, event.top

 widget_control, grim_data.draw, /hourglass
 grim_refresh, grim_data, /home

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_home_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Sets the tvim home view settings. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 5/2005</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_home_help_event:source"></a>pro grim_menu_view_home_help_event, event
 text = ''
 nv_help, 'grim_menu_view_home_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_home_event:source"></a>pro grim_menu_view_home_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass
 grim_refresh, grim_data, /home

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_save_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Saves the current view settings. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_save_help_event:source"></a>pro grim_menu_view_save_help_event, event
 text = ''
 nv_help, 'grim_menu_view_save_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_save_event:source"></a>pro grim_menu_view_save_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass
 grim_wset, grim_data, /noplot, /save

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_restore_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Restores the last-saved view settings. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_restore_help_event:source"></a>pro grim_menu_view_restore_help_event, event
 text = ''
 nv_help, 'grim_menu_view_restore_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_restore_event:source"></a>pro grim_menu_view_restore_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass
 grim_refresh, grim_data, /restore

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_previous_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Restores the previous view settings. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_previous_help_event:source"></a>pro grim_menu_view_previous_help_event, event
 text = ''
 nv_help, 'grim_menu_view_previous_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_previous_event:source"></a>pro grim_menu_view_previous_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass
 grim_refresh, grim_data, /previous

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_entire_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Applies the 'entire' display parameters, as given in tvim. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_entire_help_event:source"></a>pro grim_menu_view_entire_help_event, event
 text = ''
 nv_help, 'grim_menu_view_entire_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_entire_event:source"></a>pro grim_menu_view_entire_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass
 grim_refresh, grim_data, /entire

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_initial_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Reverts to the initial view parameters for this grim widget. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 10/2007</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_initial_help_event:source"></a>pro grim_menu_view_initial_help_event, event
 text = ''
 nv_help, 'grim_menu_view_entire_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_initial_event:source"></a>pro grim_menu_view_initial_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass

 tvd = *grim_data.tvd_init_p
 tvim, /inherit, /silent, zoom=tvd.zoom, order=tvd.order, offset=tvd.offset

 grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_flip_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Reverses the curent display order. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_flip_help_event:source"></a>pro grim_menu_view_flip_help_event, event
 text = ''
 nv_help, 'grim_menu_view_flip_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_flip_event:source"></a>pro grim_menu_view_flip_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass
 grim_refresh, grim_data, /flip

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_frame_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Modifies view settings so as to display the either all overlays</span>
<span class="comments">;	or those that are active. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 9/2007</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_frame_help_event:source"></a>pro grim_menu_view_frame_help_event, event
 text = ''
 nv_help, 'grim_menu_view_frame_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_frame_event:source"></a>pro grim_menu_view_frame_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 widget_control, grim_data.draw, /hourglass

 ptd = grim_get_all_active_overlays(grim_data, plane=plane)
 if(NOT keyword_set(ptd)) then $
   ptd = grim_get_all_overlays(grim_data, plane=plane)
 if(NOT keyword_set(ptd)) then return

 grim_frame_overlays, grim_data, plane, ptd

 grim_refresh, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_header_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Opens a text window showing the image header. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 10/2003</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_header_help_event:source"></a>pro grim_menu_view_header_help_event, event
 text = ''
 nv_help, 'grim_menu_view_header_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_header_event:source"></a>pro grim_menu_view_header_event, event

 grim_data = grim_get_data(event.top)
 grim_edit_header, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_notes_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Opens a text window allowing the user to enter notes for each plane. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 10/2003</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_notes_help_event:source"></a>pro grim_menu_notes_help_event, event
 text = ''
 nv_help, 'grim_menu_notes_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_notes_event:source"></a>pro grim_menu_notes_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)
 grim_edit_notes, grim_data, plane=plane

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_toggle_image_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Toggles the image On/Off. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 9/2012</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_image_help_event:source"></a>pro grim_menu_image_help_event, event
 text = ''
 nv_help, 'grim_menu_toggle_image_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_toggle_image_event:source"></a>pro grim_menu_toggle_image_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)
 grim_toggle_image, grim_data, plane

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_toggle_image_overlays_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Toggles the image and overlays On/Off. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 9/2012</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_image_overlays_help_event:source"></a>pro grim_menu_image_overlays_help_event, event
 text = ''
 nv_help, 'grim_menu_toggle_image_overlays_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_toggle_image_overlays_event:source"></a>pro grim_menu_toggle_image_overlays_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)
 grim_toggle_image_overlays, grim_data, plane

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_context_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Toggles the context window On/Off. </span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 9/2005</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_context_help_event:source"></a>pro grim_menu_context_help_event, event
 text = ''
 nv_help, 'grim_menu_context_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_context_event:source"></a>pro grim_menu_context_event, event

 grim_data = grim_get_data(event.top)
 grim_toggle_context, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_axes_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Toggles the axes window On/Off.  The colors are as follows:</span>
<span class="comments">;</span>
<span class="comments">;	 Blue	- Inertial axes.</span>
<span class="comments">;	 Red	- Camera axes.</span>
<span class="comments">;	 Green	- Direction to primary planet, not foreshortened.</span>
<span class="comments">;	 Yellow	- Direction to Sun, not foreshortened.</span>
<span class="comments">;</span>
<span class="comments">;	Vectors pointing away from the camera are dotted.  The vectors are </span>
<span class="comments">;	rooted at a point 1d5 distance units in front of the camera .  </span>
<span class="comments">;	In the direction corresponding to the image position of the drawn </span>
<span class="comments">;	axes.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 9/2005</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_axes_help_event:source"></a>pro grim_menu_axes_help_event, event
 text = ''
 nv_help, 'grim_menu_axes_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_axes_event:source"></a>pro grim_menu_axes_event, event

 grim_data = grim_get_data(event.top)
 grim_toggle_axes, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_render_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Renders the visible scene and places it in a new plane unless</span>
<span class="comments">;	the current plane is already rendering. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2015</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_render_help_event:source"></a>pro grim_menu_render_help_event, event
 text = ''
 nv_help, 'grim_menu_render_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_render_event:source"></a>pro grim_menu_render_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)
 grim_render, grim_data, plane=plane
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_view_colors_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Opens grim_colortool. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_view_colors_help_event:source"></a>pro grim_menu_view_colors_help_event, event
 text = ''
 nv_help, 'grim_menu_view_colors_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_view_colors_event:source"></a>pro grim_menu_view_colors_event, event

 grim_data = grim_get_data(event.top)
 grim_set_primary, grim_data.base
 grim_modify_colors, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; OVERLAYS MENU</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_points_planet_centers_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Obtains the necessary descriptors through the translators and computes</span>
<span class="comments">;	planet center positions using pg_center for all active objects.  If no</span>
<span class="comments">;	active objects, then all centers are computed.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_points_planet_centers_help_event:source"></a>pro grim_menu_points_planet_centers_help_event, event
 text = ''
 nv_help, 'grim_menu_points_planet_centers_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_points_planet_centers_event:source"></a>pro grim_menu_points_planet_centers_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; load descriptors and compute centers</span>
 <span class="comments">;------------------------------------------------</span>
 grim_overlay, grim_data, 'planet_center'
<span class="comments">; grim_planet_centers, grim_data</span>

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; draw centers</span>
 <span class="comments">;------------------------------------------------</span>
<span class="comments">; grim_draw, grim_data, /center, /label</span>
 grim_refresh, grim_data, /use_pixmap

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_points_limbs_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Obtains the necessary descriptors through the translators and computes</span>
<span class="comments">;	limbs using pg_limbs for all active objects.  If no active objects, </span>
<span class="comments">;	then all limbs are computed.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_points_limbs_help_event:source"></a>pro grim_menu_points_limbs_help_event, event
 text = ''
 nv_help, 'grim_menu_points_limbs_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_points_limbs_event:source"></a>pro grim_menu_points_limbs_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; load descriptors and compute limbs</span>
 <span class="comments">;------------------------------------------------</span>
 grim_overlay, grim_data, 'limb'
<span class="comments">; grim_limbs, grim_data</span>

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; draw limbs</span>
 <span class="comments">;------------------------------------------------</span>
<span class="comments">; grim_draw, grim_data, /limb</span>
 grim_refresh, grim_data, /use_pixmap


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_points_terminators_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Obtains the necessary descriptors through the translators and computes</span>
<span class="comments">;	terminators using pg_limb with the sun as the observer for all active</span>
<span class="comments">;	objects.  If no active objects, then all terminators are computed.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_points_terminators_help_event:source"></a>pro grim_menu_points_terminators_help_event, event
 text = ''
 nv_help, 'grim_menu_points_terminators_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_points_terminators_event:source"></a>pro grim_menu_points_terminators_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; load descriptors and compute terminators</span>
 <span class="comments">;------------------------------------------------</span>
 grim_overlay, grim_data, 'terminator'
<span class="comments">; grim_terminators, grim_data</span>

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; draw terminators</span>
 <span class="comments">;------------------------------------------------</span>
<span class="comments">; grim_draw, grim_data, /term</span>
 grim_refresh, grim_data, /use_pixmap


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_points_planet_grids_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Obtains the necessary descriptors through the translators and computes</span>
<span class="comments">;	planet grids using pg_grid for all active objects.  If no active</span>
<span class="comments">;	objects, then all grids are computed.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_points_planet_grids_help_event:source"></a>pro grim_menu_points_planet_grids_help_event, event
 text = ''
 nv_help, 'grim_menu_points_planet_grids_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_points_planet_grids_event:source"></a>pro grim_menu_points_planet_grids_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; load descriptors and compute planet grids</span>
 <span class="comments">;------------------------------------------------</span>
 grim_overlay, grim_data, 'planet_grid'
<span class="comments">; grim_planet_grids, grim_data</span>

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; draw planet grids</span>
 <span class="comments">;------------------------------------------------</span>
<span class="comments">; grim_draw, grim_data, /plgrid</span>
 grim_refresh, grim_data, /use_pixmap


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_points_rings_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Obtains the necessary descriptors through the translators and computes</span>
<span class="comments">;	ring outlines using pg_disk. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_points_rings_help_event:source"></a>pro grim_menu_points_rings_help_event, event
 text = ''
 nv_help, 'grim_menu_points_rings_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_points_rings_event:source"></a>pro grim_menu_points_rings_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; load descriptors and compute rings</span>
 <span class="comments">;------------------------------------------------</span>
 grim_overlay, grim_data, 'ring'
<span class="comments">;grim_rings, grim_data</span>

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; draw rings</span>
 <span class="comments">;------------------------------------------------</span>
<span class="comments">; grim_draw, grim_data, /ring</span>
 grim_refresh, grim_data, /use_pixmap


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_points_ring_grids_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Obtains the necessary descriptors through the translators and computes</span>
<span class="comments">;	ring grids using pg_grid for all active objects.  If no active</span>
<span class="comments">;	objects, then all grids are computed.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_points_ring_grids_help_event:source"></a>pro grim_menu_points_ring_grids_help_event, event
 text = ''
 nv_help, 'grim_menu_points_ring_grids_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_points_ring_grids_event:source"></a>pro grim_menu_points_ring_grids_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass

<span class="comments">; grim_interrupt_begin, grim_data</span>

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; load descriptors and compute planet grids</span>
 <span class="comments">;------------------------------------------------</span>
 grim_overlay, grim_data, 'ring_grid'

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; draw planet grids</span>
 <span class="comments">;------------------------------------------------</span>
 grim_refresh, grim_data, /use_pixmap

<span class="comments">; grim_interrupt_end, grim_data</span>

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_points_stations_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Obtains the necessary descriptors through the translators and computes</span>
<span class="comments">;	planet stations for all active objects.  If no active objects, then </span>
<span class="comments">;	all stations are computed.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2009</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_points_stations_help_event:source"></a>pro grim_menu_points_stations_help_event, event
 text = ''
 nv_help, 'grim_menu_points_stations_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_points_stations_event:source"></a>pro grim_menu_points_stations_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; load descriptors and compute planet grids</span>
 <span class="comments">;------------------------------------------------</span>
 grim_overlay, grim_data, 'station'

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; draw stations</span>
 <span class="comments">;------------------------------------------------</span>
 grim_refresh, grim_data, /use_pixmap


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_points_arrays_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Obtains the necessary descriptors through the translators and computes</span>
<span class="comments">;	arrays for all active objects.  If no active objects, then </span>
<span class="comments">;	all arrays are computed.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 3/2012</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_points_arrays_help_event:source"></a>pro grim_menu_points_arrays_help_event, event
 text = ''
 nv_help, 'grim_menu_points_arrays_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_points_arrays_event:source"></a>pro grim_menu_points_arrays_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; load descriptors and compute planet grids</span>
 <span class="comments">;------------------------------------------------</span>
 grim_overlay, grim_data, 'array'

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; draw arrays</span>
 <span class="comments">;------------------------------------------------</span>
 grim_refresh, grim_data, /use_pixmap


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_points_stars_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Obtains the necessary descriptors through the translators and computes</span>
<span class="comments">;	star positions using pg_center. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_points_stars_help_event:source"></a>pro grim_menu_points_stars_help_event, event
 text = ''
 nv_help, 'grim_menu_points_stars_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_points_stars_event:source"></a>pro grim_menu_points_stars_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; load descriptors and compute stars</span>
 <span class="comments">;------------------------------------------------</span>
 grim_overlay, grim_data, 'star'

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; draw stars</span>
 <span class="comments">;------------------------------------------------</span>
<span class="comments">; grim_draw, grim_data, /star, /label</span>
 grim_refresh, grim_data, /use_pixmap


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_points_shadows_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Obtains the necessary descriptors through the translators and computes</span>
<span class="comments">;	shadows of the currently active overlay points on all other objects. </span>
<span class="comments">;	Note that you may have to disable overlay hiding in order to compute</span>
<span class="comments">;	and activate all of the appropriate source points for the shadows</span>
<span class="comments">;	since many point that are not visible to the observer may still have</span>
<span class="comments">;	a line of sight to the sun.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 1/2003</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_points_shadows_help_event:source"></a>pro grim_menu_points_shadows_help_event, event
 text = ''
 nv_help, 'grim_menu_points_shadows_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_points_shadows_event:source"></a>pro grim_menu_points_shadows_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; load descriptors and compute shadows</span>
 <span class="comments">;------------------------------------------------</span>
 grim_overlay, grim_data, 'shadow'
<span class="comments">;grim_shadows, grim_data</span>

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; draw shadow</span>
 <span class="comments">;------------------------------------------------</span>
<span class="comments">; grim_draw, grim_data, /shadow</span>
 grim_refresh, grim_data, /use_pixmap


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_points_reflections_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Obtains the necessary descriptors through the translators and computes</span>
<span class="comments">;	reflections of the currently active overlay points on all other objects. </span>
<span class="comments">;	Note that you may have to disable overlay hiding in order to compute</span>
<span class="comments">;	and activate all of the appropriate source points for the reflections</span>
<span class="comments">;	since many point that are not visible to the observer may still have</span>
<span class="comments">;	a line of sight to the sun.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 1/2003</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_points_reflections_help_event:source"></a>pro grim_menu_points_reflections_help_event, event
 text = ''
 nv_help, 'grim_menu_points_reflections_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_points_reflections_event:source"></a>pro grim_menu_points_reflections_event, event

 grim_data = grim_get_data(event.top)
 widget_control, grim_data.draw, /hourglass

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; load descriptors and compute reflections</span>
 <span class="comments">;------------------------------------------------</span>
 grim_overlay, grim_data, 'reflection'
<span class="comments">;grim_reflections, grim_data</span>

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; draw reflection</span>
 <span class="comments">;------------------------------------------------</span>
<span class="comments">; grim_draw, grim_data, /reflection</span>
 grim_refresh, grim_data, /use_pixmap


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_hide_all_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	 Hides/unhides all overlay objects.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;	 </span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 1/2003</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_hide_all_help_event:source"></a>pro grim_menu_hide_all_help_event, event
 text = ''
 nv_help, 'grim_menu_hide_all_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_hide_all_event:source"></a>pro grim_menu_hide_all_event, event

 grim_data = grim_get_data(event.top)

 grim_set_primary, grim_data.base
 grim_hide_overlays, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_clear_all_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	 Clears all objects.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;	 </span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 9/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_clear_all_help_event:source"></a>pro grim_menu_clear_all_help_event, event
 text = ''
 nv_help, 'grim_menu_clear_all_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_clear_all_event:source"></a>pro grim_menu_clear_all_event, event

 grim_message, /question, result=result, $
           ['Are you sure you want to clear all overlays?']
 if(result NE 'Yes') then return


 grim_data = grim_get_data(event.top)
 grim_clear_objects, grim_data, /all

 grim_refresh, grim_data, /use_pixmap
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_clear_active_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	 Clears all active objects.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;	 </span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 9/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_clear_active_help_event:source"></a>pro grim_menu_clear_active_help_event, event
 text = ''
 nv_help, 'grim_menu_clear_active_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_clear_active_event:source"></a>pro grim_menu_clear_active_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 grim_clear_active_overlays, grim_data, plane
 grim_clear_active_user_overlays, plane


 grim_refresh, grim_data, /use_pixmap
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_activate_all_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	 Activates all objects.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 9/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_activate_all_help_event:source"></a>pro grim_menu_activate_all_help_event, event
 text = ''
 nv_help, 'grim_menu_activate_all_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_activate_all_event:source"></a>pro grim_menu_activate_all_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 grim_activate_all, grim_data, plane
 grim_refresh, grim_data, /no_image

 return
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_deactivate_all_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	 Deactivates all objects.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;	 </span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 9/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_deactivate_all_help_event:source"></a>pro grim_menu_deactivate_all_help_event, event
 text = ''
 nv_help, 'grim_menu_deactivate_all_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_deactivate_all_event:source"></a>pro grim_menu_deactivate_all_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 grim_deactivate_all, grim_data, plane
 grim_refresh, grim_data, /no_image

 return
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_invert_all_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	 Inverts current overlay activations.  Desccriptor activations are</span>
<span class="comments">;	 determined by the resulting overlay activations. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;	 </span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 11/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_invert_all_help_event:source"></a>pro grim_menu_invert_all_help_event, event
 text = ''
 nv_help, 'grim_menu_invert_all_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_invert_event:source"></a>pro grim_menu_invert_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 grim_invert_all_overlays, grim_data, plane

 grim_refresh, grim_data, /no_image
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_menu_points_settings_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Allows the user modify settings relevant to the overlay points.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_points_settings_help_event:source"></a>pro grim_menu_points_settings_help_event, event
 text = ''
 nv_help, 'grim_menu_points_settings_event', cap=text
 if(keyword_set(text)) then grim_help, grim_get_data(event.top), text
end
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_menu_points_settings_event:source"></a>pro grim_menu_points_settings_event, event
@grim_block.include

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 grim_overlay_settings, grim_data, plane

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_previous_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_previous_event:source"></a>pro grim_previous_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Previous plane'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; switch to previous plane</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 grim_previous_plane, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_jumpto_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_jumpto_event:source"></a>pro grim_jumpto_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Jump to plane'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; jump to new plane</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 valid = grim_jumpto(grim_data, grim_data.jumpto_text)
 if(valid) then grim_refresh, grim_data, /no_erase

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_next_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_next_event:source"></a>pro grim_next_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Next plane'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; switch to next plane</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 grim_next_plane, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_crop_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_crop_event:source"></a>pro grim_crop_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Crop data to view'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; crop data</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 grim_crop_plane, grim_data, plane

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_refresh_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_refresh_event:source"></a>pro grim_refresh_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Refresh'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; switch to next plane</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 grim_refresh, grim_data


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_entire_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_entire_event:source"></a>pro grim_entire_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'View entire image'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; switch to next plane</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 widget_control, grim_data.draw, /hourglass
 grim_refresh, grim_data, /entire


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_view_previous_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_view_previous_event:source"></a>pro grim_view_previous_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Previous view'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; switch to next plane</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 widget_control, grim_data.draw, /hourglass
 grim_refresh, grim_data, /previous


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_colors_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_colors_event:source"></a>pro grim_colors_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Modify color tables'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; open color tool</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 grim_modify_colors, grim_data


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_settings_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_settings_event:source"></a>pro grim_settings_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Overlay settings'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; open settings dialog</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_overlay_settings, grim_data, plane


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_header_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_header_event:source"></a>pro grim_header_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Edit image header'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; open header editor</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 grim_edit_header, grim_data


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_notes_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_notes_event:source"></a>pro grim_notes_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Edit image notes'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; open header editor</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 grim_edit_notes, grim_data, plane=plane


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_undo_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_undo_event:source"></a>pro grim_undo_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then $
    begin
     grim_print, grim_data, 'Undo last data edit.'
    end
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; undo last edit</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 widget_control, grim_data.draw, /hourglass
 grim_undo, grim_data, plane



end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_redo_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_redo_event:source"></a>pro grim_redo_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then $
    begin
     grim_print, grim_data, 'Redo last data edit.'
    end
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; redo last edit</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 widget_control, grim_data.draw, /hourglass
 grim_redo, grim_data, plane



end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_toggle_image_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_toggle_image_event:source"></a>pro grim_toggle_image_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then $
    begin
     if(NOT plane.image_visible) then grim_print, grim_data, 'Unhide image' $
     else grim_print, grim_data, 'Hide image'
    end
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; toggle image</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 widget_control, grim_data.draw, /hourglass
 grim_toggle_image, grim_data, plane



end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_toggle_image_overlays_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_toggle_image_overlays_event:source"></a>pro grim_toggle_image_overlays_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then $
    begin
     if(NOT plane.image_visible) then s = 'Unhide image' $
     else s = 'Hide image'

     if(grim_data.hidden) then s = s + ' and unhide all overlays' $
     else s = s + ' and hide all overlays'

     grim_print, grim_data, s
    end
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; toggle image</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 widget_control, grim_data.draw, /hourglass
 grim_toggle_image_overlays, grim_data, plane



end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_hide_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_hide_event:source"></a>pro grim_hide_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then $
    begin
     if(grim_data.hidden) then grim_print, grim_data, 'Unhide all overlays' $
     else grim_print, grim_data, 'Hide all overlays'
    end
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; hide all overlays</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 widget_control, grim_data.draw, /hourglass
 grim_hide_overlays, grim_data



end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_tracking_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_tracking_event:source"></a>pro grim_tracking_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Toggle cursor tracking on/off'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; toggle tracking flag</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 if(grim_data.tracking EQ 0) then grim_data.tracking = 1 $
 else grim_data.tracking = 0

 grim_set_data, grim_data, event.top

 grim_set_tracking, grim_data
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_grid_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_grid_event:source"></a>pro grim_grid_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Toggle RA/DEC grid on/off'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; toggle grid flag</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 grim_data.grid_flag = NOT grim_data.grid_flag

 grim_set_data, grim_data, event.top
 if(grim_data.grid_flag) then grim_refresh, grim_data, /no_image $
 else grim_refresh, grim_data, /use_pixmap

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_pixel_grid_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_pixel_grid_event:source"></a>pro grim_pixel_grid_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Toggle Pixel grid on/off'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; toggle grid flag</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 grim_data.pixel_grid_flag = NOT grim_data.pixel_grid_flag

 grim_set_data, grim_data, event.top
 if(grim_data.pixel_grid_flag) then grim_refresh, grim_data, /no_image $
 else grim_refresh, grim_data, /use_pixmap
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_guideline_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_guideline_event:source"></a>pro grim_guideline_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Toggle guidelines on/off'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; toggle grid flag</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 grim_data.guideline_flag = NOT grim_data.guideline_flag

 if(NOT grim_data.guideline_flag) then grim_erase_guideline, grim_data

 grim_set_data, grim_data, event.top

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_context_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_context_event:source"></a>pro grim_context_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then $
       grim_print, grim_data, 'Open/Close image context window'
   return
  end $
 else if(NOT grim_test_motion_event(event)) then $
                                               grim_set_primary, grim_data.base

 <span class="comments">;----------------------------</span>
 <span class="comments">; toggle the mapping state</span>
 <span class="comments">;----------------------------</span>
 grim_toggle_context, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_axes_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_axes_event:source"></a>pro grim_axes_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Toggle axes on/off'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; toggle axes state</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_toggle_axes, grim_data

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_render_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_render_event:source"></a>pro grim_render_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Generate new rendering'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; render</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_render, grim_data, plane=plane


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_activate_all_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_activate_all_event:source"></a>pro grim_activate_all_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Activate all overlays'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; switch to next plane</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 grim_activate_all, grim_data, plane
 grim_refresh, grim_data, /no_image

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_deactivate_all_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_deactivate_all_event:source"></a>pro grim_deactivate_all_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Deactivate all overlays'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; switch to next plane</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_set_primary, grim_data.base
 grim_deactivate_all, grim_data, plane
 grim_refresh, grim_data, /no_image


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_repeat_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_repeat_event:source"></a>pro grim_repeat_event, event

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Repeat last menu item.'
   return
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; repeat last option</span>
 <span class="comments">;---------------------------------------------------------</span>
 grim_repeat, grim_data


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_help</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_help:source"></a>pro grim_help, grim_data, text

 plane = grim_get_plane(grim_data)
 widget_control, grim_data.draw, /hourglass

 if(NOT widget_info(grim_data.help_text, /valid)) then $
  begin
   grim_data.help_text = textedit(text, base=base, xs=80, resource_prefix='grim_help')
   widget_control, base, tlb_set_title='GRIM Help'
   grim_data.help_base = base
   grim_set_data, grim_data
   grim_refresh, grim_data, /no_image, /no_objects
  end $
 else $
  begin
   widget_control, grim_data.help_text, set_value=text
   widget_control, grim_data.help_base, /map
  end

<span class="comments">; hide button</span>

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_create_help_menu</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_create_help_menu:source"></a>function grim_create_help_menu, _menu_desc

 menu_desc = _menu_desc

 help_desc = strep_s(menu_desc, '_event', '_help_event')
 menu_desc = ['1\Help', help_desc]

 return, menu_desc
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_cull_menu_desc</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_cull_menu_desc:source"></a>function grim_cull_menu_desc, _menu_desc, plot, map, beta, $
            map_items=map_items, $
            map_indices=map_indices, $
            od_map_items=od_map_items, $
            od_map_indices=od_map_indices, $
            plot_items=plot_items, $
            plot_indices=plot_indices, $
            plot_only_items=plot_only_items, $
            plot_only_indices=plot_only_indices, $
            beta_only_indices=beta_only_indices

 menu_desc = _menu_desc

 <span class="comments">;-------------------------------------------</span>
 <span class="comments">; mark items to cull</span>
 <span class="comments">;-------------------------------------------</span>
 if(plot) then mark = complement(menu_desc, [plot_indices, plot_only_indices]) $
 else mark = plot_only_indices

 if(map) then $
   mark = append_array(mark, complement(menu_desc, [map_indices, od_map_indices]))

 if(NOT beta) then mark = append_array(mark, beta_only_indices)

 ii = complement(menu_desc, mark)
 if(ii[0] EQ -1) then return, ''
 menu_desc = menu_desc[ii]


 <span class="comments">;-------------------------------------------</span>
 <span class="comments">; remove consecutive duplicate items</span>
 <span class="comments">;-------------------------------------------</span>
 mark = 0
 for i=1, n_elements(menu_desc)-1 do $
       if(menu_desc[i] EQ menu_desc[i-1]) then mark = append_array(mark, [i])
 if(keyword_set(mark)) then menu_desc = rm_list_item(menu_desc, mark)


 <span class="comments">;-------------------------------------------</span>
 <span class="comments">; remove null menus</span>
 <span class="comments">;-------------------------------------------</span>
 mark = 0
 for i=1, n_elements(menu_desc)-1 do $
       if(strmid(menu_desc[i],0,1) EQ '2') then $
             if(strmid(menu_desc[i-1],0,1) EQ '1') then mark = append_array(mark, [i])
 if(keyword_set(mark)) then menu_desc = rm_list_item(menu_desc, mark)


 return, menu_desc
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_parse_menu_desc</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_parse_menu_desc:source"></a>function grim_parse_menu_desc, _menu_desc, $
            map_items=map_items, $
            map_indices=map_indices, $
            od_map_items=od_map_items, $
            od_map_indices=od_map_indices, $
            plot_items=plot_items, $
            plot_indices=plot_indices, $
            plot_only_items=plot_only_items, $
            plot_only_indices=plot_only_indices, $
            beta_only_indices=beta_only_indices

 map_token = '*'
 od_token = '#'
 plot_token = '+'
 plot_only_token = '%'
 beta_only_token = '?'

 map_items = ''
 od_map_items = ''
 plot_items = ''
 menu_desc = _menu_desc

 p = strpos(menu_desc, map_token)
 w = where(p NE -1)
 if(w[0] NE -1) then $
  begin
   ss = str_nnsplit(menu_desc[w], map_token, rem=map_items)
   menu_desc[w] = ss + map_items
   map_indices = w
  end

 p = strpos(menu_desc, od_token)
 w = where(p NE -1)
 if(w[0] NE -1) then $
  begin
   ss = str_nnsplit(menu_desc[w], od_token, rem=od_map_items)
   menu_desc[w] = ss + od_map_items
   od_map_indices = w
  end

 p = strpos(menu_desc, plot_token)
 w = where(p NE -1)
 if(w[0] NE -1) then $
  begin
   ss = str_nnsplit(menu_desc[w], plot_token, rem=plot_items)
   menu_desc[w] = ss + plot_items
   plot_indices = w
  end

 p = strpos(menu_desc, plot_only_token)
 w = where(p NE -1)
 if(w[0] NE -1) then $
  begin
   ss = str_nnsplit(menu_desc[w], plot_only_token, rem=plot_only_items)
   menu_desc[w] = ss + plot_only_items
   plot_only_indices = w
  end

 p = strpos(menu_desc, beta_only_token)
 w = where(p NE -1)
 if(w[0] NE -1) then $
  begin
   ss = str_nnsplit(menu_desc[w], beta_only_token, rem=beta_only_items)
   menu_desc[w] = ss + beta_only_items
   beta_only_indices = w
  end

 return, menu_desc
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_menu_desc</span>
<span class="comments">;</span>
<span class="comments">;  Items containing '*' work for maps as well.</span>
<span class="comments">;  Items containing '#' work for maps with observer descriptors.</span>
<span class="comments">;  Items containing '+' work for plots as well.</span>
<span class="comments">;  Items containing '%' work only for plots.</span>
<span class="comments">;  Items containing '?' work only for the beta version.</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_desc:source"></a>function grim_menu_desc, cursor_modes=cursor_modes

 desc = [ '+*1\File' , $
           '0\Load                \+*grim_menu_file_load_event', $
           '0\Browse              \*grim_menu_file_browse_event', $
           '0\Save                \+*grim_menu_file_save_event', $
           '0\Save As             \+*grim_menu_file_save_as_event', $
           '0\Open As RGB          \+*grim_menu_open_as_rgb_event', $
           '0\--------------------\+grim_menu_delim_event', $ 
           '0\Save User Points    \+*grim_menu_file_save_user_ptd_event', $
           '0\Save All User Points\+*grim_menu_file_save_all_user_ptd_event', $
           '0\Load User Points    \+*grim_menu_file_load_user_ptd_event', $
           '0\Load All User Points\+*grim_menu_file_load_all_user_ptd_event', $
           '0\--------------------\grim_menu_delim_event', $ 
           '0\Save Tie Points     \*grim_menu_file_save_tie_ptd_event', $
           '0\Save All Tie Points \*grim_menu_file_save_all_tie_ptd_event', $
           '0\Load Tie Points     \*grim_menu_file_load_tie_ptd_event', $
           '0\Load All Tie Points \*grim_menu_file_load_all_tie_ptd_event', $
           '0\--------------------\grim_menu_delim_event', $ 
           '0\Save Curves         \*grim_menu_file_save_curves_event', $
           '0\Save All Curves     \*grim_menu_file_save_all_curves_event', $
           '0\Load Curves         \*grim_menu_file_load_curves_event', $
           '0\Load All Curves     \*grim_menu_file_load_all_curves_event', $
           '0\--------------------\grim_menu_delim_event', $ 
           '0\Save Mask           \*grim_menu_file_save_mask_event', $
           '0\Save All Masks      \*grim_menu_file_save_all_masks_event', $
           '0\Load Mask           \*grim_menu_file_load_mask_event', $
           '0\Load All Masks      \*grim_menu_file_load_all_masks_event', $
           '0\--------------------\+grim_menu_delim_event', $ 
           '0\Save Postscript     \+*grim_menu_file_save_ps_event', $
           '0\--------------------\+grim_menu_delim_event', $ 
           '0\Repeat              \+*grim_menu_repeat_event', $
           '0\Undo                \+*grim_menu_undo_event', $
           '0\Redo                \+*grim_menu_redo_event', $
           '0\--------------------\+grim_menu_delim_event', $ 
           '0\Select              \+*grim_select_event', $
           '0\Identify            \+*grim_identify_event', $
           '0\Close               \+*grim_menu_file_close_event', $
           '2\&lt;null>               \+*grim_menu_delim_event', $

          '+*1\Mode' , $

          '+*1\Plane' , $
           '0\Next               \+*grim_menu_plane_next_event' , $
           '0\Previous           \+*grim_menu_plane_previous_event', $
           '0\Jump               \+*grim_menu_plane_jump_event' , $
           '0\Browse             \*grim_menu_plane_browse_event', $
           '0\Open in new window \*grim_menu_plane_open_event', $
           '0\Crop to view       \+*grim_menu_plane_crop_event' , $
           '0\Reorder by time    \grim_menu_plane_reorder_time_event', $
           '0\Sequence           \*grim_menu_plane_sequence_event', $
           '0\Dump               \*grim_menu_plane_dump_event', $
           '0\Coregister         \grim_menu_plane_coregister_event', $
           '0\Coadd              \grim_menu_plane_coadd_event', $
           '0\Toggle Syncing            [xxx]\*grim_menu_plane_toggle_plane_syncing_event', $
           '0\Toggle Highlight          [xxx]\*grim_menu_plane_highlight_event', $
           '0\-------------------\*grim_menu_delim_event', $ 
           '0\Copy tie points     \*grim_menu_plane_copy_tiepoints_event', $
<span class="comments">;           '0\Propagate tie points\*grim_menu_plane_propagate_tiepoints_event', $</span>
           '0\Toggle tie point syncing  [xxx]\*grim_menu_plane_toggle_tiepoint_syncing_event', $
           '0\Clear tie points    \*grim_menu_plane_clear_tiepoints_event', $
           '0\-------------------\*grim_menu_delim_event', $ 
           '0\Copy curves        \*grim_menu_plane_copy_curves_event', $
<span class="comments">;           '0\Propagate curves    \*grim_menu_plane_propagate_curves_event', $</span>
           '0\Toggle curves syncing     [xxx]\*grim_menu_plane_toggle_curve_syncing_event', $
           '0\Clear curves        \*grim_menu_plane_clear_curves_event', $
           '0\-------------------\*grim_menu_delim_event', $ 
           '0\Copy mask          \*grim_menu_plane_copy_mask_event', $
           '0\Clear mask         \*grim_menu_plane_clear_mask_event', $
           '0\-------------------\*grim_menu_delim_event', $ 
           '0\Settings           \+*grim_menu_plane_settings_event', $
           '2\&lt;null>               \+*grim_menu_delim_event', $

          '+*1\Data' , $
           '0\Adjust values        \+*grim_menu_data_adjust_event' , $
           '2\&lt;null>               \+*grim_menu_delim_event', $

          '+*1\View' , $
           '0\Refresh              \+*grim_menu_view_refresh_event' , $
           '+*1\Zoom' , $
             '0\Specify           \+*grim_menu_view_zoom_event' , $
             '0\Double            \+*grim_menu_view_zoom_double_event' , $
             '0\Half              \+*grim_menu_view_zoom_half_event' , $
             '0\1                 \+*grim_menu_view_zoom_1_event' , $
             '0\2                 \+*grim_menu_view_zoom_2_event' , $
             '0\3                 \+*grim_menu_view_zoom_3_event' , $
             '0\4                 \+*grim_menu_view_zoom_4_event' , $
             '0\5                 \+*grim_menu_view_zoom_5_event' , $
             '0\6                 \+*grim_menu_view_zoom_6_event' , $
             '0\7                 \+*grim_menu_view_zoom_7_event' , $
             '0\8                 \+*grim_menu_view_zoom_8_event' , $
             '0\9                 \+*grim_menu_view_zoom_9_event' , $
             '0\10                 \+*grim_menu_view_zoom_10_event' , $
             '0\1/2                 \+*grim_menu_view_zoom_1_2_event' , $
             '0\1/3                 \+*grim_menu_view_zoom_1_3_event' , $
             '0\1/4                 \+*grim_menu_view_zoom_1_4_event' , $
             '0\1/5                 \+*grim_menu_view_zoom_1_5_event' , $
             '0\1/6                 \+*grim_menu_view_zoom_1_6_event' , $
             '0\1/7                 \+*grim_menu_view_zoom_1_7_event' , $
             '0\1/8                 \+*grim_menu_view_zoom_1_8_event' , $
             '0\1/9                 \+*grim_menu_view_zoom_1_9_event' , $
             '0\1/10                 \+*grim_menu_view_zoom_1_10_event' , $
             '2\&lt;null>               \+*grim_menu_delim_event', $
           '+*1\Rotate' , $
             '0\0                 \+*grim_menu_view_rotate_0_event' , $
             '0\1                 \+*grim_menu_view_rotate_1_event' , $
             '0\2                 \+*grim_menu_view_rotate_2_event' , $
             '0\3                 \+*grim_menu_view_rotate_3_event' , $
             '0\4                 \+*grim_menu_view_rotate_4_event' , $
             '0\5                 \+*grim_menu_view_rotate_5_event' , $
             '0\6                 \+*grim_menu_view_rotate_6_event' , $
             '0\7                 \+*grim_menu_view_rotate_7_event' , $
             '2\&lt;null>               \+*grim_menu_delim_event', $
           '0\Recenter             \+*grim_menu_view_recenter_event' , $
           '%0\Apply to all Planes  \+*grim_menu_view_apply_event' , $
           '0\Home                 \+*grim_menu_view_home_event' , $
           '0\Save                 \+*grim_menu_view_save_event' , $
           '0\Restore              \+*grim_menu_view_restore_event', $
           '0\Previous             \+*grim_menu_view_previous_event', $
           '0\Entire               \+*grim_menu_view_entire_event', $
           '0\Initial              \+*grim_menu_view_initial_event', $
           '0\Reverse Order        \*grim_menu_view_flip_event', $ 
           '0\Frame Overlays\*grim_menu_view_frame_event', $ 
           '0\---------------------\*grim_menu_delim_event', $ 
           '0\Header               \grim_menu_view_header_event', $
           '0\Notes                \grim_menu_notes_event', $
           '0\---------------------\*grim_menu_delim_event', $ 
           '0\Toggle Image         \+*grim_menu_toggle_image_event' , $
           '0\Toggle Image/Overlays \+*grim_menu_toggle_image_overlays_event' , $
           '0\Toggle Context       \+*grim_menu_context_event' , $
           '0\Toggle Axes          \*grim_menu_axes_event' , $
           '0\---------------------\*grim_menu_delim_event', $ 
           '0\Render               \grim_menu_render_event' , $
           '0\---------------------\*grim_menu_delim_event', $ 
           '0\Colors               \*grim_menu_view_colors_event', $ 
           '2\&lt;null>               \+*grim_menu_delim_event', $

          '+*1\Overlays' ,$
           '0\Compute planet centers \grim_menu_points_planet_centers_event', $ 
           '0\Compute limbs          \#grim_menu_points_limbs_event', $        
           '0\Compute terminators    \#grim_menu_points_terminators_event', $
           '0\Compute planet grids   \*grim_menu_points_planet_grids_event', $ 
           '0\Compute rings          \grim_menu_points_rings_event', $
           '0\Compute ring grids     \grim_menu_points_ring_grids_event', $ 
           '0\Compute stations       \*grim_menu_points_stations_event', $ 
           '0\Compute arrays         \*grim_menu_points_arrays_event', $ 
           '0\Compute stars          \grim_menu_points_stars_event', $ 
           '0\Compute shadows        \grim_menu_points_shadows_event', $ 
           '0\Compute reflections    \?grim_menu_points_reflections_event', $ 
           '0\-------------------------\*grim_menu_delim_event', $ 
           '0\Hide/Unhide all        \+*grim_menu_hide_all_event', $ 
           '0\Clear all              \*grim_menu_clear_all_event', $ 
           '0\Clear active           \*grim_menu_clear_active_event', $ 
           '0\Activate all           \*grim_menu_activate_all_event', $ 
           '0\Deactivate all         \*grim_menu_deactivate_all_event', $ 
           '0\Invert activations     \*grim_menu_invert_event', $ 
           '0\-------------------------\*grim_menu_delim_event', $ 
           '0\Overlay Settings       \+*grim_menu_points_settings_event', $
           '2\&lt;null>               \+*grim_menu_delim_event']

 <span class="comments">;----------------------------------------------</span>
 <span class="comments">; Insert cursor mode menu items</span>
 <span class="comments">;----------------------------------------------</span>
 if(keyword_set(cursor_modes)) then $
  begin
   p = strpos(desc, '1\Mode')
   w = (where(p NE -1))[0]

   nn = max([strlen(cursor_modes.menu), 8])

   items = '0\' + cursor_modes.menu + '  \' + cursor_modes.event_pro
   n = n_elements(items)
<span class="comments">;   items[n-1] = strep(items[n-1], '2', 0)</span>
   items = append_array(items, '2\&lt;null>               \+*grim_menu_delim_event')

   desc = [desc[0:w], items, desc[w+1:*]]
   cursor_modes.event_pro = grim_parse_menu_desc(cursor_modes.event_pro)
  end

 return, desc
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_get_window_size</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_get_window_size:source"></a>pro grim_get_window_size, grim_data, xsize=xsize, ysize=ysize

 _xsize = 0
 _ysize = 0

 plane = grim_get_plane(grim_data)

 dim = dat_dim(plane.dd)
 if(n_elements(dim) EQ 2) then $
  begin
   xs = double(dim[0])*grim_data.zoom
   ys = double(dim[1])*grim_data.zoom

   if(xs GT _xsize) then _xsize = xs
   if(ys GT _ysize) then _ysize = ys
  end

 if(NOT keyword_set(xsize)) then xsize = _xsize
 if(NOT keyword_set(ysize)) then ysize = _ysize
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_menu_capture</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_menu_capture:source"></a>pro grim_menu_capture, fn, event
 grim_data = grim_get_data(event.top)
 if(NOT keyword_set(grim_data)) then return

 if(fn EQ 'grim_menu_repeat_event') then return

 grim_data.repeat_fn = fn
 *grim_data.repeat_event_p = event

 grim_set_data, grim_data, grim_data.base
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_widgets</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_widgets:source"></a>pro grim_widgets, grim_data, xsize=xsize, ysize=ysize, cursor_modes=cursor_modes, $
   menu_fname=menu_fname, menu_extensions=menu_extensions
@grim_constants.common

 if(grim_data.retain GT 0) then retain = grim_data.retain

 map = grim_test_map(grim_data)
 plot = grim_data.type EQ 'plot'
 beta = grim_data.beta

 <span class="comments">;-----------------------------------------</span>
 <span class="comments">; base, menu bar</span>
 <span class="comments">;-----------------------------------------</span>
 grim_data.base = widget_base(mbar=mbar, /col, /tlb_size_events, $
                          resource_name='grim_base', rname_mbar='grim_mbar')
 grim_data.mbar = mbar
 grim_data.grnum = grim_top_to_grnum(grim_data.base, /new)

 menu_desc = grim_menu_desc(cursor_modes=cursor_modes)
 for i=0, n_elements(menu_extensions)-1 do $
                   menu_desc = [menu_desc, call_function(menu_extensions[i])]

 if(keyword_set(menu_fname)) then $
  begin
   user_menu_desc = strtrim(strip_comment(read_txt_file(menu_fname)), 2)
   if(keyword_set(user_menu_desc)) then menu_desc = [menu_desc, user_menu_desc]
  end


 <span class="comments">;-----------------------------------------</span>
 <span class="comments">; setup menus</span>
 <span class="comments">;-----------------------------------------</span>
 menu_desc = grim_parse_menu_desc(menu_desc, $
     map_items=map_items, map_indices=map_indices, $
     od_map_items=od_map_items, od_map_indices=od_map_indices, $
     plot_items=plot_items, plot_indices=plot_indices, $
     plot_only_items=plot_only_items, plot_only_indices=plot_only_indices, $
     beta_only_indices=beta_only_indices)


<span class="comments">;;;;; problem is consecutive 2/&lt;null> lines....</span>
 menu_desc = grim_cull_menu_desc(menu_desc, plot, map, beta, $
     map_items=map_items, map_indices=map_indices, $
     od_map_items=od_map_items, od_map_indices=od_map_indices, $
     plot_items=plot_items, plot_indices=plot_indices, $
     plot_only_items=plot_only_items, plot_only_indices=plot_only_indices, $
     beta_only_indices=beta_only_indices)

 grim_data.menu_desc_p = nv_ptr_new(menu_desc)
 grim_data.map_items_p = nv_ptr_new(map_items)
 grim_data.od_map_items_p = nv_ptr_new(od_map_items)

 grim_data.menu = $
          cw__pdmenu(grim_data.mbar, menu_desc, /mbar, ids=menu_ids, $
                                                  capture='grim_menu_capture')
 grim_data.menu_ids_p = nv_ptr_new(menu_ids)
 help_menu_desc = grim_create_help_menu(menu_desc)
 grim_data.help_menu = cw__pdmenu(grim_data.mbar, help_menu_desc, /mbar)


 <span class="comments">;-----------------------------------------</span>
 <span class="comments">; shortcut buttons</span>
 <span class="comments">;-----------------------------------------</span>
 grim_data.shortcuts_base = $
        widget_base(grim_data.base, /row, space=0, xpad=0, ypad=0, $
                                      resource_name='grim_shortcuts_base')

 grim_data.shortcuts_base1 = $
        widget_base(grim_data.shortcuts_base, /row, space=0, xpad=0, ypad=0)

 grim_data.select_button = widget_button(grim_data.shortcuts_base1, $
             resource_name='grim_select_button', $
             value=grim_unselect_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_select_event')

 gm = widget_info(grim_data.shortcuts_base1, /geom)
 ys = gm.ysize
 grim_data.shortcuts_base2 = $
           widget_base(grim_data.shortcuts_base, /row, $
                                       space=0, xpad=4, ypad=0, ysize=ys)

 grim_data.previous_button = widget_button(grim_data.shortcuts_base2, $
             resource_name='grim_previous_button', $
             value=grim_previous_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_previous_event')

 grim_data.jumpto_text = widget_text(grim_data.shortcuts_base2, $
                     resource_name='grim_jumpto_text', xsize=3, $
                               value='', /tracking_events, /editable, $
                                              event_pro='grim_jumpto_event')

 grim_data.next_button = widget_button(grim_data.shortcuts_base2, $
             resource_name='grim_next_button', $
             value=grim_next_bitmap(), /bitmap, /tracking_events, $
                                                  event_pro='grim_next_event')


 grim_data.shortcuts_base3 = $
        widget_base(grim_data.shortcuts_base, /row, space=0, xpad=0, ypad=0)

 grim_data.crop_button = widget_button(grim_data.shortcuts_base3, $
             resource_name='grim_crop_button', $
             value=grim_crop_bitmap(), /bitmap, /tracking_events, $
                                                  event_pro='grim_crop_event')

 grim_data.refresh_button = widget_button(grim_data.shortcuts_base3, $
              resource_name='grim_refresh_button', $
              value=grim_refresh_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_refresh_event')

 grim_data.entire_button = widget_button(grim_data.shortcuts_base3, $
              resource_name='grim_entire_button', $
              value=grim_entire_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_entire_event')

 grim_data.view_previous_button = widget_button(grim_data.shortcuts_base3, $
              resource_name='grim_view_previous_button', $
              value=grim_view_previous_bitmap(), /bitmap, /tracking_events, $
                                          event_pro='grim_view_previous_event')


 grim_data.shortcuts_base4 = $
        widget_base(grim_data.shortcuts_base, /row, space=0, xpad=4, ypad=0)

 grim_data.hide_button = widget_button(grim_data.shortcuts_base4, $
              resource_name='grim_hide_button', $
              value=grim_hide_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_hide_event')

 grim_data.toggle_image_button = widget_button(grim_data.shortcuts_base4, $
              resource_name='grim_toggle_image_button', $
              value=grim_hide_image_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_toggle_image_event')

 grim_data.toggle_image_overlays_button = widget_button(grim_data.shortcuts_base4, $
              resource_name='grim_toggle_image_overlays_button', $
              value=grim_hide_image_bitmap() AND grim_hide_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_toggle_image_overlays_event')

 if((NOT plot) AND (NOT map)) then $
   grim_data.render_button = widget_button(grim_data.shortcuts_base4, $
              resource_name='grim_render_button', $
              value=grim_render_bitmap(), /bitmap, /tracking_events, $
                                                 event_pro='grim_render_event')



 grim_data.shortcuts_base5 = $
        widget_base(grim_data.shortcuts_base, /row, space=0, xpad=0, ypad=0)

 if(NOT plot) then $
   grim_data.color_button = widget_button(grim_data.shortcuts_base5, $
              resource_name='grim_color_button', $
              value=grim_colors_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_colors_event')

 grim_data.settings_button = widget_button(grim_data.shortcuts_base5, $
              resource_name='grim_settings_button', $
              value=grim_settings_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_settings_event')


 grim_data.shortcuts_base6 = $
        widget_base(grim_data.shortcuts_base, /row, space=0, xpad=4, ypad=0)

 grim_data.tracking_button = widget_button(grim_data.shortcuts_base6, $
              resource_name='grim_tracking_button', $
              value=grim_tracking_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_tracking_event')

  grim_data.guideline_button = widget_button(grim_data.shortcuts_base6, $
              resource_name='grim_guideline_button', $
              value=grim_guideline_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_guideline_event')

 if(NOT plot) then $
  if(NOT grim_test_map(grim_data)) then $
    grim_data.grid_button = widget_button(grim_data.shortcuts_base6, $
              resource_name='grim_grid_button', $
              value=grim_grid_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_grid_event')

 if(NOT plot) then $
   grim_data.pixel_grid_button = widget_button(grim_data.shortcuts_base6, $
              resource_name='grim_pixel_grid_button', $
              value=grim_pixel_grid_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_pixel_grid_event')



 grim_data.shortcuts_base9 = $
        widget_base(grim_data.shortcuts_base, /row, space=0, xpad=0, ypad=0)

 grim_data.context_button = widget_button(grim_data.shortcuts_base9, $
              resource_name='grim_context_button', $
              value=grim_context_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_context_event')

 if(NOT plot) then $
   grim_data.axes_button = widget_button(grim_data.shortcuts_base9, $
              resource_name='grim_axes_button', $
              value=grim_axes_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_axes_event')


 grim_data.shortcuts_base7 = $
        widget_base(grim_data.shortcuts_base, /row, space=0, xpad=4, ypad=0)

 if(NOT plot) then $
   grim_data.activate_all_button = widget_button(grim_data.shortcuts_base7, $
         resource_name='grim_activate_all_button', $
         value=grim_activate_all_bitmap(), /bitmap, /tracking_events, $
                                     event_pro='grim_activate_all_event')

 if(NOT plot) then $
   grim_data.deactivate_all_button = widget_button(grim_data.shortcuts_base7, $
         resource_name='grim_deactivate_all_button', $
         value=grim_deactivate_all_bitmap(), /bitmap, /tracking_events, $
                                     event_pro='grim_deactivate_all_event')


 grim_data.shortcuts_base8 = $
        widget_base(grim_data.shortcuts_base, /row, space=0, xpad=0, ypad=0)

 grim_data.header_button = widget_button(grim_data.shortcuts_base8, $
         resource_name='grim_header_button', $
         value=grim_header_bitmap(), /bitmap, /tracking_events, $
                                     event_pro='grim_header_event')

 grim_data.notes_button = widget_button(grim_data.shortcuts_base8, $
         resource_name='grim_notes_button', $
         value=grim_notes_bitmap(), /bitmap, /tracking_events, $
                                     event_pro='grim_notes_event')

 grim_data.repeat_button = widget_button(grim_data.shortcuts_base8, $
         resource_name='grim_repeat_button', $
         value=grim_repeat_bitmap(), /bitmap, /tracking_events, $
                                     event_pro='grim_repeat_event')

 grim_data.undo_button = widget_button(grim_data.shortcuts_base8, $
         resource_name='grim_undo_button', $
         value=grim_undo_bitmap(), /bitmap, /tracking_events, $
                                     event_pro='grim_undo_event')
 w = where(strpos(menu_desc, 'grim_menu_undo_event') NE -1)
 grim_data.undo_menu_id = menu_ids[w[0]]

 grim_data.redo_button = widget_button(grim_data.shortcuts_base8, $
         resource_name='grim_redo_button', $
         value=grim_redo_bitmap(), /bitmap, /tracking_events, $
                                     event_pro='grim_redo_event')
 w = where(strpos(menu_desc, 'grim_menu_redo_event') NE -1)
 grim_data.redo_menu_id = menu_ids[w[0]]


 grim_data.identify_button = widget_button(grim_data.shortcuts_base8, $
             resource_name='grim_identify_button', $
             value=grim_identify_bitmap(), /bitmap, /tracking_events, $
                                              event_pro='grim_identify_event')



 grim_data.sub_base = widget_base(grim_data.base, /row, xpad=0, space=2)



 <span class="comments">;-----------------------------------------</span>
 <span class="comments">; mode buttons</span>
 <span class="comments">;-----------------------------------------</span>
 grim_data.modes_base = $
        widget_base(grim_data.sub_base, /col, space=0, xpad=0, ypad=0, $
                                             resource_name='grim_modes_base')


 <span class="comments">;-----------------------------------------</span>
 <span class="comments">; cursor modes</span>
 <span class="comments">;-----------------------------------------</span>
 nmodes = n_elements(cursor_modes)
 if(nmodes GT 0) then $
  begin
   for i=0, nmodes-1 do $
    begin
     event_pro = grim_parse_menu_desc(cursor_modes[i].event_pro)
     w = where(strpos(menu_desc, event_pro) NE -1)

     if(w[0] NE -1) then $
      begin
       ii = w[0]
       <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
       <span class="comments">; Because we override the event_pro here, the user modes do not</span>
       <span class="comments">; participate in grim's capture mechanism, so the 'repeat'</span>
       <span class="comments">; command does not apply.  This is necessary because the user</span>
       <span class="comments">; modes store their data in their button's uvalue, which would</span>
       <span class="comments">; otherwise be used by the capture mechanism.</span>
       <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
       button = widget_button(grim_data.modes_base, $
                   value=cursor_modes[i].bitmap, /bitmap, /tracking_events, $
                              event_pro=event_pro, uname='mode', $
                                                   uvalue=cursor_modes[i].name)
       widget_control, button, set_uvalue=cursor_modes[i]

       widget_control, menu_ids[ii], set_uvalue=cursor_modes[i], $
                                        event_pro=cursor_modes[i].event_pro
      end
    end
   end


 window, /free, /pixmap, xsize=MAG_SIZE_DEVICE, ysize=MAG_SIZE_DEVICE
 grim_data.mag_pixmap = !d.window
 window, /free, /pixmap, xsize=MAG_SIZE_DEVICE, ysize=MAG_SIZE_DEVICE
 grim_data.mag_redraw_pixmap = !d.window


 <span class="comments">;-----------------------------------------</span>
 <span class="comments">; main draw window</span>
 <span class="comments">;-----------------------------------------</span>
 grim_data.draw_base = widget_base(grim_data.sub_base, $
                      xsize=xsize, ysize=ysize, space=0, xpad=0, ypad=0)

<span class="comments">; grim_data.scale_draw = $</span>
<span class="comments">;      widget_draw(grim_data.main_draw_base, $</span>
<span class="comments">;            xsize=xsize+SCALE_WIDTH*2, ysize=ysize+SCALE_WIDTH*2, retain=retain)</span>


<span class="comments">; grim_data.draw_base = widget_base(grim_data.main_draw_base, $</span>
<span class="comments">;                                xsize=xsize, ysize=ysize, space=0, xoff=0, yoff=0)</span>
 grim_data.draw = $
     widget_draw(grim_data.draw_base, $
                /button_events, /tracking_events, /motion_events, $
                event_pro='grim_draw_event', resource_name='grim_draw', $
                retain=retain)
 if(idl_v_chrono(!version.release) GE idl_v_chrono('6.4')) then $
                             widget_control, grim_data.draw, /draw_wheel_events
<span class="comments">; widget_control, grim_data.draw_base, map=0</span>


 <span class="comments">;-----------------------------------------</span>
 <span class="comments">; message line</span>
 <span class="comments">;-----------------------------------------</span>
 grim_data.message_base = $
        widget_base(grim_data.base, /row, space=0, xpad=0, ypad=0, $
                                      resource_name='grim_message_base')

 grim_data.xy_label = $
       widget_label(grim_data.message_base, val='(----,----): ----------------', $
                       frame=1, /align_left, resource_name='grim_xy_label')

 grim_data.label = $
       widget_label(grim_data.message_base, val=' ', frame=1, /align_left, $
                                                    resource_name='grim_label')

 widget_control, grim_data.base, map=0
 widget_control, /realize, grim_data.base


 widget_control, grim_data.draw, get_value=wnum
 grim_data.wnum = wnum

<span class="comments">; widget_control, grim_data.scale_draw, get_value=scale_wnum</span>
<span class="comments">; grim_data.scale_wnum = scale_wnum</span>


 <span class="comments">;-----------------------------------------</span>
 <span class="comments">; context draw window</span>
 <span class="comments">;-----------------------------------------</span>
 context_xsize = (context_ysize = CONTEXT_SIZE)
 grim_data.context_base = $
              widget_base(grim_data.draw_base, xs=context_xsize, $
                                           ys=context_ysize, xoff=0, yoff=0)
 grim_data.context_draw = widget_draw(grim_data.context_base, $
     /button_events, /motion_events, /tracking_events, /wheel_events, $
      event_pro='grim_draw_event', retain=retain)
 widget_control, grim_data.context_draw, get_value=context_wnum
 grim_data.context_wnum = context_wnum
 widget_control, grim_data.context_base, map=0

 window, /free, /pixmap, xsize=context_xsize, ysize=context_ysize
 grim_data.context_pixmap = !d.window

 wset, wnum

 <span class="comments">;-----------------------------------------</span>
 <span class="comments">; axes draw window</span>
 <span class="comments">;-----------------------------------------</span>
 axes_xsize = (axes_ysize = AXES_SIZE)
 geom = widget_info(grim_data.draw_base, /geom)
 grim_data.axes_base = $
                widget_base(grim_data.draw_base, $
                xs=axes_xsize, ys=axes_ysize)
 grim_data.axes_draw = widget_draw(grim_data.axes_base, $
                /button_events, /motion_events, /tracking_events, $
                 event_pro='grim_draw_event', retain=retain, $
                 xs=axes_xsize, ys=axes_ysize)
 widget_control, grim_data.axes_draw, get_value=axes_wnum
 grim_data.axes_wnum = axes_wnum
 widget_control, grim_data.axes_base, map=0


 wset, wnum

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_get_default_zoom</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_get_default_zoom:source"></a>function grim_get_default_zoom, dd
ratio = 0.75

 device, get_screen_size=screen_size
 
 xsize_max = screen_size[0] * ratio
 ysize_max = screen_size[1] * ratio

 dim = dat_dim(dd)
 if(n_elements(dim) EQ 1) then dim = [dim, 1]

 sx = double(dim[0])
 sy = double(dim[1])

 im = 0

 Rx = xsize_max / sx
 Ry = ysize_max / sy

 if(Rx LT Ry) then return, Rx $
 else return, Ry

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_save_initial_view</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_save_initial_view:source"></a>pro grim_save_initial_view, grim_data

 tvim, get_info=tvd, /inherit, /silent, /no_coord
 *grim_data.tvd_init_p = tvd

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_initial_framing</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_initial_framing:source"></a>pro grim_initial_framing, grim_data, frame, delay_overlays=delay_overlays

 z = 1d100

 if(keyword_set(delay_overlays)) then planes = grim_get_plane(grim_data) $
 else planes = grim_get_plane(grim_data, /all)

 for i=0, n_elements(planes)-1 do $
  begin
   name = grim_parse_overlay(frame[0], obj_name)
   if(name EQ '1') then name = ''
   ptd = grim_get_all_overlays(grim_data, plane=planes[i], name=name)
   if(NOT keyword_set(ptd)) then return

   if(keyword_set(obj_name)) then $
    begin
     obj_names = cor_name(ptd)
     w = where(obj_names[0,*] EQ obj_name[0])
     if(w[0] EQ -1) then return
     ptd = ptd[*,w]
    end

   grim_frame_overlays, grim_data, planes[i], ptd
   tvim, get_info=tvd, /inherit, /silent
   if(min(tvd.zoom) LT z) then $
    begin
     z = min(tvd.zoom)
     off = tvd.offset
    end
  end

 tvim, zoom=z, offset=off, /inherit, /silent

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_initial_overlays</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_initial_overlays:source"></a>pro grim_initial_overlays, grim_data, plane=plane, _overlays, exclude=exclude, $
    only=only, temp=temp, ptd=ptd

 widget_control, /hourglass

 if(keyword_set(plane)) then planes = plane $
 else planes = grim_get_plane(grim_data, /all)
 nplanes = n_elements(planes)

 if(grim_data.slave_overlays) then nplanes = 1

 <span class="comments">;------------------------------------------------------------------</span>
 <span class="comments">; check each plane for initial overlays that have not been cleared</span>
 <span class="comments">;------------------------------------------------------------------</span>
 for j=0, nplanes-1 do $
  begin
   overlays = *planes[j].initial_overlays_p

   if(keyword_set(overlays)) then $
    begin
     <span class="comments">;---------------------------------------------------------------------</span>
     <span class="comments">; clear overlays so they are not computed again for this plane</span>
     <span class="comments">;---------------------------------------------------------------------</span>
     *planes[j].initial_overlays_p = ''

     <span class="comments">;-----------------------------------------------------</span>
     <span class="comments">; handle special keywords</span>
     <span class="comments">;-----------------------------------------------------</span>
     if(keyword_set(exclude)) then $
      begin
       *planes[j].initial_overlays_p = overlays
       for i=0, n_elements(exclude)-1 do $
	begin
	 w = where(overlays EQ exclude[i])
	 if(w[0] NE -1) then overlays = rm_list_item(overlays, w[0])
	end
      end

     if(keyword_set(only)) then $
      begin
       *planes[j].initial_overlays_p = overlays
       _overlays = overlays
       overlays = ''
       for i=0, n_elements(only)-1 do $
	begin
	 w = where(_overlays EQ only[i])
	 if(w[0] NE -1) then overlays = append_array(overlays, only[i])
	end 
      end
     
     <span class="comments">;-----------------------------------------------------</span>
     <span class="comments">; compute overlays</span>
     <span class="comments">;-----------------------------------------------------</span>
     if(keyword_set(overlays)) then $
      for i=0, n_elements(overlays)-1 do $
       begin
        name = grim_parse_overlay(overlays[i], obj_name)
        grim_print, grim_data, 'Plane ' + strtrim(j,1) + ': ' + name
        grim_overlay, grim_data, name, plane=planes[j], obj_name=obj_name, temp=temp, ptd=_ptd
        if(grim_data.activate) then grim_activate_all, grim_data, planes[j]
        if(keyword_set(_ptd)) then ptd = append_array(ptd, _ptd[*])
       end

     grim_set_plane, grim_data, planes[j], pn=planes[j].pn
    end
  end


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_rgb_dim_fn</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_rgb_dim_fn:source"></a>function grim_rgb_dim_fn, dd, dat
 return, (dat_dim(dd, /true))[0:1]
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_get_arg</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_get_arg:source"></a>pro grim_get_arg, arg, dd=dd, grnum=grnum, extensions=extensions

 if(NOT keyword_set(arg)) then return

 type = size(arg, /type)
 dim = size(arg, /dim) 
 ndim = n_elements(dim)

 <span class="comments">;---------------------------------------------------</span>
 <span class="comments">; object -- assume data descriptor </span>
 <span class="comments">;---------------------------------------------------</span>
 if(type EQ 11) then $
  begin
   dd = append_array(dd, arg)
   return
  end

 <span class="comments">;---------------------------------------------------</span>
 <span class="comments">; string -- assume file name(s); read descriptors </span>
 <span class="comments">;---------------------------------------------------</span>
 if(type EQ 7) then $
  begin
   dd = dat_read(arg, extensions=extensions)
   return
  end

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; scalar arg is grnum</span>
 <span class="comments">;------------------------------------------------</span>
 if((ndim EQ 1) AND (dim[0] EQ 0)) then $
  begin
   grnum = arg
   return
  end

 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; 1-D, 2-D or 3-D arg: just make dd</span>
 <span class="comments">;------------------------------------------------</span>
 if(ndim LE 3) then $
  begin
   _dd = dat_create_descriptors(1, data=arg)
   dd = append_array(dd, _dd)
   return
  end


 <span class="comments">;------------------------------------------------</span>
 <span class="comments">; other inputs are invalid</span>
 <span class="comments">;------------------------------------------------</span>
 grim_message, 'Invalid argument.'
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_get_args</span>
<span class="comments">;</span>
<span class="comments">; Possible arguments to GRIM:</span>
<span class="comments">; 	dd (object)</span>
<span class="comments">; 	filename (string)</span>
<span class="comments">; 	grnum (scalar)</span>
<span class="comments">; 	image (2d array)</span>
<span class="comments">; 	plot (1d array)</span>
<span class="comments">; 	cube (3d array)</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_get_args:source"></a>pro grim_get_args, arg1, arg2, dd=dd, grnum=grnum, type=type, xzero=xzero, nhist=nhist, $
               maintain=maintain, compress=compress, extensions=extensions, rgb=rgb

 <span class="comments">;--------------------------------------------</span>
 <span class="comments">; build data descriptors list </span>
 <span class="comments">;--------------------------------------------</span>
 grim_get_arg, arg1, dd=_dd, grnum=grnum, extensions=extensions
 grim_get_arg, arg2, dd=_dd, grnum=grnum, extensions=extensions


 <span class="comments">;--------------------------------------------</span>
 <span class="comments">; process data descriptors </span>
 <span class="comments">;--------------------------------------------</span>
 n_dd = n_elements(_dd)

 for i=0, n_dd-1 do $
  begin
   dim = dat_dim(_dd[i])
   ndim = n_elements(dim)

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; set dd controls</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   if(keyword_set(nhist)) then dat_set_nhist, _dd[i], nhist[0]
   if(keyword_set(maintain)) then dat_set_maintain, _dd[i], maintain[0]
   if(keyword_set(compress)) then dat_set_compress, _dd[i], compress[0]

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; non-3-D arrays get a plane and a zero offset</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   if((ndim LT 3) OR keyword_set(rgb)) then $
    begin
     dd = append_array(dd, _dd[i])
     if(keyword_set(rgb)) then dat_set_dim_fn, dd, 'grim_rgb_dim_fn'
    end $ 
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; 3-D arrays are multi-plane if not rgb</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   else dd = append_array(dd, dat_slices(_dd[i]))
  end


 <span class="comments">;-------------------------------------------------------------------</span>
 <span class="comments">; all dd assumed to have same type as first one; default is image</span>
 <span class="comments">;-------------------------------------------------------------------</span>
 type = 'image'
 if(keyword_set(dd)) then $
  begin 
   dim = dat_dim(dd[0])
   if(n_elements(dim) EQ 1) then type = 'plot'
   if(dim[0] EQ 2) then type = 'plot'
  end


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_create_cursor_mode</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_create_cursor_mode:source"></a>function grim_create_cursor_mode, name, mode_args, cursor_modes, no_prefix=no_prefix

 prefix = ''
 if(NOT keyword_set(no_prefix)) then prefix = 'grim_mode_'

 arg = ''
 if(keyword_set(mode_args)) then $
  begin
   if(size(mode_args, /type) EQ 7) then $
    begin
     names = str_nnsplit(mode_args, ':', rem=args)
     w = where(strupcase(names) EQ strupcase(name))
     if(w[0] NE -1) then arg = args[w]
    end $
   else arg = mode_args
  end

 cursor_mode = call_function(prefix + name, arg)
 return, append_array(cursor_modes, cursor_mode)
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim:source"></a>pro grim, arg1, arg2, gd=gd, _extra=keyvals, $
        cd=cd, pd=pd, rd=rd, sd=sd, std=std, ard=ard, sund=sund, od=od, $
	new=new, xsize=xsize, ysize=ysize, $
	default=default, previous=previous, restore=restore, activate=activate, $
	doffset=doffset, no_erase=no_erase, filter=filter, rgb=rgb, visibility=visibility, channel=channel, exit=exit, $
	zoom=zoom, rotate=rotate, order=order, offset=offset, retain=retain, maintain=maintain, $
	mode_init=mode_init, modal=modal, xzero=xzero, frame=frame, $
	refresh_callbacks=refresh_callbacks, refresh_callback_data_ps=refresh_callback_data_ps, $
	plane_callbacks=plane_callbacks, plane_callback_data_ps=plane_callback_data_ps, $
	nhist=nhist, compress=compress, path=path, symsize=symsize, $
	user_psym=user_psym, workdir=workdir, mode_args=mode_args, $
        save_path=save_path, load_path=load_path, overlays=overlays, pn=pn, $
	menu_fname=menu_fname, cursor_swap=cursor_swap, fov=fov, clip=clip, hide=hide, $
	menu_extensions=menu_extensions, button_extensions=button_extensions, $
	arg_extensions=arg_extensions, loadct=loadct, max=max, grnum=grnum, $
	extensions=extensions, beta=beta, rendering=rendering, npoints=npoints, $
	cam_trs=cam_trs, plt_trs=plt_trs, rng_trs=rng_trs, str_trs=str_trs, $
        sun_trs=sun_trs, stn_trs=stn_trs, arr_trs=arr_trs, assoc_dd=assoc_dd, $
        plane_syncing=plane_syncing, tiepoint_syncing=tiepoint_syncing, $
	curve_syncing=curve_syncing, render_sample=render_sample, $
	render_pht_min=render_pht_min, slave_overlays=slave_overlays, $
	position=position, delay_overlays=delay_overlays, auto_stretch=auto_stretch, $
     <span class="comments">;----- extra keywords for plotting only ----------</span>
	color=color, xrange=xrange, yrange=yrange, thick=thick, nsum=nsum, ndd=ndd, $
        xtitle=xtitle, ytitle=ytitle, psym=psym, title=title
common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr
@grim_block.include
@grim_constants.common

 if(keyword_set(exit)) then $
  begin
   grim_exit
   return
  end

 grim_constants

 grim_rc_settings, rcfile='.ominas/grimrc', keyvals=keyvals, $
	cam_select=cam_select, plt_select=plt_select, rng_select=rng_select, $
	str_select=str_select, stn_select=stn_select, arr_select=arr_select, $
	sun_select=sun_select, cmd=cmd, $
	new=new, xsize=xsize, ysize=ysize, mode_init=mode_init, $
	zoom=zoom, rotate=rotate, order=order, offset=offset, filter=filter, retain=retain, $
	path=path, save_path=save_path, load_path=load_path, symsize=symsize, $
        overlays=overlays, menu_fname=menu_fname, cursor_swap=cursor_swap, $
	fov=fov, clip=clip, menu_extensions=menu_extensions, button_extensions=button_extensions, arg_extensions=arg_extensions, $
	cam_trs=cam_trs, plt_trs=plt_trs, rng_trs=rng_trs, str_trs=str_trs, sun_trs=sun_trs, stn_trs=stn_trs, arr_trs=arr_trs, $
	hide=hide, mode_args=mode_args, xzero=xzero, $
        psym=psym, nhist=nhist, maintain=maintain, ndd=ndd, workdir=workdir, $
        activate=activate, frame=frame, compress=compress, loadct=loadct, max=max, $
	extensions=extensions, beta=beta, rendering=rendering, npoints=npoints, $
        plane_syncing=plane_syncing, tiepoint_syncing=tiepoint_syncing, curve_syncing=curve_syncing, $
	visibility=visibility, channel=channel, render_sample=render_sample, $
	render_pht_min=render_pht_min, slave_overlays=slave_overlays, rgb=rgb, $
	delay_overlays=delay_overlays, auto_stretch=auto_stretch

 if(keyword_set(ndd)) then dat_set_ndd, ndd

 if(NOT keyword_set(menu_extensions)) then $
                                     menu_extensions = 'grim_default_menus' $
 else if(strmid(menu_extensions[0],0,1) EQ '+') then $
  begin
   menu_extensions[0] = strmid(menu_extensions[0], 1, strlen(menu_extensions[0])-1)
   menu_extensions = ['grim_default_menus', menu_extensions]
  end

 <span class="comments">;=========================================================</span>
 <span class="comments">; cursor modes</span>
 <span class="comments">;=========================================================</span>
 cursor_modes = grim_create_cursor_mode('activate', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('zoom_plot', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('zoom', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('pan_plot', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('pan', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('readout', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('tiepoints', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('curves', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('mask', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('magnify', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('xyzoom', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('remove', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('trim', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('select', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('region', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('smooth', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('plane', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('drag', mode_args, cursor_modes)
 cursor_modes = grim_create_cursor_mode('navigate', mode_args, cursor_modes)

 <span class="comments">;-------------------------------------------</span>
 <span class="comments">; cursor mode extensions</span>
 <span class="comments">;-------------------------------------------</span>
 n_ext = n_elements(button_extensions)
 if(n_ext GT 0) then $
  begin
   if(NOT keyword_set(arg_extensions)) then arg_extensions = lonarr(n_ext)
   for i=0, n_ext-1 do $
    begin
     if(size(arg_extensions, /type) EQ 10) then arg_extension = *arg_extensions[i] $
     else arg_extension = arg_extensions[i]
    
     cursor_modes = append_array(cursor_modes, $
        grim_create_cursor_mode(button_extensions[i], arg_extension, /no_prefix))
    end
  end


 <span class="comments">;=========================================================</span>
 <span class="comments">; input defaults</span>
 <span class="comments">;=========================================================</span>
 new = keyword_set(new)
 if(NOT keyword_set(fov)) then fov = 0
 if(NOT keyword_set(clip)) then clip = 0
 if(NOT defined(hide)) then hide = 1
 if(n_elements(retain) EQ 0) then retain = 2
 if(n_elements(maintain) EQ 0) then maintain = 1
 if(NOT keyword_set(compress)) then compress = ''
 if(NOT keyword_set(extensions)) then extensions = ''
 if(NOT keyword_set(trs)) then trs = ''
 if(NOT keyword_set(cam_trs)) then cam_trs = ''
 if(NOT keyword_set(plt_trs)) then plt_trs = ''
 if(NOT keyword_set(rng_trs)) then rng_trs = ''
 if(NOT keyword_set(str_trs)) then str_trs = ''
 if(NOT keyword_set(stn_trs)) then stn_trs = ''
 if(NOT keyword_set(arr_trs)) then arr_trs = ''
 if(NOT keyword_set(sun_trs)) then sun_trs = ''
 
 if(NOT keyword_set(title)) then title = ''
 if(NOT keyword_set(xtitle)) then xtitle = ''
 if(NOT keyword_set(ytitle)) then ytitle = ''

 <span class="comments">;=========================================================</span>
 <span class="comments">; resolve arguments</span>
 <span class="comments">;=========================================================</span>
 grim_get_args, arg1, arg2, dd=dd, grnum=grnum, type=type, $
             nhist=nhist, maintain=maintain, compress=compress, $
             extensions=extensions, rgb=rgb

<span class="comments">; if(keyword_set(rendering)) then ....</span>

 if(NOT keyword_set(grim_get_data())) then new = 1

 if(NOT keyword_set(mode_init)) then $
  begin
   if(type EQ 'plot') then mode_init = 'grim_mode_zoom_plot' $
   else mode_init = 'grim_mode_activate'
  end


 if(type EQ 'plot') then $
  begin
   if(NOT keyword_set(xsize)) then xsize = 500
   if(NOT keyword_set(ysize)) then ysize = 500
  end

 <span class="comments">;=========================================================</span>
 <span class="comments">; if new instance, set up widgets and data structures</span>
 <span class="comments">;=========================================================</span>
 if(new) then $
  begin
   <span class="comments">;-----------------------------</span>
   <span class="comments">; defaults</span>
   <span class="comments">;-----------------------------</span>
   if(NOT keyword_set(dd)) then $
    begin
     if(NOT keyword_set(xsize)) then xsize = 768
     if(NOT keyword_set(ysize)) then ysize = 768
     dd = dat_create_descriptors(1, data=grim_blank(xsize, ysize), $
          name='BLANK', nhist=nhist, maintain=maintain, compress=compress)
    end $
   else $
    for i=0, n_elements(dd)-1 do $
     if(NOT keyword_set(dat_dim(dd[i]))) then $
      begin
       if(NOT keyword_set(xsize)) then xsize = 512
       if(NOT keyword_set(ysize)) then ysize = 512
       dat_set_maintain, dd[i], 0
       dat_set_compress, dd[i], compress
       dat_set_data, dd[i], grim_blank(xsize, ysize) 
      end

   if(NOT keyword_set(zoom)) then zoom = grim_get_default_zoom(dd[0])

   <span class="comments">;----------------------------------------------</span>
   <span class="comments">; initialize data structure and common block</span>
   <span class="comments">;----------------------------------------------</span>
   grim_data = grim_init(dd, dd0=dd0, zoom=zoom, wnum=wnum, grnum=grnum, type=type, $
       filter=filter, retain=retain, user_callbacks=user_callbacks, $
       user_psym=user_psym, path=path, save_path=save_path, load_path=load_path, $
       cursor_swap=cursor_swap, fov=fov, clip=clip, hide=hide, $
       cam_trs=cam_trs, plt_trs=plt_trs, rng_trs=rng_trs, str_trs=str_trs, stn_trs=stn_trs, sun_trs=sun_trs, arr_trs=arr_trs, $
       cam_select=cam_select, plt_select=plt_select, rng_select=rng_select, str_select=str_select, stn_select=stn_select, arr_select=arr_select, sun_select=sun_select, $
       cmd=cmd, color=color, xrange=xrange, yrange=yrange, position=position, thick=thick, nsum=nsum, $
       psym=psym, xtitle=xtitle, ytitle=ytitle, cursor_modes=cursor_modes, workdir=workdir, $
       symsize=symsize, nhist=nhist, maintain=maintain, $
       compress=compress, extensions=extensions, max=max, beta=beta, npoints=npoints, $
       visibility=visibility, channel=channel, $
       title=title, render_sample=render_sample, slave_overlays=slave_overlays, $
       render_pht_min=render_pht_min, overlays=overlays, activate=activate)


   <span class="comments">;----------------------------------------------</span>
   <span class="comments">; initialize colors common block</span>
   <span class="comments">;----------------------------------------------</span>
   if(NOT defined(loadct)) then loadct = 0
   if(NOT keyword_set(r_curr)) then loadct, loadct
   ctmod

   <span class="comments">;-----------------------------</span>
   <span class="comments">; widgets</span>
   <span class="comments">;-----------------------------</span>
   if(type NE 'plot') then grim_get_window_size, grim_data, xsize=xsize, ysize=ysize
   grim_widgets, grim_data, xsize=xsize, ysize=ysize, cursor_modes=cursor_modes, $
         menu_fname=menu_fname, menu_extensions=menu_extensions

   grnum = grim_data.grnum 

   planes = grim_get_plane(grim_data, /all)
   for i=0, n_elements(planes)-1 do planes[i].grnum = grnum
   grim_set_plane, grim_data, planes

   grim_set_mode, grim_data, mode_init, /init
   grim_set_data, grim_data, grim_data.base

   grim_resize, grim_data, /init
   widget_control, grim_data.base, map=1
   widget_control, grim_data.draw_base, map=1<span class="comments">;, $</span>
             <span class="comments">; xsize=xsize, ysize=ysize;, xoff=SCALE_WIDTH, yoff=SCALE_WIDTH</span>


   geom = widget_info(grim_data.base, /geom)
   grim_data.base_xsize = geom.xsize
   grim_data.base_ysize = geom.ysize

   <span class="comments">;----------------------------------------------</span>
   <span class="comments">; store initial tvim settings</span>
   <span class="comments">;----------------------------------------------</span>
   grim_wset, grim_data, /save

   <span class="comments">;----------------------------------------------</span>
   <span class="comments">; register data descriptor events</span>
   <span class="comments">;----------------------------------------------</span>
   nv_notify_register, dd, 'grim_descriptor_notify', scalar_data=grim_data.base

   xmanager, 'grim', grim_data.base, $
                 /no_block, modal=modal, cleanup='grim_kill_notify'
   if(keyword_set(modal)) then return

  end


 <span class="comments">;======================================================================</span>
 <span class="comments">; change to new window if specified</span>
 <span class="comments">;======================================================================</span>
 if(defined(grnum)) then $
  begin
   grim_data = grim_get_data(grnum=grnum)
   grim_wset, grim_data
  end




 <span class="comments">;======================================================================</span>
 <span class="comments">; update descriptors if any given</span>
 <span class="comments">;  If one plane, then descriptors all go to that plane; in that case</span>
 <span class="comments">;   only one cd, od, sund are allowed</span>
 <span class="comments">;  If multiple planes, descriptors are sorted using gd dd's</span>
 <span class="comments">;  If assoc_dd given as argument, use those instead.  </span>
 <span class="comments">;   In that case, if a map descriptor given, associate cd with dd</span>
 <span class="comments">;   instead of assoc_dd since dd will be the corresponding map.</span>
 <span class="comments">;  If a cube, cd and od are assigned to planes one-to-one, and all other</span>
 <span class="comments">;  descriptors are assigned to all planes</span>
 <span class="comments">;======================================================================</span>
 if(NOT keyword_set(cd)) then cd = dat_gd(gd, dd=dd, /cd)
 if(NOT keyword_set(pd)) then pd = dat_gd(gd, dd=dd, /pd)
 if(NOT keyword_set(rd)) then rd = dat_gd(gd, dd=dd, /rd)
 if(NOT keyword_set(sd)) then sd = dat_gd(gd, dd=dd, /sd)
 if(NOT keyword_set(std)) then std = dat_gd(gd, dd=dd, /std)
 if(NOT keyword_set(ard)) then ard = dat_gd(gd, dd=dd, /ard)
 if(NOT keyword_set(sund)) then sund = dat_gd(gd, dd=dd, /sund)
 if(NOT keyword_set(od)) then od = dat_gd(gd, dd=dd, /od)

 grim_data = grim_get_data()
 planes = grim_get_plane(grim_data, /all)
 nplanes = n_elements(planes)

 for i=0, nplanes-1 do $
  begin
   _assoc_dd = 0
   if(nplanes NE 1) then _assoc_dd = planes[i].dd
   if(keyword_set(assoc_dd)) then _assoc_dd = assoc_dd[i]

   if(keyword_set(pd)) then $
	 grim_add_descriptor, grim_data, planes[i].pd_p, pd, assoc_dd=_assoc_dd
   if(keyword_set(rd)) then $
	 grim_add_descriptor, grim_data, planes[i].rd_p, rd, assoc_dd=_assoc_dd
   if(keyword_set(std)) then $
	 grim_add_descriptor, grim_data, planes[i].std_p, std, assoc_dd=_assoc_dd
   if(keyword_set(ard)) then $
	 grim_add_descriptor, grim_data, planes[i].ard_p, ard, assoc_dd=_assoc_dd
   if(keyword_set(sd)) then $
	 grim_add_descriptor, grim_data, planes[i].sd_p, sd, assoc_dd=_assoc_dd
   if(keyword_set(sund)) then $
	 grim_add_descriptor, grim_data, planes[i].sund_p, sund[i], /one, assoc_dd=_assoc_dd
   if(keyword_set(od)) then $
     grim_add_descriptor, grim_data, planes[i].od_p, od[i], /one, /noregister, assoc_dd=_assoc_dd

   if(keyword_set(cd)) then $
    begin
     if(keyword_set(_assoc_dd)) then $
       if(cor_class(cd[i]) EQ 'MAP') then _assoc_dd = planes[i].dd
     grim_add_descriptor, grim_data, planes[i].cd_p, cd[i], /one, assoc_dd=_assoc_dd
    end
  end


 <span class="comments">;=========================================================</span>
 <span class="comments">; if new instance, setup initial view</span>
 <span class="comments">;=========================================================</span>
 if(new) then $
  begin
   grim_set_primary, grim_data.base

   <span class="comments">;----------------------------------------------</span>
   <span class="comments">; sampling</span>
   <span class="comments">;----------------------------------------------</span>
   if(type NE 'plot') then $
      for i=0, nplanes-1 do $
         dat_set_sampling_fn, planes[i].dd, 'grim_sampling_fn', /noevent

   entire = 1 & default = 0
   if(type EQ 'plot') then $
    begin
     entire = 0 & default = 1
    end

   <span class="comments">;----------------------------------------------</span>
   <span class="comments">; initial settings</span>
   <span class="comments">;----------------------------------------------</span>
   widget_control, grim_data.draw, /hourglass
   grim_refresh, grim_data, default=default, entire=entire, $
	xsize=xsize, ysize=ysize, $
	xrange=planes[0].xrange, yrange=planes[0].yrange, $
	zoom=zoom, $
	rotate=rotate, $
	order=order, $
	offset=offset, /no_plot, /no_objects
  end $
 <span class="comments">;=========================================================</span>
 <span class="comments">; if not new instance, just tvim with new settings</span>
 <span class="comments">;=========================================================</span>
 else $
  begin
   grim_data = grim_get_data()

   widget_control, grim_data.draw, /hourglass
   grim_refresh, grim_data, $
	default=default, previous=previous, restore=restore, $
	doffset=doffset, $
	zoom=zoom, $
	rotate=rotate, $
	order=order, $
	offset=offset, no_erase=no_erase
  end


 <span class="comments">;----------------------------------------------</span>
 <span class="comments">; add any callbacks</span>
 <span class="comments">;----------------------------------------------</span>
 if(keyword_set(refresh_callbacks)) then $
        grim_add_refresh_callback, refresh_callbacks, refresh_callback_data_ps

 if(keyword_set(plane_callbacks)) then $
        grim_add_plane_callback, plane_callbacks, plane_callback_data_ps


 <span class="comments">;----------------------------------------------</span>
 <span class="comments">; initial framing</span>
 <span class="comments">;----------------------------------------------</span>
 if(keyword_set(frame)) then $
        grim_initial_framing, grim_data, frame, delay_overlays=delay_overlays


 <span class="comments">;-------------------------</span>
 <span class="comments">; save initial view</span>
 <span class="comments">;-------------------------</span>
 grim_save_initial_view, grim_data
 

 <span class="comments">;----------------------------------------------</span>
 <span class="comments">; initial toggles</span>
 <span class="comments">;----------------------------------------------</span>
 if(keyword_set(plane_syncing)) then $
                   grim_set_toggle_flag, grim_data, 'PLANE_SYNCING', 1
 if(keyword_set(tiepoint_syncing)) then $
                   grim_set_toggle_flag, grim_data, 'TIEPOINT_SYNCING', 1
 if(keyword_set(curve_syncing)) then $
                   grim_set_toggle_flag, grim_data, 'CURVE_SYNCING', 1
 if(keyword_set(highlght)) then $
                   grim_set_toggle_flag, grim_data, 'PLANE_HIGHLIGHT', 1


 <span class="comments">;----------------------------------------------</span>
 <span class="comments">; if new instance, initialize menu extensions</span>
 <span class="comments">;----------------------------------------------</span>
 if(new) then $
  begin
   if(keyword_set(menu_extensions)) then $
    begin
     for i=0, n_elements(menu_extensions)-1 do $
         if(routine_exists(menu_extensions[i]+'_init')) then $
                  call_procedure, menu_extensions[i]+'_init', grim_data
    end
  end

 <span class="comments">;----------------------------------------------</span>
 <span class="comments">; if new instance, initialize cursor modes</span>
 <span class="comments">;----------------------------------------------</span>
 if(new) then $
     for i=0, n_elements(cursor_modes)-1 do $
        if(routine_exists(cursor_modes[i].name+'_init')) then $
            call_procedure, cursor_modes[i].name+'_init', grim_data, cursor_modes[i].data_p



 <span class="comments">;----------------------------------------------</span>
 <span class="comments">; if new instance, initialize menu toggles</span>
 <span class="comments">;----------------------------------------------</span>
 if(new) then $
  begin
   grim_update_menu_toggle, grim_data, $
         'grim_menu_plane_toggle_plane_syncing_event', $
          grim_get_toggle_flag(grim_data, 'PLANE_SYNCING')
   grim_update_menu_toggle, grim_data, $
         'grim_menu_plane_toggle_tiepoint_syncing_event', $
          grim_get_toggle_flag(grim_data, 'TIEPOINT_SYNCING')
   grim_update_menu_toggle, grim_data, $
         'grim_menu_plane_toggle_curve_syncing_event', $
          grim_get_toggle_flag(grim_data, 'CURVE_SYNCING')
   grim_update_menu_toggle, grim_data, $
         'grim_menu_plane_highlight_event', $
          grim_get_toggle_flag(grim_data, 'PLANE_HIGHLIGHT')
  end


 <span class="comments">;-------------------------</span>
 <span class="comments">; initial color stretch</span>
 <span class="comments">;-------------------------</span>
 if(keyword_set(auto_stretch)) then grim_stretch_plane, grim_data, planes

 <span class="comments">;-------------------------</span>
 <span class="comments">; draw initial image</span>
 <span class="comments">;-------------------------</span>
 grim_refresh, grim_data, no_erase=no_erase


 <span class="comments">;----------------------------------------------</span>
 <span class="comments">; compute any initial overlays</span>
 <span class="comments">;----------------------------------------------</span>
 if(keyword_set(overlays)) then $
    if(NOT keyword_set(delay_overlays)) then $
                        grim_initial_overlays, grim_data, plane=_plane


end
<span class="comments">;=============================================================================</span>
</code>
    </div>
  </body>
</html>