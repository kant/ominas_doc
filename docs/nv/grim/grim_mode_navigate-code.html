<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Fri Jul 14 10:59:31 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>grim_mode_navigate.pro (OMINAS API Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="grim_mode_navigate.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_bitmap</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_bitmap:source"></a>function grim_mode_navigate_bitmap

 return, [                               $
                [255B, 255B],                   $
                [255B, 255B],                   $
                [255B, 255B],                   $
                [255B, 255B],                   $
                [255B, 255B],                   $
                [127B, 254B],                   $
                [071B, 249B],                   $
                [127B, 231B],                   $
                [067B, 223B],                   $
                [127B, 231B],                   $
                [071B, 249B],                   $
                [127B, 254B],                   $
                [255B, 255B],                   $
                [255B, 255B],                   $
                [255B, 255B],                   $
                [255B, 255B]                    $
                ]


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_get_points</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_get_points:source"></a>pro grim_mode_navigate_get_points, grim_data, plane=plane, points_ptd, curves_ptd

 points_ptdp = grim_get_overlay_ptdp(grim_data, plane=plane, genre='point', /fast)
 curves_ptdp = grim_get_overlay_ptdp(grim_data, plane=plane, genre='curve', /fast)
 for i=0, n_elements(points_ptdp)-1 do points_ptds = append_array(points_ptds, *points_ptdp[i])
 for i=0, n_elements(curves_ptdp)-1 do curves_ptds = append_array(curves_ptds, *curves_ptdp[i])
 points_ptd = pnt_compress(points_ptds)
 curves_ptd = pnt_compress(curves_ptds)

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_reposition</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_reposition:source"></a>pro grim_mode_navigate_reposition, cd, cd0, curves_ptd, points_ptd, tracking, xarr, yarr, axes=axes

speed = 1

 <span class="comments">;-------------------------------------------</span>
 <span class="comments">; update position</span>
 <span class="comments">;-------------------------------------------</span>
 nv_copy, cd, cd0

 xy = (convert_coord(double(xarr), double(yarr), /device, /to_data))[0:1,*]
 dxy = xy[*,1] - xy[*,0]

 dr = speed*dxy

 pos = bod_pos(cd)
 om = bod_orient(cd)

 pos = pos + $
         axes[0]*dr[0]*om[0,*] + axes[1]*dr[1]*om[1,*] + axes[2]*dr[1]*om[2,*]
 bod_set_pos, cd, pos


 grim_draw_vectors, cd, curves_ptd, points_ptd
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_reposition_xy</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_reposition_xy:source"></a>pro grim_mode_navigate_reposition_xy, data, xarr, yarr, pixmap, win_num
 grim_data = data.grim_data
 plane = grim_get_plane(grim_data)

 curves_ptd = data.curves_ptd
 points_ptd = data.points_ptd
 cd = data.cd

 cd0 = *plane.cd_p

 scale = (cam_scale(cd))[0]
scale=1d
 grim_mode_navigate_reposition, cd, cd0, curves_ptd, points_ptd, tracking, xarr, yarr, axes=[scale,-1,0]
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_reposition_xz</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_reposition_xz:source"></a>pro grim_mode_navigate_reposition_xz, data, xarr, yarr, pixmap, win_num
common grim_mode_navigate_reposition_xz_block, name, bx, inertial_pt0

 grim_data = data.grim_data
 plane = grim_get_plane(grim_data)

 curves_ptd = data.curves_ptd
 points_ptd = data.points_ptd
 cd = data.cd

 cd0 = *plane.cd_p
 nv_copy, cd, cd0

 xy = (convert_coord(double(xarr), double(yarr), /device, /to_data))[0:1,*]

 <span class="comments">;-------------------------------------------</span>
 <span class="comments">; get initial point on first call</span>
 <span class="comments">;-------------------------------------------</span>
 if(p_mag(xy[*,1]-xy[*,0]) EQ 0) then $
  begin
   name = ''
   surf_pts = grim_image_to_surface(grim_data, plane, xy[*,0], $
                                         bx=bx, names=names, body_pts=body_pts)
   if(keyword_set(surf_pts)) then $
    begin
     name = names[0]
     bx = bx[0]

     body_pt0 = body_pts[0,*]
     inertial_pt0 = bod_body_to_inertial_pos(bx, body_pt0)

     grim_draw_vectors, cd, curves_ptd, points_ptd
    end
   return
  end
 if(NOT keyword_set(name)) then return


 <span class="comments">;-------------------------------------------</span>
 <span class="comments">; reposition camera</span>
 <span class="comments">;-------------------------------------------</span>
 dist = v_mag(inertial_pt0 - bod_pos(cd0))
 speed = dist*(cam_scale(cd))[0]

 grim_mode_navigate_reposition, cd, cd0, curves_ptd, points_ptd, tracking, xarr, yarr, axes=-[speed,0,speed]
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_reposition_track</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_reposition_track:source"></a>pro grim_mode_navigate_reposition_track, data, xarr, yarr, pixmap, win_num
common grim_mode_navigate_reposition_track_block, name, bx, body_pt0

 grim_data = data.grim_data
 plane = grim_get_plane(grim_data)

 curves_ptd = data.curves_ptd
 points_ptd = data.points_ptd
 cd = data.cd

 cd0 = *plane.cd_p
 nv_copy, cd, cd0

 xy = (convert_coord(double(xarr), double(yarr), /device, /to_data))[0:1,*]


 <span class="comments">;-------------------------------------------</span>
 <span class="comments">; get surface point on first call</span>
 <span class="comments">;-------------------------------------------</span>
 if(p_mag(xy[*,1]-xy[*,0]) EQ 0) then $
  begin
   name = ''
   surf_pts = grim_image_to_surface(grim_data, plane, xy[*,0], $
                                         bx=bx, names=names, body_pts=body_pts)
   if(keyword_set(surf_pts)) then $
    begin
     name = names[0]
     body_pt0 = body_pts[0,*]
     bx = bx[0]
     grim_draw_vectors, cd, curves_ptd, points_ptd
    end
   return
  end
 if(NOT keyword_set(name)) then return


 <span class="comments">;-------------------------------------------------------------------------</span>
 <span class="comments">; reposition cd such that:</span>
 <span class="comments">;  - bx center stays fixed in the image plane</span>
 <span class="comments">;  - cd altitude above bx stays constant</span>
 <span class="comments">;  - body_pt maps to xy[*,1] in image plane</span>
 <span class="comments">;-------------------------------------------------------------------------</span>

 <span class="comments">;- - - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; rotate cd position about bx center</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - - -</span>
 body_pt = surface_intersect(/near, hit=hit, bx, $
                    bod_inertial_to_body_pos(bx, bod_pos(cd)), $
                                        bod_inertial_to_body(bx, $
                                          image_to_inertial(cd, xy[*,1])))
 body_pt = body_pt[0,*]

 n = v_unit(v_cross(body_pt, body_pt0))
 theta = v_angle(body_pt0, body_pt)

 pos = bod_pos(cd)
 pos_body = bod_inertial_to_body_pos(bx, pos)

 pos = v_rotate(pos_body, n, sin(theta), cos(theta))
 bod_set_pos, cd, bod_body_to_inertial_pos(bx, pos)

 <span class="comments">;- - - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; adjust cd altitude above bx surface</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - - -</span>
 surf_pt0 = body_to_surface(bx, $
             bod_inertial_to_body_pos(bx, bod_pos(cd0)))
 surf_pt = body_to_surface(bx, $
             bod_inertial_to_body_pos(bx, bod_pos(cd)))
 n = surface_normal(bx, pos_body, body_pt)
 alt0 = surf_pt0[2]
 alt = surf_pt[2]
 bod_set_pos, cd, bod_pos(cd) + n*(alt-alt0)

 <span class="comments">;- - - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; repoint cd </span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - - -</span>
 vcent0 = v_unit(bod_pos(bx) - bod_pos(cd0))
 vcent = v_unit(bod_pos(bx) - bod_pos(cd))

 M = v_rot(vcent0, vcent)
 bod_set_orient, cd, M##bod_orient(cd0)


 grim_draw_vectors, cd, curves_ptd, points_ptd
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_draw</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_draw:source"></a>pro grim_mode_navigate_draw, wnum, pixmap, erase_pixmap, cd, curves_ptd, points_ptd

 wset, pixmap
 device, copy=[0,0, !d.x_size,!d.y_size, 0,0, erase_pixmap]
 grim_draw_vectors, cd, curves_ptd, points_ptd
 wset, wnum
 device, copy=[0,0, !d.x_size,!d.y_size, 0,0, pixmap]

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_reposition_y_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_reposition_y_event:source"></a>pro grim_mode_navigate_reposition_y_event, event
common grim_mode_navigate_reposition_y_block, name, bx, surf_pt0, body_pt0

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 data = *grim_data.misc_data_p
 struct = tag_names(event, /struct)

 curves_ptd = data.curves_ptd
 points_ptd = data.points_ptd
 cd = data.cd
 event_pro = data.event_pro
 wnum = data.wnum
 pixmap = data.pixmap
 erase_pixmap = data.erase_pixmap

 <span class="comments">;---------------------------------------------------------------</span>
 <span class="comments">; quit and restore main handler if not wheel or motion event</span>
 <span class="comments">;---------------------------------------------------------------</span>
 done = 0
 if(struct NE 'WIDGET_DRAW') then done = 1 $
 else if((event.type NE 7) AND (event.type NE 2)) then done = 1 $
 else if(NOT keyword_set(event.modifiers)) then done = 1

 if(done) then $
  begin
   nv_copy, *plane.cd_p, cd
   nv_free, [cd, curves_ptd, points_ptd]
   widget_control, grim_data.draw, event_pro=event_pro
   wdelete, pixmap
   wdelete, erase_pixmap
   bx = 0
   return
  end


 p0 = (convert_coord(double(event.x), double(event.y), /device, /to_data))[0:1]

 <span class="comments">;-------------------------------------------</span>
 <span class="comments">; get initial point on first call</span>
 <span class="comments">;-------------------------------------------</span>
 if(NOT keyword_set(bx)) then $
  begin
   surf_pts = grim_image_to_surface(grim_data, plane, p0[*,0], $
                                         bx=bx, names=names, body_pts=body_pts)
   if(NOT keyword_set(names)) then return
   name = names[0]
   surf_pt0 = surf_pts[0,*]
   body_pt0 = body_pts[0,*]
   bx = bx[0]

   return
  end
 if(keyword_set(name)) then if(name EQ 'SKY') then return


 <span class="comments">;---------------------------------------------------------------</span>
 <span class="comments">; determine speed</span>
 <span class="comments">;---------------------------------------------------------------</span>
 surf_pt = body_to_surface(bx, $
             bod_inertial_to_body_pos(bx, bod_pos(cd)))
 alt = surf_pt[2]
 speed = alt[0]*0.1


 <span class="comments">;---------------------------------------------------------------</span>
 <span class="comments">; move along click direction</span>
 <span class="comments">;---------------------------------------------------------------</span>
 dm = event.clicks

 v = image_to_inertial(cd, p0)

 pos = bod_pos(cd)
 pos = pos + v*speed*dm
 bod_set_pos, cd, pos


 <span class="comments">;---------------------------------------------------------------</span>
 <span class="comments">; draw points</span>
 <span class="comments">;---------------------------------------------------------------</span>
 grim_mode_navigate_draw, wnum, pixmap, erase_pixmap, cd, curves_ptd, points_ptd


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_reposition_y</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_reposition_y:source"></a>pro grim_mode_navigate_reposition_y, grim_data

 plane = grim_get_plane(grim_data)


 grim_mode_navigate_get_points, grim_data, plane=plane, points_ptd, curves_ptd
 cd = nv_clone(*plane.cd_p)

 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; temporarily replace main event handler</span>
 <span class="comments">;-----------------------------------------------</span>
 event_pro = widget_info(grim_data.draw, /event_pro)
 widget_control, grim_data.draw, event_pro='grim_mode_navigate_reposition_y_event'

 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; set up display maps</span>
 <span class="comments">;-----------------------------------------------</span>
 wnum = !d.window

 window, /free, /pixmap, xsize=!d.x_size, ysize=!d.y_size
 pixmap = !d.window

 window, /free, /pixmap, xsize=!d.x_size, ysize=!d.y_size
 erase_pixmap = !d.window
 device, copy=[0,0, !d.x_size,!d.y_size, 0,0, wnum]

 grim_mode_navigate_draw, wnum, pixmap, erase_pixmap, cd, curves_ptd, points_ptd


 *grim_data.misc_data_p = {cd:cd, curves_ptd:curves_ptd, points_ptd:points_ptd, event_pro:event_pro, $
                   wnum:wnum, pixmap:pixmap, erase_pixmap:erase_pixmap}

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_reorient_nod</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_reorient_nod:source"></a>pro grim_mode_navigate_reorient_nod, data, xarr, yarr, pixmap, win_num
 grim_data = data.grim_data
 plane = grim_get_plane(grim_data)

 curves_ptd = data.curves_ptd
 points_ptd = data.points_ptd
 cd = data.cd

 cd0 = *plane.cd_p

 xy = (convert_coord(double(xarr), double(yarr), /device, /to_data))[0:1,*]
 dxy = xy[*,1] - xy[*,0]

 nv_copy, cd, cd0
 cam_reorient, cd, [0,0], dxy, 0

 grim_draw_vectors, cd, curves_ptd, points_ptd
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_reorient_twist</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_reorient_twist:source"></a>pro grim_mode_navigate_reorient_twist, data, xarr, yarr, pixmap, win_num
common grim_mode_navigate_reorient_twist_block, p0
 grim_data = data.grim_data
 plane = grim_get_plane(grim_data)

 minpix = 10

 curves_ptd = data.curves_ptd
 points_ptd = data.points_ptd
 cd = data.cd

 cd0 = *plane.cd_p

 xy = (convert_coord(double(xarr), double(yarr), /device, /to_data))[0:1,*]

 dxyarr = [xarr[1]-xarr[0], yarr[1]-yarr[0]]
 dxy = xy[*,1] - xy[*,0]

 <span class="comments">;---------------------------------------------</span>
 <span class="comments">; no rotation if too close to origin point</span>
 <span class="comments">;---------------------------------------------</span>
 if(p_mag(dxyarr) LT minpix) then p0 = 0 $
 <span class="comments">;---------------------------------------------</span>
 <span class="comments">; otherwise rotate about origin point</span>
 <span class="comments">;---------------------------------------------</span>
 else $
  begin
   if(NOT keyword_set(p0)) then p0 = xy[*,1]

   r0 = p0 - xy[*,0]
   r1 = xy[*,1] - xy[*,0]
   theta0 = atan(r0[1,*], r0[0,*])
   theta1 = atan(r1[1,*], r1[0,*])
   dtheta = theta1 - theta0

   nv_copy, cd, cd0
   cam_reorient, cd, xy[*,0], [0,0], dtheta

  end

 grim_draw_vectors, cd, curves_ptd, points_ptd
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_mouse_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_mouse_event:source"></a>pro grim_mode_navigate_mouse_event, event, data

 grim_data = grim_get_data(event.top)
 plane = grim_get_plane(grim_data)

 struct = tag_names(event, /struct)
 if(struct NE 'WIDGET_DRAW') then return
 if(event.press EQ 2) then return

 <span class="comments">;---------------------------------------</span>
 <span class="comments">; scroll wheel -- adjust distance</span>
 <span class="comments">;---------------------------------------</span>
 if(event.type EQ 7) then $
  if(event.modifiers EQ 1) then $
   begin
    grim_refresh, grim_data, plane=plane, /use_pixmap, /no_objects
    grim_mode_navigate_reposition_y, grim_data
    return
   end
 if(event.type NE 0) then return


 <span class="comments">;---------------------------------------</span>
 <span class="comments">; get points</span>
 <span class="comments">;---------------------------------------</span>
 grim_mode_navigate_get_points, grim_data, plane=plane, points_ptd, curves_ptd
 cd = nv_clone(*plane.cd_p)
 p0 = [event.x, event.y]

 fn = ''
 fn_data = {curves_ptd:curves_ptd, points_ptd:points_ptd, cd:cd, grim_data:grim_data}

<span class="comments">; grim_refresh, grim_data, plane=plane, /use_pixmap, /no_objects, /noglass</span>

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; reposition mode</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 if(event.modifiers EQ 1) then $
        fn = event.press EQ 1 ? 'reposition_xz' : 'reposition_track' $
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; reorient mode</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 else fn = event.press EQ 1 ? 'reorient_nod' : 'reorient_twist'

 if(keyword_set(fn)) then $
       pp = tvline(p0=p0, fn_draw='grim_mode_navigate_'+fn, fn_data=fn_data)

 nv_copy, *plane.cd_p, cd
 nv_free, [cd, points_ptd, curves_ptd]

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_mode</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_mode:source"></a>pro grim_mode_navigate_mode, grim_data, data_p

 device, cursor_standard = 142
 grim_print, grim_data, $
      'NAVIGATE CAMERA -- LEFT: Nod; RIGHT: Twist  &lt;Shift> LEFT:XZ; RIGHT: track; WHEEL: Y '

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	grim_mode_navigate_button_event</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Selects the navigate cursor mode.  </span>
<span class="comments">;</span>
<span class="comments">;	 Camera orientation: </span>
<span class="comments">;	   Left button:		Allows the optic axis to be repointed.</span>
<span class="comments">;</span>
<span class="comments">;	   Right button:	Allows the camera to twist about an axis </span>
<span class="comments">;				corresponding to the selected pixel location.</span>
<span class="comments">;</span>
<span class="comments">;	 Camera position:</span>
<span class="comments">;	   &lt;Shift> Left:	Allows the camera to be repositioned in the </span>
<span class="comments">;				X-Z plane (image plane).  Speeds depend on</span>
<span class="comments">;				the object under the cursor.</span>
<span class="comments">;</span>
<span class="comments">;	   &lt;Shift> Right:	Allows the camera to be repositioned and </span>
<span class="comments">;				reoriented simultaneosly by tracking the</span>
<span class="comments">;				object under the cursor.</span>
<span class="comments">;</span>
<span class="comments">;	   &lt;Shift> Wheel:	Allows the camera to be repositioned in the </span>
<span class="comments">;				Y (optic axis) direction.  Speeds depend on</span>
<span class="comments">;				the object under the cursor.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; OPERATION:</span>
<span class="comments">;	Allow the user to fly around the system.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/2009</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<span class="comments">;pro grim_navigate_mode_help_event, event</span>
<span class="comments">; text = ''</span>
<span class="comments">; nv_help, 'grim_navigate_mode_event', cap=text</span>
<span class="comments">; if(keyword_set(text)) then grim_help, grim_get_data(event.top), text</span>
<span class="comments">;end</span>
<span class="comments">;----------------------------------------------------------------------------</span>
<a id="grim_mode_navigate_button_event:source"></a>pro grim_mode_navigate_button_event, event

 grim_data = grim_get_data(event.top)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; if tracking event, just print usage info</span>
 <span class="comments">;---------------------------------------------------------</span>
 struct = tag_names(event, /struct)
 if(struct EQ 'WIDGET_TRACKING') then $
  begin
   if(event.enter) then grim_print, grim_data, 'Fly through system'
   return
  end

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; otherwise, change mode</span>
 <span class="comments">;---------------------------------------------------------</span>
 widget_control, event.id, get_uvalue=data
 grim_set_mode, grim_data, 'grim_mode_navigate', /new, data_p=data.data_p
 grim_set_data, grim_data, event.top

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate_init</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate_init:source"></a>pro grim_mode_navigate_init, grim_data, data_p



end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_mode_navigate</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_mode_navigate:source"></a>function grim_mode_navigate, arg

 data = 0

 return, $
     {grim_user_mode_struct, $
		 name:		'grim_mode_navigate', $
		 event_pro:	'grim_mode_navigate_button_event', $
                 bitmap:	 grim_mode_navigate_bitmap(), $
                 menu:		'Navigate', $
                 data_p:	 nv_ptr_new(data) }

end
<span class="comments">;=============================================================================</span>
</code>
    </div>
  </body>
</html>