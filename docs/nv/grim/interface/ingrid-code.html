<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Fri Jul 14 10:59:41 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>ingrid.pro (OMINAS API Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="ingrid.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	INGRID</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	INterface to GRIm Data -- command-line access to GRIM data.</span>
<span class="comments">;	The returned descriptors allow direct access to the memory images of</span>
<span class="comments">;	GRIM's descriptor set.  Therefore changes made from the command line</span>
<span class="comments">;	affect the descriptors that GRIM is using.  GRIM monitors those </span>
<span class="comments">;	descriptors and updates itself whenever a change occurs.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/GR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	ingrid, arg, &lt;xd>=&lt;xd></span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;  INPUT:</span>
<span class="comments">;	arg:	GRIM window number or GRIM data struture.  If not given, the </span>
<span class="comments">;		most recently accessed grim instance is used.</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;  INPUT:</span>
<span class="comments">;	plane:	Grim plane structure(s) instead of giving pn.  Note all planes</span>
<span class="comments">;		must belong to the same grim instance.</span>
<span class="comments">;</span>
<span class="comments">;	pn:	Plane numer(s) to access.  If not given, then current plane</span>
<span class="comments">;		is used.</span>
<span class="comments">;</span>
<span class="comments">;	all:	If set, all planes are used.</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT:</span>
<span class="comments">;	dd:	GRIM's data descriptor.</span>
<span class="comments">;</span>
<span class="comments">;	cd:	GRIM's camera descriptor.</span>
<span class="comments">;</span>
<span class="comments">;	od:	GRIM's observer descriptor.</span>
<span class="comments">;</span>
<span class="comments">;	sund:	GRIM's sun descriptor.</span>
<span class="comments">;</span>
<span class="comments">;	pd:	GRIM's planet descriptors.</span>
<span class="comments">;</span>
<span class="comments">;	rd:	GRIM's ring descriptors.</span>
<span class="comments">;</span>
<span class="comments">;	sd:	GRIM's star descriptors.</span>
<span class="comments">;</span>
<span class="comments">;	std:	GRIM's station descriptors.</span>
<span class="comments">;</span>
<span class="comments">;	ard:	GRIM's array descriptors.</span>
<span class="comments">;</span>
<span class="comments">;	gd:	Generic descriptor containing all of the above descriptors. </span>
<span class="comments">;</span>
<span class="comments">;	center_ptd:</span>
<span class="comments">;		POINT object giving the planet centers.</span>
<span class="comments">;</span>
<span class="comments">;	limb_ptd:</span>
<span class="comments">;		POINT object giving the limb points.</span>
<span class="comments">;</span>
<span class="comments">;	ring_ptd:</span>
<span class="comments">;		POINT object giving the ring points.</span>
<span class="comments">;</span>
<span class="comments">;	star_ptd:</span>
<span class="comments">;		POINT object giving the star points.</span>
<span class="comments">;</span>
<span class="comments">;	term_ptd:</span>
<span class="comments">;		POINT object giving the terminator points.</span>
<span class="comments">;</span>
<span class="comments">;	station_ptd:</span>
<span class="comments">;		POINT object giving the station points.</span>
<span class="comments">;</span>
<span class="comments">;	array_ptd:</span>
<span class="comments">;		POINT object giving the array points.</span>
<span class="comments">;</span>
<span class="comments">;	plgrid_ptd:</span>
<span class="comments">;		POINT object giving the planet grid points.</span>
<span class="comments">;</span>
<span class="comments">;	shadow_ptd:</span>
<span class="comments">;		POINT object giving the shadow points.</span>
<span class="comments">;</span>
<span class="comments">;	object_ptd:</span>
<span class="comments">;		POINT object giving all overlay points.</span>
<span class="comments">;</span>
<span class="comments">;	tie_ptd:</span>
<span class="comments">;		POINT object giving the tie points.</span>
<span class="comments">;</span>
<span class="comments">;	curve_ptd:</span>
<span class="comments">;		POINT object giving the curve points.</span>
<span class="comments">;</span>
<span class="comments">;	active_*_ptd:</span>
<span class="comments">;		Returns same as above ptd outputs, except ony active arrays</span>
<span class="comments">;		are returned.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;	(1) Open a GRIM window, load an image, and compute limb points.</span>
<span class="comments">;</span>
<span class="comments">;	(2) At the command line, type:</span>
<span class="comments">;</span>
<span class="comments">;		IDL> ingrid, cd=cd</span>
<span class="comments">;		IDL> pg_repoint, [50,50], 0d, cd=cd</span>
<span class="comments">;</span>
<span class="comments">;	GRIM should detect the change to the camera descriptor and update</span>
<span class="comments">;	itself by recomputing the limb points and refreshing the display.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KNOWN ISSUES:</span>
<span class="comments">;	This procedure has unresolved issues, is unreliable, behaves </span>
<span class="comments">;	irrationally, is overly complicated, and has periodic breakdowns for </span>
<span class="comments">;	no externally apparent reason.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; STATUS:</span>
<span class="comments">;	Has unresolved issues that need to be confronted and addressed.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;	grim, gr_draw</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="ingrid:source"></a>pro ingrid, arg, plane=planes, gd=_gd, $
         dd=_dd, cd=_cd, pd=_pd, rd=_rd, sd=_sd, std=_std, ard=_ard, sund=_sund, od=_od, $
         limb_ptd=_limb_ptd, ring_ptd=_ring_ptd, star_ptd=_star_ptd, station_ptd=_station_ptd, array_ptd=_array_ptd, term_ptd=_term_ptd, $
         plgrid_ptd=_plgrid_ptd, center_ptd=_center_ptd, object_ptd=_object_ptd, $
         tie_ptd=_tie_ptd, curve_ptd=_curve_ptd, shadow_ptd=_shadow_ptd, reflection_ptd=_reflection_ptd, pn=pn, all=all, grnum=_grnum, $
         active_pd=_active_pd, active_rd=_active_rd, active_sd=_active_sd, $
         active_std=_active_std, active_ard=_active_ard, active_xd=_active_xd, $
         active_limb_ptd=_active_limb_ptd, active_ring_ptd=_active_ring_ptd, $
         active_star_ptd=_active_star_ptd, active_term_ptd=_active_term_ptd, $
         active_plgrid_ptd=_active_plgrid_ptd, active_center_ptd=_active_center_ptd, $
         active_shadow_ptd=_active_shadow_ptd, active_reflection_ptd=_active_reflection_ptd, active_station_ptd=_active_station_ptd, $
         active_array_ptd=_active_array_ptd


 active = keyword_set(active)	<span class="comments">; Looks like I was going to simplify this by </span>
				<span class="comments">; having a /active keyword instead of a million</span>
				<span class="comments">; repeated keywords with "active_" in front</span>
				<span class="comments">; of their names.  That would be simpler.</span>

 arg_type = size(arg, /type)
 if(arg_type EQ 8) then grim_data = arg $
 else if(arg_type NE 0) then grnum = arg

 if(defined(grnum)) then $
                     grim_data = grim_get_data(grim_grnum_to_top(grnum)) $
 else grim_data = grim_get_data(/primary)

 if(NOT keyword_set(grim_data)) then grim_data = grim_get_data(planes[0])

 _grnum = grim_data.grnum

 
 if(NOT keyword_set(planes)) then $
  begin
   if(keyword_set(all)) then planes = grim_get_plane(grim_data, /all) $
   else planes = grim_get_plane(grim_data)
  end
 nplanes = n_elements(planes)


 for i=0, nplanes-1 do $
  begin
   plane = planes[i]
   if(arg_present(_dd)) then dd = append_array(dd, plane.dd)

   if(arg_present(_cd)) then cd = append_array(cd, *plane.cd_p)
   if(arg_present(_pd)) then pd = append_array(pd, tr(*plane.pd_p))
   if(arg_present(_rd)) then rd = append_array(rd, tr(*plane.rd_p))
   if(arg_present(_sd)) then sd = append_array(sd, tr(*plane.sd_p))
   if(arg_present(_std)) then std = append_array(std, tr(*plane.std_p))
   if(arg_present(_ard)) then ard = append_array(ard, tr(*plane.ard_p))
   if(arg_present(_sund)) then sund = append_array(sund, *plane.sund_p)
   if(arg_present(_od)) then od = append_array(od, *plane.od_p)

   if(arg_present(_active_pd)) then $
      active_pd = append_array(active_pd, grim_get_active_xds(plane, 'planet'))
   if(arg_present(_active_rd)) then $
      active_rd = append_array(active_rd, grim_get_active_xds(plane, 'ring'))
   if(arg_present(_active_sd)) then $
      active_sd = append_array(active_sd, grim_get_active_xds(plane, 'star'))
   if(arg_present(_active_std)) then $
      active_std = append_array(active_std, grim_get_active_xds(plane, 'station'))
   if(arg_present(_active_ard)) then $
      active_ard = append_array(active_ard, grim_get_active_xds(plane, 'station'))

   if(arg_present(_active_limb_ptd)) then $
      _active_limb_ptd = append_array(active_limb_ptd, $
   			grim_get_active_overlays(grim_data, 'limb'))
   if(arg_present(_active_ring_ptd)) then $
      _active_ring_ptd = append_array(active_ring_ptd, $
   			grim_get_active_overlays(grim_data, 'ring'))
   if(arg_present(_active_star_ptd)) then $
      _active_star_ptd = append_array(active_star_ptd, $
   			grim_get_active_overlays(grim_data, 'star'))
   if(arg_present(_active_term_ptd)) then $
      _active_term_ptd = append_array(active_term_ptd, $
   			grim_get_active_overlays(grim_data, 'terminator'))
   if(arg_present(_active_plgrid_ptd)) then $
      _active_plgrid_ptd = append_array(active_plgrid_ptd, $
   			grim_get_active_overlays(grim_data, 'planet_grid'))
   if(arg_present(_active_center_ptd)) then $
      _active_center_ptd = append_array(active_center_ptd, $
   			grim_get_active_overlays(grim_data, 'planet_center'))
   if(arg_present(_active_shadow_ptd)) then $
      _active_shadow_ptd = append_array(active_shadow_ptd, $
   			grim_get_active_overlays(grim_data, 'shadow'))
   if(arg_present(_active_reflection_ptd)) then $
      _active_reflection_ptd = append_array(active_reflection_ptd, $
   			grim_get_active_overlays(grim_data, 'reflection'))
   if(arg_present(_active_station_ptd)) then $
      _active_station_ptd = append_array(active_station_ptd, $
   			grim_get_active_overlays(grim_data, 'station'))
   if(arg_present(_active_array_ptd)) then $
      _active_array_ptd = append_array(active_array_ptd, $
   			grim_get_active_overlays(grim_data, 'array'))

   if(arg_present(_active_xd)) then $
   		  active_xd = append_array(active_xd, *plane.active_xd_p)

   if(arg_present(_limb_ptd)) then $
    if(ptr_valid(grim_get_overlay_ptdp(grim_data, plane=plane, 'limb'))) then $
   		limb_ptd = append_array(limb_ptd, *(grim_get_overlay_ptdp(grim_data, plane=plane, 'limb')))
   if(arg_present(_ring_ptd)) then $
    if(ptr_valid(grim_get_overlay_ptdp(grim_data, plane=plane, 'ring'))) then $
   		ring_ptd = append_array(ring_ptd, *(grim_get_overlay_ptdp(grim_data, plane=plane, 'ring')))
   if(arg_present(_star_ptd)) then $
    if(ptr_valid(grim_get_overlay_ptdp(grim_data, plane=plane, 'star'))) then $
   		star_ptd = append_array(star_ptd, *(grim_get_overlay_ptdp(grim_data, plane=plane, 'star'))) 
   if(arg_present(_term_ptd)) then $
    if(ptr_valid(grim_get_overlay_ptdp(grim_data, plane=plane, 'terminator'))) then $
   		term_ptd = append_array(term_ptd, *(grim_get_overlay_ptdp(grim_data, plane=plane, 'terminator'))) 
   if(arg_present(_plgrid_ptd)) then $
    if(ptr_valid(grim_get_overlay_ptdp(grim_data, plane=plane, 'planet_grid'))) then $
   		plgrid_ptd = append_array(plgrid_ptd, *(grim_get_overlay_ptdp(grim_data, plane=plane, 'planet_grid'))) 
   if(arg_present(_center_ptd)) then $
    if(ptr_valid(grim_get_overlay_ptdp(grim_data, plane=plane, 'planet_center'))) then $
   		center_ptd = append_array(center_ptd, *(grim_get_overlay_ptdp(grim_data, plane=plane, 'planet_center'))) 
   if(arg_present(_shadow_ptd)) then $
    if(ptr_valid(grim_get_overlay_ptdp(grim_data, plane=plane, 'shadow'))) then $
   		shadow_ptd = append_array(shadow_ptd, *(grim_get_overlay_ptdp(grim_data, plane=plane, 'shadow'))) 
   if(arg_present(_reflection_ptd)) then $
    if(ptr_valid(grim_get_overlay_ptdp(grim_data, plane=plane, 'reflection'))) then $
   		reflection_ptd = append_array(reflection_ptd, *(grim_get_overlay_ptdp(grim_data, plane=plane, 'reflection'))) 
   if(arg_present(_object_ptd)) then $
      object_ptd = append_array(object_ptd, grim_cat_points(grim_data))
   if(arg_present(_station_ptd)) then $
    if(ptr_valid(grim_get_overlay_ptdp(grim_data, plane=plane, 'station'))) then $
   		station_ptd = append_array(station_ptd, *(grim_get_overlay_ptdp(grim_data, plane=plane, 'station'))) 
   if(arg_present(_array_ptd)) then $
    if(ptr_valid(grim_get_overlay_ptdp(grim_data, plane=plane, 'array'))) then $
   		array_ptd = append_array(array_ptd, *(grim_get_overlay_ptdp(grim_data, plane=plane, 'array'))) 

   if(arg_present(_tie_ptd)) then $
   		  tie_ptd = append_array(tie_ptd, *plane.tiepoint_ptdp)

   if(arg_present(_curve_ptd)) then $
   		curve_ptd = append_array(curve_ptd, *plane.curve_ptdp)
  end
 
 if(nplanes NE 1) then $
  begin
   if(keyword_set(pd)) then pd = transpose(pd)
   if(keyword_set(rd)) then rd = transpose(rd)
   if(keyword_set(sd)) then sd = transpose(sd)
   if(keyword_set(std)) then std = transpose(std)
   if(keyword_set(ard)) then ard = transpose(ard)
  end $
 else $
  begin
   if(keyword_set(pd)) then pd = reform(pd)
   if(keyword_set(rd)) then rd = reform(rd)
   if(keyword_set(sd)) then sd = reform(sd)
   if(keyword_set(std)) then std = reform(std)
   if(keyword_set(ard)) then ard = reform(ard)
  end

 if(keyword_set(dd)) then _dd = dd 
 if(keyword_set(cd)) then _cd = cd 
 if(keyword_set(pd)) then _pd = pd 
 if(keyword_set(rd)) then _rd = rd 
 if(keyword_set(sd)) then _sd = sd 
 if(keyword_set(std)) then _std = std 
 if(keyword_set(ard)) then _ard = ard 
 if(keyword_set(active_pd)) then _active_pd = active_pd 
 if(keyword_set(active_rd)) then _active_rd = active_rd 
 if(keyword_set(active_sd)) then _active_sd = active_sd 
 if(keyword_set(active_std)) then _active_std = active_std 
 if(keyword_set(active_ard)) then _active_ard = active_ard 
 if(keyword_set(sund)) then _sund = sund 
 if(keyword_set(od)) then _od = od
 if(keyword_set(active_limb_ptd)) then _active_limb_ptd = active_limb_ptd 
 if(keyword_set(active_ring_ptd)) then _active_ring_ptd = active_ring_ptd 
 if(keyword_set(active_star_ptd)) then _active_star_ptd = active_star_ptd 
 if(keyword_set(active_term_ptd)) then _active_term_ptd = active_term_ptd
 if(keyword_set(active_plgrid_ptd)) then _active_plgrid_ptd = active_plgrid_ptd 
 if(keyword_set(active_center_ptd)) then _active_center_ptd = active_center_ptd 
 if(keyword_set(active_station_ptd)) then _active_station_ptd = active_station_ptd 
 if(keyword_set(active_array_ptd)) then _active_array_ptd = active_array_ptd 
 if(keyword_set(limb_ptd)) then _limb_ptd = limb_ptd 
 if(keyword_set(ring_ptd)) then _ring_ptd = ring_ptd 
 if(keyword_set(star_ptd)) then _star_ptd = star_ptd 
 if(keyword_set(term_ptd)) then _term_ptd = term_ptd
 if(keyword_set(plgrid_ptd)) then _plgrid_ptd = plgrid_ptd 
 if(keyword_set(center_ptd)) then _center_ptd = center_ptd 
 if(keyword_set(station_ptd)) then _station_ptd = station_ptd 
 if(keyword_set(array_ptd)) then _array_ptd = array_ptd 
 if(keyword_set(object_ptd)) then _object_ptd = object_ptd

 w = where(pnt_valid(tie_ptd))
 if(w[0] NE -1) then _tie_ptd = tie_ptd[w]

 w = where(pnt_valid(curve_ptd))
 if(w[0] NE -1) then _curve_ptd = curve_ptd[w]

 if(keyword_set(shadow_ptd)) then _shadow_ptd = shadow_ptd
 if(keyword_set(reflection_ptd)) then _reflection_ptd = reflection_ptd

 gd = cor_create_gd(dd=dd, crd=crd, bd=bd, md=md, dkd=dkd, $
                    gbd=gbd, pd=pd, sd=sd, std=std, ard=ard, $
                    rd=rd, cd=cd, sund=sund, od=od)

 if(keyword_set(gd)) then _gd = gd

end
<span class="comments">;=============================================================================</span>
</code>
    </div>
  </body>
</html>