<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 20:38:09 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>grim_image_include.pro (OMINAS Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="grim_image_include.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">; grim_get_n_colors</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_get_n_colors:source"></a>function grim_get_n_colors, grim_data, plane=plane, type=type

 if(NOT keyword_set(grim_data)) then grim_data = grim_get_data(plane=plane)
 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)
 type = dat_typecode(plane.dd)

 return, grim_n_colors(type)
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_visible_planes</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_visible_planes:source"></a>function grim_visible_planes, grim_data, plane=plane, current=current
 
 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 if(keyword_set(current)) then return, plane
 planes = grim_get_plane(grim_data, /all)

 vis = planes.visibility
 vis[plane.pn] = 1
 w = where(vis EQ 1)


 return, planes[w]
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_get_plane_by_xy</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_get_plane_by_xy:source"></a>function grim_get_plane_by_xy, grim_data, xy

 planes = grim_visible_planes(grim_data)
 nplanes = n_elements(planes)

 dn = dblarr(nplanes)
 for i=0, nplanes-1 do dn[i] = dat_data(planes[i].dd, sample=xy, /nd)

 w = where(dn EQ max(dn))
 return, planes[w[0]]
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_get_plane_by_overlay</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_get_plane_by_overlay:source"></a>function grim_get_plane_by_overlay, grim_data, xy

 plane = grim_get_plane(grim_data)
 planes = grim_get_plane(grim_data, /all)
 nplanes = n_elements(planes)

 dist = make_array(nplanes, val=1d100)

 for i=0, nplanes-1 do $
  if((planes[i].pn EQ plane.pn) OR planes[i].visible) then $
  begin
   ptdp = grim_get_overlay_ptdp(grim_data, plane=planes[i], 'all')
   nptdp = n_elements(ptdp)
   for j=0, nptdp-1 do $
    begin
     ptd = *ptdp[j]
     if(keyword_set(ptd)) then $ 
      begin
       ii = grim_nearest_overlay(plane, xy, ptd, mm=mm)
       if(ii[0] NE -1) then if(mm LT dist[i]) then dist[i] = mm
      end
    end
  end

 w = where(dist LT 1d100)
 if(w[0] EQ -1) then return, 0

 w = min(where(dist EQ min(dist)))
 return, planes[w[0]]
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_test_single_channel</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_test_single_channel:source"></a>function grim_test_single_channel, grim_data
 if(NOT keyword_set(grim_data)) then grim_data = grim_get_data(/primary)

 planes = grim_visible_planes(grim_data)
 for i=0, n_elements(planes)-1 do $
            if(grim_test_rgb(grim_data, planes[i])) then return, 0

 rgb = planes.rgb
 return, total(rgb) EQ n_elements(planes)*3
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_toggle_image</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_toggle_image:source"></a>pro grim_toggle_image, grim_data, plane, no_refresh=no_refresh, bm=bm

 if(NOT plane.image_visible) then $
  begin
   plane.image_visible = 1
   bm = grim_hide_image_bitmap()
   use_pixmap = 1
   tvd_save = *plane.tvd_save_p
   if(keyword_set(tvd_save)) then $
    begin
     tvim, grim_data.wnum, get=tvd, /no_coord
if(tvd.zoom[0] NE tvd_save.zoom[0]) then use_pixmap = 0
if(tvd.zoom[1] NE tvd_save.zoom[1]) then use_pixmap = 0
if(tvd.offset[0] NE tvd_save.offset[0]) then use_pixmap = 0
if(tvd.offset[1] NE tvd_save.offset[1]) then use_pixmap = 0
if(tvd.order NE tvd_save.order) then use_pixmap = 0
if(tvd.rotate NE tvd_save.rotate) then use_pixmap = 0
<span class="comments">;     if(NOT nv_compare(tvd, tvd_save)) then use_pixmap = 0</span>
    end
  end $
 else $
  begin
   plane.image_visible = 0
   bm = grim_unhide_image_bitmap()
   tvim, grim_data.wnum, get=tvd, /no_coord
   *plane.tvd_save_p = tvd
  end

 widget_control, grim_data.toggle_image_button, set_value=bm

 grim_set_plane, grim_data, plane, pn=plane.pn
 grim_set_data, grim_data, grim_data.base

 if(NOT keyword_set(no_refresh)) then grim_refresh, grim_data, use_pixmap=use_pixmap

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_toggle_image_overlays</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_toggle_image_overlays:source"></a>pro grim_toggle_image_overlays, grim_data, plane, no_refresh=no_refresh

 grim_toggle_image, grim_data, plane, /no_refresh, bm=bmi
 grim_hide_overlays, grim_data, /no_refresh, bm=bmo

<span class="comments">; widget_control, grim_data.toggle_image_overlays_button, set_value=bmi AND bmo</span>


 if(NOT keyword_set(no_refresh)) then grim_refresh, grim_data, /use_pixmap
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_render_image</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_render_image:source"></a>pro grim_render_image, grim_data, plane=plane, image_pts=image_pts

 <span class="comments">;-----------------------------------------</span>
 <span class="comments">; load relevant descriptors</span>
 <span class="comments">;-----------------------------------------</span>
 grim_suspend_events
 cd = grim_get_cameras(grim_data, plane=plane)
 pd = grim_get_planets(grim_data, plane=plane)
 rd = grim_get_rings(grim_data, plane=plane)
 sund = grim_get_sun(grim_data, plane=plane)
 grim_resume_events


 <span class="comments">;-----------------------------------------</span>
 <span class="comments">; load maps</span>
 <span class="comments">;-----------------------------------------</span>
 if(NOT keyword_set(*grim_data.dd_map_p)) then dd_map = pg_load_maps(md=md, bx=pd)
 if(keyword_set(dd_map)) then $
  begin
   *grim_data.dd_map_p = dd_map
   *grim_data.md_map_p = md
  end


 <span class="comments">;-----------------------------------------</span>
 <span class="comments">; render</span>
 <span class="comments">;-----------------------------------------</span>
 bx = append_array(pd, rd)
 dd_map = *grim_data.dd_map_p
 md = *grim_data.md_map_p

 stat = pg_render(/psf, /nodd, show=plane.render_show, $
                    cd=cd, bx=bx, sund=sund, md=md, ddmap=dd_map, map=map, $
                    pht=plane.render_pht_min, $
                    sample=plane.render_sample, $
                    image_ptd=image_pts)

 
 image_pts = reform(image_pts, 2, n_elements(map), /over)
 dat_set_data, plane.dd, map
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_image</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_image:source"></a>function grim_image, grim_data, plane=plane, pn=pn, colormap=colormap, $
                     channel=channel, current=current, $
                     xrange=xrange, yrange=yrange

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)
 ctmod, top=top
 dim = (dat_dim(plane.dd))[0:1]

 <span class="comments">;---------------------------------------</span>
 <span class="comments">; get all visible planes</span>
 <span class="comments">;---------------------------------------</span>
 planes = grim_visible_planes(grim_data, current=current, plane=plane)
 rgb = planes.rgb

 max = plane.max[0]
 if(NOT keyword_set(max)) then max = max(dat_max(planes.dd))

 <span class="comments">;---------------------------------------</span>
 <span class="comments">; get appropriate channel if specified</span>
 <span class="comments">;---------------------------------------</span>
 if(defined(channel)) then $
  begin
   w = where(rgb[channel,*] EQ 1)
   if(w[0] EQ -1) then return, 0
   planes = planes[w]
  end
 nplanes = n_elements(planes)

 <span class="comments">;------------------------------------------------------------------------</span>
 <span class="comments">; Get output image grid </span>
 <span class="comments">;------------------------------------------------------------------------</span>
 vp = get_viewport_indices(dim, xrange=xrange, yrange=yrange, $
              device_indices=vpi, device_size=device_size, p=data_xy, $
                                                      noclip=plane.rendering)
 if(n_elements(vp) EQ 1) then return, 0
 *grim_data.data_xy_p = data_xy


 <span class="comments">;----------------------------------------------------------------------</span>
 <span class="comments">; construct output image by considering only unique data coords and</span>
 <span class="comments">; averaging all visible planes</span>
 <span class="comments">;----------------------------------------------------------------------</span>
 im = (weight = 0)
 for i=0, nplanes-1 do $
  begin
   <span class="comments">; - - - - - - - - - - - - - - -</span>
   <span class="comments">; get sub image</span>
   <span class="comments">; - - - - - - - - - - - - - - -</span>
   _im = grim_get_image(grim_data, plane=planes[i], $
                          channel=channel, sample=data_xy, abscissa=grid)

   <span class="comments">; - - - - - - - - - - - - - - -</span>
   <span class="comments">; apply color map</span>
   <span class="comments">; - - - - - - - - - - - - - - -</span>
   colormap = compute_colormap(planes[i].cmd)
   _im = apply_colormap(_im, colormap, channel=channel, max=max, min=0)

   <span class="comments">; - - - - - - - - - - - - - - -</span>
   <span class="comments">; add current image</span>
   <span class="comments">; - - - - - - - - - - - - - - -</span>
   im = im + _im
   weight = weight + fix(_im&lt;1)

   grim_set_plane, grim_data, plane
  end


 <span class="comments">;----------------------------------------------------------------------</span>
 <span class="comments">; weight average</span>
 <span class="comments">;----------------------------------------------------------------------</span>
 w = where(weight EQ 0)
 if(w[0] NE -1) then weight[w] = 1

 im = im / weight


 <span class="comments">;----------------------------------------------------------------------</span>
 <span class="comments">; create final device image</span>
 <span class="comments">;----------------------------------------------------------------------</span>
 image = make_array(type=size(im, /type), dim=device_size)
 image[vpi] = im

<span class="comments">; image = bytscl(image, max=plane.cmd.n_colors)</span>
<span class="comments">;image = bytscl(image, top=plane.cmd.n_colors)</span>
<span class="comments">;;image = bytscl(image, max=max, top=plane.cmd.n_colors)</span>
<span class="comments">;;;;;;;;print, min(image), max(image)</span>

 return, image
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_scale_image</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_scale_image:source"></a>function grim_scale_image, grim_data, r, g, b, current=current, $
     plane=plane, no_scale=no_scale, top=top, xrange=xrange, yrange=yrange

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; test for single-channel</span>
 <span class="comments">;------------------------------------------------------</span>
 if(grim_test_single_channel(grim_data)) then $
   image = grim_image(grim_data, plane=plane, current=current, xrange=xrange, yrange=yrange) $

 <span class="comments">;------------------------------------------------------------------</span>
 <span class="comments">; otherwise display according to current channel settings </span>
 <span class="comments">;------------------------------------------------------------------</span>
 else $
  begin
   ctmod, visual=visual

   red = grim_image(grim_data, channel=0, current=current, xrange=xrange, yrange=yrange)
   grn = grim_image(grim_data, channel=1, current=current, xrange=xrange, yrange=yrange)
   blu = grim_image(grim_data, channel=2, current=current, xrange=xrange, yrange=yrange)     

   <span class="comments">;---------------------------------------</span>
   <span class="comments">; pseudo-color (8-bit) display</span>
   <span class="comments">;---------------------------------------</span>
   if(visual EQ 8) then $
    begin
     image = color_quan(red, grn, blu, r, g, b)
     tvlct, r, g, b
     no_scale = 1
    end $
   <span class="comments">;---------------------------------------</span>
   <span class="comments">; otherwise assume decomposed colors</span>
   <span class="comments">;---------------------------------------</span>
   else $
    begin
     sr = size(red, /dim)
     if(NOT keyword_set(red)) then sr = [0l,0l]
     sg = size(grn, /dim)
     if(NOT keyword_set(grn)) then sg = [0l,0l]
     sb = size(blu, /dim)
     if(NOT keyword_set(blu)) then sb = [0l,0l]
     
     xs = max([sr[0], sg[0], sb[0]])
     ys = max([sr[1], sg[1], sb[1]])

     if(xs EQ 0) then return, 0

     image = dblarr(xs, ys, 3)
     if(keyword_set(red)) then image[0:sr[0]-1,0:sr[1]-1,0] = red
     if(keyword_set(grn)) then image[0:sg[0]-1,0:sg[1]-1,1] = grn
     if(keyword_set(blu)) then image[0:sb[0]-1,0:sb[1]-1,2] = blu
    end

  end


 ctmod, top=top
 tvlct, r, g, b, /get

 return, image
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_display_image</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_display_image:source"></a>pro grim_display_image, grim_data, plane=plane, $
       entire=entire, wnum=wnum, doffset=doffset, zoom=zoom, rotate=rotate, order=order, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, offset=offset, top=top, noplot=no_plot, $
       no_scale=no_scale, no_wset=no_wset, no_coord=no_coord, tvimage=tvimage, $
       home=home, draw_pixmap=draw_pixmap, current=current, no_copy=no_copy


 dim = dat_dim(plane.dd)

 <span class="comments">;-------------------------------</span>
 <span class="comments">; set tvim coordinate system</span>
 <span class="comments">;-------------------------------</span>
 if(keyword_set(entire)) then $
  begin 
   wset, wnum
   entire_xsize = double(!d.x_size)
   entire_ysize = double(!d.y_size)
   wset, grim_data.wnum

   zoom = min([entire_xsize/dim[0], entire_ysize/dim[1]]) * 0.95

   offset = 0.5 * [dim[0]-entire_xsize/zoom, $
                     dim[1]-entire_ysize/zoom]
  end

 tvim, wnum, /silent, doffset=doffset, zoom=zoom, rotate=rotate, order=order, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, offset=offset, top=top, noplot=no_plot, $
       no_scale=no_scale, no_wset=no_wset, no_coord=no_coord, tvimage=tvimage, $
       home=home, draw_pixmap=draw_pixmap, no_copy=no_copy<span class="comments">;, erase=erase</span>

 if(NOT plane.image_visible) then return


 <span class="comments">;---------------------------------------------------------------------------</span>
 <span class="comments">; if first time, compute a scaled image to get the data loaded so that</span>
 <span class="comments">; the data ranges will be known.</span>
 <span class="comments">;---------------------------------------------------------------------------</span>
 if(NOT plane.prescaled) then $
  begin
   tvimage = grim_scale_image(grim_data, r, g, b, current=current, $
                                      plane=plane, no_scale=no_scale, top=top)
   plane.prescaled = 1
  end

 <span class="comments">;---------------------------------</span>
 <span class="comments">; scale image for real</span>
 <span class="comments">;---------------------------------</span>
 tvimage = grim_scale_image(grim_data, r, g, b, current=current, $
                                      plane=plane, no_scale=no_scale, top=top)
 if(NOT keyword_set(tvimage)) then $
  begin
   erase
   return
  end

 *grim_data.tv_rp = r
 *grim_data.tv_gp = g
 *grim_data.tv_bp = b
 grim_set_data, grim_data, grim_data.base

 s = size(tvimage)
 image_xsize = s[1]
 image_ysize = s[2]


 if(((where(r-g NE 0))[0] NE -1) OR ((where(g-b NE 0))[0] NE -1)) then $
  begin
   _tvimage = dblarr(image_xsize, image_ysize, 3)
   _tvimage[*,*,0] = apply_colormap(tvimage, r)
   _tvimage[*,*,1] = apply_colormap(tvimage, g)
   _tvimage[*,*,2] = apply_colormap(tvimage, b)
   tvimage = _tvimage
   _tvimage = 0   
  end


 <span class="comments">;---------------------</span>
 <span class="comments">; display image</span>
 <span class="comments">;---------------------</span>
 if(wnum EQ grim_data.wnum) then draw_pixmap = grim_data.redraw_pixmap

 tvim, tvimage, /tvimage, /silent, wnum, noplot=no_plot, $
     draw_pixmap=draw_pixmap, no_copy=no_copy, $
     no_scale=no_scale

 min = (max = 0)

 if(keyword_set(tvimage)) then $
  begin
   if(NOT defined(min)) then min = min(tvimage)
   if(NOT defined(max)) then max = max(tvimage)
  end

 *grim_data.min_p = min
 *grim_data.max_p = max


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_display_plot</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_display_plot:source"></a>pro grim_display_plot, grim_data, plane=plane, doffset=doffset, $
       wnum=wnum, xrange=xrange, yrange=yrange, no_wset=no_wset, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, position=position, dx=dx, dy=dy, $
       entire=entire, erase=erase, no_coord=no_coord, $
       color=color, nodraw=nodraw, current=current

 planes = grim_visible_planes(grim_data, current=current, plane=plane)
 nplanes = n_elements(planes)

 for i=0, nplanes-1 do $
  begin
   <span class="comments">;---------------------------------------</span>
   <span class="comments">; set view unless forced</span>
   <span class="comments">;---------------------------------------</span>
   if((NOT keyword_set(default)) $
       AND (NOT keyword_set(previous)) $
       AND (NOT keyword_set(flip)) $
       AND (NOT keyword_set(restore)) ) then $
    begin
     tvgr, grim_data.wnum, get=tvd

     if(NOT keyword_set(xrange)) then $
       if((plane.xrange[0] NE 0) OR (plane.xrange[1] NE 0)) then xrange = plane.xrange $
     else xrange = [dat_min(plane.dd, /ab), dat_max(plane.dd, /ab)]

     if(NOT keyword_set(yrange)) then $
       if((plane.yrange[0] NE 0) OR (plane.yrange[1] NE 0)) then yrange = plane.yrange $
     else yrange = [dat_min(plane.dd), dat_max(plane.dd)]

     if(NOT keyword_set(position)) then $
       if((planes[i].position[0] NE 0) OR (planes[i].position[1] NE 0)) then position = planes[i].position $
     else if((tvd.position[0] NE 0) OR (tvd.position[1] NE 0)) then position = tvd.position
    end

   parm = planes[i].parm


   <span class="comments">;-----------------------------------------------------------------------</span>
   <span class="comments">; if /entire, set ranges so that entire image is displayed</span>
   <span class="comments">;-----------------------------------------------------------------------</span>
   if(keyword_set(entire)) then $
    begin 
     xrange = [dat_min(plane.dd, /ab), dat_max(plane.dd, /ab)]
     yrange = [dat_min(plane.dd), dat_max(plane.dd)]
    end


   <span class="comments">;---------------------</span>
   <span class="comments">; set color</span>
   <span class="comments">;---------------------</span>
   if(NOT keyword_set(no_color)) then $
    begin
     color = parm.color
<span class="comments">;stop</span>
<span class="comments">;     if(keyword_set(plane.override_color) $</span>
<span class="comments">;               AND (strupcase(plane.override_color) NE 'NONE')) then $</span>
<span class="comments">;                                                   color = plane.override_color</span>

    end

   if(keyword_set(doffset)) then $
    begin
     dx = doffset[0]
     dy = doffset[1]
    end


   <span class="comments">;---------------------------------------</span>
   <span class="comments">; set view</span>
   <span class="comments">;---------------------------------------</span>
<span class="comments">; need to sample here instead of getting entire array...</span>
   if(i GT 0) then erase = 0
   tvgr, wnum, 0, 0, xrange=xrange, yrange=yrange, no_wset=no_wset, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, position=position, dx=dx, dy=dy, $
       entire=entire, erase=erase, no_coord=no_coord, $
       xtitle=plane.xtitle, ytitle=plane.ytitle, $
       title=plane.title, thick=parm.thick, nsum=parm.nsum


   <span class="comments">;---------------------------------------</span>
   <span class="comments">; get data array</span>
   <span class="comments">;---------------------------------------</span>

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - </span>
   <span class="comments">; sampling</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - </span>
   xdev = lindgen(1,!d.x_size)
   nx = n_elements(xdev)
   axis = [xdev, make_array(1,nx, val=0)]
   xdat = transpose((convert_coord(/device, /to_data, axis))[0,*])

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; Alough this can greatly peed up the plotting, it is not ideal </span>
   <span class="comments">; because it causes the full array to be read rather than just the </span>
   <span class="comments">; samples needed to display it in the current view</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   yarr = dat_data(planes[i].dd, abscissa=xarr)
   ydat = interpol(yarr, xarr, xdat)

   <span class="comments">;---------------------</span>
   <span class="comments">; display plot(s)</span>
   <span class="comments">;---------------------</span>
   tvgr, wnum, xdat, ydat
  end

 <span class="comments">;----------------------------</span>
 <span class="comments">; save view</span>
 <span class="comments">;----------------------------</span>
 tvgr, grim_data.wnum, get=tvd
 plane.xrange = tvd.xrange
 plane.yrange = tvd.yrange

 <span class="comments">;-----------------------------------</span>
 <span class="comments">; bind xranges of all planes</span>
 <span class="comments">;-----------------------------------</span>
 all_planes = grim_get_plane(grim_data, /all, pn=pn)
 nall = n_elements(all_planes)
 for i=0, nall-1 do if(pn[i] NE plane.pn) then $ 
  begin
   all_planes[i].xrange = plane.xrange
   grim_set_plane, grim_data, all_planes[i], pn=pn[i]
  end


 plane.position = tvd.position
 grim_set_plane, grim_data, plane, pn=plane.pn

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_display</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_display:source"></a>pro grim_display, grim_data, plane=plane, wnum=wnum, home=home, $
       no_image=no_image, no_axes=no_axes, doffset=doffset, no_erase=no_erase, $
       zoom=zoom, rotate=rotate, order=order, xsize=xsize, ysize=ysize, offset=offset, $
       default=default, previous=previous, flip=flip, restore=restore,$
       use_pixmap=use_pixmap, pixmap_box_center=pixmap_box_center, no_copy=no_copy, $
       pixmap_box_side=pixmap_box_side, no_back=no_back, entire=entire, $
       no_wset=no_wset, no_coord=no_coord, tvimage=tvimage, no_plot=no_plot, $
       nodraw=nodraw, xrange=xrange, yrange=yrange, dx=dx, dy=dy, current=current, $
       pixmap_to_use=pixmap_to_use

 erase = 1
 if(keyword_set(no_erase)) then erase = 0
 no_scale = 1


 if(NOT keyword_set(pixmap_to_use)) then pixmap_to_use = grim_data.pixmap

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)
 if(NOT keyword_set(wnum)) then wnum = grim_data.wnum


 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; if image display is off then just erase</span>
 <span class="comments">;------------------------------------------------------</span>
<span class="comments">;;;; also need to do view settings; /entire, etc..</span>
<span class="comments">; if(NOT plane.image_visible) then $</span>
<span class="comments">;  begin</span>
<span class="comments">;   erase </span>
<span class="comments">;   return</span>
<span class="comments">;  end</span>
 if(NOT plane.image_visible) then erase


 <span class="comments">;------------------------------------------------------------</span>
 <span class="comments">; if /use_pixmap then just copy from stored image</span>
 <span class="comments">;------------------------------------------------------------</span>
 if(keyword_set(use_pixmap)) then $
  begin
   if(plane.image_visible) then $
    begin
     x0 = 0 & y0 = 0
     xsize = !d.x_size-1 
     ysize = !d.y_size-1

     if(keyword_set(pixmap_box_center)) then $
      begin 
       x0 = (pixmap_box_center[0] - pixmap_box_side/2) > 0
       y0 = (pixmap_box_center[1] - pixmap_box_side/2) > 0
       xsize = pixmap_box_side &lt; $
  		      abs(xsize - pixmap_box_center[0] + pixmap_box_side/2)
       ysize = pixmap_box_side &lt; $
  		      abs(ysize - pixmap_box_center[1] + pixmap_box_side/2)
      end

     wset, wnum
     if((x0 GE 0) AND (x0 LT !d.x_size) AND $
        (y0 GE 0) AND (y0 LT !d.y_size) AND $
        (xsize GT 0) AND (ysize GT 0)) then $
 	     device, copy=[x0,y0, xsize,ysize, x0,y0, pixmap_to_use]  
    end 
  end $

 <span class="comments">;------------------------------------------------------</span>
 <span class="comments">; otherwise generate a new image</span>
 <span class="comments">;------------------------------------------------------</span>
 else $
  begin
   if(grim_data.type NE 'plot') then $
     grim_display_image, grim_data, plane=plane, no_copy=no_copy, $
       entire=entire, wnum=wnum, doffset=doffset, zoom=zoom, rotate=rotate, order=order, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, offset=offset, top=top, noplot=no_plot, $
       no_scale=no_scale, no_wset=no_wset, no_coord=no_coord, tvimage=tvimage, $
       home=home, draw_pixmap=draw_pixmap, current=current $

   else grim_display_plot, grim_data, plane=plane, doffset=doffset, $
       wnum=wnum, xrange=xrange, yrange=yrange, no_wset=no_wset, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, position=position, dx=dx, dy=dy, current=current, $
       entire=entire, erase=erase, no_coord=no_coord, color=color, nodraw=nodraw
  end


 <span class="comments">;-------------------------------------</span>
 <span class="comments">; copy to backing pixmap</span>
 <span class="comments">;-------------------------------------</span>
 if(plane.image_visible) then $
  if(NOT keyword_set(no_back)) then $
   begin
    wnum = !d.window
    wset, pixmap_to_use
    device, copy=[0,0, !d.x_size-1,!d.y_size-1, 0,0, wnum]
    wset, wnum
   end


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_show_context_image</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_show_context_image:source"></a>pro grim_show_context_image, grim_data

 wset, grim_data.context_wnum
 device, copy=[0,0, !d.x_size-1,!d.y_size-1, 0,0, grim_data.context_pixmap]
 wset, grim_data.wnum

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_show_axes</span>
<span class="comments">;</span>
<span class="comments">;  inertial axes:	blue</span>
<span class="comments">;  sun direction:	yellow</span>
<span class="comments">;  camera axes:		red</span>
<span class="comments">;  dir. to primary:	green</span>
<span class="comments">;</span>
<span class="comments">;  Axis source is just in front of the camera.</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_show_axes:source"></a>pro grim_show_axes, grim_data, plane
@grim_constants.common

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)
 widget_control, grim_data.axes_base, xoff=0, yoff=!d.y_size-AXES_SIZE

 <span class="comments">;---------------------------------</span>
 <span class="comments">; clear axes window</span>
 <span class="comments">;---------------------------------</span>
 wnum = !d.window
 wset, grim_data.axes_wnum
 erase
 wset, wnum

 <span class="comments">;---------------------------------</span>
 <span class="comments">; draw axis vectors</span>
 <span class="comments">;---------------------------------</span>
 if(NOT grim_test_map(grim_data)) then $
  if(grim_data.axes_flag) then $
   if(keyword_set(*plane.cd_p)) then $ 
    begin
     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     <span class="comments">; compute source location</span>
     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     device_pt = [AXES_SIZE/2, AXES_SIZE/2]
     image_pt = (convert_coord(device_pt[0], device_pt[1], /device, /to_data))[0:1]

     cd = *plane.cd_p
     dir = image_to_inertial(cd, image_pt)
     source = bod_pos(cd) + dir*100000d 

     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     <span class="comments">; compute length in data units</span>
     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     device_len = AXES_SIZE/3
     device_corners = [tr([0,0]), tr([!d.x_size-1,0])]
     image_corners = (convert_coord(device_corners[0,*], device_corners[1,*], $
                                                    /device, /to_data))[0:1,*]
     len = device_len * p_mag(image_corners[*,0]-image_corners[*,1])/!d.x_size

     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     <span class="comments">; draw inertial axes</span>
     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     pg_draw_vector, cd=cd, source, (bod_orient(bod_inertial())), $
         plab=['x','y','z'], col='blue', len=len, draw_wnum=grim_data.axes_wnum, $
         label_shade=0.75

     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     <span class="comments">; draw camera axes</span>
     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     pg_draw_vector, cd=cd, source, (bod_orient(cd)), $
         plab=['cx','cy','cz'], col='red', len=len, draw_wnum=grim_data.axes_wnum, $
         label_shade=0.75

     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     <span class="comments">; draw sun vector</span>
     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     if(keyword_set(*plane.sund_p)) then $
       pg_draw_vector, cd=cd, source, /noshort, /fix, $
         v_unit(bod_pos(*plane.sund_p) - bod_pos(cd)), $
         plab=['SUN'], col='yellow', len=len, draw_wnum=grim_data.axes_wnum, $
         label_shade=0.75

     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     <span class="comments">; draw primary planet vector</span>
     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     if(keyword_set(*plane.pd_p)) then $
      begin
       pd = get_primary(cd, *plane.pd_p)
       pg_draw_vector, cd=cd, source, /noshort, /fix, $
         v_unit(bod_pos(pd) - bod_pos(cd)), $
         plab=cor_name(pd), col='green', len=len, draw_wnum=grim_data.axes_wnum, $
         label_shade=0.75
      end
    end

 <span class="comments">;----------------------------</span>
 <span class="comments">; axes window outline</span>
 <span class="comments">;----------------------------</span>
 wset, grim_data.axes_wnum
 plots, /device, col=ctblue(), $
     [0,!d.x_size-1,!d.x_size-1,0,0], [0,0,!d.y_size-1,!d.y_size-1,0], th=4
 grim_wset, grim_data, grim_data.wnum

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_add_refresh_callback</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_add_refresh_callback:source"></a>pro grim_add_refresh_callback, callbacks, data_ps, top=top, no_wset=no_wset

 grim_data = grim_get_data(top, no_wset=no_wset)

 rf_callbacks = *grim_data.rf_callbacks_p
 rf_data_ps = *grim_data.rf_callbacks_data_pp

 grim_add_callback, callbacks, data_ps, rf_callbacks, rf_data_ps

 *grim_data.rf_callbacks_p = rf_callbacks
 *grim_data.rf_callbacks_data_pp = rf_data_ps

 grim_set_data, grim_data, grim_data.base
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_rm_refresh_callback</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_rm_refresh_callback:source"></a>pro grim_rm_refresh_callback, data_ps, top=top

 grim_data = grim_get_data(top)
 if(NOT grim_exists(grim_data)) then return

 rf_callbacks = *grim_data.rf_callbacks_p
 rf_data_ps = *grim_data.rf_callbacks_data_pp

 grim_rm_callback, data_ps, rf_callbacks, rf_data_ps

 *grim_data.rf_callbacks_p = rf_callbacks
 *grim_data.rf_callbacks_data_pp = rf_data_ps

 grim_set_data, grim_data, grim_data.base
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_call_refresh_callbacks</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_call_refresh_callbacks:source"></a>pro grim_call_refresh_callbacks, grim_data

 grim_call_callbacks, *grim_data.rf_callbacks_p, *grim_data.rf_callbacks_data_pp

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_title</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_title:source"></a>function grim_title, plane, primary=primary

 if(NOT keyword_set(plane)) then $
  begin
   grim_data = grim_get_data(primary=primary)
   plane = grim_get_plane(grim_data)
  end

 return, cor_name(plane.dd)
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_channel_string</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_channel_string:source"></a>function grim_channel_string, plane

 c = ['R', 'G', 'B']
 w = where(plane.rgb)
 c = c[w]

 return, str_comma_list(c, delim='+')
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_refresh</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_refresh:source"></a>pro grim_refresh, grim_data, wnum=wnum, plane=plane, $
 no_image=no_image, no_objects=no_objects, no_axes=no_axes, $
 no_title=no_title, home=home, xrange=xrange, yrange=yrange, $
 doffset=doffset, no_erase=no_erase, zoom=zoom, rotate=rotate, order=order, $
 default=default, previous=previous, flip=flip, restore=restore, $
 xsize=xsize, ysize=ysize, offset=offset, use_pixmap=use_pixmap, $
 pixmap_box_center=pixmap_box_center, pixmap_box_side=pixmap_box_side, $
 context=context, entire=entire, noglass=noglass, no_wset=no_wset, $
 no_context=no_context, no_callback=no_callback, no_back=no_back, $
 no_coord=no_coord, tvimage=tvimage, no_plot=no_plot, just_image=just_image, $
 dx=dx, dy=dy, update=update, current=current, no_copy=no_copy, no_main=no_main, $
 no_user=no_user
@grim_block.include



 if(NOT keyword_set(grim_data)) then grim_data = grim_get_data(plane=plane) 
 if(NOT keyword_set(noglass)) then widget_control, grim_data.draw, /hourglass
 if(NOT keyword_set(no_wset)) then grim_wset, grim_data, grim_data.wnum


 grim_data.guideline_save_xy = [-1,-1]

 if(NOT keyword_set(plane)) then $
  begin
   plane = grim_get_plane(grim_data)
   planes = grim_get_visible_planes(grim_data)
  end $
 else planes = plane

 <span class="comments">;-----------------------------------</span>
 <span class="comments">; apply any default activations</span>
 <span class="comments">;-----------------------------------</span>
<span class="comments">; grim_default_activations, grim_data, plane=plane</span>


 <span class="comments">;-----------------------------------</span>
 <span class="comments">; redraw main image</span>
 <span class="comments">;-----------------------------------</span>
 if(NOT keyword_set(no_image)) then $
  if(NOT keyword_set(no_main)) then $
   begin
    grim_display, grim_data, wnum=wnum, plane=plane, xrange=xrange, yrange=yrange, $
         no_axes=no_axes, doffset=doffset, no_wset=no_wset, no_back=no_back, $
         no_erase=no_erase, zoom=zoom, rotate=rotate, order=order, entire=entire, $
         default=default, previous=previous, flip=flip, restore=restore, $
         xsize=xsize, ysize=ysize, offset=offset, use_pixmap=use_pixmap, $
         pixmap_box_center=pixmap_box_center, pixmap_box_side=pixmap_box_side, $
         no_coord=no_coord, tvimage=tvimage, no_plot=no_plot, home=home, $
         dx=dx, dy=dy, current=current, no_copy=no_copy
   end


 <span class="comments">;-----------------------------------</span>
 <span class="comments">; redraw context image</span>
 <span class="comments">;-----------------------------------</span>
 if(NOT keyword_set(no_context)) then $
  if(NOT keyword_set(no_image)) then $
   if(grim_data.context_mapped) then $
    begin
     tvim, grim_data.wnum, get=tvd, /no_coord

     grim_display, grim_data, wnum=grim_data.context_pixmap, plane=plane, $
<span class="comments">;           use_pixmap=use_pixmap, pixmap_to_use=grim_data.context_pixmap, $</span>
           /entire, order=tvd.order, nodraw=nodraw, /no_back

     grim_display, grim_data, wnum=grim_data.context_wnum, plane=plane, $
           /entire, order=tvd.order, /no_back, /no_image, /no_erase, nodraw=nodraw
     grim_wset, grim_data, grim_data.wnum
    end


 <span class="comments">;------------------------------------</span>
 <span class="comments">; redisplay grids</span>
 <span class="comments">;------------------------------------</span>
 if(NOT keyword_set(no_axes)) then $
           grim_draw_grids, grim_data, plane=plane, no_wset=no_wset


 <span class="comments">;-----------------------------------</span>
 <span class="comments">; redraw overlays</span>
 <span class="comments">;-----------------------------------</span>
 if(NOT keyword_set(no_objects)) then $
          grim_draw, grim_data, plane=planes, /all, update=update, no_user=no_user


 <span class="comments">;------------------------------------</span>
 <span class="comments">; redisplay axes</span>
 <span class="comments">;------------------------------------</span>
 if(NOT keyword_set(no_axes)) then $
           grim_draw_axes, grim_data, data, plane=plane, $
                                   no_context=no_context, no_wset=no_wset


 <span class="comments">;------------------------------------------</span>
 <span class="comments">; copy context image to screen if mapped</span>
 <span class="comments">;------------------------------------------</span>
 if(NOT keyword_set(no_context)) then $
        if(grim_data.context_mapped) then grim_show_context_image, grim_data


 <span class="comments">;-----------------------------------</span>
 <span class="comments">; set base title</span>
 <span class="comments">;-----------------------------------</span>
 if(NOT keyword_set(no_title)) then $
  begin
   beta = ''
   if(grim_data.beta) then beta = '(beta)'
   title = 'grim' + beta + ' ' + strtrim(grim_data.grnum,2) + $
           ';  plane ' + strtrim(grim_data.pn,2) + ' of ' + $
           strtrim(grim_data.n_planes,2) + ';  ' + $
           grim_title(plane)
    if(keyword_set(grim_data.def_title)) then title = title + ' -- ' + grim_data.def_title
    
    title = title + ' &lt;' + grim_channel_string(plane) + '>'

   widget_control, grim_data.base,  tlb_set_title = title
  end


 <span class="comments">;-----------------------------------</span>
 <span class="comments">; clear out plane text box</span>
 <span class="comments">;-----------------------------------</span>
 widget_control, grim_data.jumpto_text, set_value=''


 <span class="comments">;-----------------------------------</span>
 <span class="comments">; update menu item sensitivity</span>
 <span class="comments">;-----------------------------------</span>
 menu_ids = *grim_data.menu_ids_p
 menu_desc = *grim_data.menu_desc_p
 if(grim_test_map(grim_data, plane=plane)) then $
  begin
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; allowed menu items</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   md_items = *grim_data.map_items_p
   if(keyword_set(*plane.od_p)) then $
       md_items = append_array(md_items, *grim_data.od_map_items_p)
   mark = bytarr(n_elements(menu_ids))

   n = n_elements(md_items)
   for i=0, n-1 do $
    begin
     w = where(strpos(menu_desc, md_items[i]) NE -1)
     if(w[0] NE -1) then $
      begin
       widget_control, menu_ids[w[0]], sensitive=1
       mark[w[0]] = 1
      end
    end

   w = where(mark EQ 0)
   if(w[0] NE -1) then for i=0, n_elements(w)-1 do $
               widget_control, menu_ids[w[i]], sensitive=0
  end $
 else $
  begin
   n = n_elements(menu_ids)
   for i=0, n-1 do widget_control, menu_ids[i], sensitive=1
  end

 <span class="comments">;-----------------------------------</span>
 <span class="comments">; update undo/redo sensitivity</span>
 <span class="comments">;-----------------------------------</span>
 nhist = dat_nhist(plane.dd)
 sens = nhist GT 1
 widget_control, grim_data.undo_button, sensitive=sens
 widget_control, grim_data.undo_menu_id, sensitive=sens
 widget_control, grim_data.redo_button, sensitive=sens
 widget_control, grim_data.redo_menu_id, sensitive=sens


 <span class="comments">;-----------------------------------</span>
 <span class="comments">; update render button</span>
 <span class="comments">;-----------------------------------</span>
 if(grim_data.type NE 'plot') then $
  if(NOT grim_test_map(grim_data)) then $
   begin
    bm = grim_render_bitmap()
    if(plane.rendering) then bm = grim_unrender_bitmap()
    widget_control, grim_data.render_button, set_value=bm
   end

 <span class="comments">;-----------------------------------</span>
 <span class="comments">; update active and primary arrays</span>
 <span class="comments">;-----------------------------------</span>
 grim_update_activated, grim_data, plane=plane


 <span class="comments">;-----------------------------------</span>
 <span class="comments">; cull descriptors</span>
 <span class="comments">;-----------------------------------</span>
<span class="comments">; grim_cull_descriptors, grim_data</span>


 <span class="comments">;-----------------------------------</span>
 <span class="comments">; update header window</span>
 <span class="comments">;-----------------------------------</span>
 if(widget_info(grim_data.header_text, /valid)) then $
  begin
   widget_control, grim_data.header_text, set_value=dat_header(plane.dd)
   widget_control, grim_data.header_base, tlb_set_title=grim_title(plane)
  end


 <span class="comments">;-----------------------------------</span>
 <span class="comments">; update notes window</span>
 <span class="comments">;-----------------------------------</span>
 if(widget_info(grim_data.notes_text, /valid)) then $
  begin
   widget_control, grim_data.notes_text, set_value=*plane.notes_p
   widget_control, grim_data.notes_base, tlb_set_title=grim_title(plane)
  end

 
 <span class="comments">;-----------------------------------</span>
 <span class="comments">; update _all_tops list</span>
 <span class="comments">;-----------------------------------</span>
 w = -1
 if(keyword_set(_all_tops)) then w = where(_all_tops EQ grim_data.base)
 if(w[0] EQ -1) then _all_tops = append_array(_all_tops, grim_data.base)


 <span class="comments">;-----------------------------------</span>
 <span class="comments">; contact refresh callbacks</span>
 <span class="comments">;-----------------------------------</span>
 if(NOT keyword_set(no_callback)) then $
  begin
   grim_call_refresh_callbacks, grim_data
   grim_call_primary_callbacks
  end

 grim_wset, grim_data, grim_data.wnum

<span class="comments">; nv_flush</span>
end
<span class="comments">;=============================================================================</span>

<a id="grim_image_include:source"></a>pro grim_image_include
a=!null
end

</code>
    </div>
  </body>
</html>