<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 20:35:57 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>_cas_spice_ck_detect.pro (OMINAS Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="_cas_spice_ck_detect.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">; get_all_ck_files</span>
<span class="comments">;=============================================================================</span>
<a id="get_all_ck_files:source"></a>function get_all_ck_files, ckpath

 all_files = file_search(ckpath + '/*??.bc')

<span class="comments">; yydoy_files = file_search(ckpath + '/?????_?????*.bc')</span>
<span class="comments">; yymmdd_files = file_search(ckpath + '/??????_??????*.bc')</span>
<span class="comments">; all_files = append_array(yydoy_files, yymmdd_files)</span>

 if(NOT keyword_set(all_files)) then $
  begin
   year = 98
   done = 0

   while(NOT done) do $
    begin
     year_files = file_search(ckpath + '/' + str_pad(strtrim(year,2),2,c='0',align=1) + '*??.bc')
     if(NOT keyword_set(year_files)) then done = 1 $
     else all_files = append_array(all_files, year_files)
     year = (year + 1) mod 100
    end

  end

 return, all_files
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; cas_spice_ck_components</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="cas_spice_ck_components:source"></a>pro cas_spice_ck_components, all_names, format, ii=ii, $
   jd_start=jd_start, jd_stop=jd_stop, type=_type, version=_version, desc=desc

 jd_start = (jd_stop = (_type = (_version = (_desc = ''))))

 n = n_elements(all_names)
 ii = lindgen(n)

 <span class="comments">;-------------------------------------</span>
 <span class="comments">; extract start time</span>
 <span class="comments">;-------------------------------------</span>
 start = str_nnsplit(all_names, '_', rem=rem)
 l = strlen(start)

 lf = strlen(format)
 ww = where(l EQ lf)
 if(ww[0] EQ -1) then return
 start = start[ww]
 ii = ii[ww]

 <span class="comments">;-------------------------------------</span>
 <span class="comments">; extract stop time, type, version</span>
 <span class="comments">;-------------------------------------</span>
 rem = rem[ww]
 stop = strmid(rem, 0, lf)
 type = strmid(rem, lf, 1)
 version = strmid(rem, lf+1, 1)

 desc = type & desc[*] = ''
 w = where(strpos(rem, '_') NE -1)
 if(w[0] NE -1) then $
  begin
   junk = str_nnsplit(rem[w], '_', rem=rem)
   desc[w] = rem 
  end

 <span class="comments">;----------------------------------------------------------------------</span>
 <span class="comments">; sometimes they forget to put the type and version, so we'll use</span>
 <span class="comments">; 'p0' so that it's superceded by any other file with the same </span>
 <span class="comments">; coverage.</span>
 <span class="comments">;----------------------------------------------------------------------</span>
 w = where(type EQ '')
 if(w[0] NE -1) then $
  begin
   type[w] = 'p'
   version[w] = '0'
  end

 <span class="comments">;----------------------------------------------------------------------</span>
 <span class="comments">; weed out the bad names</span>
 <span class="comments">;----------------------------------------------------------------------</span>
 w = str_isnum(start)
 if(w[0] EQ -1) then return
 ii = ii[w]
 start=start[w] & stop=stop[w] & type=type[w] & version=version[w] & desc=desc[w]

 w = str_isnum(stop)
 if(w[0] EQ -1) then return
 ii = ii[w]
 start=start[w] & stop=stop[w] & type=type[w] & version=version[w] & desc=desc[w]

 w = str_isalpha(type)
 if(w[0] EQ -1) then return
 ii = ii[w]
 start=start[w] & stop = stop[w] & type=type[w] & version=version[w] & desc=desc[w]

 w = str_isalphanum(version)
 if(w[0] EQ -1) then return
 ii = ii[w]
 start=start[w] & stop=stop[w] & type=type[w] & version=version[w] & desc=desc[w]


 jd_start = call_function(format+'_to_jd', start)
 jd_stop = call_function(format+'_to_jd', stop)

 _type = type
 _version = version
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; cas_spice_ck_detect</span>
<span class="comments">;</span>
<span class="comments">; Only kernels whose filenames match the standard convention and whose </span>
<span class="comments">; coverage dates are within djd days of the given image are returned.</span>
<span class="comments">;</span>
<span class="comments">; The naming scheme is described at :</span>
<span class="comments">;   https://cassini.jpl.nasa.gov/cel/cedr/inv/work_area/work_group/spice/</span>
<span class="comments">;</span>
<span class="comments">; 12/2006: kernels whose names contain the image name are also matched.</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="cas_spice_ck_detect:source"></a>function cas_spice_ck_detect, dd, ckpath, sc=sc, djd=djd, time=time, $
                                               all=all, strict=strict
 if(NOT keyword_set(djd)) then djd = 1d			<span class="comments">; days, +/-</span>


 <span class="comments">;--------------------------------</span>
 <span class="comments">; get image jd</span>
 <span class="comments">;--------------------------------</span>
 jd = spice_et2jed(time)

 <span class="comments">;--------------------------------</span>
 <span class="comments">; get ck jd's</span>
 <span class="comments">;--------------------------------</span>
 all_files = get_all_ck_files(ckpath)
 if(NOT keyword_set(all_files)) then return, ''
 if(keyword_set(all)) then return, all_files

 <span class="comments">;--------------------------------------------------</span>
 <span class="comments">; get rid of 'waypoint' kernels</span>
 <span class="comments">;--------------------------------------------------</span>
 p = strpos(all_files, 'waypoint')
 w = where(p EQ -1)
 if(w[0] EQ -1) then return, all_files
 all_files = all_files[w]

 split_filename, all_files, dir, all_names
 all_names = str_nnsplit(all_names, '.')


 <span class="comments">;--------------------------------------------------</span>
 <span class="comments">; extract components for each date convention</span>
 <span class="comments">;--------------------------------------------------</span>
 cas_spice_ck_components, all_names, 'yymmdd', ii=_ii, $
   jd_start=_jd_start, jd_stop=_jd_stop, type=_type, version=_version, desc=_desc
 jd_start = append_array(jd_start, _jd_start)
 jd_stop = append_array(jd_stop, _jd_stop)
 type = append_array(type, _type)
 version = append_array(version, _version)
 desc = append_array(desc, _desc)
 ii = append_array(ii, _ii)

 cas_spice_ck_components, all_names, 'yydoy', ii=_ii, $
    jd_start=_jd_start, jd_stop=_jd_stop, type=_type, version=_version, desc=_desc
 jd_start = append_array(jd_start, _jd_start)
 jd_stop = append_array(jd_stop, _jd_stop)
 type = append_array(type, _type)
 version = append_array(version, _version)
 desc = append_array(desc, _desc)
 ii = append_array(ii, _ii)

 nii = n_elements(ii)


 <span class="comments">;----------------------------------------------------------</span>
 <span class="comments">; accept only latest revision, ignore "improved" versions</span>
 <span class="comments">;----------------------------------------------------------</span>
 wr = (wi = (wp = -1))
 if(keyword_set(type)) then $
  begin
   wr = where(type EQ 'r')
   wi = where(type EQ 'i')
   wp = where(type EQ 'p')
  end

 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; change types so they'll sort as desired</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - -</span>
 if(wr[0] NE -1) then type[wr] = 'b'
 if(wp[0] NE -1) then type[wp] = 'a'
 ww = lindgen(nii)
 if(wi[0] NE -1) then ww = rm_list_item(ww, wi, only='')
 if(size(ww[0], /type) EQ 7) then return, '' $
 else $
  begin
   jd_start = jd_start[ww] & jd_stop = jd_stop[ww]
   type = type[ww] & version = version[ww] & ii = ii[ww] & desc = desc[ww]
  end


 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; sort list such that latest versions are selected</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="comments">; sort_names = strtrim(jd_start,2) + '_' + strtrim(jd_stop,2) + desc + type + version</span>
 sort_names = strtrim(jd_start,2) + '_' + strtrim(jd_stop,2) + type + version

 ss = sort(sort_names)
 ii = ii[ss]
 jd_start = jd_start[ss] & jd_stop = jd_stop[ss]
 type = type[ss] & version = version[ss] & desc = desc[ss]


<span class="comments">; sort_names = strtrim(jd_start,2) + '_' + strtrim(jd_stop,2) + type + desc</span>
 sort_names = strtrim(jd_start,2) + '_' + strtrim(jd_stop,2) + type

 uu = uniq(sort_names)
 ii = ii[uu]
 jd_start = jd_start[uu] & jd_stop = jd_stop[uu] 
 type = type[uu] & version = version[uu] & desc = desc[uu]


 <span class="comments">;--------------------------------------------------------------------</span>
 <span class="comments">; compare dates</span>
 <span class="comments">;--------------------------------------------------------------------</span>
<span class="comments">; w = where((jd GE jd_start-djd) AND (jd LE jd_stop+djd))</span>
 w = where((jd_start-djd LT min(jd)) AND (jd_stop+djd GT max(jd)))
 if(w[0] NE -1) then $
  begin 
   ii = ii[w]
   jd_start = jd_start[w] & jd_stop = jd_stop[w]
   type = type[w] & version = version[w] & desc = desc[w]


   <span class="comments">;----------------------------------------------------------------------</span>
   <span class="comments">; sort such that latest versions are last, r kernels after p kernels</span>
   <span class="comments">;----------------------------------------------------------------------</span>
   code = type + version
   ss = sort(code)
   ii = ii[ss]
   jd_start = jd_start[ss] & jd_stop = jd_stop[ss]
   type = type[ss] & version = version[ss] & desc = desc[ss]
   ck_files = all_files[ii]
  end 


<span class="comments">; ;---------------------------------------------------------</span>
<span class="comments">; ; match kernels whose names start with the image name</span>
<span class="comments">; ;---------------------------------------------------------</span>
<span class="comments">; if(keyword_set(all_files)) then $</span>
<span class="comments">;  begin</span>
<span class="comments">;   split_filename, cor_name(dd), dir, name, ext</span>
<span class="comments">;   if(keyword_set(name)) then $</span>
<span class="comments">;    begin </span>
<span class="comments">;     len = max(strlen(name))</span>
<span class="comments">;     _all_names = strmid(all_names, 0, len)</span>
<span class="comments">;     w = str_nmatch(_all_names, name)</span>
<span class="comments">;     if(w[0] NE -1) then ck_files = append_array(ck_files, all_files[w])</span>
<span class="comments">;    end </span>
<span class="comments">;  end</span>


<span class="comments">; ;----------------------------------------------------------------------</span>
<span class="comments">; ; now move "waypoint" kernels to the very end.</span>
<span class="comments">; ;----------------------------------------------------------------------</span>
<span class="comments">; if(keyword_set(ck_files)) then $</span>
<span class="comments">;  begin</span>
<span class="comments">;   p = strpos(strlowcase(ck_files), 'waypoint')</span>
<span class="comments">;   ww = where(p NE -1)</span>
<span class="comments">;   w = where(p EQ -1)</span>
<span class="comments">;   _ck_files = ''</span>
<span class="comments">;   if(ww[0] NE -1) then _ck_files = ck_files[ww]</span>
<span class="comments">;   if(w[0] NE -1) then _ck_files = append_array(_ck_files, ck_files[w])</span>
<span class="comments">;   ck_files = _ck_files</span>
<span class="comments">;  end</span>


 <span class="comments">;----------------------------------------------------------</span>
 <span class="comments">; if no kernels found, then return first ck file in order</span>
 <span class="comments">; to avoid naiflib error </span>
 <span class="comments">;----------------------------------------------------------</span>
 if(NOT keyword_set(ck_files)) then ck_files = all_files[0]

 return, ck_files
end
<span class="comments">;=============================================================================</span>









<span class="comments">;=============================================================================</span>
<span class="comments">; cas_spice_ck_detect</span>
<span class="comments">;</span>
<span class="comments">; Only kernels whose filenames match the standard convention and whose </span>
<span class="comments">; coverage dates are within djd days of the given image are returned.</span>
<span class="comments">;</span>
<span class="comments">; The naming scheme is described at :</span>
<span class="comments">;   https://cassini.jpl.nasa.gov/cel/cedr/inv/work_area/work_group/spice/</span>
<span class="comments">;</span>
<span class="comments">; 12/2006: kernels whose names contain the image name are also matched.</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="____cas_spice_ck_detect:source"></a>function ____cas_spice_ck_detect, dd, ckpath, djd=djd, time=time, $
                             all=all, strict=strict
<span class="comments">;common cas_spice_ck_block, all_files, all_names_block, ckpath_block, $</span>
<span class="comments">;      jd_start_block, jd_stop_block, type_block, version_block, desc_block, ii_block</span>

 if(NOT keyword_set(djd)) then djd = 1d			<span class="comments">; days, +/-</span>

 label = dat_header(dd)
<span class="comments">; all_files = ''</span>
 

 <span class="comments">;--------------------------------</span>
 <span class="comments">; get image jd</span>
 <span class="comments">;--------------------------------</span>
<span class="comments">; if(NOT keyword_set(time)) then jd = spice_str2jed(cas_spice_time(label)) $</span>
<span class="comments">; else jd = spice_et2jed(time)</span>
 if(NOT keyword_set(time)) then time = cas_spice_time(label)
 jd = spice_et2jed(time)

 jd = jd[0]



 <span class="comments">;--------------------------------</span>
 <span class="comments">; get ck jd's</span>
 <span class="comments">;--------------------------------</span>
 if(keyword_set(ckpath_block)) then $
  if(ckpath NE ckpath_block) then jd_start_block = ''

 if(NOT keyword_set(jd_start_block)) then $
  begin
   all_files = get_all_ck_files(ckpath)
   if(keyword_set(all)) then return, all_files

   <span class="comments">;--------------------------------------------------</span>
   <span class="comments">; get rid of 'waypoint' kernels</span>
   <span class="comments">;--------------------------------------------------</span>
   p = strpos(all_files, 'waypoint')
   w = where(p EQ -1)
   if(w[0] EQ -1) then return, all_files
   all_files = all_files[w]

   split_filename, all_files, dir, all_names
   all_names = str_nnsplit(all_names, '.')


   <span class="comments">;--------------------------------------------------</span>
   <span class="comments">; extract components for each date convention</span>
   <span class="comments">;--------------------------------------------------</span>
   cas_spice_ck_components, all_names, 'yymmdd', ii=_ii, $
     jd_start=_jd_start, jd_stop=_jd_stop, type=_type, version=_version, desc=_desc
   jd_start_block = append_array(jd_start_block, _jd_start)
   jd_stop_block = append_array(jd_stop_block, _jd_stop)
   type_block = append_array(type_block, _type)
   version_block = append_array(version_block, _version)
   desc_block = append_array(desc_block, _desc)
   ii_block = append_array(ii_block, _ii)

   cas_spice_ck_components, all_names, 'yydoy', ii=_ii, $
      jd_start=_jd_start, jd_stop=_jd_stop, type=_type, version=_version, desc=_desc
   jd_start_block = append_array(jd_start_block, _jd_start)
   jd_stop_block = append_array(jd_stop_block, _jd_stop)
   type_block = append_array(type_block, _type)
   version_block = append_array(version_block, _version)
   desc_block = append_array(desc_block, _desc)
   ii_block = append_array(ii_block, _ii)

   ckpath_block = ckpath
   all_names_block = all_names
  end

 jd_start = jd_start_block
 jd_stop = jd_stop_block
 type = type_block
 version = version_block
 desc = desc_block
 ii = ii_block
 all_names = all_names_block

 nii = n_elements(ii)

 <span class="comments">;----------------------------------------------------------</span>
 <span class="comments">; accept only latest revision, ignore "improved" versions</span>
 <span class="comments">;----------------------------------------------------------</span>
 wr = (wi = (wp = -1))
 if(keyword_set(type)) then $
  begin
   wr = where(type EQ 'r')
   wi = where(type EQ 'i')
   wp = where(type EQ 'p')
  end

 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; change types so they'll sort as desired</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - -</span>
 if(wr[0] NE -1) then type[wr] = 'b'
 if(wp[0] NE -1) then type[wp] = 'a'
 ww = lindgen(nii)
 if(wi[0] NE -1) then ww = rm_list_item(ww, wi, only='')
 if(size(ww[0], /type) EQ 7) then return, '' $
 else $
  begin
   jd_start = jd_start[ww] & jd_stop = jd_stop[ww]
   type = type[ww] & version = version[ww] & ii = ii[ww] & desc = desc[ww]
  end


 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; sort list such that latest versions are selected</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="comments">; sort_names = strtrim(jd_start,2) + '_' + strtrim(jd_stop,2) + desc + type + version</span>
 sort_names = strtrim(jd_start,2) + '_' + strtrim(jd_stop,2) + type + version

 ss = sort(sort_names)
 ii = ii[ss]
 jd_start = jd_start[ss] & jd_stop = jd_stop[ss]
 type = type[ss] & version = version[ss] & desc = desc[ss]


<span class="comments">; sort_names = strtrim(jd_start,2) + '_' + strtrim(jd_stop,2) + type + desc</span>
 sort_names = strtrim(jd_start,2) + '_' + strtrim(jd_stop,2) + type

 uu = uniq(sort_names)
 ii = ii[uu]
 jd_start = jd_start[uu] & jd_stop = jd_stop[uu] 
 type = type[uu] & version = version[uu] & desc = desc[uu]


 <span class="comments">;--------------------------------------------------------------------</span>
 <span class="comments">; compare dates</span>
 <span class="comments">;--------------------------------------------------------------------</span>
 w = where((jd GE jd_start-djd) AND (jd LE jd_stop+djd))
 if(w[0] NE -1) then $
  begin 
   ii = ii[w]
   jd_start = jd_start[w] & jd_stop = jd_stop[w]
   type = type[w] & version = version[w] & desc = desc[w]


   <span class="comments">;----------------------------------------------------------------------</span>
   <span class="comments">; sort such that latest versions are last, r kernels after p kernels</span>
   <span class="comments">;----------------------------------------------------------------------</span>
   code = type + version
   ss = sort(code)
   ii = ii[ss]
   jd_start = jd_start[ss] & jd_stop = jd_stop[ss]
   type = type[ss] & version = version[ss] & desc = desc[ss]
   ck_files = all_files[ii]
  end 


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; match kernels whose names contain the image id string</span>
 <span class="comments">;---------------------------------------------------------</span>
 if(keyword_set(all_files)) then $
  begin
   split_filename, cor_name(dd), dir, name, ext
   if(keyword_set(name)) then $
    begin 
     p = strpos(strupcase(all_names), strupcase(name))
     w = where(p NE -1) 
     if(w[0] NE -1) then ck_files = append_array(ck_files, all_files[w])
    end 
  end


<span class="comments">; ;----------------------------------------------------------------------</span>
<span class="comments">; ; now move "waypoint" kernels to the very end.</span>
<span class="comments">; ;----------------------------------------------------------------------</span>
<span class="comments">; if(keyword_set(ck_files)) then $</span>
<span class="comments">;  begin</span>
<span class="comments">;   p = strpos(strlowcase(ck_files), 'waypoint')</span>
<span class="comments">;   ww = where(p NE -1)</span>
<span class="comments">;   w = where(p EQ -1)</span>
<span class="comments">;   _ck_files = ''</span>
<span class="comments">;   if(ww[0] NE -1) then _ck_files = ck_files[ww]</span>
<span class="comments">;   if(w[0] NE -1) then _ck_files = append_array(_ck_files, ck_files[w])</span>
<span class="comments">;   ck_files = _ck_files</span>
<span class="comments">;  end</span>


 <span class="comments">;----------------------------------------------------------</span>
 <span class="comments">; if no kernels found, then return first ck file in order</span>
 <span class="comments">; to avoid naiflib error </span>
 <span class="comments">;----------------------------------------------------------</span>
 if(NOT keyword_set(ck_files)) then ck_files = all_files[0]


help, ck_files
 return, ck_files
end
<span class="comments">;=============================================================================</span>
</code>
    </div>
  </body>
</html>