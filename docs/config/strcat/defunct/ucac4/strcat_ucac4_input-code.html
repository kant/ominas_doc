<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 14:16:46 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>strcat_ucac4_input.pro (OMINAS Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="strcat_ucac4_input.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;===============================================================================</span>
<span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; Input translator for ucact-c star catalog compiled by Bill Owen.</span>
<span class="comments">;</span>
<span class="comments">; Usage</span>
<span class="comments">; =====</span>
<span class="comments">; This routine is called via `dat_get_value`, which is used to read the</span>
<span class="comments">; translator table. In particular, the specific translator for the scene</span>
<span class="comments">; to be processed should contain the following line::</span>
<span class="comments">;</span>
<span class="comments">;      -   strcat_ucac4_input     -       /j2000    # or /b1950 if desired</span>
<span class="comments">; </span>
<span class="comments">; For the star catalog translator system to work properly, only one type</span>
<span class="comments">; of catalog may be used at a time for a particular instrument.</span>
<span class="comments">;</span>
<span class="comments">; The UCAC4 catalog is the final release version of the USNO CCD Astrograph</span>
<span class="comments">; Catalog. The version of the catalog which is expected by this catalog was</span>
<span class="comments">; obtained from the `CDS Strasbourg database &lt;ftp://cdsarc.u-strasbg.fr/pub/cats/more/UCAC4/u4b/>`.</span>
<span class="comments">; Each of the 900 zone files is required. Additionally, there is an </span>
<span class="comments">; `ASCII index file &lt;ftp://cdsarc.u-strasbg.fr/pub/cats/more/UCAC4/u4i/>`</span>
<span class="comments">; named u4index.asc, which is used to determine which zone files to load.</span>
<span class="comments">;</span>
<span class="comments">; Restrictions</span>
<span class="comments">; ============</span>
<span class="comments">;</span>
<span class="comments">; Since the distance to stars are not given in the UCAC4 catalog, the</span>
<span class="comments">; position vector magnitude is set as 10 parsec and the luminosity</span>
<span class="comments">; is calculated from the visual magnitude and the 10 parsec distance.</span>
<span class="comments">;</span>
<span class="comments">; Procedure</span>
<span class="comments">; =========</span>
<span class="comments">;</span>
<span class="comments">; Stars are found in a square area in RA and DEC around a given</span>
<span class="comments">; or calculated center.  The star descriptor is filled with stars</span>
<span class="comments">; that fit in this area.  If B1950 is selected, input sd's orient </span>
<span class="comments">; matrix is assumed to be B1950 also, if not, input is assumed to</span>
<span class="comments">; be J2000, like the catalog.</span>
<span class="comments">;</span>
<span class="comments">; :Categories:</span>
<span class="comments">;   nv, config</span>
<span class="comments">;   </span>
<span class="comments">; :Version:</span>
<span class="comments">;    Incomplete</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;   Jacqueline Ryan, 8/2016</span>
<span class="comments">;   </span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; :Private:</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;-</span>
<span class="comments">;===============================================================================</span>




<span class="comments">;===============================================================================</span>
<span class="comments">; ucac4_get_regions</span>
<span class="comments">;</span>
<span class="comments">;===============================================================================</span>
<a id="ucac4_get_regions:source"></a>function ucac4_get_regions, ra1, ra2, dec1, dec2, path_ucac4=path_ucac4
 return, path_ucac4 + '/u4index.asc'	<span class="comments">; there's only one "region" file</span>
end
<span class="comments">;===============================================================================</span>




<span class="comments">;===============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; :Private:</span>
<span class="comments">; :Hidden:</span>
<span class="comments">; Ingests a set of records from the UCAC4 star catalog and generates star</span>
<span class="comments">; descriptors for each star within a specified scene.</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;   array of star descriptors</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   dd : in, required, type="data descriptor"</span>
<span class="comments">;      data descriptor</span>
<span class="comments">;   filename : in, required, type=string</span>
<span class="comments">;      name of index file, or regions file</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   b1950 : in, optional, type=string</span>
<span class="comments">;      if set, coordinates are output wrt b1950</span>
<span class="comments">;   ra1 : in, required, type=double</span>
<span class="comments">;      lower bound in right ascension of scene</span>
<span class="comments">;   ra2 : in, required, type=double</span>
<span class="comments">;      upper bound in right ascension of scene</span>
<span class="comments">;   dec1 : in, required, type=double</span>
<span class="comments">;      lower bound in declination of scene</span>
<span class="comments">;   dec2 : in, required, type=double</span>
<span class="comments">;      upper bound in declination of scene</span>
<span class="comments">;   faint : in, optional, type=double</span>
<span class="comments">;      stars with magnitudes fainter than this will not be returned</span>
<span class="comments">;   bright : in, optional, type=double</span>
<span class="comments">;      stars with magnitudes brighter than this will not be returned</span>
<span class="comments">;   nbright : in, optional, type=double</span>
<span class="comments">;      if set, selects only the n brightest stars</span>
<span class="comments">;   names : in, optional, type="string array"</span>
<span class="comments">;      if set, will return only the stars with the expected names</span>
<span class="comments">;   mag : out, required, type=double</span>
<span class="comments">;      magnitude of returned stars</span>
<span class="comments">;   jtime : in, optional, type=double</span>
<span class="comments">;      Years since 1950 (the epoch of catalog) for precession</span>
<span class="comments">;      and proper motion correction. If not given, it is taken</span>
<span class="comments">;      from the object descriptor bod_time, which is assumed to</span>
<span class="comments">;      be seconds past 2000, unless keyword /b1950 is set</span>
<span class="comments">;-</span>
<span class="comments">;===============================================================================</span>
<a id="ucac4_get_stars:source"></a>function ucac4_get_stars, dd, filename, $
         b1950=b1950, ra1=ra1, ra2=ra2, dec1=dec1, dec2=dec2, $
         faint=faint, bright=bright, nbright=nbright, $
         names=names, mag=mag, jtime=jtime

 print, filename
 f = file_search(filename)
 if(f[0] eq '') then $
  begin
   nv_message, 'File does not exist - ' + filename
   return, ''
  end
 
 <span class="comments">; Determine ra bins (j) between 1 and 1440</span>
 jmin = floor(ra1 * 4)
 jmax = ceil(ra2 * 4)
 <span class="comments">; Determine dec zones (zn) between 1 and 900</span>
 zmin = ceil(dec1 * 5) + 450
 zmax = ceil(dec2 * 5) + 450
 nz = zmax - zmin
 
 openr, index, filename, /get_lun
 skip_lun, index, 1440 * zmin + jmin, /lines
 line = ''
 bounds = intarr(2, nz)
 rec_bytes = 78
 recs = [ ]
 for i = 0, nz do $
  begin
   readf, index, line
   first = long(strmid(line, 0, 6))
   skip_lun, index, jmax - jmin - 1, /lines
   readf, index, line
   last = long(strmid(line, 0, 6))
   skip_lun, index, 1439 - jmax + jmin, /lines

   z_fname = 'z' + string(zmin + i, format='(I03)')
   z_strs = last - first
   z_recs = replicate({ucac4_record}, z_strs)
   openr, zone, getenv('NV_UCAC4_DATA') + '/' + z_fname, /get_lun
   point_lun, zone, first * rec_bytes
   readu, zone, z_recs
   recs = [recs, z_recs]
   close, zone
   free_lun, zone
  endfor
 close, index
 free_lun, index
 
 <span class="comments">;-----------------------------------</span>
 <span class="comments">; probe byte order</span>
 <span class="comments">;-----------------------------------</span>
 <span class="comments">;b = 1l</span>
 <span class="comments">;byteorder, b, /htonl</span>
 <span class="comments">;swap = (b EQ 1)</span>

 <span class="comments">;-----------------------------------</span>
 <span class="comments">; open file </span>
 <span class="comments">;-----------------------------------</span>
 <span class="comments">;openr, unit, filename, /get_lun</span>

 <span class="comments">;-----------------------------------</span>
 <span class="comments">; read header</span>
 <span class="comments">;-----------------------------------</span>
 <span class="comments">;hrec = assoc(unit, {ucac4_header})</span>
 <span class="comments">;header = hrec[0]</span>

 <span class="comments">;-----------------------------------</span>
 <span class="comments">; read zone directories</span>
 <span class="comments">;-----------------------------------</span>
 <span class="comments">;point_lun, -unit, pos</span>
 <span class="comments">;zrec = assoc(unit, replicate({ucac4_directory},180), pos)</span>
 <span class="comments">;zones = zrec[0]</span>
 <span class="comments">;if(swap) then zones = swap_endian(zones)</span>

 <span class="comments">;-------------------------------------------</span>
 <span class="comments">; build a list of star records</span>
 <span class="comments">;-------------------------------------------</span>
 <span class="comments">;point_lun, -unit, pos</span>
 <span class="comments">;srec = assoc(unit, {ucac4_record}, pos)</span>

<span class="comments">;;; _z1 = fix(90-dec1)</span>
<span class="comments">;;; _z2 = fix(90-dec2)</span>
 <span class="comments">;_z1 = round(90-dec1)</span>
 <span class="comments">;_z2 = round(90-dec2)</span>
 <span class="comments">;z1 = min([_z1,_z2])</span>
 <span class="comments">;z2 = max([_z1,_z2])</span>

<span class="comments">; z = lindgen(z2-z1+1) + z1</span>
<span class="comments">; if(z1 EQ z2) then z = z1</span>
<span class="comments">;;; z = lindgen((z2-z1)>1) + z1</span>
 <span class="comments">;z = lindgen((z2-z1+2)>1) + z1 - 1</span>

 <span class="comments">;nz = n_elements(z)</span>
 <span class="comments">;for i=0, nz-1 do $</span>
 <span class="comments">; begin</span>
<span class="comments">;stop</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; starting ra for each star record in this zone</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">;  ra_start = double(zones[z[i]].ra_start[0:zones[z[i]].numrec-1]) / $</span>
 <span class="comments">;                                                     268435456d * 180d/!dpi</span>

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; number of first (2560-byte) star record in this zone</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
  <span class="comments">; rec_start = zones[z[i]].rec_start - zones[0].rec_start</span>
  <span class="comments">; if(rec_start[0] NE -1) then $</span>
  <span class="comments">;  begin</span>
<span class="comments">;w1 = max(where(ra1 GE ra_start))</span>
<span class="comments">;w2 = min(where(ra2 LE ra_start))</span>
<span class="comments">;if(w2[0] EQ -1) then w2 = n_elements(ra_start)-1</span>
<span class="comments">;;;     w1 = min(where(ra_start GE ra1))</span>
<span class="comments">;;;     w2 = max(where(ra_start LE ra2) + 1) </span>
<span class="comments">;stop</span>
<span class="comments">;     w = lindgen(w2-w1+1) + w1</span>
<span class="comments">;     nw = n_elements(w)</span>

     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     <span class="comments">; extract selected records</span>
     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="comments">;     ps = replicate({ucac4_packed_star}, nw*71)</span>
<span class="comments">;     ns = 0</span>
<span class="comments">;     for j=0, nw-1 do $</span>
<span class="comments">;      begin</span>
<span class="comments">;       recnum = rec_start+w[j]</span>
<span class="comments">;       if(recnum LE 686945) then $</span>
<span class="comments">;        begin</span>
<span class="comments">;         record = srec[recnum]</span>
<span class="comments">;         if(swap) then record = swap_endian(record)</span>
<span class="comments">;</span>
<span class="comments">;         ps[ns:ns+record.nstars-1] = record.stars[0:record.nstars-1]</span>
<span class="comments">;         ns = ns + record.nstars</span>
<span class="comments">;        end</span>
<span class="comments">;      end</span>

<span class="comments">;     if(ns GT 0) then $</span>
<span class="comments">;      begin</span>
<span class="comments">;       ps = ps[0:ns-1]</span>
<span class="comments">;</span>
       <span class="comments">;- - - - - - - - - - - - - - - - - - - -</span>
       <span class="comments">; select stars within magnitude limits</span>
       <span class="comments">;- - - - - - - - - - - - - - - - - - - -</span>
<span class="comments">;       mag = ''</span>
<span class="comments">;       if(keyword_set(faint)) then $</span>
<span class="comments">;        begin</span>
<span class="comments">;         ucac4_unpack_stars, ps, mag=mag</span>
<span class="comments">;         w = where(mag LE faint)</span>
<span class="comments">;         if(w[0] NE -1) then $</span>
<span class="comments">;          begin</span>
<span class="comments">;           ps = ps[w]</span>
<span class="comments">;           mag = mag[w]</span>
<span class="comments">;          end else ps = (mag = 0)</span>
<span class="comments">;        end</span>
<span class="comments">;</span>
<span class="comments">;       if(keyword_set(bright)) then $</span>
<span class="comments">;        begin</span>
<span class="comments">;         if(NOT keyword_set(mag)) then ucac4_unpack_stars, ps, mag=mag</span>
<span class="comments">;         w = where(mag GE bright)</span>
<span class="comments">;         if(w[0] NE -1) then $</span>
<span class="comments">;          begin</span>
<span class="comments">;           ps = ps[w]</span>
<span class="comments">;           mag = mag[w]</span>
<span class="comments">;          end else ps = (mag = 0)</span>
<span class="comments">;        end</span>
<span class="comments">;</span>
       <span class="comments">;- - - - - - - - - - - - - - - - - - - -</span>
       <span class="comments">; select brightest stars </span>
       <span class="comments">;- - - - - - - - - - - - - - - - - - - -</span>
<span class="comments">;       if(keyword_set(nbright)) then $</span>
<span class="comments">;        begin</span>
<span class="comments">;         nps = n_elements(ps)</span>
<span class="comments">;         if(NOT keyword_set(mag)) then ucac4_unpack_stars, ps, mag=mag</span>
<span class="comments">;         ss = sort(mag)</span>
<span class="comments">;         ps = (ps[ss])[0:(nbright&lt;nps)-1]</span>
<span class="comments">;        end</span>



        <span class="comments">;- - - - - - - - - - - - - - - - - - - -</span>
        <span class="comments">; add stars </span>
        <span class="comments">;- - - - - - - - - - - - - - - - - - - -</span>
<span class="comments">;        packed_stars = append_array(packed_stars, ps)</span>
<span class="comments">;      end</span>
<span class="comments">;    end</span>
<span class="comments">;  end</span>

 <span class="comments">;-------------------------------------------</span>
 <span class="comments">; close file</span>
 <span class="comments">;-------------------------------------------</span>
 <span class="comments">;close, unit</span>
 <span class="comments">;free_lun, unit</span>
 
 <span class="comments">;-------------------------------------------</span>
 <span class="comments">; unpack star records</span>
 <span class="comments">;-------------------------------------------</span>
 <span class="comments">;if(NOT keyword_set(packed_stars)) then return, ''</span>
 <span class="comments">;ucac4_unpack_stars, packed_stars, $</span>
 <span class="comments">; ra=stars_ra, dec=stars_dec, _rapm=stars_rapm, _decpm=stars_decpm, $</span>
 <span class="comments">; mag=stars_mag, px=stars_px, sp=stars_sp, num=stars_num, $</span>
 <span class="comments">; epochra=stars_epochra, epochdec=stars_epochdec</span>

 mas_deg = 3600000d


<span class="comments">; see http://ad.usno.navy.mil/ucac/readme_u4v5...</span>
 nstars = n_elements(recs)
 stars = replicate({ucac4_star}, nstars)
 stars.ra = recs.ra / mas_deg                           <span class="comments">; mas -> deg </span>
 stars.dec = (recs.spd / mas_deg) - 90d                 <span class="comments">; mas above south pole -> deg declination</span>
 cosdec = cos(stars.dec * (!dpi / 180d)) * (180d / !dpi) 
 stars.rapm = recs.pmrac / (cosdec * mas_deg)  <span class="comments">; pmRA * cos(dec) [mas/yr] -> pmRA [deg/yr]</span>
 stars.decpm = recs.pmdc / mas_deg
 stars.mag = recs.apasm[1]/1000

<span class="comments">;;;		 stars.px = stars_px	;; look up in hipsupl.dat</span>
<span class="comments">;;;		 stars.sp = recs.objt	;; not in record</span>
 stars.num = recs.pts_key		<span class="comments">;;; some are zero</span>
<span class="comments">;;; stars.epochra = recs.cepra</span>
<span class="comments">;;; stars.epochdec = recs.cepdc</span>
 href = recs.rnm			<span class="comments">;;; for look-up in hipsupl.dat</span>

 <span class="comments">;------------------------------------------------------------------</span>
 <span class="comments">; If limits are defined, remove stars that fall outside the limits</span>
 <span class="comments">; Limits in deg, Assumes RA's + DEC's in J2000 (B1950 if /b1950)</span>
 <span class="comments">;------------------------------------------------------------------</span>
<span class="comments">; *** need to use strcat_radec_regions (see strcat_tycho2_input) ***</span>
 if(keyword_set(dec1) AND keyword_set(dec2)) then $
   begin
    subs = where((stars.dec GE dec1) AND (stars.dec LE dec2), count)
    if(count EQ 0) then return, ''
    stars = stars[subs]
   end


 if(keyword_set(ra1) AND keyword_set(ra2)) then $
   begin
    subs = where((stars.ra GE ra1) AND (stars.ra LE ra2), count)
    if(count EQ 0) then return, ''
    stars = stars[subs]
   end

 <span class="comments">;--------------------------------------------------------</span>
 <span class="comments">; Apply proper motion to star </span>
 <span class="comments">; jtime = years past 2000.0</span>
 <span class="comments">; rapm and decpm = radians per year</span>
 <span class="comments">;--------------------------------------------------------</span>
 stars.ra = stars.ra + stars.rapm*(jtime-(stars.epochra-2000))
 stars.dec = stars.dec + stars.decpm*(jtime-(stars.epochdec-2000))

 <span class="comments">;-------------------------------------------</span>
 <span class="comments">; work in radians now</span>
 <span class="comments">;-------------------------------------------</span>
 stars.ra = stars.ra * !dpi/180d
 stars.dec = stars.dec * !dpi/180d
 stars.rapm = stars.rapm * !dpi/180d
 stars.decpm = stars.decpm * !dpi/180d

 <span class="comments">;-----------------------------------------------------------</span>
 <span class="comments">; if desired, select only nbright brightest stars</span>
 <span class="comments">;-----------------------------------------------------------</span>
 if(keyword_set(nbright)) then $
  begin
   mag = stars.mag
   w = strcat_nbright(mag, nbright)
   stars = stars[w]
  end

 <span class="comments">;-------------------------------------</span>
 <span class="comments">; select named stars</span>
 <span class="comments">;-------------------------------------</span>
 file = file_search(getenv('OMINAS_DIR')+'/config/strcat/stars.txt')
 openr, lun, file, /get_lun
 line = ''
 linarr = strarr(file_lines(file), 7)
 i = 0
 while not eof(lun) do $
  begin
   readf, lun, line
   fields = strsplit(line, ';', /extract)
   linarr[i, *] = fields
   i = i + 1
  endwhile
 free_lun, lun
 
 n = n_elements(stars)
 matches = intarr(n)
 for i=0, n - 1 do matches[i] = where(strpos(linarr[*,2], stars[i].num) ne -1)
 name = 'ucac4 ' + strtrim(string(stars.num), 2)
 ndx = where(matches ne -1)
 matches = matches[ndx]
 for i = 0, n_elements(matches) - 1 do $
  begin
    lin_ndx = matches[i]
    if strtrim(linarr[lin_ndx, 1], 2) ne '-1' then name[ndx[i]] = linarr[lin_ndx, 1]
    if strtrim(linarr[lin_ndx, 0], 2) ne '-1' then name[ndx[i]] = linarr[lin_ndx, 0]
    print, name[ndx[i]]
  endfor
 
 if(keyword_set(names)) then $
  begin
   w = where(names EQ name)
   if(w[0] NE -1) then _stars = stars[w]
   if(NOT keyword__set(_stars)) then return, ''
   stars = _stars
   name = name[w]
  end

 <span class="comments">;----------------------</span>
 <span class="comments">; Fill star descriptors</span>
 <span class="comments">;----------------------</span>
 n = n_elements(stars)
 print, 'Total of ',n,' stars.'
 if(n eq 0) then return, ''

 <span class="comments">;-----------------------------</span>
 <span class="comments">; Calculate "dummy" properties</span>
 <span class="comments">;-----------------------------</span>
 orient = make_array(3,3,n)
 _orient = [ [1d,0d,0d], [0d,1d,0d], [0d,0d,1d] ]
 for j = 0 , n-1 do orient[*,*,j] = _orient
 avel = make_array(1,3,n,value=0d)
 vel = make_array(1,3,n,value=0d)
 time = make_array(n,value=0d)
 radii = make_array(3,n,value=1d)
 lora = make_array(n, value=0d)


 <span class="comments">;--------------------------------------------------------------------</span>
 <span class="comments">; Calculate position vector, use a very large distance unless </span>
 <span class="comments">; parallax is known.</span>
 <span class="comments">;--------------------------------------------------------------------</span>
 dist = make_array(n,val=1d21)	
		<span class="comments">; this is something like the diameter of the milky way</span>

 <span class="comments">;--------------------------------------------------------</span>
 <span class="comments">; if parallax is known, then compute the actual distance</span>
 <span class="comments">;--------------------------------------------------------</span>
 w = where(stars.px NE 0)
 if(w[0] NE -1) then $
  begin
   px_rad = stars[w].px / 3600d * !dpi/180d
<span class="comments">;   dist[w] = 1.5d11 / tan(0.5d*px_rad) </span>
   dist[w] = 1.5d11 / tan(px_rad) 
  end

 radec = transpose([transpose([stars.ra]), transpose([stars.dec]), transpose([dist])])
 pos = transpose(bod_radec_to_body(bod_inertial(), radec))

<span class="comments">; pos = make_array(3,n,value=0d)</span>
<span class="comments">; pos[0,*] = cos(stars.ra)*cos(stars.dec)*dist</span>
<span class="comments">; pos[1,*] = sin(stars.ra)*cos(stars.dec)*dist</span>
<span class="comments">; pos[2,*] = sin(stars.dec)*dist</span>

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; compute skyplane velocity from proper motion </span>
 <span class="comments">;---------------------------------------------------------</span>
 radec_vel = transpose([transpose([stars.rapm]/86400d/365.25d), transpose([stars.decpm]/86400d/365.25d), dblarr(1,n)])
 vel = bod_radec_to_body_vel(bod_inertial(), radec, radec_vel)



 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Precess J2000 to B1950 if desired</span>
 <span class="comments">;---------------------------------------------------------</span>
 if(keyword_set(b1950)) then pos = $
  transpose(b1950_to_j2000(transpose(pos),/reverse))
 pos = reform(pos,1,3,n)

 if(keyword_set(b1950)) then vel = $
  transpose(b1950_to_j2000(transpose(vel),/reverse))
 vel = reform(vel,1,3,n)


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Calculate "luminosity" from visual Magnitude using the </span>
 <span class="comments">; Sun as a model. If distance is unknown, lum will be </span>
 <span class="comments">; incorrect, but the magnitudes will work out.</span>
 <span class="comments">;---------------------------------------------------------</span>
 pc = const_get('parsec')
 Lsun = const_get('Lsun')
 m = stars.mag - 5d*alog10(dist/pc) + 5d
 lum = Lsun * 10.d^( (4.83d0-m)/2.5d ) 

 _sd = str_create_descriptors(n, $
        gd=make_array(n, val=dd), $
        name=name, $
        orient=orient, $
        avel=avel, $
        pos=pos, $
        vel=vel, $
        time=time, $
        radii=radii, $
        lora=lora, $
        lum=lum, $
        sp=sp )

 mag = stars.mag

 return, _sd
end

<span class="comments">;+</span>
<span class="comments">; :Private:</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;-</span>
<a id="strcat_ucac4_input:source"></a>function strcat_ucac4_input, dd, keyword, values=values, status=status, $
@nv_trs_keywords_include.pro
@nv_trs_keywords1_include.pro
	end_keywords

 ndd = n_elements(dd)
 for i=0, ndd-1 do $
  begin
  _sd = strcat_input(dd[i], keyword, 'ucac4', values=values, status=status, $
@nv_trs_keywords_include.pro
@nv_trs_keywords1_include.pro
	end_keywords )
   sd = append_array(sd, _sd)
  end

 return, sd
end
<span class="comments">;===============================================================================</span>
</code>
    </div>
  </body>
</html>