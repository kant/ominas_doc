<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 13:33:05 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>sxpar.pro (OMINAS Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="sxpar.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	sxpar</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Obtains the value of a parameter in a FITS header.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	UTIL/FITS</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	result = sxpar(hdr, name [, abort])</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;  INPUT:</span>
<span class="comments">;	hdr:	FITS header array, (e.g. as returned by SXOPEN or READFITS)  </span>
<span class="comments">;		string array, each element should have a length of 80</span>
<span class="comments">;		characters.</span>
<span class="comments">;</span>
<span class="comments">;	name:	String name of the parameter to return.   If Name is of </span>
<span class="comments">;		the form 'keyword*' then an array is returned containing </span>
<span class="comments">;		values of keywordN where N is an integer.  The value</span>
<span class="comments">;		of keywordN will be placed in RESULT(N-1).  The data type </span>
<span class="comments">;		of RESULT will be the type of the first valid match of keywordN </span>
<span class="comments">;		found.</span>
<span class="comments">;</span>
<span class="comments">;	abort:	String specifying that SXPAR should do a RETALL</span>
<span class="comments">;		if a parameter is not found.  ABORT should contain</span>
<span class="comments">;		a string to be printed if the keyword parameter is not found.</span>
<span class="comments">;		If not supplied SXPAR will return with a negative</span>
<span class="comments">;		!err if a keyword is not found.</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;  INPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT:</span>
<span class="comments">;	count:	Returns a value equal to the number of parameters found by sxpar.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; RETURN:</span>
<span class="comments">;	Value of parameter in header.  If parameter is double precision,</span>
<span class="comments">;	floating, long or string, the result is of that type.  Apostrophes are</span>
<span class="comments">;	stripped from strings.  If the parameter is logical, 1 is returned for T,</span>
<span class="comments">;	and 0 is returned for F.  If Name was of form 'keyword*' then a vector of</span>
<span class="comments">;	values are returned.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;	xx:	xx</span>
<span class="comments">;</span>
<span class="comments">;	xx:	xx</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;       Keyword COUNT returns the number of parameters found.</span>
<span class="comments">;	!err is set to -1 if parameter not found, 0 for a scalar</span>
<span class="comments">;	value returned.  If a vector is returned it is set to the</span>
<span class="comments">;	number of keyword matches found.</span>
<span class="comments">;</span>
<span class="comments">;       If a keyword occurs more than once in a header, a warning is given,</span>
<span class="comments">;       and the first occurence is used.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;	xx</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;	The first 8 chacters of each element of Hdr are searched for a </span>
<span class="comments">;       match to Name.  The value from the last 20 characters is returned.  </span>
<span class="comments">;       An error occurs if there is no parameter with the given name.</span>
<span class="comments">;       </span>
<span class="comments">;       If a numeric value has no decimal point it is returned as type</span>
<span class="comments">;       LONG.   If it contains more than 8 numerals, or contains the </span>
<span class="comments">;       character 'D', then it is returned as type DOUBLE.  Otherwise</span>
<span class="comments">;       it is returned as type FLOAT</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;        Given a FITS header, h, return the values of all the NAXISi values</span>
<span class="comments">;        into a vector.    Then place the history records into a string vector.</span>
<span class="comments">;</span>
<span class="comments">;         IDL> naxisi = sxpar( h ,'NAXIS*')         ; Extract NAXISi value</span>
<span class="comments">;         IDL> history = sxpar( h, 'HISTORY' )      ; Extract HISTORY records</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; STATUS:</span>
<span class="comments">;	Complete</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;	sxaddpar, sxdelpar</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;	DMS, May, 1983, Written.</span>
<span class="comments">;   D. Lindler Jan 90 added ABORT input parameter</span>
<span class="comments">;   J. Isensee Jul,90 added COUNT keyword</span>
<span class="comments">;   W. Thompson, Feb. 1992, added support for FITS complex values.</span>
<span class="comments">;   W. Thompson, May 1992, corrected problem with HISTORY/COMMENT/blank</span>
<span class="comments">;			   keywords, and complex value error correction.</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="SXPAR:source"></a>function SXPAR, hdr, name, abort, COUNT=matches   
 if N_params() LT 2 then begin
     print,'Syntax -     result =  sxpar( hdr, name, [abort, COUNT = ])
     return, -1
 endif 

 VALUE = 0
 if N_params() LE 2 then begin
      abort_return = 0
      abort = 'FITS Header'
 end else abort_return = 1
 if abort_return then On_error,1 else On_error,2

<span class="comments">;       Check for valid header</span>

  s = size(hdr)		<span class="comments">;Check header for proper attributes.</span>
  if ( s(0) NE 1 ) or ( s(2) NE 7 ) then $
	   message,'FITS Header (first parameter) must be a string array'

  nam = strtrim( strupcase(name) )	<span class="comments">;Copy name, make upper case     </span>

<span class="comments">; Determine if name is of form 'keyword*'</span>

   if strpos( nam, '*' ) EQ strlen( nam ) - 1 then begin    
	    nam = strmid( nam, 0, strlen( nam ) - 1)  
	    vector = 1	   		<span class="comments">;Flag for vector output  </span>
	    name_length = strlen(nam)  	<span class="comments">;Length of name </span>
	    num_length = 8 - name_length 	<span class="comments">;Max length of number portion  </span>
	    if num_length LE 0 then  $ 
		  message, 'Keyword length must be 8 characters or less'
    endif else begin  
	 	while strlen(nam) LT 8 do nam = nam + ' ' <span class="comments">;Make 8 chars long</span>
		vector = 0      
    endelse
<span class="comments">;</span>
<span class="comments">; Loop on lines of the header </span>
<span class="comments">;</span>
 keyword = strmid( hdr, 0, 8)
 histnam = (nam eq 'HISTORY ') or (nam eq 'COMMENT ') or (nam eq '        ') 
 if vector then begin
           nfound = where(strpos(keyword,nam) GE 0, matches)
	   if ( matches GT 0 ) then begin
                   numst= strmid(hdr(nfound), name_length, num_length)
                   number = intarr(matches)-1
                   for i = 0, matches-1 do $
	            if strnumber( numst(i), num) then number(i) = num
                   igood = where(number GE 0, matches)
                   if matches GT 0 then begin
                        nfound = nfound(igood) & number = number(igood)
                   endif
           endif

 endif else begin

       nfound = where(keyword EQ nam, matches)
       if not histnam then if matches GT 1 then message,$
         'WARNING- Keyword '+NAM +'located more than once in '+abort,/inform
 endelse   

<span class="comments">; Process string parameter </span>

 if matches GT 0 then begin
  line = hdr(nfound)
  svalue = strtrim( strmid(line,9,70),2)
  if histnam then $
	value = strtrim(strmid(line,8,71),2) else for i = 0,matches-1 do begin
      if ( strmid(svalue(i),0,1) EQ "'" ) then begin   <span class="comments">;Is it a string?</span>
	          test = strmid( svalue(i),1,strlen( svalue(i) )-1)
		  next_char = 0
		  value = '' 
          NEXT_APOST:
		  endap = strpos(test, "'", next_char)      <span class="comments">;Ending apostrophe  </span>
	     	  if endap LT 0 then $ 
			    MESSAGE,'Value of '+name+' invalid in '+abort
	  	  value = value + strmid( test, next_char, endap-next_char )  
<span class="comments">;</span>
<span class="comments">;  Test to see if the next character is also an apostrophe.  If so, then the</span>
<span class="comments">;  string isn't completed yet.  Apostrophes in the text string are signalled as</span>
<span class="comments">;  two apostrophes in a row.</span>
<span class="comments">;</span>
          	 if strmid( test, endap+1, 1) EQ "'" then begin    
	     	    value = value + "'"
	      	    next_char = endap+2         
		    goto, NEXT_APOST
          	 endif      
<span class="comments">;</span>
<span class="comments">; Process non-string value  </span>
<span class="comments">;</span>
          endif else begin
	       value = strtrim( strmid(line(i), 10, 20), 2)   <span class="comments">;Extract value    </span>
	       if ( value EQ 'T' ) then value = 1 else $
	       if ( value EQ 'F' ) then value = 0 else begin
<span class="comments">;</span>
<span class="comments">;  Test to see if a complex number.  It's not a complex number of columns 31-50</span>
<span class="comments">;  are blank, or if a slash character occurs in columns 11-50.  Otherwise, try</span>
<span class="comments">;  to interpret columns 31-50 as a number.</span>
<span class="comments">;</span>
	    	value2 = strtrim( strmid(line(i),30,20), 2) <span class="comments">;Imaginary part</span>
                if value2 EQ '' then goto, NOT_COMPLEX
		if strpos( strmid( line(i),10,40), '/') GE 0 then $
                       goto,NOT_COMPLEX
		On_ioerror, NOT_COMPLEX
	   	value2 = float(value2)
		value = complex(value,value2)
		goto, GOT_VALUE
<span class="comments">;</span>
<span class="comments">;  Not a complex number.  Decide if it is a floating point, double precision,</span>
<span class="comments">;  or integer number.</span>
<span class="comments">;</span>
NOT_COMPLEX:
		On_ioerror, GOT_VALUE
		  if strpos(value,'.') GE 0 then begin      
		      if ( strpos(value,'D') GT 0 ) or $
			 ( strlen(value) GE 8 ) then value = double(value) $
						else value = float(value)
		       END ELSE value = long(value)
<span class="comments">;</span>
GOT_VALUE:
		On_IOerror, NULL
		endelse
	     endelse<span class="comments">; if c eq apost</span>
<span class="comments">;</span>
<span class="comments">;  Add to vector if required</span>
<span class="comments">;</span>
	 if vector then begin
               maxnum = max(number)
	       if ( i EQ 0 ) then begin
                     sz_value = size(value)
                     result = make_array( maxnum, type=sz_value(1), /NOZERO)
	       endif 
               result( number(i)-1 ) =  value
	  endif
  endfor

  if vector then begin
         !ERR = matches     
         return, result
  endif else !ERR = 0

endif  else  begin    
     if abort_return then message,'Keyword '+nam+' not found in '+abort
     !ERR = -1
endelse     

return, value       

END                 
</code>
    </div>
  </body>
</html>