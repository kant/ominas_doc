<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 13:33:28 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>spice_input.pro (OMINAS Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="spice_input.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	spice_input</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Generic NAIF/SPICE input translator core.  This routine is not an </span>
<span class="comments">;	OMINAS input translator; it is intended to be called by an input</span>
<span class="comments">;	translator that is taylored to a specific mission. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/CONFIG</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	result = spice_input(dd, keyword, prefix)</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;  INPUT:</span>
<span class="comments">;	dd:		Data descriptor.</span>
<span class="comments">;</span>
<span class="comments">;	keyword:	String giving the name of the translator quantity.</span>
<span class="comments">;			The following keywords are recognized:</span>
<span class="comments">;</span>
<span class="comments">;			'CAM_DESCRIPTORS': The function [prefix]_spice_cameras</span>
<span class="comments">;					   Is called.</span>
<span class="comments">;</span>
<span class="comments">;			'PLT_DESCRIPTORS': The function [prefix]_spice_planets</span>
<span class="comments">;					   Is called.</span>
<span class="comments">;</span>
<span class="comments">;			'STR_DESCRIPTORS': The function [prefix]_spice_sun</span>
<span class="comments">;					   Is called.  Only the sun is</span>
<span class="comments">;				           recognized.</span>
<span class="comments">;</span>
<span class="comments">;	prefix:		String giving a prefix to use in constructing the names</span>
<span class="comments">;			of the input functions:</span>
<span class="comments">;</span>
<span class="comments">;			  [prefix]_spice_cameras</span>
<span class="comments">;			  [prefix]_spice_planets</span>
<span class="comments">;			  [prefix]_spice_sun</span>
<span class="comments">;</span>
<span class="comments">;			These functions are wrappers that prepare the relevant</span>
<span class="comments">;			inputs for a specific mission and call either</span>
<span class="comments">;			spice_cameras or spice_planets to obtain the appropriate</span>
<span class="comments">;			descriptors.  To obtain sun data, a planet descriptor is</span>
<span class="comments">;			obtained from spice_planets and converted to a star</span>
<span class="comments">;			descriptor.  See cas_spice_input for an example of how</span>
<span class="comments">;			to write such functions.</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT:</span>
<span class="comments">;	NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;  INPUT:</span>
<span class="comments">;	key1:		Camera descriptor.</span>
<span class="comments">;</span>
<span class="comments">;	key7:		Requested object time.</span>
<span class="comments">;</span>
<span class="comments">;	key8:		Array of requested object names.  Planets are requested</span>
<span class="comments">;			in the order given, except that the primary target body</span>
<span class="comments">;			is placed at the front of the list.</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT:</span>
<span class="comments">;	status:		Zero if valid data is returned.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;  TRANSLATOR KEYWORDS:</span>
<span class="comments">;	ref:		Name of the reference frame for the output quantities.</span>
<span class="comments">;			Default is 'j2000'.</span>
<span class="comments">;</span>
<span class="comments">;	j2000:		/j2000 is equivalent to specifying ref=j2000.</span>
<span class="comments">;</span>
<span class="comments">;	b1950:		/b1950 is equivalent to specifying ref=b1950.</span>
<span class="comments">;</span>
<span class="comments">;	klist:		Name of a file giving a list of SPICE kernels to use.</span>
<span class="comments">;			If no path is included, the path is taken from the </span>
<span class="comments">;			NV_SPICE_KER environment variable.  Note that this</span>
<span class="comments">;			keyword is effective only before any kernels have been</span>
<span class="comments">;			loaded or when /reload is specified.  This file </span>
<span class="comments">;			contains a list of file specifications, one per line.  </span>
<span class="comments">;			Lines beginning with '#' are ignored.  Kernels may</span>
<span class="comments">;			also be selected by image time using the keywords</span>
<span class="comments">;			START_TIME, STOP_TIME, and DEFAULT as in the </span>
<span class="comments">;			following example:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;			$NV_SPICE_SPK/010419_SE_SAT077.bsp</span>
<span class="comments">;			$NV_SPICE_CK/051008_051217_s15s16_port3_pa.bc</span>
<span class="comments">;</span>
<span class="comments">;			START_TIME = 2002-270T10:57:56.870</span>
<span class="comments">;			 $NV_SPICE_SPK/000331R_SK_LP0_V1P32.bsp</span>
<span class="comments">;			 $NV_SPICE_SPK/010419_SE_SAT077.bsp</span>
<span class="comments">;			STOP_TIME = 2002-281T20:57:56.870</span>
<span class="comments">;</span>
<span class="comments">;			START_TIME = 2002-290T20:57:56.870</span>
<span class="comments">;			 $NV_SPICE_SPK/000331R_SK_LP0_V1P32.bsp</span>
<span class="comments">;			 $NV_SPICE_SPK/010419_SE_SAT077.bsp</span>
<span class="comments">;			STOP_TIME = 2002-291T20:57:56.870</span>
<span class="comments">;</span>
<span class="comments">;			DEFAULT</span>
<span class="comments">;			 $NV_SPICE_SPK/000331R_SK_LP0_V1P32.bsp</span>
<span class="comments">;			 $NV_SPICE_SPK/010419_SE_SAT077.bsp-bb</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;			Files appearing before the first START_TIME are always</span>
<span class="comments">;			loaded.  If the image time is not covered in a</span>
<span class="comments">;			START/STOP_TIME block, then the DEFAULT kernels are</span>
<span class="comments">;			loaded.  Keywords must appear at the beginning of</span>
<span class="comments">;			the line and DEFAULT must come last.</span>
<span class="comments">;</span>
<span class="comments">;	&lt;type>_in:	List of input kernels of the given type; e,g, ck_in,</span>
<span class="comments">;			spk_in, lsk_in, etc.  List must be delineated by </span>
<span class="comments">;			semimcolons with no space.  The kernel list</span>
<span class="comments">;			file is still used, but these kernels take</span>
<span class="comments">;			precedence.  Entries in this list may be file</span>
<span class="comments">;			specification strings.  On each call, kernels are </span>
<span class="comments">;			loaded and unloaded such that the kernel pool will </span>
<span class="comments">;			consist of the klist kernels and these kernels.  </span>
<span class="comments">;			If the value 'auto' is given, then an attempt may be </span>
<span class="comments">;			made to detect the correct kernel file for the given</span>
<span class="comments">;			image, depending on the instrument.  Kernels specified </span>
<span class="comments">;			explicitly by name here take precedence over those </span>
<span class="comments">;			determined using the auto-detection.  If a path</span>
<span class="comments">;			is specified with 'auto', the kernels that path</span>
<span class="comments">;			is used to autodetection instead of the path given</span>
<span class="comments">;			by the relevant environment variable.</span>
<span class="comments">;</span>
<span class="comments">;	reverse:	If set, klist kernels are loaded last, causing them to</span>
<span class="comments">;			take precedence.</span>
<span class="comments">;</span>
<span class="comments">;	&lt;type>_reverse:	If set, the type of kernel will be loaded before</span>
<span class="comments">;			the klist, demoting their precedence.</span>
<span class="comments">;</span>
<span class="comments">;	&lt;type>_strict:	Causes /strict to be passed to the corresponding</span>
<span class="comments">;			kernel auto-detection routine.  The behavior </span>
<span class="comments">;			depends on the routine, but typically this will</span>
<span class="comments">;			result in fewer kernels being loaded.  </span>
<span class="comments">;</span>
<span class="comments">;	&lt;type>_all:	Causes /all to be passed to the corresponding</span>
<span class="comments">;			kernel auto-detection routine.  The behavior </span>
<span class="comments">;			depends on the routine, but typically this should</span>
<span class="comments">;			result in all kernels of the given type being loaded.  </span>
<span class="comments">;</span>
<span class="comments">;	protect:	Semicolon-delimited list of file specifications.  All</span>
<span class="comments">;			kernels matched are left untouched in the kernel pool.</span>
<span class="comments">;			If a file specification starts with '!', then only </span>
<span class="comments">;			kernels not matched will be left untouched in the</span>
<span class="comments">;			kernel pool.</span>
<span class="comments">;</span>
<span class="comments">;	reload:		If set, all kernels are unloaded and the current </span>
<span class="comments">;			kernel pool is loaded from scratch.  The interface</span>
<span class="comments">;			operates very reliably, but very inefficiently using</span>
<span class="comments">;			this option.</span>
<span class="comments">;</span>
<span class="comments">;	constants:	If set, only kernels containing constants are loaded.</span>
<span class="comments">;			Only those quantities are filled in.</span>
<span class="comments">;</span>
<span class="comments">;	targets:	Name of text file listing the targets to be requested</span>
<span class="comments">;			from the kernel pool.  If not given, the name of the</span>
<span class="comments">;			file is taken from the environment variable</span>
<span class="comments">;			[prefix]_SPICE_TARGETS.</span>
<span class="comments">;</span>
<span class="comments">;	nokernels:	If set, the kernel pool will not be modified.</span>
<span class="comments">;</span>
<span class="comments">;	name:		If given, objects names are taken from this keyword</span>
<span class="comments">;			rather than from key8.</span>
<span class="comments">;</span>
<span class="comments">;	obs:		Name or NAIF ID of observer.  Default is SSB.</span>
<span class="comments">;</span>
<span class="comments">;	pos:		Get only position information, not pointing.</span>
<span class="comments">;</span>
<span class="comments">;	strict_priority:If set, previously loaded kernels are uncloded and </span>
<span class="comments">;			reloaded in order to preserve thei priority.  This is</span>
<span class="comments">;			potentially very slow.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ENVIRONMENT VARIABLES:</span>
<span class="comments">;	NV_SPICE_KER:		Directory containing the kernel list file.</span>
<span class="comments">;</span>
<span class="comments">;	NV_SPICE_&lt;type>:	Directory containing the kernel files specified</span>
<span class="comments">;				using &lt;type>_in.  Multiple directories can be</span>
<span class="comments">;				delimited using the ':' character.</span>
<span class="comments">;</span>
<span class="comments">;	[prefix]_SPICE_TARGETS:	Name of optional targets file; see targets</span>
<span class="comments">;				keyword.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; RETURN:</span>
<span class="comments">;	Descriptors associated with the requested keyword.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; STATUS:</span>
<span class="comments">;	Complete</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; FULL DESCRIPTION:</span>
<span class="comments">;</span>
<span class="comments">;  The purpose of the OMINAS SPICE interface is to allow SPICE kernels to be</span>
<span class="comments">;  directly read into and written from OMINAS via input and output translators. </span>
<span class="comments">;  Because SPICE kernels are mission-dependent (the exact layout of the C-matrix</span>
<span class="comments">;  depends on the camera in question, for example), unique input and output</span>
<span class="comments">;  translators must be written for each mission supported.  Translators and</span>
<span class="comments">;  supporting routines for each mission reside in subdirectories whose names are</span>
<span class="comments">;  abbreviations of the mission name, for example 'cas' or 'gll'. The package</span>
<span class="comments">;  described here provides as much generic support for those specific transators</span>
<span class="comments">;  as possible.</span>
<span class="comments">;</span>
<span class="comments">;  The SPICE input translator, SPICE_INPUT, reads all of the SPICE spacecraft</span>
<span class="comments">;  and planetary ephemeris data and returns the appropriate descriptors.  The</span>
<span class="comments">;  SPICE output translator, SPICE_OUTPUT, currently recognizes only camera</span>
<span class="comments">;  descriptors, writing only a C-kernel containing any number of C matrices.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;  Generic Kernel Detectors</span>
<span class="comments">;  ------------------------</span>
<span class="comments">;  The fundamental problem in the NAIF/SPICE system is determining which kernels</span>
<span class="comments">;  are needed for a given image.   For kernels generated by NAIF, ths is relatively</span>
<span class="comments">;  simple, as they adhere to a strict naming convention.  However, project-</span>
<span class="comments">;  generated kernels (mainly CK and SPK) reside in a special level of hell where </span>
<span class="comments">;  file names may have any meaning or none at all, may give the coverage dates, </span>
<span class="comments">;  some kind of mission-specific version code, may be generated according to an </span>
<span class="comments">;  algorithm, or may be written by a human operator who may or may not have had </span>
<span class="comments">;  a good day.  Therefore, automatic construction of a kernel pool is not trivial.</span>
<span class="comments">;  Indeed, we are not aware that it has ever been accomplished in a generic sense.</span>
<span class="comments">;</span>
<span class="comments">;  One solution to the problem is to have a separate set of kernel detectors for</span>
<span class="comments">;  each mission.  For example, the CAS package has a set of detectors that can </span>
<span class="comments">;  identify kernels based on known Cassini conventions.  However, coding such a </span>
<span class="comments">;  system is often one of the most difficult parts of adding a SPICE translator</span>
<span class="comments">;  for a new mission.  Therefore we have attempted to developed and automatic </span>
<span class="comments">;  system for generic kernel pool detection.  These detectors are automatically </span>
<span class="comments">;  called if no specific detectors are fould for a mission package.  At present, </span>
<span class="comments">;  the system funtions, but needs refinement to produce the most concise kernel </span>
<span class="comments">;  pool.</span>
<span class="comments">; </span>
<span class="comments">;  Coverage times are specified within the kernel or its detached label, so </span>
<span class="comments">;  determining a set of kernels that covers a given observation is conceptually</span>
<span class="comments">;  simple.  In practice, reading the coverage times from every available kernel </span>
<span class="comments">;  file and finding the relevant kernels may take minutes, so we have implemented </span>
<span class="comments">;  a system that catalogs all relevant kernel information into a database that can </span>
<span class="comments">;  be searched quickly (see below).  </span>
<span class="comments">;</span>
<span class="comments">;  Determining the latest version of a kernel is much more difficult because the </span>
<span class="comments">;  SPICE system does not track version information; that information typically</span>
<span class="comments">;  is encoded (if at all) in the kernel file name, in a project-specific code.  </span>
<span class="comments">;  We attempt to solve this problem by looking at a number of indicators like</span>
<span class="comments">;  segment interval lengths, label time stamps, file time stamps, etc.</span>
<span class="comments">; </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;[[needs updating...]]</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;Kernel Databases</span>
<span class="comments">;----------------</span>
<span class="comments">;</span>
<span class="comments">;Stored in the ~/.ominas directory (.ominas directory under</span>
<span class="comments">;the users home directory) are two types of kernel databases.</span>
<span class="comments">;Camera kernels (CKs) and Spacecraft and Planetary ephemeris</span>
<span class="comments">;kernels (SPKs) each have databases specified by directory:</span>
<span class="comments">;</span>
<span class="comments">;spice_ck_database.&lt;encoded path of ck directory></span>
<span class="comments">;spice_spk_database.&lt;encoded path of spk directory></span>
<span class="comments">;</span>
<span class="comments">;The encoded path is the actual path of the kernels</span>
<span class="comments">;with interior "/" replaced by "_" to avoid file directory</span>
<span class="comments">;structure issues.  The path can include a wildcard, </span>
<span class="comments">;i.e. can span several subdirectories.  In this case the </span>
<span class="comments">;wildcard "*" is replaced by a "x".  When a wildcard is </span>
<span class="comments">;included in a path for kernels, the database contains</span>
<span class="comments">;files for all applicable directories.</span>
<span class="comments">;</span>
<span class="comments">;------------------</span>
<span class="comments">;Example:</span>
<span class="comments">;</span>
<span class="comments">;If SPKs have the following structure...</span>
<span class="comments">;</span>
<span class="comments">;/user/kernels/cas/spk/ephem</span>
<span class="comments">;/user/kernels/cas/spk/tour</span>
<span class="comments">;</span>
<span class="comments">;One would specify the path as "/user/kernels/cas/spk/*"</span>
<span class="comments">;and the database would be</span>
<span class="comments">;</span>
<span class="comments">;spice_spk_database.user_kernels_cas_spk_x</span>
<span class="comments">;</span>
<span class="comments">;------------------</span>
<span class="comments">;</span>
<span class="comments">;The kernel database contains full-path names for all</span>
<span class="comments">;files in the kernel path.  It includes the range</span>
<span class="comments">;each file covers (ET seconds for SPK, Spacecraft clock</span>
<span class="comments">;ticks for CK) for valid kernel files, otherwise they</span>
<span class="comments">;contain the value -1.  For each file there is time</span>
<span class="comments">;information (if available, -1 if not) about the creation</span>
<span class="comments">;date of the file to use in kernel load ordering.  SPICE</span>
<span class="comments">;uses later loaded kernels to handle times which are</span>
<span class="comments">;defined in multiple kernel files.  The current</span>
<span class="comments">;implemetation has three times, the file system time</span>
<span class="comments">;returned by the operating system, the creation time</span>
<span class="comments">;read from a PDS label file, and a time read from the</span>
<span class="comments">;OMINAS installation timestamps file which attemps to</span>
<span class="comments">;store the time on the file from the source location.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;Kernel database creation</span>
<span class="comments">;------------------------</span>
<span class="comments">;</span>
<span class="comments">;The IDL methods to create them are</span>
<span class="comments">;</span>
<span class="comments">;spice_ck_build_db</span>
<span class="comments">;spice_spk_build_db</span>
<span class="comments">;</span>
<span class="comments">;Each has two arguments, the path of the kernels and</span>
<span class="comments">;an optional return of a structure of database contents.</span>
<span class="comments">;</span>
<span class="comments">;Since the range times stored in the database correspond</span>
<span class="comments">;to the internal times in the kernels, no leapsecond</span>
<span class="comments">;or sclk kernels are needed to create them.  However,</span>
<span class="comments">;the ICY library needs to be installed with dlm_register.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;Ordered Kernel files</span>
<span class="comments">;--------------------</span>
<span class="comments">;In order to retrieve an ordered list of kernel files</span>
<span class="comments">;to load for the SPICE calculations, two functions exist,</span>
<span class="comments">;one for each type of kernel:</span>
<span class="comments">;</span>
<span class="comments">;files = spice_ck_detect( ckpath, sc=xxx, time=xxx)</span>
<span class="comments">;files = spice_spk_detect( kpath, time=xxx )</span>
<span class="comments">;</span>
<span class="comments">;Both routines accept time as ET seconds as the time</span>
<span class="comments">;to use to deterimine kernel coverage.  This means</span>
<span class="comments">;that a leapseconds kernel and a sclk kernel needs</span>
<span class="comments">;to be loaded for the spice_ck_detect routine.  The</span>
<span class="comments">;CK routine also needs the NAIF spacecraft ID.  If</span>
<span class="comments">;no files are found an empty string is returned.</span>
<span class="comments">;</span>
<span class="comments">;Files returned are in order of creation according</span>
<span class="comments">;to the following.</span>
<span class="comments">;</span>
<span class="comments">;Once files are selected by applicability to the time</span>
<span class="comments">;input, values for the three different time systems</span>
<span class="comments">;are checked.  If PDS Label times exist for all files then</span>
<span class="comments">;the PDS Label time is used, if they don't exist for</span>
<span class="comments">;all the selected files then OMINAS timestamps are</span>
<span class="comments">;used if they exist for all selected files.  If not,</span>
<span class="comments">;operating system times are used.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;	spice_output</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 10/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; si_manage_kernels</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="si_manage_kernels:source"></a>pro si_manage_kernels, dd, prefix=prefix, pos=pos, reload=reload, $
                             constants=constants, time=time, status=status
 status = 0
<span class="comments">;;; need to give dirs in error messages</span>

 <span class="comments">;-----------------------------------------------------------------</span>
 <span class="comments">; if data descriptor already kernel list, load those kernels</span>
 <span class="comments">;-----------------------------------------------------------------</span>
 kernel_pool = cor_udata(dd, 'SPICE_KERNEL_POOL')
 if(keyword_set(kernel_pool)) then $
  begin
   spice_load, kernel_pool, /pool
   return
  end


 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; translator arguments</span>
 <span class="comments">;-----------------------------------------------</span>

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; /strict keywords</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 ck_strict = fix(tr_keyword_value(dd, 'ck_strict'))
 spk_strict = fix(tr_keyword_value(dd, 'spk_strict'))
 pck_strict = fix(tr_keyword_value(dd, 'pck_strict'))
 fk_strict = fix(tr_keyword_value(dd, 'fk_strict'))
 ik_strict = fix(tr_keyword_value(dd, 'ik_strict'))
 sck_strict = fix(tr_keyword_value(dd, 'sck_strict'))
 lsk_strict = fix(tr_keyword_value(dd, 'lsk_strict'))
 xk_strict = fix(tr_keyword_value(dd, 'xk_strict'))

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; /all keywords</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 ck_all = fix(tr_keyword_value(dd, 'ck_all'))
 spk_all = fix(tr_keyword_value(dd, 'spk_all'))
 pck_all = fix(tr_keyword_value(dd, 'pck_all'))
 fk_all = fix(tr_keyword_value(dd, 'fk_all'))
 ik_all = fix(tr_keyword_value(dd, 'ik_all'))
 sck_all = fix(tr_keyword_value(dd, 'sck_all'))
 lsk_all = fix(tr_keyword_value(dd, 'lsk_all'))
 xk_all = fix(tr_keyword_value(dd, 'xk_all'))

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; reverse keywords</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 reverse = fix(tr_keyword_value(dd, 'reverse'))

 ck_reverse = fix(tr_keyword_value(dd, 'ck_reverse'))
 spk_reverse = fix(tr_keyword_value(dd, 'spk_reverse'))
 pck_reverse = fix(tr_keyword_value(dd, 'pck_reverse'))
 fk_reverse = fix(tr_keyword_value(dd, 'fk_reverse'))
 ik_reverse = fix(tr_keyword_value(dd, 'ik_reverse'))
 sck_reverse = fix(tr_keyword_value(dd, 'sck_reverse'))
 lsk_reverse = fix(tr_keyword_value(dd, 'lsk_reverse'))
 xk_reverse = fix(tr_keyword_value(dd, 'xk_reverse'))

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; strict_priority</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 strict_priority = fix(tr_keyword_value(dd, 'strict_priority'))

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; protect keyword</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 protect = tr_keyword_value(dd, 'protect')


 <span class="comments">;-----------------------</span>
 <span class="comments">; manage kernel pool</span>
 <span class="comments">;-----------------------</span>
 if(NOT keyword_set(constants)) then $
  begin
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; Handle LS and SC kernels first.</span>
   <span class="comments">;  LS kernels are needed so that times can be compared in the kernel </span>
   <span class="comments">;   list file.</span>
   <span class="comments">;  SC kernels are needed for the ck and spk auto detect functions</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; load the kernel list file</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   klist = tr_keyword_value(dd, 'klist')
   if(keyword_set(klist)) then $
    if(strpos(klist, '/') EQ -1) then $
     begin
      kpath = spice_get_kpath('NV_SPICE_KER', klist)
      klist = kpath + '/' + klist
     end

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; first, look for lsk and sck files in the klist</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   lsk_in = spice_read_klist(dd, klist, prefix=prefix, /notime, ext='tls')
   sck_in = spice_read_klist(dd, klist, prefix=prefix, /notime, ext='tsc')

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; otherwise, check for lsk and sck keywords</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   if(NOT keyword_set(lsk_in)) then $
     lsk_in = spice_kernel_parse(dd, prefix, 'lsk', ext='tls', $
	      exp=lsk_exp, strict=lsk_strict, all=lsk_all, time=time)
   if(NOT keyword_set(sck_in)) then $
     sck_in = spice_kernel_parse(dd, prefix, 'sck', ext='tsc', $
	      exp=sck_exp, strict=sck_strict, all=sck_all, time=time)

   if(NOT keyword_set(lsk_in)) then nv_message, 'No leap-second kernels.'
   if(NOT keyword_set(constants)) then $
       if(NOT keyword_set(sck_in)) then nv_message, 'No spacecraft clock kernels.'

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; load lsk if found</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   k_in = lsk_in
   if(keyword_set(sck_in)) then k_in = [k_in, sck_in]

   spice_sort_kernels, k_in, $
     reload=reload, reverse=reverse, protect=protect, $
     lsk_in=lsk_in, lsk_exp=lsk_exp, $
     sck_in=sck_in, sck_exp=sck_exp, $
     kernels_to_load=k_to_load, kernels_to_unload=k_to_unload, $
     lsk_reverse=lsk_reverse, sck_reverse=sck_reverse
   spice_load, k_to_load

   if(defined(time)) then $
       if(size(time, /type) EQ 7) then time = spice_str2et(time) 

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  </span>
   <span class="comments">; kernel list file</span>
   <span class="comments">;  Kernels are read from this file and inserted into the kernel list</span>
   <span class="comments">;  in front of the kernels input using translator keywords.  </span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
   k_in = spice_read_klist(dd, klist, time=time, prefix=prefix)
  end


 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; kernel input keywords</span>
 <span class="comments">;  Each type of kernel may be specified using a keyword named as &lt;type>_in; </span>
 <span class="comments">;  e.g., "ck_in".  These kernels are appended to the kernel list after those </span>
 <span class="comments">;  read from the kernel list file, so they take precedence.</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
 ck_in = ''
 if(NOT keyword_set(pos) AND (NOT keyword_set(od))) then $
   if(NOT keyword_set(constants)) then $
     ck_in = spice_kernel_parse(dd, prefix, 'ck', ext='bc', $
	       exp=ck_exp, strict=ck_strict, all=ck_all, time=time)

 if(NOT keyword_set(constants)) then $
   spk_in = spice_kernel_parse(dd, prefix, 'spk', ext='bsp', $
        	exp=spk_exp, strict=spk_strict, all=spk_all, time=time)

 pck_in = spice_kernel_parse(dd, prefix, 'pck', ext='tpc', $
		  exp=pck_exp, strict=pck_strict, all=pck_all, time=time)
 fk_in = spice_kernel_parse(dd, prefix, 'fk', ext='tf', $
		  exp=fk_exp, strict=fk_strict, all=fk_all, time=time)
 ik_in = spice_kernel_parse(dd, prefix, 'ik', ext='ti', $
		  exp=ik_exp, strict=ik_strict, all=ik_all, time=time)
 xk_in = spice_kernel_parse(dd, prefix, 'xk', $
		  exp=xk_exp, strict=xk_strict, all=xk_all, time=time)


 all_kernels = ''
 if(keyword_set(k_in)) then all_kernels = append_array(all_kernels, k_in)
 if(keyword_set(ck_in)) then all_kernels = append_array(all_kernels, ck_in)
 if(keyword_set(spk_in)) then all_kernels = append_array(all_kernels, spk_in)
 if(keyword_set(pck_in)) then all_kernels = append_array(all_kernels, pck_in)
 if(keyword_set(fk_in)) then all_kernels = append_array(all_kernels, fk_in)
 if(keyword_set(ik_in)) then all_kernels = append_array(all_kernels, ik_in)
 if(keyword_set(sck_in)) then all_kernels = append_array(all_kernels, sck_in)
 if(keyword_set(lsk_in)) then all_kernels = append_array(all_kernels, lsk_in)
 if(keyword_set(xk_in)) then all_kernels = append_array(all_kernels, xk_in)

 <span class="comments">;-----------------------------------------------------------------</span>
 <span class="comments">; Determine kernels to load / unload.  If no kernels specified, </span>
 <span class="comments">; the pool is left untouched.</span>
 <span class="comments">;-----------------------------------------------------------------</span>
 spice_sort_kernels, all_kernels, $
   reload=reload, reverse=reverse, protect=protect, $
   k_in=k_in, ck_in=ck_in, spk_in=spk_in, pck_in=pck_in, $
   fk_in=fk_in, ik_in=ik_in, sck_in=sck_in, lsk_in=lsk_in, xk_in=xk_in, $
   ck_exp=ck_exp, spk_exp=spk_exp, pck_exp=pck_exp, $
   fk_exp=fk_exp, ik_exp=ik_exp, sck_exp=sck_exp, lsk_exp=lsk_exp, xk_exp=xk_exp, $
   kernels_to_load=kernels_to_load, kernels_to_unload=kernels_to_unload, $
   ck_reverse=ck_reverse, spk_reverse=spk_reverse, pck_reverse=pck_reverse, $
   fk_reverse=fk_reverse, ik_reverse=ik_reverse, sck_reverse=sck_reverse, $
   lsk_reverse=lsk_reverse, xk_reverse=xk_reverse, strict_priority=strict_priority

 <span class="comments">;-----------------------------------------</span>
 <span class="comments">; load/unload kernels</span>
 <span class="comments">;-----------------------------------------</span>
 spice_load, kernels_to_load, uk_in=kernels_to_unload
<span class="comments">;  spice_cull</span>


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; si_get</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="si_get:source"></a>function si_get, dd, keyword, prefix, od=od, time=__time, status=status

 if(keyword_set(__time)) then time = __time

 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; translator arguments</span>
 <span class="comments">;-----------------------------------------------</span>

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; obs</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 obs = tr_keyword_value(dd, 'obs')
 if(str_isnum(obs) EQ 0) then obs = long(obs)

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; pos</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 pos = tr_keyword_value(dd, 'pos')

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; ref</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 ref = tr_keyword_value(dd, 'ref')
 if(NOT keyword_set(ref)) then ref = 'j2000'

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; j2000</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 j2000 = fix(tr_keyword_value(dd, 'j2000'))
 if(keyword_set(j2000)) then ref = 'j2000'

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; b1950</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 b1950 = fix(tr_keyword_value(dd, 'b1950'))
 if(keyword_set(b1950)) then ref = 'b1950'

 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; reload</span>
 <span class="comments">;  Force /reload if this call has a different prefix than the last one.</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
 reload = fix(tr_keyword_value(dd, 'reload'))
 if(keyword_set(last_prefix)) then if(prefix NE last_prefix) then reload = 1
 last_prefix = prefix

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; constants</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 constants = fix(tr_keyword_value(dd, 'constants'))
 if(keyword_set(constants)) then time = -1

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; name</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 name = tr_keyword_value(dd, 'name')
 if(keyword_set(name)) then names = name

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; time</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 _time = tr_keyword_value(dd, 'time')
 if(defined(_time)) then $
  begin
   if(keyword_set(_time)) then time = _time $
   else if((size(_time, /type) NE 7)) then time = _time
  end

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; nokernels</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 nokernels = fix(tr_keyword_value(dd, 'nokernels'))

 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; targets</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - -</span>
 targ_list = tr_keyword_value(dd, 'targets')
 if(NOT keyword_set(targ_list)) then $
  begin
   var = strupcase(prefix) + '_SPICE_TARGETS'
   targ_list = getenv(var)
  end 


 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; get time if needed</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
 if((NOT keyword_set(time)) AND keyword_set(od)) then $
  begin
   if(NOT cor_isa(od, 'BODY')) then $
    begin
     status = -1
     return, 0
    end
   time = bod_time(od)
  end


 <span class="comments">;---------------------------------------------------------------</span>
 <span class="comments">; manage kernels unless /nokernels</span>
 <span class="comments">;---------------------------------------------------------------</span>
 if(NOT keyword_set(nokernels)) then $
     si_manage_kernels, dd, prefix=prefix, pos=pos, reload=reload, $
                            constants=constants, time=time, status=status
 if(status NE 0) then return, !null


 if(defined(time)) then $
         if(size(time, /type) EQ 7) then time = spice_str2et(time)


 <span class="comments">;--------------------------</span>
 <span class="comments">; match keyword</span>
 <span class="comments">;--------------------------</span>
 case keyword of
  <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
  <span class="comments">; CAM_DESCRIPTORS</span>
  <span class="comments">;  Construct a descriptor for the relevant camera.</span>
  <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
  'CAM_DESCRIPTORS': $
	result = call_function(prefix + '_spice_cameras', time=time, pos=pos, $
                      constants=constants, dd, ref, n_obj=n_obj, dim=dim, $
                      status=status, orient=orient, obs=obs)

  <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
  <span class="comments">; PLT_DESCRIPTORS</span>
  <span class="comments">;  Construct descriptors for all planets, or for those requested.  </span>
  <span class="comments">;  Although the SUN is returned by NAIFLIB, it is not returned</span>
  <span class="comments">;  here unless specifically requested.</span>
  <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
  'PLT_DESCRIPTORS': $
	begin
         names0 = ''
         if(keyword_set(names)) then names0 = names
	 result = call_function(prefix + '_spice_planets', dd, ref, $
                     time=time, targ_list=targ_list, constants=constants, $
	             n_obj=n_obj, dim=dim, status=status, planets=names, obs=obs)
	 if(NOT keyword_set(result)) then status = -1 $
	 else if((where(names0 EQ 'SUN'))[0] EQ -1) then $
	  begin
	   names = cor_name(result)
  	   w = where(strupcase(names) EQ 'SUN')
	   if(w[0] NE -1) then $
            begin
             result = rm_list_item(result, w[0], only=nv_ptr_new())
             n_obj = n_obj - 1
            end
	  end
	end

  <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
  <span class="comments">; STR_DESCRIPTORS</span>
  <span class="comments">;  Construct descriptors for all stars.  The only star that would be </span>
  <span class="comments">;  returned by NAIFLIB is the sun.</span>
  <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
  'STR_DESCRIPTORS': $
	begin
         if(keyword_set(key8)) then $
          begin
           w = where(strpos(strupcase(key8), 'SUN') NE -1)
           if(w[0] EQ -1) then $
            begin
	     status = -1
	     result = 0
            end
          end 

	 if(status NE -1) then $
                result = call_function(prefix + '_spice_sun', dd, ref, $
	                       time=time, constants=constants, $
	                       n_obj=n_obj, dim=dim, status=status, obs=obs)
	end

  else: $
	begin
	 status = -1
	 result = 0
	end
 endcase

 if(NOT keyword_set(result)) then status = -1
	

 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
 <span class="comments">; Save kernel pool for this data descriptor</span>
 <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
 kernel_pool = cor_udata(dd, 'SPICE_KERNEL_POOL')
 if(NOT keyword_set(kernel_pool)) then $
  begin
   loaded_kernels = spice_loaded()
   if(keyword_set(loaded_kernels)) then $
             cor_set_udata, dd, 'SPICE_KERNEL_POOL', loaded_kernels
  end

 return, result
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; spice_input</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="spice_input:source"></a>function spice_input, dd, keyword, prefix, values=values, status=status, $
@nv_trs_keywords_include.pro
@nv_trs_keywords1_include.pro
	end_keywords
common spice_input_block, last_prefix

 status = 0
 n_obj = 0
 dim = [1]

 ndd = n_elements(dd)

 if((keyword NE ('CAM_DESCRIPTORS')) AND $
    (keyword NE ('PLT_DESCRIPTORS')) AND $
    (keyword NE ('STR_DESCRIPTORS'))) then $
  begin
   status = -1
   return, 0
  end

 if(NOT spice_test()) then $
  begin
   nv_message, /con, $
     'Aborting because the NAIF/SPICE interface not installed.'
   status = -1
   return, 0
  end


 <span class="comments">;------------------------------------------------------------</span>
 <span class="comments">; primary planet descriptors (key4) must not be present</span>
 <span class="comments">;------------------------------------------------------------</span>
 if(keyword_set(key4)) then $
  begin
   status = -1
   return, 0
  end

 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; observer descriptor passed as key1</span>
 <span class="comments">;-----------------------------------------------</span>
 if(keyword_set(key1)) then od = key1
 if(keyword_set(od) AND (keyword EQ 'CAM_DESCRIPTORS')) then $
  begin
   status = -1
   return, 0
  end
 if(NOT keyword_set(od)) then od = bytarr(ndd)

 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; default orientation passed as key3</span>
 <span class="comments">;-----------------------------------------------</span>
 if(keyword_set(key3)) then orient = key3
 
 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; object times passed as key7</span>
 <span class="comments">;-----------------------------------------------</span>
 if(defined(key7)) then $
  begin
   if(size(key7, /type) NE 7) then time = key7 $
   else if(keyword_set(key7)) then time = key7
  end

 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; object names passed as key8</span>
 <span class="comments">;-----------------------------------------------</span>
 if(keyword_set(key8)) then names = key8


 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; get descriptors for each dd</span>
 <span class="comments">;-----------------------------------------------</span>
 for i=0, ndd-1 do $
      result = append_array(result, si_get(dd[i], $
                         keyword, prefix, od=od[i], time=time, status=status))

 return, result
end
<span class="comments">;===========================================================================</span>
</code>
    </div>
  </body>
</html>