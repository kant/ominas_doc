<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 13:33:22 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>tascpds.pro (OMINAS Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="tascpds.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; NAME: TASCPDS   [Table ASCII PDS]</span>
<span class="comments">; </span>
<span class="comments">; PURPOSE: To read a PDS ascii table file into an IDL structure containing </span>
<span class="comments">;     columns of the data table as elements.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE: Result = TASCPDS (filename, label, objindex, [/SILENT])</span>
<span class="comments">; </span>
<span class="comments">; INPUTS:</span>
<span class="comments">;     Filename: Scalar string containing the name of the PDS file to read.</span>
<span class="comments">;     Label: String array containing the table header information.</span>
<span class="comments">;     Objindex: Integer specifying the starting index of teh current table</span>
<span class="comments">;         object in the label array to be read.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;     Result: Table structure constructed from designated records with fields</span>
<span class="comments">;         for each column in the table, along with a string array field </span>
<span class="comments">;         containing the name of each column.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT:</span>
<span class="comments">;     SILENT: Suppresses any messages from the procedure.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;     To read an ascii table file TABLE.LBL into a structure "table":</span>
<span class="comments">;         IDL> label = HEADPDS ('TABLE.LBL', /SILENT)</span>
<span class="comments">;         IDL> table = TASCPDS ('TABLE.LBL', label, /SILENT)</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;     Functions: OBJPDS, GET_INDEX, CLEAN, REMOVE, STR2NUM, PDSPAR, POINTPDS</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;     Written by: John D. Koch [December 1994] (adapted from READFITS by</span>
<span class="comments">;                                               Wayne Landsman)</span>
<span class="comments">;     Re-written by: Puneet Khetarpal [08 July, 2004] </span>
<span class="comments">;     </span>
<span class="comments">;     Modifications:</span>
<span class="comments">;     S. Martinez [11 February, 2009]. ROW_SUFFIX/PREFIX_BYTES data type changed to </span>
<span class="comments">;        unsigned long 64. Range of previous data type exceeded.</span>
<span class="comments">;        </span>
<span class="comments">;     To view a complete list of modifications made to this routine, </span>
<span class="comments">;     please see changelog.txt file.</span>
<span class="comments">;</span>
<span class="comments">;-----------------------------------------------------------------------------</span>

<span class="comments">;- level 2 -------------------------------------------------------------------</span>

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: the name variable is a viable required keyword scalar string,</span>
<span class="comments">;     label is a viable PDS label string array, and start and end_ind are</span>
<span class="comments">;     viable integers pointing at the start and end of the current table</span>
<span class="comments">;     object being processed.</span>
<span class="comments">; postcondition: extracts the "name" keyword from the label, stores it in a </span>
<span class="comments">;     structure, and returns to the main block.</span>

<a id="obtain_keyword:source"></a>function obtain_keyword, name, label, start_ind, end_ind
   <span class="comments">; initialize keyword structure:</span>
   struct = create_struct("flag",1)

   <span class="comments">; obtain keyword parameters:</span>
   val = pdspar (label, name, count=count, index=index)    <span class="comments">; external routine</span>

   <span class="comments">; if no viable params found, then issue error:</span>
   if (count eq 0) then begin
       print, "Error: missing required " + name + " keyword(s)."
       goto, endfun
   endif

   <span class="comments">; extract the indices where keyword index is between start_ind and end_ind:</span>
   pos = where (index gt start_ind and index lt end_ind, cnt)

   <span class="comments">; if none found then return flag as -1:</span>
   if (cnt eq 0) then goto, endfun

   <span class="comments">; store the viable values, indices, and count for "name" keyword:</span>
   val = val[pos]
   index = index[pos]
   count = n_elements(val)

   <span class="comments">; place the stored params in the structure:</span>
   struct = create_struct(struct,"val",val,"count",count,"index",index)
   return, struct

   endfun:
      struct.flag = -1
      return, struct
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: name is a structure containing all names param for current</span>
<span class="comments">;     table object, label is a viable PDS label string array, and start_ind</span>
<span class="comments">;     and end_ind are integer pointers to start and end of current object.</span>
<span class="comments">; postcondition: the table name is searched through all the name values and</span>
<span class="comments">;     then removed from the structure, the count is decremented by one, and</span>
<span class="comments">;     the index value is also removed from the corresponding structure field.</span>
<span class="comments">;</span>

<a id="remove_table_name:source"></a>function remove_table_name, name, label, start_ind, end_ind
    <span class="comments">; first obtain COLUMN object indices for current table object:</span>
    column = objpds(label, "COLUMN")                      <span class="comments">; external routine</span>
    pos = where (column.index gt start_ind and column.index lt end_ind)
    column.index = column.index[pos]

    <span class="comments">; check to see if the first name index is less than the first column</span>
    <span class="comments">; index value. If found then there exists a table name, and is removed:</span>
    if (name.index[0] lt column.index[0]) then begin
        temp = name.val[1:name.count - 1]
        name.val = ''
        name.val = temp
        
        temp = name.index[1:name.count - 1]
        name.index = ''
        name.index = temp
        
        name.count = name.count - 1
    endif

    <span class="comments">; clean up name array values, and removed unwanted characters:</span>
    param = ['"', "'", "(", ")"]
    for j = 0, name.count-1 do begin
        name.val[j] = clean (name.val[j])                 <span class="comments">; external routine</span>
        name.val[j] = remove (name.val[j], param)         <span class="comments">; external routine</span>
    endfor

    return, name
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: data_type is a structure containing the required keyword </span>
<span class="comments">;     params for DATA_TYPE keyword.</span>
<span class="comments">; postcondition: the data type keyword values are cleaned, and the values after</span>
<span class="comments">;     the first '_' character are extracted, if present. </span>
<span class="comments">;</span>

<a id="separate_table_data_type:source"></a>function separate_table_data_type, data_type
    <span class="comments">; set the param variable:</span>
    param = ['"', "'", ")", "("]

    <span class="comments">; start the loop to go through each data_type value array:</span>
    for j = 0, data_type.count - 1 do begin
        <span class="comments">; first clean data_type:</span>
        data_type.val[j] = clean (data_type.val[j], /space)  <span class="comments">; external routine</span>
        data_type.val[j] = remove (data_type.val[j], param)  <span class="comments">; external routine</span>

        <span class="comments">; extract the second component of value if '_' present:</span>
        if (!version.release gt 5.2) then begin
            temp = strsplit(data_type.val[j], '_', /extract)
        endif else begin
            temp = str_sep (data_type.val[j], '_')   <span class="comments">; obsolete in IDL v. > 5.2</span>
        endelse
        if (n_elements(temp) eq 3) then begin
            data_type.val[j] = temp[1] + '_' + temp[2] 
        endif else if (n_elements(temp) gt 1) then begin
            data_type.val[j] = temp[1]
        endif
    endfor

    return, data_type
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: keywds contains all required keyword values in a structure,</span>
<span class="comments">;     items contains all item keyword values, curr_ind and next_ind are </span>
<span class="comments">;     integer pointers to current and next column object being processed, and</span>
<span class="comments">;     curpos is an integer containing the current cursor position being</span>
<span class="comments">;     processed in the record.</span>
<span class="comments">; postcondition: the routine tests whether there are any table items for</span>
<span class="comments">;     current column object, and if found, then populates the necessary</span>
<span class="comments">;     item structure for current column object and returns to main block.</span>
<span class="comments">;     If no table items are found, then simply extracts the number of</span>
<span class="comments">;     bytes for current object and returns it as a bytarr.</span>

<a id="process_table_items:source"></a>function process_table_items, keywds, items, curpos, curr_ind, next_ind
    <span class="comments">; first determine whether there exist ITEMS for current COLUMN:</span>
        
    if (items.flag eq -1) then begin
        ipos = -1
    endif else begin
        ipos = where (items.items.index gt curr_ind and items.items.index lt $
                  next_ind)
    endelse

    <span class="comments">; if items not present then extract the number of bytes for current object:</span>
    if (ipos[0] eq -1) then begin
        <span class="comments">; determine the index for current bytes values to be assigned:</span>
        pos = where (keywds.bytes.index gt curr_ind and $
                     keywds.bytes.index lt next_ind)
        element = bytarr(long(keywds.bytes.val[pos[0]]))

        <span class="comments">; increment the cursor position by current bytes:</span>
        curpos = curpos + long(keywds.bytes.val[pos[0]])
    endif else begin
        <span class="comments">; if items are present, then create a secondary element bytarr </span>
        <span class="comments">; for each item, and start a temp cursor position for this column:</span>
        item_bytes = long(items.bytes.val[ipos[0]])
        element = bytarr(item_bytes)
        temppos = item_bytes

        <span class="comments">; check for offset keyword values. if offset is 0 then simply</span>
        <span class="comments">; set the item element structure to be element, else construct</span>
        <span class="comments">; a bytarr for offset buffer to be read, increment temppos, and</span>
        <span class="comments">; add the offset buffer to item element structure along with element:</span>
        if (items.offset.count eq 0) then begin
            item_offset = 0
        endif else begin
            item_offset = long(items.offset.val[ipos[0]])
        endelse
        if (item_offset eq 0) then begin
            item_elem = create_struct("element", element)
        endif else begin
            offtemp = bytarr(item_offset)
            temppos = temppos + item_offset
            item_elem = create_struct("element", element, "offtemp", offtemp)
        endelse

        <span class="comments">; now replicate the item element structure number of items - 1 times.</span>
        <span class="comments">; it is being replicated items - 1 times because of the offset buffer.</span>
        <span class="comments">; when there is an offset, the offset bytes do not carry after the</span>
        <span class="comments">; last item, so the item_elem structure constructed earlier would be</span>
        <span class="comments">; incorrect:</span>
        <span class="comments">;</span>
        <span class="comments">; 1/13/2010 : Some datasets use ITEMS = 1. Add logical branch to</span>
        <span class="comments">; handle this special case. If ITEMS = 1, we simply store item_elem</span>
        <span class="comments">; to element, and avoid the creation of special temporary elements.</span>
        num_items = long(items.items.val[ipos[0]])

        if num_items gt 1 then begin
            item_elem = replicate(item_elem, num_items - 1)

            <span class="comments">; multiply temppos by the number of items - 1:</span>
            temppos = temppos * (num_items - 1)

            <span class="comments">; create a temporary structure to hold last array element, and</span>
            <span class="comments">; increment temppos by item_bytes:</span>
            temp_struct = create_struct("element",element)
            temppos = temppos + item_bytes

            <span class="comments">; populate the column structure to act as the element to be read:</span>
            element = create_struct("item_elem",item_elem,"last",temp_struct)
        endif else begin
            element = create_struct("item_elem", item_elem)
        endelse

        <span class="comments">; finally increment main cursor position by temppos value:</span>
        curpos = curpos + temppos
    endelse

    <span class="comments">; add cursor position and element into column object structure:</span>
    object_struct = create_struct("curpos",curpos,"data",element)

    return, object_struct
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: element is an n dimensional bytarr data read from the file,</span>
<span class="comments">;     type contains the data type of the element being processed, and rows</span>
<span class="comments">;     is the number of rows in the table.</span>
<span class="comments">; postcondition: element is converted into the n dimensional array of type </span>
<span class="comments">;     "type", and returned to main block.</span>
<span class="comments">;</span>

<a id="convert_table_element:source"></a>function convert_table_element, element, type, rows
    <span class="comments">; error protection:</span>
    on_ioerror, error_case

    <span class="comments">; depending on the case of the type assign each element to its own</span>
    <span class="comments">; element conversion type:</span>
    data = create_struct("flag",1)
    stat = size(element)

    <span class="comments">; IDL has issues with converting from bytarr into string for n rows by 1 </span>
    <span class="comments">; column bytarr for n > 1, as a string conversion reduces the dimension of</span>
    <span class="comments">; the array by one. Therefore, when there are n rows GT 1, the number of</span>
    <span class="comments">; dimensions is 1, and the size of that one dimension is 1, then perform</span>
    <span class="comments">; a conversion into string, element by element. e.g., array is in format:</span>
    <span class="comments">; array = [[1], [2], [3], [4], [5]]:</span>
    if (type ne "N/A") then begin
        if (stat[0] eq 1 && stat[1] gt 1 && rows gt 1) then begin
            temp = strarr(stat[1])
            for i = 0, stat[1] - 1 do begin
                temp[i] = string(element[i])
            endfor
            element = temp
        endif else begin
            element = string(element)
        endelse
    endif

    case type of
                 "INTEGER": element = long(element)
        "UNSIGNED_INTEGER": element = long(element)
                    "REAL": element = double(element)
                   "FLOAT": element = float(element)
               "CHARACTER": element = string(element)
                  "DOUBLE": element = double(element)
                    "BYTE": element = long(element)
                 "BOOLEAN": element = long(element)
                    "TIME": element = string(element)
                    "DATE": element = string(element)
                     "N/A": <span class="comments">; no conversion performed, spare column</span>
                      else: begin
                                print, "Error: " + type + $
                                       " not a recognized data type!"
                                data.flag = -1
                                return, data
                            end                        
    endcase

    data = create_struct(data, "element",element)
    return, data

    error_case:
        on_ioerror, null
        print, !err_string
        <span class="comments">;stop</span>
        print, "WARNING: bad table data - no conversion performed" 
        data = create_struct(data, "element", element)
        return, data
end

<span class="comments">;- level 1 -------------------------------------------------------------------</span>

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: label is a viable PDS label string array, start_ind is the</span>
<span class="comments">;     index specifying the start of the current object, and end index its</span>
<span class="comments">;     end. Label must contain a valid ASCII table with INTERCHANGE format</span>
<span class="comments">;     keyword.</span>
<span class="comments">; postcondition: returns a boolean (1 or -1) depending on whether it finds</span>
<span class="comments">;     an ASCII interchange format keyword, or not.</span>
<span class="comments">;</span>

<a id="tasc_interform:source"></a>function tasc_interform, label, start_ind, end_ind
    <span class="comments">; obtain all INTERCHANGE_FORMAT keyword values from label:</span>
    interform = pdspar (label, "INTERCHANGE_FORMAT", count=cnt, index=int_ind)

    <span class="comments">; check whether there exist any interchange format keywords:</span>
    if (cnt eq 0) then begin
        print, "Error: missing required INTERCHANGE_FORMAT keyword"
        return, -1
    endif else begin
        <span class="comments">; obtain the indices of interchange format array object, where</span>
        <span class="comments">; they are between start and end index:</span>
        interpos = where (int_ind gt start_ind and int_ind lt end_ind, cnt2)

        <span class="comments">; extract the interform values:</span>
        interform = interform[interpos[0]]
        interform = interform[0]

        <span class="comments">; remove all white space, and remove the '"' chars if found:</span>
        interform = clean(interform,/space)            <span class="comments">; external routine</span>
        interform = remove(interform, '"')             <span class="comments">; external routine</span>

        <span class="comments">; if interchange format value is binary, then return -1 with error:</span>
        if (interform eq "BINARY") then begin
            print, "Error: This is binary table file; try TBINPDS."
            return, -1
        endif
    endelse
    <span class="comments">; if all goes well, then return 1:</span>
    return, 1
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: label is a viable PDS label string array, and start_ind and</span>
<span class="comments">;     end_ind are valid integers specifying the start and end of the </span>
<span class="comments">;     current table object as index pointers in the string array.</span>
<span class="comments">; postcondition: extracts required keywords for table object in the label.</span>
<span class="comments">;</span>

<a id="obtain_table_req:source"></a>function obtain_table_req, label, start_ind, end_ind
    <span class="comments">; initialize keyword structure:</span>
    keywds = create_struct("flag",1)

    <span class="comments">; obtain table object definitions for current object:</span>
    <span class="comments">; extract the keyword structure from subroutine, and check whether</span>
    <span class="comments">; there are any params for the keyword, if not then return to main block</span>
    <span class="comments">; else store the value</span>

    <span class="comments">; first obtain number of COLUMNS:</span>
    columns_num = obtain_keyword("COLUMNS", label, start_ind, end_ind)
    if (columns_num.flag eq -1) then goto, endfun
    columns = fix(columns_num.val[0])

    <span class="comments">; obtain ROW_BYTES keyword:</span>
    row_bytes = obtain_keyword("ROW_BYTES",label, start_ind, end_ind)
    if (row_bytes.flag eq -1) then goto, endfun
    row_bytes = long(row_bytes.val[0])

    <span class="comments">; obtain ROWS keyword:</span>
    rows = obtain_keyword("ROWS", label, start_ind, end_ind)
    if (rows.flag eq -1) then goto, endfun
    rows = long(rows.val[0])

    <span class="comments">; obtain RECORD_BYTES keyword:</span>
    record_bytes = obtain_keyword("RECORD_BYTES", label, 0, end_ind)
    if (record_bytes.flag eq -1) then goto, endfun
    record_bytes = long(record_bytes.val[0])

    <span class="comments">; check whether either columns, rows or row_bytes equal 0:    </span>
    if ((columns le 0) or (rows le 0) or (row_bytes le 0)) then begin
        print, "Error: ROWS OR ROW_BYTES or COLUMNS &lt;= 0. No data read."
        goto, endfun
    endif

    <span class="comments">; obtain information for each column object:</span>

    <span class="comments">; obtain NAME keyword:</span>
    name = obtain_keyword("NAME", label, start_ind, end_ind)
    if (name.flag eq -1) then goto, endfun

    <span class="comments">; remove table name from name structure if present:</span>
    name = remove_table_name(name, label, start_ind, end_ind)

    <span class="comments">; obtain DATA_TYPE keyword, then clean, separate, and extract it:</span>
    data_type = obtain_keyword("DATA_TYPE", label, start_ind, end_ind)
    if (data_type.flag eq -1) then goto, endfun

    <span class="comments">; obtain data architecture and separate data type:</span>
    data_type = separate_table_data_type(data_type)

    <span class="comments">; obtain BYTES keyword:</span>
    bytes = obtain_keyword ("BYTES", label, start_ind, end_ind)
    if (bytes.flag eq -1) then goto, endfun

    <span class="comments">; obtain START_BYTE keyword, and subtract 1 for IDL indexing:</span>
    start_byte = obtain_keyword("START_BYTE", label, start_ind, end_ind)
    if (start_byte.flag eq -1) then goto, endfun
    start_byte.val = long(start_byte.val) - 1

    <span class="comments">; store values into the keyword structure:</span>
    keywds = create_struct(keywds, "columns",columns,"row_bytes",row_bytes, $
                           "rows",rows,"name",name,"data_type",data_type, $
                           "bytes",bytes,"start_byte",start_byte, $
                           "record_bytes",record_bytes)

    return, keywds

    endfun:
       keywds.flag = -1
       return, keywds
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: label is a viable PDS label string array, start_ind and end_ind</span>
<span class="comments">;     are integer pointers to start and end of current table in label.</span>
<span class="comments">; postcondition: obtains the optional table keywords from the label, and </span>
<span class="comments">;     returns them in a structure.</span>

<a id="obtain_tasc_opt:source"></a>function obtain_tasc_opt, label, start_ind, end_ind
    <span class="comments">; initialize structure:</span>
    keywds = create_struct("flag", 1, "prefix", 0ULL, "suffix", 0ULL)

    <span class="comments">; obtain ROW_PREFIX_BYTES keyword:</span>
    rowprefix = pdspar (label, "ROW_PREFIX_BYTES", count=pcount, index=pindex)
    if (pcount gt 0) then begin
        pos = where (pindex gt start_ind and pindex lt end_ind, cnt)
        if (cnt gt 0) then begin
            keywds.prefix = ulong64(rowprefix[pos[0]])
            if (keywds.prefix lt 0) then begin
                print, "Error: invalid ROW_PREFIX_BYTES (" + $
                       clean(string(keywds.prefix), /space) + ")."
                goto, endfun
            endif
        endif
    endif

    <span class="comments">; obtain ROW_SUFFIX_BYTES keyword:</span>
    rowsuffix = pdspar (label, "ROW_SUFFIX_BYTES", count=scount, index=sindex)
    if (scount gt 0) then begin
        pos = where (sindex gt start_ind and sindex lt end_ind, cnt)
        if (cnt gt 0) then begin
            keywds.suffix = ulong64(rowsuffix[pos[0]])
            if (keywds.suffix lt 0) then begin
                print, "Error: invalid ROW_SUFFIX_BYTES (" + $
                       clean(string(keywds.suffix), /space) + ")."
                goto, endfun
            endif
        endif
    endif

    return, keywds

    endfun:
        keywds.flag = -1
        return, keywds
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: label is viable PDS label string array, req_keywds is a </span>
<span class="comments">;     structure containing required table object keywords, and start and </span>
<span class="comments">;     end_ind are viable integer pointers to start and end of the current</span>
<span class="comments">;     table object.</span>
<span class="comments">; postcondition: Extracts table items keyword params from label and returns</span>
<span class="comments">;     to main block as a structure.</span>

<a id="obtain_table_items:source"></a>function obtain_table_items, label, req_keywds, start_ind, end_ind
    <span class="comments">; initialize items keyword structure:</span>
    keywds = create_struct("flag", 1, "flag2", 1)

    <span class="comments">; obtain necessary ITEM keyword values:</span>
    <span class="comments">; first obtain ITEMS keyword values:</span>
    items = pdspar (label, "ITEMS", count=items_count, index=items_index)
    if (items_count eq 0) then begin
        goto, endfun
    endif

    <span class="comments">; extract values of items between start_ind and end_ind, and store:</span>
    pos = where (items_index gt start_ind and items_index lt end_ind, cnt)
    if (cnt eq 0) then goto, endfun
    items = create_struct("val",items[pos],"count",n_elements(items), $
                          "index",items_index[pos])

    <span class="comments">; now we know that there are columns with ITEMS keyword in current table</span>
    <span class="comments">; object, so extract the other item keyword values:</span>

    <span class="comments">; obtain ITEM_BYTES keyword values:</span>
    bytes = pdspar (label, "ITEM_BYTES", count=byte_count, index=byte_index)
    if (byte_count eq 0) then begin
        print, "Error: missing required ITEM_BYTES keyword for items column."
        keywds.flag2 = -1
        goto, endfun
    endif
    pos = where (byte_index gt start_ind and byte_index lt end_ind, cnt)
    if (cnt eq 0) then begin
        print, "Error: missing required ITEM_BYTES keyword for current table."
        keywds.flag2 = -1
        goto, endfun
    endif
    bytes = create_struct("val", bytes[pos], "count", n_elements(bytes), $
                          "index", byte_index[pos])

    <span class="comments">; initialize a temp structure to hold default values:</span>
    temp = create_struct("val",0,"count",0,"index",0)

    <span class="comments">; obtain ITEM_OFFSET keyword values, if present:</span>
    offset = pdspar (label, "ITEM_OFFSET", count=off_count, index=off_index)

    <span class="comments">; if there exist ITEM_OFFSET keywords, then obtain ones between</span>
    <span class="comments">; start and end_ind else set it to temp structure:</span>
    if (off_count gt 0) then begin
        pos = where (off_index GT start_ind AND off_index LT end_ind, cnt)
        if (cnt eq 0) then begin
            offset = temp
        endif else begin
            offset = create_struct("val", long(offset[pos]), "count", $
                                   n_elements(offset),"index",off_index[pos])
            <span class="comments">; since the offset values in the PDS label are given as the </span>
            <span class="comments">; number of bytes from the beginning of a one item to the</span>
            <span class="comments">; beginning of next, therefore, the offset that we are concerned</span>
            <span class="comments">; with is the difference between the end of one item and the</span>
            <span class="comments">; beginning of next:</span>
            offset.val = long(offset.val) - long(bytes.val)
            lt_zero = where(offset.val lt 0, lt_cnt)
            if (lt_cnt gt 0) then begin
                print, "Error: invalid ITEM_OFFSET value, must be >=ITEM_BYTES"
                keywds.flag2 = -1
                goto, endfun
            endif
        endelse
    endif else offset = temp

    <span class="comments">; store info into a structure:</span>
    keywds = create_struct(keywds, "items",items, "bytes",bytes,"offset", $
                           offset)
    return, keywds 

    endfun:
        keywds.flag = -1
        return, keywds
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: keywds contains required keywords for current table object,</span>
<span class="comments">;     items contains items keywords for current table object, label is a </span>
<span class="comments">;     viable PDS label string array, start_ind and end_ind are integer</span>
<span class="comments">;     pointers to start and end of current table object</span>
<span class="comments">; postcondition: creates a structure to be read from the data file and returns</span>
<span class="comments">;     to the main block.</span>

<a id="create_table_struct:source"></a>function create_table_struct, keywds, opt, items, label, start_ind, end_ind
    <span class="comments">; initialize variables:</span>
    curpos = 0            <span class="comments">; cursor position</span>
    complete_set = create_struct("flag", 1)      <span class="comments">; structure to be returned</span>
    data_set = 0          <span class="comments">; data structure set</span>

    <span class="comments">; create structure for row prefix bytes if any:</span>
    if (opt.prefix gt 0) then begin
        data_set = create_struct("prefix", bytarr(opt.prefix))
    endif

    <span class="comments">; start the loop:</span>
    for j = 0, keywds.columns - 1 do begin
        
        <span class="comments">; set current and next COLUMN object index pointers:</span>
        curr_ind = keywds.name.index[j]
        if (j eq keywds.columns - 1) then begin
            next_ind = end_ind
        endif else begin
            next_ind = keywds.name.index[j+1]
        endelse

        <span class="comments">; name of current column:</span>
        name = "COLUMN" + clean(string(j+1),/space)     <span class="comments">; external routine</span>
        <span class="comments">; extract start byte value for current column:</span>
        start_byte = long(keywds.start_byte.val[j])

        <span class="comments">; the temp buffer to be read is: difference between start_byte of</span>
        <span class="comments">; current column and last curpos:</span>
        buffer_length = start_byte - curpos
        if (buffer_length lt 0) then begin
            print, "Error: inconsistent START_BYTE and BYTES specification" + $
                   " in COLUMNS " + clean(string(j),/space) + " and " + $
                   clean(string(j+1), /space) + "."
            goto, endfun
        endif else if (buffer_length eq 0) then begin
            temp = -1            
        endif else begin
            temp = bytarr (buffer_length)
            curpos = start_byte
        endelse

        <span class="comments">; process item objects for current COLUMN object:</span>
        element = process_table_items (keywds, items, curpos,curr_ind,next_ind)

        <span class="comments">; create column structure:</span>
        if (temp[0] eq -1) then begin
            col_struct = create_struct ("element", element.data)
        endif else begin
            col_struct = create_struct ("temp", temp, "element", element.data)
        endelse

        <span class="comments">; construct structure to be read:</span>
        if (size(data_set,/type) eq 8) then begin
            data_set = create_struct(data_set, name, col_struct)
        endif else begin
            data_set = create_struct(name, col_struct)
        endelse
    endfor

    <span class="comments">; accomodate for row bytes</span>
      bytescheck = (opt.suffix gt 0) ? keywds.row_bytes : keywds.row_bytes - 2
    <span class="comments">; *** added for testing*** bytescheck = keywds.row_bytes</span>
    <span class="comments">; set additional buffer array at end of record:</span>
    <span class="comments">; if cursor position &lt; bc then take the difference between bc and curpos</span>
    <span class="comments">; and create a temporary buffer to be read at the end of each record.</span>
    <span class="comments">; if cursor position > bc then issue error, and exit routine:</span>
    <span class="comments">; Following if statements were restructured to remove BYTE specification problem - Parin K</span>
    if (bytescheck gt curpos) then begin
        diff = bytescheck - curpos
        data_set = create_struct(data_set, "temp", bytarr(diff))
        if (opt.suffix gt 0) then begin
            data_set = create_struct(data_set, "suffix", bytarr(opt.suffix))
        endif
    endif 
    if (bytescheck eq curpos) then begin
        <span class="comments">; check for row suffix bytes:</span>
        if (opt.suffix gt 0) then begin
            data_set = create_struct(data_set,"suffix", bytarr(opt.suffix))
        endif
    endif
    if (bytescheck lt curpos) then begin
            print, "Error: Improper START_BYTE or BYTES specification"
            print, "in PDS label, or data file missing carriage return"
            print, "and/or line feed characters."
            goto, endfun
    endif

    <span class="comments">; set the CR and LF structure elements if needed:</span>
    if (opt.suffix eq 0) then begin
        data_set = create_struct(data_set, "crlf", bytarr(2))
    endif 

    <span class="comments">; replicate data structure ROWS times and construct the complete data structure:</span>
    complete_set = create_struct (complete_set, "data_set", replicate (data_set, keywds.rows))

    return, complete_set

    endfun:
        complete_set.flag = -1
        return, complete_set
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: pointer is a structure containing viable pointer information</span>
<span class="comments">;     for current table object, data_struct contains the data structure to</span>
<span class="comments">;     be read from file, keywds contains all the required keyword info, and </span>
<span class="comments">;     silent is set to either 0 or 1 depending on the function specification.</span>
<span class="comments">; postcondition: this subroutine reads the data from the pointer datafile</span>
<span class="comments">;     and returns the data structure.</span>
<span class="comments">;</span>

<a id="read_table_data:source"></a>function read_table_data, pointer, data_struct, keywds, silent
    <span class="comments">; error protection:</span>
    on_ioerror, signal

    bigflag = 1
    <span class="comments">; construct data_set structure:</span>
    data_set = create_struct("flag", 1)

    <span class="comments">; first inform user of status:</span>
    if (silent eq 0) then begin
        text = clean(string(keywds.columns), /space) + " Columns and " + $
               clean(string(keywds.rows), /space) + " Rows" <span class="comments">; external routine</span>
        print, "Now reading table with " + text
    endif

    <span class="comments">; now open file and read data after setting the file pointer to skip:</span>
    openr, unit, pointer.datafile, /get_lun
    point_lun, unit, pointer.skip
    readu, unit, data_struct
    close, unit
    free_lun, unit
    
    data_set = create_struct(data_set, "data", temporary(data_struct))

    return, data_set

    signal:
        on_ioerror, null
        print, "Error: File either corrupted or bad PDS label."
        data_set.flag = -1
        close, unit
        free_lun, unit
        return, data_set
end


<span class="comments">;- level 0 -------------------------------------------------------------------</span>

<a id="tascpds:source"></a>function tascpds, fname, label, objindex, SILENT=silent
    <span class="comments">; error protection:</span>
    <span class="comments">;on_error, 2</span>

    <span class="comments">; check for number of parameters in function call:</span>
    if (n_params() lt 3) then begin
        print, "Syntax: result = tascpds (filename,label,objindex[,/SILENT])"
        return, -1
    endif

    <span class="comments">; check for silent keyword:</span>
    silent = keyword_set(SILENT)

    <span class="comments">; obtain viable objects for label:</span>
    objects = objpds(label, "ALL")                         <span class="comments">; external routine</span>
    if (objects.flag eq -1) then begin
        print, "Error: No viable TABLE objects found in label."
        return, -1
    endif

    <span class="comments">; match the indices of all viable objects against objindex:</span>
    objpos = where (objindex eq objects.index)

    <span class="comments">; if a match is found, then store the name of that object, else </span>
    <span class="comments">; indicate the specification of invalid objindex:</span>
    if (objpos[0] ne -1) then begin
        objects.array = objects.array[objpos[0]]
        objectname = objects.array[0]
    endif else begin
        print, "Error: Invalid objindex specified: " + $
             clean(string(objects.index[objpos[0]]), /space)
        return, -1
    endelse

    <span class="comments">; set start and end object pointers for current table object:</span>
    start_ind = objindex
    end_ind = get_index(label, start_ind)                  <span class="comments">; external routine</span>
    if (end_ind eq -1) then return, -1

    <span class="comments">; check for valid interchange format using subroutine:</span>
    if (tasc_interform(label, start_ind, end_ind) eq -1) then return, -1

    <span class="comments">; obtain required keywords for the current object:</span>
    req_keywds = obtain_table_req(label, start_ind, end_ind)   <span class="comments">; subroutine</span>
    if (req_keywds.flag eq -1) then return, -1

    <span class="comments">; obtain optional keywords for current object:</span>
    opt_keywds = obtain_tasc_opt(label, start_ind, end_ind)    <span class="comments">; subroutine</span>
    if (opt_keywds.flag eq -1) then return, -1

    <span class="comments">; obtain items keywords for the column objects using subroutine:</span>
    items = obtain_table_items(label, req_keywds, start_ind, end_ind)
    if (items.flag2 eq -1) then return, -1

    <span class="comments">; obtain pointer information for table object:</span>
    pointer = pointpds (label, fname, objectname)          <span class="comments">; external routine</span>
    if (pointer.flag EQ -1) then return, -1

    <span class="comments">; create data structure to be read:</span>
    complete_set = create_table_struct (req_keywds, opt_keywds, items, label, $
                                        start_ind, end_ind)    <span class="comments">; subroutine</span>
    if (complete_set.flag eq -1) then begin
        return, -1
    endif else begin
        data_struct = complete_set.data_set
    endelse

    <span class="comments">; read data structure from file using subroutine:</span>
    data_set = read_table_data (pointer, data_struct, req_keywds, silent)
    if (data_set.flag eq -1) then return, -1

    <span class="comments">; check for CR and LF chars</span>
    if (opt_keywds.suffix gt 0) then begin
        cr_arr = data_set.data.suffix
    endif else begin
        cr_arr = data_set.data.crlf
    endelse

    <span class="comments">; find the positions where the cr and lf chars are present in struct:</span>
    crpos = where (cr_arr eq 13B, crcount)
    lfpos = where (cr_arr eq 10B, lfcount)

    <span class="comments">; since data is an array of structures for each record, therefore, the </span>
    <span class="comments">; cr and lf chars must equal the number of elements in the structure array:</span>
    if ((crcount ne n_elements(data_set.data)) && $
        (lfcount ne n_elements(data_set.data))) then begin

        <span class="comments">;Modified A.Cardesin 02 Jun 2005</span>
        <span class="comments">;print ROW number, to be able to verify the file easily</span>

        print, "Error in ROW: ",lfcount+1
        print, "Error in table: Insufficient number of carriage return "+ $
               "and line feed characters found. Carriage return and " + $
               "line feed characters should terminate each line."
        CRLFflag = -1
    endif else begin
        CRLFflag = 1
    endelse

    if (CRLFflag eq -1) then begin
        return, -1
    endif

    <span class="comments">; separate data into columns and convert into appropriate type:</span>

    data_set_org = create_struct("flag", 1)
    name_val = req_keywds.name.val[0:req_keywds.name.count-1]
    data_struct = create_struct("names", name_val)
    rows = req_keywds.rows

    <span class="comments">; go through each column and convert data structure into array:</span>
    for i = 0, req_keywds.columns - 1 do begin
        <span class="comments">; get the column title and data type:</span>
        title = "column" + clean(i + 1,/space)
        type = req_keywds.data_type.val[i]

        <span class="comments">; obtain the ith tag's element and store it as temp element, and </span>
        <span class="comments">; determine the type of object element is, i.e., a structure, array:</span>
        if (size(data_set.data.(0), /type) ne 8) then begin
            element = data_set.data.(i+1).element
        endif else begin
            element = data_set.data.(i).element
        endelse
        stat = size(element, /type)

        <span class="comments">; check to see if current column is a structure:</span>
        if (stat eq 8) then begin
            <span class="comments">; perform conversion of the element into arrays using subroutine:</span>
            stat = size(element.item_elem.element)

            if float(strtrim(items.items.val[i],1)) ne 1 then begin
                combo = bytarr(stat[1], stat[2] + 1, stat[3])
                combo[*, 0:stat[2] - 1, *] = element.item_elem.element
                combo[*, stat[2], *] = element.last.element
            endif else begin
                combo = bytarr(stat[1], stat[2], stat[3])
                combo = element.item_elem.element
            endelse
            temp = convert_table_element(combo, type, rows)    <span class="comments">; subroutine</span>
        endif else begin
            temp = convert_table_element(element, type, rows)  <span class="comments">; subroutine</span>
        endelse
        
        <span class="comments">; if conversion not successful then return to main block with flag:</span>
        if (temp.flag eq 1) then begin
            element = temp.element
        endif else begin
            data_set.flag = -1
            BREAK
        endelse

        <span class="comments">; add to data structure:</span>
        data_struct = create_struct(temporary(data_struct), temporary(title), temporary(element))
    endfor

    if (data_set.flag eq 1) then begin
        return, data_struct
    endif else begin
        return, -1
    endelse
end
</code>
    </div>
  </body>
</html>