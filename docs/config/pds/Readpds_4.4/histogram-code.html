<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 13:33:17 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>histogram.pro (OMINAS Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="histogram.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; Notes: 1d & 2d mix for contour plots</span>
<span class="comments">; Let user decide contour levels</span>

<span class="comments">;------------------------------------------------------------------------------</span>
<span class="comments">;- Normal Functions -----------------------------------------------------------</span>
<span class="comments">;------------------------------------------------------------------------------</span>

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Removes a tag from a structure                      ;;;</span>
<span class="comments">;;; Pre-Condition : Must enter a valid structure and tag name           ;;;</span>
<span class="comments">;;; Post-Condition: Returns the structure without the supplied tag name ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<a id="rm_tag:source"></a>function rm_tag, input, badtag
   all_tags = get_tags(input)                                     <span class="comments">; Get all the tags for the input structure</span>
   top_tags = strarr(n_elements(all_tags))                        <span class="comments">; Findthe parent tag name (since all_tags may return badtag.XXX)</span>

   for z=0,n_elements(all_tags)-1,1 do begin
      spltarr = strsplit(all_tags[z],'.',/extract)
      top_tags[z] = spltarr[0]
   endfor

   bad      = [strupcase(badtag),"."+strupcase(badtag)]           <span class="comments">; Store the possible bad tag structures</span>

   tmpstr   = input                                               <span class="comments">; Create a temporary copy of the structure</span>
   goodind  = where(top_tags NE bad[0] AND all_tags NE bad[1])    <span class="comments">; Find where the GOOD tags are</span>
   newtags  = all_tags[goodind]                                   <span class="comments">; Save a list of all the good tags</span>

   exstr = "output = create_struct("
   for a=0,n_elements(newtags)-1,1 do begin
      exstr = exstr + '"'+strmid(newtags[a],1)+'",tmpstr'+newtags[a]+','
   endfor
   exstr = strmid(exstr,0,strlen(exstr)-1)+")"

print,exstr

   void = EXECUTE(exstr)
   return,output
end

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Creates a 2D Array containing input to CONTOUR               ;;;</span>
<span class="comments">;;; Pre-Condition : A cache variable that contains the substructure "indices"    ;;;</span>
<span class="comments">;;;                 "indices" is a 2xN array with the (X,Y) coordinates of every ;;;</span>
<span class="comments">;;;                 selected item in the table. Used for testing if current tab  ;;;</span>
<span class="comments">;;;                 has selected values. This is a bit of a hold over from a     ;;;</span>
<span class="comments">;;;                 previous version.                                            ;;;</span>
<span class="comments">;;; Post-Condition: Returns a 2D Array with table values to go into CONTOUR.     ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<a id="makecon:source"></a>function makecon, cache, itr,shiftx,shifty
   indtab = "IND"+strtrim(string(itr),1)
   stat   = tag_exist(cache.indices,indtab)           <span class="comments">; Return Boolean value on whether cache.indices exists</span>

   IF stat EQ 1 THEN BEGIN
      WIDGET_CONTROL, cache.tablelist[itr], GET_VALUE=value, /USE_TABLE_SELECT   <span class="comments">; Get table value for current coordinate</span>
      
      indarr = WIDGET_INFO(cache.tablelist[itr], /TABLE_SELECT)

      xmin   = min(indarr[0,*])
      ymin   = min(indarr[1,*])
      xdim   = max(indarr[0,*])-min(indarr[0,*])+1    <span class="comments">; Find the X-Dimensions of contour array by taking span of selected indices</span>
      ydim   = max(indarr[1,*])-min(indarr[1,*])+1    <span class="comments">; Find the Y-Dimensions of contour array by taking range of selected indices</span>
      
      xdim   = xdim + shiftx
      ydim   = ydim + shifty

      output = fltarr(xdim,ydim)

      cache.conoff[*,itr] = [xmin,ymin]

      for a=0L,n_elements(indarr[0,*])-1,1 do begin
         ix = indarr[0,a] - xmin                      <span class="comments">; Shift the x index to fit within range of new table</span>
         iy = indarr[1,a] - ymin                      <span class="comments">; Shift the y index to fit within range of new table</span>

         output[ix+shiftx,iy+shifty] = value[a]
      endfor

      return,output
   ENDIF ELSE BEGIN
      return,-1
   ENDELSE
end

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Creates string array of axis values to display              ;;;</span>
<span class="comments">;;; Pre-Condition : Requires the cache variable. The user must submit a valid   ;;;</span>
<span class="comments">;;;                 binsize, and there must be a selection made in the table.   ;;;</span>
<span class="comments">;;; Post-Condition: Returns either a 1D String Array with Axis values if the    ;;;</span>
<span class="comments">;;;                 user has opted for a Histogram, or a 2D string array if the ;;;</span>
<span class="comments">;;;                 user opted for a contour plot.                              ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<a id="xvals:source"></a>function xvals, cache
   IF cache.disptype EQ "histogram" THEN BEGIN                    <span class="comments">; If cache.disptype is set to histogram, create 1D string array of x values</span>
      FOR i=0,n_elements(cache.tablelist)-1,1 DO BEGIN            <span class="comments">; Loop over all tables</span>
         tabs   = get_tags(cache.indices)                         <span class="comments">; Store tabs with selected values</span>
         tabitr = intarr(n_elements(tabs))                        <span class="comments">; Integer array that will store which tabs are in use so we only access corresponding tables</span>
   
         for a=0,n_elements(tabs)-1,1 do begin
            tabitr[a] = int(strmid(tabs[a],4))                    <span class="comments">; Strip the number from a tab name to populate tabitr</span>
         endfor
   
         goodtabs = where(i EQ tabitr)                            <span class="comments">; Test to see if the current table is in use</span>

         IF goodtabs[0] NE -1 THEN BEGIN
            WIDGET_CONTROL, cache.tablelist[i], GET_VALUE=value, /USE_TABLE_SELECT   <span class="comments">; Get the currently selected table values and store to 'value'</span>
         
            IF i EQ int(tabitr[0]) THEN BEGIN                  <span class="comments">; Need to initialize minm and maxm</span>
               minm = min(value)
               maxm = max(value)
            ENDIF ELSE BEGIN
               IF min(value) LT minm THEN minm = min(value)    <span class="comments">; If the current value is less than the original minm, save it</span>
               IF max(value) GT maxm THEN maxm = max(value)    <span class="comments">; If the current value is greater than the original maxm, save it</span>
            ENDELSE
         ENDIF
      ENDFOR

      WIDGET_CONTROL, cache.binsize, GET_VALUE=bin             <span class="comments">; Get the current number of bins the user wants</span>

      dx   = float(bin[0])
      nbin = int(((maxm-minm)/dx)+1)
      nbin = nbin[0]
      xvector = (nbin LT 5) ? strarr(5) : strarr(nbin)

     
      for i=0L,nbin-1,1 do begin
         xvector[i] = strtrim(string(minm+i*dx),1)
      endfor
   
      if nbin LT 5 then begin
         dbin = 5-nbin
         for a=0,dbin-1,1 do begin
            xvector[n_elements(xvector)-1-a] = ' '
         endfor
      endif

      return, xvector
   ENDIF ELSE BEGIN                                         <span class="comments">; If cache.disptype is not 'histogram' then it must be 'distribution'</span>
      tags = get_tags(cache.indices)                        <span class="comments">; Store all tag names currently in cache.indices</span>
      for k=0,n_elements(tags)-1,1 do begin
         exstr = 'tempind = cache.indices'+tags[k]
         void  = EXECUTE(exstr)                             <span class="comments">; Save the current tag in cache.indices to tempind</span>
            
         IF k EQ 0 THEN indarr = tempind                    <span class="comments">; Initialize indarr from tempind</span>
         IF k NE 0 THEN indarr = [[indarr],[tempind]]       <span class="comments">; Concatenate indarr with tempind</span>
      endfor
      
      xvector = strarr(2,6)
      
      minx = min(indarr[0,*])
      maxx = max(indarr[0,*])
      miny = min(indarr[1,*])
      maxy = max(indarr[1,*])
      
      dx = (maxx-minx)/5.
      dy = (maxy-miny)/5.
      
      for a=0,5,1 do begin
         xvector[0,a] = strtrim(string(minx+a*dx),1)
         xvector[1,a] = strtrim(string(miny+a*dy),1)
      endfor
      return,xvector
   ENDELSE
end

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Finds the dimensions of an input array of up to two dimensions ;;;</span>
<span class="comments">;;; Pre-Condition : An array.                                                      ;;;</span>
<span class="comments">;;; Post-Condition: Returns a structure with the X-dimensions and Y-dimensions.    ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<a id="dimensions:source"></a>function dimensions,iTable
   sz = size(iTable,/DIMENSIONS)
   sx = sz[0]
   sy = (n_elements(sz) EQ 1) ? 0 : sz[1]
   return,{sx:sx,sy:sy}
end

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Produces the vector containing the histogram output      ;;;</span>
<span class="comments">;;; Pre-Condition : Requires the cache variable to be passed as an argument. ;;;</span>
<span class="comments">;;; Post-Condition: Returns a vector with histogram values.                  ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<a id="makehist:source"></a>function makehist, cache, itr
   WIDGET_CONTROL, cache.binsize, GET_VALUE=bin

   tabs   = get_tags(cache.indices)
   tabitr = intarr(n_elements(tabs))
   
   for a=0,n_elements(tabs)-1,1 do begin
      tabitr[a] = float(strmid(tabs[a],4))
   endfor
   
   goodtabs = where(itr EQ tabitr)

   IF goodtabs[0] NE -1 THEN BEGIN
      WIDGET_CONTROL, cache.tablelist[itr], GET_VALUE=value, /USE_TABLE_SELECT
   ENDIF ELSE BEGIN
      return,-1
   ENDELSE

   value = DOUBLE(value)

   if cache.histmins[0] EQ -999 then begin
      cache.histmins = [min(value)]
   endif else begin
      tmp   = [cache.histmins,min(value)]
      cache = rm_tag(cache,"histmins")
      cache = create_struct(cache,histmins,tmp)
   endelse

   return,histogram(value,BINSIZE=bin)
end


<span class="comments">;- Environment Functions -----------------------------------------------------</span>

<a id="helpinfo:source"></a>function helpinfo, ev
   IF !VERSION.OS EQ 'linux' THEN spawn,'nice +19 nedit histreadme.txt'
   IF !VERSION.OS EQ 'MacOS' THEN spawn,'textedit histreadme.txt'
end

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Changes the display type variable in the cache.          ;;;</span>
<span class="comments">;;; Pre-Condition : Requires the ev structure to be passed from the xmanager ;;;</span>
<span class="comments">;;; Post-Condition: Returns a modified cache structure by means of ev.TOP    ;;;</span>
<span class="comments">;;; NOTE          : Logically identical to disptype_hist, but is a seperate  ;;;</span>
<span class="comments">;;;                 function due to simplicity of widget use. UVALUE could   ;;;</span>
<span class="comments">;;;                 potentially allow for a merger of these two functions.   ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<a id="disptype_dist:source"></a>function disptype_dist, ev
   WIDGET_CONTROL, ev.TOP, GET_UVALUE=cache
   
   cache.disptype = "distribution"

   WIDGET_CONTROL, ev.TOP, SET_UVALUE=cache
end

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Changes the display type variable in the cache.          ;;;</span>
<span class="comments">;;; Pre-Condition : Requires the ev structure to be passed from the xmanager ;;;</span>
<span class="comments">;;; Post-Condition: Returns a modified cache structure by means of ev.TOP    ;;;</span>
<span class="comments">;;; NOTE          : Logically identical to disptype_hist, but is a seperate  ;;;</span>
<span class="comments">;;;                 function due to simplicity of widget use. UVALUE could   ;;;</span>
<span class="comments">;;;                 potentially allow for a merger of these two functions.   ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<a id="disptype_hist:source"></a>function disptype_hist, ev
   WIDGET_CONTROL, ev.TOP, GET_UVALUE=cache

   cache.disptype = "histogram"

   WIDGET_CONTROL, ev.TOP, SET_UVALUE=cache
end

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Actually selects the table values passed by the users      ;;;</span>
<span class="comments">;;;                 clicks or manual selection. A user MUST call this function ;;;</span>
<span class="comments">;;;                 if they wish to create/change their values.                ;;;</span>
<span class="comments">;;; Pre-Condition : Requires the ev structure to be passed from the xmanager   ;;;</span>
<span class="comments">;;; Post-Condition: Returns a modified cache structure by means of ev.TOP. It  ;;;</span>
<span class="comments">;;;                 also highlights the current selection in the table. This   ;;;</span>
<span class="comments">;;;                 is important, as other functions grab highlighted portions ;;;</span>
<span class="comments">;;;                 directly.                                                  ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<a id="highlight:source"></a>function highlight, ev
   WIDGET_CONTROL, ev.TOP, GET_UVALUE=cache                          <span class="comments">; Read in the cache</span>
   WIDGET_CONTROL, cache.coord1, GET_VALUE=coord1                    <span class="comments">; Read in the (x0,y0) coordinates</span>
   WIDGET_CONTROL, cache.coord2, GET_VALUE=coord2                    <span class="comments">; Read in the (x1,y1) coordinates</span>

   itab = WIDGET_INFO(cache.Tab,/TAB_CURRENT)                        <span class="comments">; Determine the current tab</span>
   
   WIDGET_CONTROL, cache.tablelist[itab], GET_VALUE=iTable

   IF coord1 EQ "(x0,y0): " AND coord2 EQ "(x1,y1): " THEN BEGIN     <span class="comments">; If the user chose to select from the table, save the selections</span>
      ind = WIDGET_INFO(cache.tablelist[itab], /TABLE_SELECT)
   ENDIF ELSE IF coord1 NE "(x0,y0): " AND coord2 NE "(x1,y1): " THEN BEGIN
      <span class="comments">;;; Find the x0 and y0 coordinates</span>
      cstr = strmid(coord1,10)
      carr = strsplit(cstr,',',/extract)
      yarr = strsplit(carr[1],')',/extract)
      x0   = int(carr[0])
      y0   = int(yarr[0])

      <span class="comments">;;; Find the x1 and y1 coordinates</span>
      cstr = strmid(coord2,10)
      carr = strsplit(cstr,',',/extract)
      yarr = strsplit(carr[1],')',/extract)
      x1   = int(carr[0])
      y1   = int(yarr[0])

      xp   = [x0,x1]
      yp   = [y0,y1]
      ymin = min(yp,minind)
      ymax = max(yp,maxind)
      xmin = xp[minind]
      xmax = xp[maxind]
   
      dx   = (abs(x1-x0) GT 0) ? abs(x1-x0) : 1                      <span class="comments">; Find the x dimension of selection. If 1D vector, force to 1.</span>
      dy   = (abs(y1-y0) GT 0) ? abs(y1-y0) : 1                      <span class="comments">; Find the y dimension of selection. If 1D vector, force to 1.</span>
            
      slope = float((ymax-ymin))/float((xmax-xmin))
      
      if abs(slope) GE 1 then begin
         slope = (slope LT 0) ? ceil(slope) : floor(slope)
         dy    = abs(slope)*dx
         ind   = intarr(2,dy)

         for j=0,dy-1,1 do ind[1,j] = ymin+j

         pos = 0
         for k=0,dx-1,1 do begin
            for l=0,abs(slope)-1,1 do begin
               ind[0,pos] = (slope GT 0) ? xmin+k:xmin-k
               pos=pos+1
            endfor
         endfor
      endif else begin
         slope = (slope LT 0) ? ceil(1/slope) : floor(1/slope)
         dx    = abs(slope)*dy
         ind   = intarr(2,dx)
         
         if slope GT 0 then begin
            for j=0,dx-1,1 do ind[0,j] = xmin+j
         endif else begin
            for j=0,dx-1,1 do ind[0,j] = xmin-j
         endelse
         
         pos = 0
         for k=0,dy-1,1 do begin
            for l=0,abs(slope)-1,1 do begin
               ind[1,pos] = ymin+k
               pos = pos +1
            endfor
         endfor
      endelse
   ENDIF ELSE BEGIN
      return,-1
   ENDELSE


   <span class="comments">;;; Remove infs and NaNs from the selection. If they are all</span>
   <span class="comments">;;; Infs or NaNs, then select nothing.</span>
   if ind[0] NE -1 then begin
      WIDGET_CONTROL, cache.tablelist[itab], GET_VALUE=vals,USE_TABLE_SELECT=ind

      infs = where(finite(vals) EQ 1)
      if infs[0] EQ -1 then return,-1
   
      indtmp = intarr(2,n_elements(infs))

      for idx=0L,n_elements(infs)-1,1 do begin
         indtmp[*,idx] = ind[*,infs[idx]]
      endfor
      
      ind = indtmp
   endif

   tabstr = 'ind'+strtrim(string(itab),1)                            <span class="comments">; "ind"+ the current tab number is so we can have a tag name that we can break up for info later</span>
   stat   = tag_exist(cache,"indices")                               <span class="comments">; Determine whether the indices structure has been made or not</span>
   
   IF stat EQ 0 THEN BEGIN
      IF ind[0] NE -1 THEN BEGIN                                     <span class="comments">; If indices does not exist, but we have new data to enter, then insert indices and the ind#</span>
         tempind = create_struct(tabstr,ind)
         cache   = create_struct(cache,"indices",tempind)
      ENDIF
   ENDIF ELSE BEGIN                                                  <span class="comments">; Logic for situations where indices already exists</span>
      all_tags = get_tags(cache.indices)
      stat_sub = tag_exist(cache.indices,tabstr)

      IF ind[0] NE -1 THEN BEGIN
         IF stat_sub EQ 0 THEN BEGIN                                 <span class="comments">; If our current tab has not been added to cache.indices, add it</span>
            cachetmp = create_struct(cache.indices,tabstr,ind)       <span class="comments">; Create a temp structure with the old cache.indices concatenated with the new ind#</span>
            cache    = rm_tag(cache,"indices")                       <span class="comments">; Remove cache.indices</span>
            cache    = create_struct(cache,"indices",cachetmp)       <span class="comments">; Recreate cache.indices with the temp structure (to avoid IDL errors of directly over-writing)</span>
         ENDIF
         IF stat_sub EQ 1 THEN BEGIN                                 <span class="comments">; If our current tab has been added to cache.indices, modify it</span>
            IF n_elements(all_tags) GT 1 THEN BEGIN
               cachetmp      = rm_tag(cache.indices,tabstr)
               cache         = rm_tag(cache,"indices")
               cache         = create_struct(cache,"indices",create_struct(cachetmp,tabstr,ind))
            ENDIF ELSE BEGIN
               cachetmp = create_struct(tabstr,ind)
               cache    = rm_tag(cache,"indices")
               cache    = create_struct(cache,"indices",cachetmp)
            ENDELSE
         ENDIF
      ENDIF
      
      IF ind[0] EQ -1 && stat_sub EQ 1 THEN BEGIN                    <span class="comments">; If our current tab exists, but nothing is selected, remove that tag</span>
         IF n_elements(all_tags) EQ 1 THEN BEGIN                     <span class="comments">; If our current tab exists and the only one, remove cache.indices</span>
            cache = rm_tag(cache,"indices")
         ENDIF ELSE BEGIN
            cachetmp = rm_tag(cache.indices,tabstr)
            cache    = rm_tag(cache,"indices")
            cache    = create_struct(cache,"indices",cachetmp)
         ENDELSE
      ENDIF
   ENDELSE

   WIDGET_CONTROL, ev.TOP, SET_UVALUE=cache                          <span class="comments">; Save the new cache to ev.TOP </span>
   WIDGET_CONTROL, cache.tablelist[itab], SET_TABLE_SELECT=ind       <span class="comments">; Set the selection in the table</span>
end

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Display TVSCL of current table data                      ;;;</span>
<span class="comments">;;; Pre-Condition : Requires the ev structure to be passed from the xmanager ;;;</span>
<span class="comments">;;; Post-Condition: Returns a new copy of cache via ev.TOP                   ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<a id="tvscl:source"></a>function tvscl, ev
   WIDGET_CONTROL, ev.TOP, GET_UVALUE=cache

   itab = WIDGET_INFO(cache.Tab,/TAB_CURRENT)                  <span class="comments">; Store the current tab number</span>

   WIDGET_CONTROL, cache.tablelist[itab], GET_VALUE=value      <span class="comments">; Grab all values from the table</span>
   
   cache.plottype = 1                                          <span class="comments">; Set the display type to 1 so zoom knows what it is handling</span>

   WSET, cache.preview                                         <span class="comments">; Set the display destination to the draw widget</span>
   DEVICE, DECOMPOSED=1
   TVSCL, congrid(value,300,300)                               <span class="comments">; Display the table data fitted to be 300x300 pixels</span>
   DEVICE, DECOMPOSED=0
   
   WIDGET_CONTROL, ev.TOP, SET_UVALUE=cache                    <span class="comments">; Store the new cache to ev.TOP</span>
end

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Plots the histogram or contour plots to the main draw widget. ;;;</span>
<span class="comments">;;; Pre-Condition : Requires the ev structure to be passed from the xmanager      ;;;</span>
<span class="comments">;;; Post-Condition: Returns a new copy of cache via ev.TOP                        ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<a id="plothist:source"></a>function plothist, ev
   WIDGET_CONTROL, ev.TOP, GET_UVALUE=cache
   WIDGET_CONTROL, cache.binsize, GET_VALUE=binval
   
   flag = 0                                                             <span class="comments">; flag lets the code know if this is the first result actually plotted or not</span>
   stat = tag_exist(cache,"indices")                                    <span class="comments">; Boolean test whether indices already exists or not.</span>

   indcnt = (stat EQ 1) ? n_elements(get_tags(cache.indices)):0         <span class="comments">; Find number of tabs with selections, allows us to vary color of plots  </span>
   cache.plottype = 2                                                   <span class="comments">; Set plottype to 2, which lets the code know we are NOT using TVSCL</span>
   WSET,cache.preview                                                   <span class="comments">; Set the display window to the main draw widget</span>

   IF cache.disptype EQ "histogram" AND stat EQ 1 THEN BEGIN            <span class="comments">; If there is some selection active, and we're plotting histograms, begin</span>
      FOR j=0,n_elements(cache.tablelist)-1,1 DO BEGIN                  <span class="comments">; Loop over all possible tables</span>
         output = makehist(cache,j)                                     <span class="comments">; Save the output from makehist to plot to screen</span>
  
         IF output[0] EQ -1 THEN continue                               <span class="comments">; makehist will return -1 if the current iteration of tables has no selection</span>

         xval   = xvals(cache)                                          <span class="comments">; Get the axis labels and store to string array</span>
     
         IF flag EQ 0 THEN BEGIN
            IF n_elements(xval) GT 8 THEN BEGIN                         <span class="comments">; If xvals is more than 8 indicies, reduce it to 8 to avoid clutter</span>
               dx  = int((n_elements(xval)-1)/8.)
               tmp = [xval[0]]
               for a=1,7,1 do tmp = [tmp,xval[0+a*dx]]
               xval = tmp
            ENDIF

            numtick = n_elements(xval)-1
            plot,output,psym=10,xtickname=xval,xticks=numtick
            flag = 1
         ENDIF ELSE BEGIN
            oplot,output,psym=10,color=(j*250/indcnt)
         ENDELSE
      ENDFOR
   ENDIF
   IF cache.disptype EQ "distribution" AND stat EQ 1 THEN BEGIN               <span class="comments">; If there is some selection active, and we're plotting contours, begin</span>
      FOR j=0,n_elements(cache.tablelist)-1,1 DO BEGIN                        <span class="comments">; Loop over all possible tables</span>
         output = makecon(cache,j,0,0)                                        <span class="comments">; Save the output from makecon to plot to screen</span>

         IF output[0] EQ -1 THEN cache.conoff[*,j] = [-1,-1]
      ENDFOR

      FOR j=0,n_elements(cache.tablelist)-1,1 DO BEGIN
         IF cache.conoff[0,j] NE -1 && cache.conoff[1,j] NE -1 THEN BEGIN
            output = makecon(cache,j,0,0)
            sz     = size(output)                                              <span class="comments">; If output is 1D, then we just plot it, if 2D, then we use contour</span>

            if sz[0] EQ 1 then begin
               IF flag EQ 0 THEN BEGIN
                  plot,output,XTITLE='Column'
                  flag = 1
               ENDIF ELSE BEGIN
                  oplot,output,color=(j*250/indcnt)
               ENDELSE
            endif else begin
               xval   = xvals(cache)

               difx   = cache.conoff[0,j] - max([min(cache.conoff[0,*]),0])
               dify   = cache.conoff[1,j] - max([min(cache.conoff[1,*]),0])

               output=makecon(cache,j,difx,dify)


               IF flag EQ 0 THEN BEGIN
                  contour,output,xtickname=xval[0,*],ytickname=xval[1,*],XTITLE='Column',YTITLE='Row',NLEVELS=5
                  flag = 1
               ENDIF ELSE BEGIN
                  contour,output,color=(j*250/indcnt),/OVERPLOT,NLEVELS=5
               ENDELSE
            endelse
         ENDIF
      ENDFOR
   ENDIF

   X = [-2,0,2]
   y = [0,0,0]
   usersym,x,y
   
   legname = strarr(indcnt)
   legsym  = intarr(indcnt)+8
   col     = intarr(indcnt)
   indname = get_tags(cache.indices)
   
   for a=0,indcnt-1,1 do begin
      numstr     = strmid(indname[a],4)
      legname[a] = 'Tab '+numstr
      col[a]     = (a*250/indcnt)
   endfor
   
   col[0]=250
   
   IF cache.plottype NE 1 THEN BEGIN
      legend,legname,psym=legsym,colors=col
   ENDIF

   IF cache.disptype EQ "histogram" AND cache.plottype NE 1 THEN BEGIN
      INFOSTR = "Minimum is: "+strtrim(string(min(cache.histmins)),2)
      xyouts,75,60,INFOSTR,/DEVICE
            
      INFOSTR = "Binsize is: "+strtrim(string(cache.binsize[0]),2)
      xyouts,75,50,INFOSTR,/DEVICE
      
      cache.histmins = [float(-999)]
   ENDIF

   WIDGET_CONTROL, ev.TOP, SET_UVALUE=cache
end

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Takes the user selected tag from a PDS structure, and       ;;;</span>
<span class="comments">;;;                 the current table values with the newly selected data.      ;;;</span>
<span class="comments">;;; Pre-Condition : Requires the ev structure to be passed from the xmanager    ;;;</span>
<span class="comments">;;; Post-Condition: Returns a new copy of cache via ev.TOP and replaces content ;;;</span>
<span class="comments">;;;                 of the main widgets table.                                  ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<a id="newform:source"></a>function newform, ev
   if ev.CLICKS EQ 2 then begin                                                     <span class="comments">; We only want to replace values on a double click</span>
      WIDGET_CONTROL, ev.TOP, GET_UVALUE=cache                                      <span class="comments">; Get the current cache from ev.TOP</span>
      
      for i=0,n_elements(cache.leafid)-1,1 do begin                                 <span class="comments">; Loop over all leaves</span>
         flag = WIDGET_INFO(cache.leafid[i], /TREE_SELECT)                          <span class="comments">; Return boolean if the current leaf in the tree is selected or not</span>
         if flag EQ 1 then iLeaf = i                                                <span class="comments">; Save the current indice for later referencing</span>
      endfor

      itab = WIDGET_INFO(cache.Tab,/TAB_CURRENT)

      WIDGET_CONTROL, cache.leafid[iLeaf], GET_UVALUE=iObj                          <span class="comments">; Get the User Value for selected leaf (The substructure path of given PDS structure)</span>
      WIDGET_CONTROL, cache.tablelist[itab], GET_UVALUE=pdsf, GET_VALUE=iTable      <span class="comments">; Get the User Value for selected leaf (The PDS structure passed by readpds)</span>
      
      exstr = 'newtable = pdsf'+iObj
      void  = EXECUTE(exstr)                                                        <span class="comments">; Store the array from PDS structure to newtable so we can display it</span>

      szstr = dimensions(iTable)                                                    <span class="comments">; Get the current table dimensions</span>
      sx    = szstr.sx
      sy    = szstr.sy
      
      szstr = dimensions(newtable)                                                  <span class="comments">; Get the new table dimensions</span>
      newsx = szstr.sx
      newsy = szstr.sy
            
      dx = (newsx-sx)                                                               <span class="comments">; Find x size difference of old and new</span>
      dy = (newsy-sy)                                                               <span class="comments">; Find y size difference of old and new</span>

      if (dx GT 0) then begin
         WIDGET_CONTROL, cache.tablelist[itab], INSERT_COLUMNS=dx                   <span class="comments">; If the new table is wider, insert columns so we can display everything</span>
      endif
      if (dy GT 0) then begin
         WIDGET_CONTROL, cache.tablelist[itab], INSERT_ROWS=dy                      <span class="comments">; If the new table is taller, insert columns so we can display everything</span>
      endif
      
      WIDGET_CONTROL, cache.tablelist[itab], SET_VALUE=[newtable]                   <span class="comments">; Replace old table with new table</span>
   endif
end

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Saves the current selection from all active tabs.        ;;;</span>
<span class="comments">;;; Pre-Condition : Requires the ev structure to be passed from the xmanager ;;;</span>
<span class="comments">;;; Post-Condition: Saves a file to current folder called 'histogram.save'   ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<a id="save:source"></a>function save, ev
   WIDGET_CONTROL, ev.TOP, GET_UVALUE=cache                                               <span class="comments">; Grab the cache</span>
   
   flag = 0                                                                               <span class="comments">; Flag to differentiate initialization from concatenation</span>
   stat = tag_exist(cache,"indices")                                                      <span class="comments">; Check to see if any selections have been made</span>

   FOR j=0,n_elements(cache.tablelist)-1,1 DO BEGIN
      tabstr  = 'ind'+strtrim(string(j),1)                                                <span class="comments">; Form substring needed to get info from cache.indices for current tab</span>
      
      if stat EQ 1 then begin                                                             <span class="comments">; If there is a selection on this tab, proceed</span>
         substat = tag_exist(cache.indices,tabstr)
         
         if substat EQ 1 then begin
            exstr = 'tmp = cache.indices.ind'+strtrim(string(j),1)                        <span class="comments">; Save the indices from that tab to the variable tmp</span>
            void  = EXECUTE(exstr)
            
            WIDGET_CONTROL, cache.tablelist[j],SET_TABLE_SELECT=tmp                       <span class="comments">; Use those indices to highlight correct values in that tab</span>
            WIDGET_CONTROL, cache.tablelist[j],GET_VALUE=vals,/USE_TABLE_SELECT           <span class="comments">; Grab the highlighted values</span>
            
            if flag EQ 0 then begin
               output = create_struct("tab"+strtrim(string(j),1),vals)                    <span class="comments">; Initialize a structure to store final results</span>
               flag   = 1                                                                 <span class="comments">; trip the flag</span>
            endif else begin
               output = create_struct(output,"tab"+strtrim(string(j),1),vals)             <span class="comments">; Concatenate new values into the structure</span>
            endelse
         endif
      endif
   endfor
   save,output,FILENAME='histogram.save'                                                  <span class="comments">; Save our structure as histogram.save</span>
end         
   
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Exits the current session.                               ;;;</span>
<span class="comments">;;; Pre-Condition : Requires the ev structure to be passed from the xmanager ;;;</span>
<span class="comments">;;; Post-Condition: None.                                                    ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<a id="exit:source"></a>function exit, ev
   WIDGET_CONTROL, ev.TOP, /DESTROY
end

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Event function for the zoomed window. Allows the user to    ;;;</span>
<span class="comments">;;;                 either close the window with a left double-click, or to     ;;;</span>
<span class="comments">;;;                 choose new selection points with single right-click.        ;;;</span>
<span class="comments">;;; Pre-Condition : Requires the ev structure to be passed from the xmanager    ;;;</span>
<span class="comments">;;; Post-Condition: If new points are selected, it will replace the coordinates ;;;</span>
<span class="comments">;;;                 in the main widget.                                         ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<a id="zoomed_event:source"></a>pro zoomed_event, ev
   WIDGET_CONTROL, ev.TOP, GET_UVALUE=cache                                               <span class="comments">; Grab the cache</span>

   if ev.CLICKS EQ 2 THEN BEGIN                                                           <span class="comments">; If the user double clicks, close the zoomed window</span>
      WIDGET_CONTROL, ev.TOP, /DESTROY
   endif
   
   IF ev.CLICKS EQ 1 AND ev.PRESS EQ 4 AND cache.plottype EQ 1 then begin                 <span class="comments">; On single right click, store user defined coordinate for draw selection</span>
      WIDGET_CONTROL, cache.coord1, GET_VALUE=coord1 
      WIDGET_CONTROL, cache.coord2, GET_VALUE=coord2
      WIDGET_CONTROL, cache.zoom, GET_VALUE=zoom

      itab = WIDGET_INFO(cache.Tab,/TAB_CURRENT)
      WIDGET_CONTROL, cache.tablelist[itab], GET_VALUE=iTable
         
      sz   = dimensions(iTable)
      xdim = sz.sx
      ydim = sz.sy
         
      xfac = xdim/float((300*zoom[0]))
      yfac = ydim/float((300*zoom[0]))

      xpos = strtrim(string(int(ev.x*xfac)),1)
      ypos = strtrim(string(int(ev.y*yfac)),1)

      IF coord1 EQ "(x0,y0): " THEN BEGIN
         WIDGET_CONTROL, cache.coord1, SET_VALUE='(x0,y0): ('+xpos+','+ypos+')'
      ENDIF
      
      IF coord1 NE "(x0,y0): " AND coord2 EQ "(x1,y1): " THEN BEGIN
         WIDGET_CONTROL, cache.coord2, SET_VALUE='(x1,y1): ('+xpos+','+ypos+')'
      ENDIF
      
      IF coord1 NE "(x0,y0): " AND coord2 NE "(x1,y1): " THEN BEGIN
         WIDGET_CONTROL, cache.coord1, SET_VALUE='(x0,y0): '
         WIDGET_CONTROL, cache.coord2, SET_VALUE='(x1,y1): '
      ENDIF
   ENDIF
end

<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="comments">;;; Description   : Event function for the small window. Allows the user to        ;;;</span>
<span class="comments">;;;                 either zoom the window with a left double-click, or to         ;;;</span>
<span class="comments">;;;                 choose new selection points with single right-click.           ;;;</span>
<span class="comments">;;; Pre-Condition : Requires the ev structure to be passed from the xmanager       ;;;</span>
<span class="comments">;;; Post-Condition: If new points are selected, it will replace the coordinates    ;;;</span>
<span class="comments">;;;                 in the main widget. If they choose to zoom, it spawns a larger ;;;</span>
<span class="comments">;;;                 draw widget.                                                   ;;;</span>
<span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<a id="histogram_event:source"></a>pro histogram_event, ev
   WIDGET_CONTROL, ev.TOP, GET_UVALUE=cache                                                  <span class="comments">; Grab the cache</span>
   itab = WIDGET_INFO(cache.Tab,/TAB_CURRENT)                                                <span class="comments">; Get the current tab so we can reference the correct values</span>
   flag = 1
   stat = tag_exist(ev,"clicks")                                                             <span class="comments">; Check to see if the user actually clicked on the widget (Leftover failsafe)</span>

   IF cache.plottype EQ 0 THEN BEGIN
      flag = 0
   ENDIF

   IF stat EQ 1 THEN BEGIN
      IF ev.CLICKS EQ 2 AND ev.PRESS EQ 1 AND flag EQ 1 THEN BEGIN                           <span class="comments">; On double left click when the draw widget isnt empty, zoom </span>
         WIDGET_CONTROL, cache.zoom, GET_VALUE=zoom                                          <span class="comments">; Grab the user specified zoom value</span>
         
         zoom   = int(zoom)                                                                  <span class="comments">; Convert string to int</span>
         width  = zoom*300                                                                   <span class="comments">; New width value</span>
         height = zoom*300                                                                   <span class="comments">; New height value</span>
   
         LRGmain     = WIDGET_BASE(/COLUMN)                                                  <span class="comments">; Initialize a new base to draw in</span>
         LRG_preview = WIDGET_DRAW(LRGmain,/BUTTON_EVENT,XS=width,YS=height,RETAIN=2)        <span class="comments">; Initialize the draw widget for the new scaled plot</span>
         
         WIDGET_CONTROL, LRGmain, /realize
         WIDGET_CONTROL, LRG_preview, GET_VALUE=LRGdrawID                                    <span class="comments">; Grab the widget ID for the new draw wiget</span>
         
         cache = create_struct(cache,"LRG_preview",LRGdrawID)                                <span class="comments">; Stuff out new draw widget id into the cache</span>
         WIDGET_CONTROL,LRGmain,SET_UVALUE=cache                                             <span class="comments">; Store the new cache variable in our widget base</span>
         
         WSET, LRGdrawID
         
         IF cache.plottype EQ 1 THEN BEGIN                                                   <span class="comments">; If we are working with the tvscl output, we need to grab the right values</span>
            WIDGET_CONTROL, cache.tablelist[itab], GET_VALUE=fulltable                       <span class="comments">; Get the values for the current tab</span>
            DEVICE, DECOMPOSED=1                                                             <span class="comments">; Allow us to edit draw widget for a moment</span>
            TVSCL,congrid(fulltable,width,height)                                            <span class="comments">; Show the current tab values when rescaled to the zoomed size</span>
            DEVICE, DECOMPOSED=0                                                             <span class="comments">; Prevent toying around with the widget</span>
         ENDIF

         indcnt = (tag_exist(cache,"indices") EQ 1) ? n_elements(get_tags(cache.indices)):0  <span class="comments">; Find out how many tabs are actually being used</span>
         
         IF cache.plottype EQ 2 THEN BEGIN                                                   <span class="comments">; 2 if a histogram or contour plot (Leftover from alpha. Should merge disptype</span>
                                                                                             <span class="comments">; and plottype properly.)</span>
            flag = 0                                                                         <span class="comments">; flag lets the code know if this is the first result actually plotted or not</span>
            IF cache.disptype EQ "histogram" THEN BEGIN
               FOR j=0,n_elements(cache.tablelist)-1,1 DO BEGIN                              <span class="comments">; Loop over the different tables to find any data that needs plotting</span>
                  output = makehist(cache,j)                                                 <span class="comments">; Create a histogram using makehist from the current table</span>

                  IF output[0] NE -1 THEN BEGIN
                     xval   = xvals(cache)                                                   <span class="comments">; Get string array with the bin locations</span>

                     IF flag EQ 0 THEN BEGIN
                        IF n_elements(xval) GT 8 THEN BEGIN                                  <span class="comments">; If xvals is more than 8 indicies, reduce it to 8 to avoid clutter</span>
                           dx  = int((n_elements(xval)-1)/8.)
                           tmp = [xval[0]]
                           for a=1,7,1 do tmp = [tmp,xval[0+a*dx]]
                           xval = tmp
                        ENDIF
                           
                        numtick = n_elements(xval)-1                                         <span class="comments">; Get the number of ticks we'll need to set the plot to display</span>
                        plot,output,PSYM=10,xtickname=xval,xticks=numtick                    <span class="comments">; Plot the histogram with our custom labels</span>
                        flag = 1                                                             <span class="comments">; trip the flag so any other histograms will use overplot instead</span>
                     ENDIF ELSE BEGIN
                        oplot,output,psym=10,color=(j*250/indcnt)                            <span class="comments">; Overplot any additional histograms using a different color</span>
                     ENDELSE
                  ENDIF
               ENDFOR
            ENDIF ELSE BEGIN
               FOR j=0,n_elements(cache.tablelist)-1,1 DO BEGIN                              <span class="comments">; Loop over the different tables to find any data that needs plotting</span>
                  output = makecon(cache,j,0,0)
               
                  IF output[0] EQ -1 THEN cache.conoff[*,j] = [-1,-1]                        <span class="comments">; If we get -1, then store -1,-1 as a flag</span>
               ENDFOR
               
               FOR j=0,n_elements(cache.tablelist)-1,1 DO BEGIN
                  IF cache.conoff[0,j] NE -1 && cache.conoff[1,j] NE -1 THEN BEGIN           <span class="comments">; Check to see if current table returned a [-1,-1]</span>
                     output = makecon(cache,j,0,0)                                           <span class="comments">; Get contour output from table</span>
                     sz     = size(output)                                                   <span class="comments">; get the size of the output</span>

                     if sz[0] EQ 1 then begin                                                <span class="comments">; If we have a 1D array, we just need to use a regular plot</span>
                        IF flag EQ 0 THEN BEGIN
                           plot,output,XTITLE='Column',YTITLE='Row'
                           flag = 1
                        ENDIF ELSE BEGIN
                           oplot,output,color=(j*250/indcnt)
                        ENDELSE
                     ENDIF ELSE BEGIN                                                        <span class="comments">; If we get a 2d array, we need to do a touch more work</span>
                                                                                             <span class="comments">; NOTE: Account for 2d and 1d mix?</span>
                        xval   = xvals(cache)                                                <span class="comments">; Get the tick names</span>

                        difx   = cache.conoff[0,j] - max([min(cache.conoff[0,*]),0])         <span class="comments">; Find the maximum offset between tabs in the X direction</span>
                        dify   = cache.conoff[1,j] - max([min(cache.conoff[1,*]),0])         <span class="comments">; Find the maximum offset between tabs in the Y direction</span>

                        output=makecon(cache,j,difx,dify)                                    <span class="comments">; Get the contour output, only now shift it according to difx and dify</span>

                        IF flag EQ 0 THEN BEGIN
                           contour,output,xtickname=xval[0,*],ytickname=xval[1,*],XTITLE='Column',YTITLE='Row',NLEVELS=5
                           flag = 1
                        ENDIF ELSE BEGIN
                           contour,output,color=(j*250/indcnt),/OVERPLOT,NLEVELS=5
                        ENDELSE
                     ENDELSE
                  ENDIF
               ENDFOR
            ENDELSE
         ENDIF
         
         IF cache.plottype NE 1 THEN BEGIN                                          <span class="comments">; If draw widget is not displaying TVSCL, come up with a legend for plots</span>
            X = [-2,0,2]                                                            <span class="comments">; Our symbols for the legend are just the line defined by [Xi,Yi]</span>
            y = [0,0,0]
            usersym,x,y
   
            legname = strarr(indcnt)                                                <span class="comments">; Initialize the string array of legend entry text</span>
            legsym  = intarr(indcnt)+8                                              <span class="comments">; Set the legend symbol array to 8, which uses the usersym output</span>
            col     = intarr(indcnt)                                                <span class="comments">; Array of colors to use for each legend entry</span>
            indname = get_tags(cache.indices)                                       <span class="comments">; Get the indice names for the active tabs</span>
   
            for a=0,indcnt-1,1 do begin
               numstr     = strmid(indname[a],4)
               legname[a] = 'Tab '+numstr
               col[a]     = (a*250/indcnt)
            endfor
   
            col[0]=250

            legend,legname,psym=legsym,colors=col                                   <span class="comments">; Plot a legend</span>
         ENDIF

         IF cache.disptype EQ "histogram" AND cache.plottype NE 1 THEN BEGIN        <span class="comments">; If we are using the histogram feature, we should also show the binsize and minimum</span>
            INFOSTR = "Minimum is: "+strtrim(string(min(float(output))),2)
            xyouts,75,60,INFOSTR,/DEVICE
            
            INFOSTR = "Binsize is: "+strtrim(string(float(cache.binsize[0])),2)
            xyouts,75,50,INFOSTR,/DEVICE
         ENDIF
         
         
         XMANAGER, 'zoomed', LRGmain
      ENDIF
      
      IF ev.CLICKS EQ 1 AND ev.PRESS EQ 4 AND cache.plottype EQ 1 then begin         <span class="comments">; If a single right click, set a point for user defined selection from draw widget</span>
         WIDGET_CONTROL, cache.coord1, GET_VALUE=coord1 
         WIDGET_CONTROL, cache.coord2, GET_VALUE=coord2
         WIDGET_CONTROL, cache.tablelist[itab], GET_VALUE=iTable
         
         sz   = dimensions(iTable)
         xdim = sz.sx
         ydim = sz.sy
         
         xfac = xdim/300.
         yfac = ydim/300.

         xpos = strtrim(string(int(ev.x*xfac)),1)
         ypos = strtrim(string(int(ev.y*yfac)),1)
  
         IF coord1 EQ "(x0,y0): " THEN BEGIN
            WIDGET_CONTROL, cache.coord1, SET_VALUE='(x0,y0): ('+xpos+','+ypos+')'
         ENDIF
         
         IF coord1 NE "(x0,y0): " AND coord2 EQ "(x1,y1): " THEN BEGIN
            WIDGET_CONTROL, cache.coord2, SET_VALUE='(x1,y1): ('+xpos+','+ypos+')'
         ENDIF
         
         IF coord1 NE "(x0,y0): " AND coord2 NE "(x1,y1): " THEN BEGIN
            WIDGET_CONTROL, cache.coord1, SET_VALUE='(x0,y0): '
            WIDGET_CONTROL, cache.coord2, SET_VALUE='(x1,y1): '
         ENDIF
      ENDIF
   ENDIF
end

<a id="histogram:source"></a>pro histogram,pdsf,tabitr
   input  = [0]                                                                        <span class="comments">; Dummy array to first initialize the table with</span>
   cache  = {disptype:"histogram",histmins:float(-999)}                                       <span class="comments">; Initialize the cache variable, which will store most of our info</span>

   <span class="comments">;;; Create the Widget Bases</span>
   main         = widget_base(mbar=BAR,/COLUMN)
   top          = widget_base(main,/ROW)
   tree_base    = widget_base(top,/COLUMN)
   preview_base = widget_base(top,/ROW)
   setting_base = widget_base(top,/COLUMN,XSIZE=300,YSIZE=300)
   coord_base   = widget_base(setting_base,/COLUMN)
   zoom_base    = widget_base(setting_base,/ROW)
   bin_base     = widget_base(setting_base,/ROW)
   prefbase     = widget_base(setting_base,/ROW,/EXCLUSIVE)

   <span class="comments">;;; Create Main Menu</span>
   filemenu  = WIDGET_BUTTON(bar, VALUE='File', /MENU)
   file_save = WIDGET_BUTTON(filemenu, VALUE='Save Selection',EVENT_FUNC='save')
   file_exit = WIDGET_BUTTON(filemenu, VALUE='Exit',EVENT_FUNC="exit")
   helpmenu  = WIDGET_BUTTON(bar, VALUE='Help', /MENU)
   help_help = WIDGET_BUTTON(helpmenu, VALUE='Help',EVENT_FUNC="helpinfo")
 

   <span class="comments">;;; Read in tags for PDS structure</span>
   <span class="comments">;;; NOTE: This is a stupid way to do things, but the best I could come up with at this time....</span>
   tags    = get_tags(pdsf)                                 <span class="comments">; Call outside procedure, get_tags.pro, to find tags in a structure</span>
   tagtree = widget_tree(tree_base,XSIZE=300,YSIZE=300)     <span class="comments">; Create Tree Widget that will house PDS Structure tags</span>
   leafid  = strarr(1)                                      <span class="comments">; Initialize array to store leaves in the Tree Widget</span>
   path    = ''                                             <span class="comments">; Initialize variable that will hold the path leading to a bottom element in a structure</span>
   
   for i=0,n_elements(tags)-1,1 do begin
      iObj = tags[i]
      void = EXECUTE('iType = type(pdsf'+iObj+')')                   <span class="comments">; Find the type of the current tag</span>
      
      if iType NE 8 then begin                                       <span class="comments">; Type 8 is a structure. We want the bottom elements. Skip Structures.</span>

         <span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      </span>
         <span class="comments">;;; To display COLUMN objects by their given name, we need to extract  ;;;</span>
         <span class="comments">;;; information from the NAMES column. We find these names, store them ;;;</span>
         <span class="comments">;;; then assign them to anything that matches *COLUMN*.                ;;;</span>
         <span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
         namesplt = strsplit(iObj,'NAMES',/extract,/regex)           <span class="comments">; Split the current element to test for possible NAMES column</span>

         IF strmid(namesplt,strlen(namesplt)-1) EQ '.' THEN BEGIN    <span class="comments">; We expect any matches to leave a substring ending in '.'</span>
            exstr   = 'names = pdsf'+iObj                            <span class="comments">; Save the names column to a regular variable 'names'</span>
            void    = EXECUTE(exstr)
            path    = namesplt
            nameind = 0                                              <span class="comments">; Iterand for going through names in later code</span>
         ENDIF

         colsplit = strsplit(iObj,'COLUMN',/extract,/regex)          <span class="comments">; If we can break up the element by COLUMN and match it to 'path', we need to assign a name</span>

         <span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
         <span class="comments">;;; Dynamically assign a leaf to the renamed PDS column. Note ;;; </span>
         <span class="comments">;;; that UVALUE stores the original tag name. This is needed  ;;;</span>
         <span class="comments">;;; for later code so we can call on the contents properly.   ;;;</span>
         <span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
         IF colsplit[0] EQ path THEN BEGIN
            exstr  = 'tagleaf'+strtrim(string(i),1)+' = WIDGET_TREE(tagtree,VALUE="'+path+names[nameind]+'",UVALUE="'+iObj+'",event_func="newform")'
            void   = EXECUTE(exstr[0])
            nameind = nameind+1
         ENDIF ELSE BEGIN
            exstr  = 'tagleaf'+strtrim(string(i),1)+' = WIDGET_TREE(tagtree,VALUE="'+iObj+'",UVALUE="'+iObj+'",event_func="newform")'
            void   = EXECUTE(exstr)
         ENDELSE

         exstr  = 'leafid = [leafid,tagleaf'+strtrim(string(i),1)+']'
         void   = EXECUTE(exstr)
      endif
   endfor
   leafid  = leafid[1:n_elements(leafid)-1]        <span class="comments">; Strip away the initial blank string we used to initialize this variable</span>
   
   
   <span class="comments">;;; Build the Preview Window</span>
   preview = WIDGET_DRAW(preview_base, XSIZE=300, YSIZE=300, /BUTTON_EVENTS,RETAIN=2)


   <span class="comments">;;; Build the Settings Window</span>
   zoomlbl      = widget_label(zoom_base,value="Zoom:    ")
   zoom         = widget_text(zoom_base,value=strtrim(string(1),1),/EDITABLE)
   binsizelbl   = widget_label(bin_base,value="Binsize: ") 
   binsize      = widget_text(bin_base,value=strtrim(string(1),1),/EDITABLE)
   tvscl_button = widget_button(setting_base, value="TVSCL", EVENT_FUNC="tvscl",ysize=40,xsize=50)
   coord1lbl    = widget_label(coord_base,value="(x0,y0): ",XS=200,/ALIGN_LEFT)
   coord2lbl    = widget_label(coord_base,value="(x1,y1): ",XS=200,/ALIGN_LEFT)
   highbutton   = widget_button(setting_base,value="Verify/Highlight Selection",EVENT_FUNC="highlight",ysize=40,xsize=50)
   histbutton   = widget_button(setting_base,value="Plot",ysize=40,xsize=50,EVENT_FUNC='plothist')
   pref_hist    = WIDGET_BUTTON(prefbase,VALUE="Histogram",EVENT_FUNC='disptype_hist')
   pref_dist    = WIDGET_BUTTON(prefbase,VALUE="Distribution",EVENT_FUNC='disptype_dist')
   tab          = WIDGET_TAB(main,YS=570)


   tbstr  = 'tablelist=['                          <span class="comments">; Initialize tbstr. Contains a list of user specified tabs and their names</span>

   <span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
   <span class="comments">;;; Concatenate the needed commands to create the user ;;;</span>
   <span class="comments">;;; tabs and their tables. Then store their name into  ;;;</span>
   <span class="comments">;;; into tbstr for later use.                          ;;;</span>
   <span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
   FOR tableIDX=0,tabitr-1,1 DO BEGIN
      exstr = 'tab'+strtrim(string(tableIDX+1),1)+'_base= WIDGET_BASE(tab,TITLE="TABLE '+strtrim(string(tableIDX+1),1)+'")'
      void  = EXECUTE(exstr)

      exstr = 'table'+strtrim(string(tableIDX+1),1)+'= widget_table(tab'+strtrim(string(tableIDX+1),1) $ 
              +'_base,value=input,/disjoint_selection,SCR_XSIZE=920,SCR_YSIZE=570,UVALUE=pdsf)'
      void  = EXECUTE(exstr)
      
      tbstr = tbstr+'table'+strtrim(string(tableIDX+1),1)+','
   ENDFOR

   tbstr = strmid(tbstr,0,strlen(tbstr)-1)+']'     <span class="comments">; Clean up the tbstr and concatenate the final character to form a list</span>
   void  = EXECUTE(tbstr)

   conoff = intarr(2,tabitr)                       <span class="comments">; Initialize Contour offsets</span>

   DEVICE, DECOMPOSED=0                            <span class="comments">; Ensure the draw widget is not destroyed when it goes to the background</span>
   loadct,2                                        <span class="comments">; Load a color pallet so the user can easily distinguish different graphs</span>
   WIDGET_CONTROL, main, /realize
   WIDGET_CONTROL, pref_hist, /SET_BUTTON          <span class="comments">; Solely cosmetic. Shows this button selected to start with.</span>
   WIDGET_CONTROL, preview, GET_VALUE=drawID       <span class="comments">; We can only get the ID of the draw widget after it has been realized</span>

   <span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
   <span class="comments">;;; The most important variable in the program. Stores the WIDGET IDs and some important flags ;;;</span>
   <span class="comments">;;; that the other functions need to operate. Be careful modifying this.                       ;;;</span>
   <span class="comments">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
   cache  = create_struct(cache,"tagtree",tagtree,"leafid",leafid,"binsize",binsize,"tablelist",tablelist,"preview",drawid,"zoom",zoom, $
                          "coord1",coord1lbl,"coord2",coord2lbl,"plottype",0,"prefh",pref_hist,"prefd",pref_dist,"Tab",tab,"conoff",conoff)

   WIDGET_CONTROL, main, SET_UVALUE=cache    <span class="comments">; Assign cache to the UVALUE of main. This way other widgets and events can grab it</span>
   XMANAGER, 'histogram', main               <span class="comments">; Boot off main to the XMANAGER. I have not tested this on systems where XMANAGER settings are not straightforward.</span>
end
</code>
    </div>
  </body>
</html>