<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 20:36:30 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>timepds.pro (OMINAS Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="timepds.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	TIMEPDS</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	To extract time from a PDS label or ASCII table, express it as</span>
<span class="comments">;	either Julian Date, decimal day of year, or decimal day from some</span>
<span class="comments">;	specific user-specified date.  Then to store the date in an IDL</span>
<span class="comments">;	variable.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	Result = TIMEPDS(label, month, day, [/doy, /jd])</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       LABEL = IDL string array containing the PDS label associated with</span>
<span class="comments">;       the file.  First use HEADPDS.PRO to retrieve the label.</span>
<span class="comments">;</span>
<span class="comments">;       MONTH = Month from which to start counting.  If either /doy or /jd</span>
<span class="comments">;       are set, month should not be specified.</span>
<span class="comments">;</span>
<span class="comments">;       DAY = Day from which to start counting.  If either /doy or /jd are</span>
<span class="comments">;       set, day should not be specified.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;       If the PDS file is a PDS IMAGE:</span>
<span class="comments">;          If no optional keywords are present or if /doy is present:</span>
<span class="comments">;	      Result = Single precision floating point scalar</span>
<span class="comments">;          If /jd is present:</span>
<span class="comments">;             Result = Double precision floating point scalar for /jd</span>
<span class="comments">;       If the file is a PDS ASCII table:</span>
<span class="comments">;          If no optional keywords are present or if /doy is set:</span>
<span class="comments">;             Result = Single precision floating point array</span>
<span class="comments">;          If /jd is present:</span>
<span class="comments">;             Result = Double precision floating point array for /jd</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT KEYWORDS:</span>
<span class="comments">;	DOY - If present and non zero, then the output will be the decimal</span>
<span class="comments">;             day of year of the observation.</span>
<span class="comments">;</span>
<span class="comments">;	JD - If present and non zero, then the output will be the Julian date</span>
<span class="comments">;            of the observation.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;	Read a PDS label associated with an image to get the day of year of </span>
<span class="comments">;       the observation:</span>
<span class="comments">;</span>
<span class="comments">;               IDL> LABEL = HEADPDS('TEST.LBL')</span>
<span class="comments">;		IDL> doy = TIMEPDS(LABEL, /DOY)</span>
<span class="comments">;</span>
<span class="comments">;       Obtain an array of decimal dates counting from January 22 using values</span>
<span class="comments">;	from a PDS ASCII index table:</span>
<span class="comments">;</span>
<span class="comments">;               IDL> LABEL = HEADPDS('INDEX.LBL')</span>
<span class="comments">;               IDL> cu_arr = TIMEPDS(LABEL, 1, 22)</span>
<span class="comments">;</span>
<span class="comments">; WARNINGS:</span>
<span class="comments">;       The default setting, with no keywords set, is to give the date(s) as</span>
<span class="comments">;       decimal day counting from the user-specified 'month' and 'day' values,</span>
<span class="comments">;       whereas if /doy is set, counting begins on 0 January.</span>
<span class="comments">;</span>
<span class="comments">;       When present and non-zero, the optional keyword /doy or /jd </span>
<span class="comments">;       should take the place of the keywords, 'month' and 'day'.</span>
<span class="comments">;</span>
<span class="comments">;       TIMEPDS requires at least a date to be present in the PDS label or</span>
<span class="comments">;       table.  An error will occur if there is a time but no date.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;	Functions:  PDSPAR, TASCPDS</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;	July 27 1999, M. Barker</span>
<span class="comments">;</span>
<span class="comments">;------------------------------------------------------------------------------</span>
<span class="comments">;------------------------------------------------------------------------------</span>
<span class="comments">;	define function that calculates julian date:</span>
<span class="comments">;------------------------------------------------------------------------------</span>

<a id="JDATE:source"></a>function JDATE, yyyy_start, mm_start, dd_start, time

<span class="comments">;	We subtract .5 from the julian date because we want the date at 12am</span>
<span class="comments">;	local time, not 12 noon.  Then we can add the decimal time, which was</span>
<span class="comments">;	calculated earlier.  We can assume that the date will always be in the</span>
<span class="comments">;	20th or 21st centuries, thus we also subtract 2400000 from the julian </span>
<span class="comments">;	date.</span>

   return, (julday(mm_start,dd_start,yyyy_start) -.5 + double(time)) - 2400000
end

<span class="comments">;------------------------------------------------------------------------------</span>
<span class="comments">;	define function that determines if the year is a leap year:</span>
<span class="comments">;------------------------------------------------------------------------------</span>

<a id="LPYEAR:source"></a>function LPYEAR, year

   <span class="comments">;	if it is a leap year, then the year is evenly divisible by 4:</span>

   rem = year MOD 4

   <span class="comments">;	centurial years are not leap years except when divisible by 400:</span>

   rem2 = year MOD 100
   rem3 = year MOD 400

   <span class="comments">;	return 1 if it is a leap year, otherwise return 0</span>

   IF ( (NOT rem AND rem2) OR (NOT rem3) ) THEN return, 1 ELSE return, 0
end

<span class="comments">;------------------------------------------------------------------------------</span>
<span class="comments">;	define function that calculates day of year:</span>
<span class="comments">;------------------------------------------------------------------------------</span>

<a id="DAY_OF_YEAR:source"></a>function DAY_OF_YEAR, yyyy_start, mm_start, dd_start, time

   CASE mm_start OF
      1: final_doy = dd_start
      2: final_doy = 31 + dd_start
      3: final_doy = 59 + dd_start
      4: final_doy = 90 + dd_start
      5: final_doy = 120 + dd_start
      6: final_doy = 151 + dd_start
      7: final_doy = 181 + dd_start
      8: final_doy = 212 + dd_start
      9: final_doy = 243 + dd_start
      10: final_doy = 273 + dd_start
      11: final_doy = 304 + dd_start
      12: final_doy = 334 + dd_start
   ELSE:  message,'ERROR - Invalid month.'
   ENDCASE

<span class="comments">;	If it is a leap year and the month is not 1 or 2, then add 1 to the</span>
<span class="comments">;	day of year, otherwise we do not need to account for the extra day.</span>

   IF lpyear(yyyy_start) AND (mm_start GT 2) $
   THEN return, float(final_doy + time + 1) $
   ELSE return, float(final_doy + time)
end

<span class="comments">;------------------------------------------------------------------------------</span>
<span class="comments">;	define function that calculates day from user-specified date:</span>
<span class="comments">;------------------------------------------------------------------------------</span>

<a id="CUSTOM:source"></a>function CUSTOM, final_doy, yyyy_start, mm_start, dd_start, usr_month, usr_day

 IF usr_month GT mm_start OR ( (usr_month EQ mm_start) $
 AND (usr_day GT dd_start) ) $
 THEN message,'ERROR -  User-supplied date cannot be after observation date.'

<span class="comments">;	calculate doy for user-specified date</span>

 CASE usr_month OF
    1: usr_doy = usr_day   
    2: usr_doy = 31 + usr_day
    3: usr_doy = 59 + usr_day
    4: usr_doy = 90 + usr_day
    5: usr_doy = 120 + usr_day
    6: usr_doy = 151 + usr_day
    7: usr_doy = 181 + usr_day
    8: usr_doy = 212 + usr_day
    9: usr_doy = 243 + usr_day
    10: usr_doy = 273 + usr_day
    11: usr_doy = 304 + usr_day
    12: usr_doy = 334 + usr_day
 ELSE:  message,'ERROR -  Invalid month provided upon call to TIMEPDS'
 ENDCASE

 IF lpyear(yyyy_start) AND (usr_month GT 2) THEN usr_doy = usr_doy + 1

 return, (final_doy - usr_doy)

end

<span class="comments">;------------------------------------------------------------------------------</span>
<span class="comments">;	define function that converts day of year to calendar date</span>
<span class="comments">;------------------------------------------------------------------------------</span>

<a id="CAL_DATE:source"></a>function CAL_DATE, yyyy_start, doy

   <span class="comments">;	If it is a leap year and the day of year is greater than 60, then </span>
   <span class="comments">;	subtract 1 to normalize the doy.</span>

   IF lpyear(yyyy_start) AND (doy GE 60) THEN doy2 = doy - 1 ELSE doy2 = doy

   CASE 1 OF
      doy2 LE 31: mm_start = 1
      doy2 LE 59: mm_start = 2
      doy2 LE 90: mm_start = 3
      doy2 LE 120: mm_start = 4
      doy2 LE 151: mm_start = 5
      doy2 LE 181: mm_start = 6
      doy2 LE 212: mm_start = 7
      doy2 LE 243: mm_start = 8
      doy2 LE 273: mm_start = 9
      doy2 LE 304: mm_start = 10
      doy2 LE 334: mm_start = 11
      doy2 LE 357: mm_start = 12
      ELSE: message,'ERROR - Invalid day of year in PDS label'
   ENDCASE

   <span class="comments">;	Find the day of the month by calculating the difference between the </span>
   <span class="comments">;	doy and the doy of the first of each month.</span>

   CASE mm_start OF
      1: dd_start = doy2
      2: dd_start = doy2 - 31
      3: dd_start = doy2 - 59
      4: dd_start = doy2 - 90
      5: dd_start = doy2 - 120
      6: dd_start = doy2 - 151
      7: dd_start = doy2 - 181
      8: dd_start = doy2 - 212
      9: dd_start = doy2 - 243
      10: dd_start = doy2 - 273
      11: dd_start = doy2 - 304
      12: dd_start = doy2 - 334
      ELSE: message,'ERROR - Invalid month in PDS label'
   ENDCASE

   cal_arr = fltarr(2)
   cal_arr(0) = mm_start
   cal_arr(1) = dd_start

   return, cal_arr
end

<span class="comments">;------------------------------------------------------------------------------</span>
<span class="comments">;	define function that separates date into mm,dd,ccyy</span>
<span class="comments">;------------------------------------------------------------------------------</span>

<a id="DATE_SEP:source"></a>function DATE_SEP, date

<span class="comments">;	First, we separate the date into its components using '-' as a</span>
<span class="comments">;	separator.</span>

if (!VERSION.RELEASE GT 5.2) then begin
    date_arr = strsplit (date, '-', /EXTRACT)
endif else begin
    date_arr = str_sep(date,'-')      <span class="comments">; obsolete in IDL v. > 5.2</span>
endelse

<span class="comments">;	Declare the date array which we will be returning:</span>

d_arr = fltarr(4)

<span class="comments">;	Initialize the last element of the date array, day of year, to zero:</span>

d_arr(3) = 0

<span class="comments">;	There are three possible date formats that are supported by PDSSBN and</span>
<span class="comments">;	the PDSREAD set of tools:  1) CCYY-MM-DD, 2) YY-DOY, and 3) CCYY-DOY.</span>
<span class="comments">;	If there are 3 elements, the format is CCYY-MM-DD</span>

IF n_elements(date_arr) EQ 3 THEN BEGIN
   year = float(date_arr(0))
   month = float(date_arr(1))
   day = float(date_arr(2))
ENDIF ELSE BEGIN

   <span class="comments">;	if there are 2 elements, the format is YY-DOY or CCYY-DOY</span>

   IF n_elements(date_arr) EQ 2 THEN BEGIN

      <span class="comments">;	determine if format is either YY-DOY or CCYY-DOY</span>

      IF strlen(date_arr(0)) EQ 4 THEN year = float(date_arr(0)) $
      ELSE year = 1900 + float(date_arr(0))  <span class="comments">;01,02,...?</span>

      <span class="comments">;		day of year</span>

      d_arr(3) = float(date_arr(1))

      <span class="comments">;		call cal_date function to calculate month and day of month</span>

      cal_arr = cal_date(year, d_arr(3))
      month = cal_arr(0)
      day = cal_arr(1)

   ENDIF ELSE BEGIN
      message,'ERROR - Invalid date format in PDS label'

   ENDELSE
ENDELSE

d_arr(0) = year
d_arr(1) = month
d_arr(2) = day

return, d_arr

end

<span class="comments">;------------------------------------------------------------------------------</span>
<span class="comments">;	define function that calculates decimal time of day</span>
<span class="comments">;------------------------------------------------------------------------------</span>

<a id="TIME_SEP:source"></a>function TIME_SEP, tm

<span class="comments">;	Separate the time into its components using ':' as a separator</span>

if (!VERSION.RELEASE GT 5.2) then begin
    time_arr = strsplit(tm, ':', /EXTRACT)
endif else begin
    time_arr = str_sep(tm,':')    <span class="comments">; obsolete in IDL v. > 5.2</span>
endelse

<span class="comments">;	We know that at least the hour and mins will be provided.</span>

hour = double(time_arr(0))
min = double(time_arr(1))

<span class="comments">;	Initialize seconds to zero.</span>

sec = 0

<span class="comments">;	test to see if seconds are provided and if 'Z' is present</span>

IF n_elements(time_arr) EQ 3 THEN BEGIN
   z = strpos(time_arr(2), 'Z')
   IF z NE -1 THEN BEGIN
      sec = strmid(time_arr(2), 0, z)
      sec = double(sec)
   ENDIF ELSE sec = double(time_arr(2))
ENDIF

<span class="comments">;	Return time as a decimal fraction of day</span>

return, float( (hour + min/60 + sec/3600)/24 )
end

<span class="comments">;------------------------------------------------------------------------------</span>
<span class="comments">;	define parent function, TIMEPDS:</span>
<span class="comments">;------------------------------------------------------------------------------</span>

<a id="TIMEPDS:source"></a>function TIMEPDS, label, usr_month, usr_day, DOY = doy, JD = jd

<span class="comments">;ON_ERROR, 1</span>

IF n_params() NE 1 AND n_params() NE 3 THEN BEGIN
 print, 'Syntax: result = TIMEPDS(label, month, day, [/DOY, /JD])'
 print, 'Note: If an optional keyword is present and nonzero, it should'
 print, 'take the place of month and day.'
 return, -1
ENDIF

<span class="comments">;	Read object to determine type of data in file</span>

object = pdspar(label,'OBJECT')

IF !ERR EQ -1 THEN message, 'ERROR - '+label+' missing required OBJECT keyword'

<span class="comments">;	a value may not be provided, so initialize it to zero</span>

time = 0
month = 0
day = 0
year = 0

FOR i = 0, (n_elements(object) - 1) DO BEGIN

   <span class="comments">;	test to see if filename is an image</span>

   IF (object(i) EQ 'IMAGE') THEN BEGIN

      <span class="comments">;	Now we look for 'TIME' and 'DATE' keywords and if neither are provided,</span>
      <span class="comments">;	an error occurs.  The following 'TIME' keywords are supported:</span>
      <span class="comments">;	START_TIME, OBSERVATION_TIME, UT_TIME, SPACECRAFT_START_TIME.  The </span>
      <span class="comments">; following 'DATE' keywords are supported:  OBSERVATION_DATE, UT_DATE.</span>

      time_flag = 1
      date_flag = 1

      start_tm = pdspar(label, 'START_TIME')
      IF !ERR EQ -1 THEN start_tm = pdspar(label, 'OBSERVATION_TIME')
      IF !ERR EQ -1 THEN start_tm = pdspar(label, 'UT_TIME')
      IF !ERR EQ -1 THEN start_tm = pdspar(label, 'SPACECRAFT_START_TIME')
      IF !ERR EQ -1 THEN time_flag = 0

      start_dt = pdspar(label, 'OBSERVATION_DATE')
      IF !ERR EQ -1 THEN start_dt = pdspar(label, 'UT_DATE')
      IF !ERR EQ -1 THEN date_flag = 0

      IF (NOT time_flag AND NOT date_flag) THEN $
         message, 'ERROR - '+label+' missing a time and date keyword'

      <span class="comments">;	There are a number of possible combinations of time and/or date</span>
      <span class="comments">;	keywords that appear in a PDS label.  First, any keyword containing</span>
      <span class="comments">;	the substring, 'TIME', will have a time and maybe a date, as well, but</span>
      <span class="comments">;	it cannot have only a date.  Similarly, any keyword containing the</span>
      <span class="comments">;	substring, 'DATE', will have a date and maybe a time, but it</span>
      <span class="comments">;	cannot have only a time.</span>
      <span class="comments">;</span>
      <span class="comments">;	First, we check for a 'TIME' keyword:</span>

      IF time_flag THEN BEGIN

         <span class="comments">;	There are two possibilities for the format of this value:</span>
         <span class="comments">;	1) time or 2) dateTtime.  We will attempt to separate the</span>
         <span class="comments">;	value using 'T' as a separator.  If the resulting array has 2</span>
         <span class="comments">;	elements, we know the format is of 2) from above, but if it</span>
         <span class="comments">;	has just 1 element, the format is of 1).</span>

         if (!VERSION.RELEASE GT 5.2) then begin
             sep_arr = strsplit(start_tm(0), 'T', /EXTRACT)
         endif else begin
             sep_arr = str_sep(start_tm(0),'T')   <span class="comments">; obsolete in IDL v. > 5.2</span>
         endelse
         IF n_elements(sep_arr) EQ 2 THEN BEGIN

            <span class="comments">;	PDS standards dictate that the time is after the date.  Call </span>
            <span class="comments">;	the function, time_sep, to calculate the decimal time and </span>
            <span class="comments">;	date_sep to calculate the day.</span>

            time = time_sep(sep_arr(1))
            d_arr = date_sep(sep_arr(0))
            year = d_arr(0)
            month = d_arr(1)
            day = d_arr(2)
            doy3 = d_arr(3)

         ENDIF ELSE BEGIN
            time = time_sep(sep_arr(0))

            <span class="comments">;	There must be a date provided in the PDS label for timepds to</span>
            <span class="comments">;	work.</span>

            IF (NOT date_flag) $
            THEN message,'ERROR - '+label+' missing required date'
         ENDELSE
      ENDIF

      <span class="comments">;	Check for the date keyword:</span>

      IF date_flag THEN BEGIN
         if (!VERSION.RELEASE GT 5.2) then begin
             sep_arr = strsplit(start_dt(0), 'T', /EXTRACT)
         endif else begin
             sep_arr = str_sep(start_dt(0),'T')    <span class="comments">; obsolete in IDL v. > 5.2</span>
         endelse

         <span class="comments">;	The date is the first element no matter what...</span>

         d_arr = date_sep(sep_arr(0))
         year = d_arr(0)
         month = d_arr(1)
         day = d_arr(2)
         doy3 = d_arr(3)

         <span class="comments">;	Check to see if the time is also provided:</span>

         IF n_elements(sep_arr) EQ 2 THEN time = time_sep(sep_arr(1))
      ENDIF

      IF keyword_set(jd) THEN BEGIN
         juldate = jdate(year, month, day, time)
         print, 'Julian Date:  2400000 +', juldate
         return, juldate
      ENDIF ELSE BEGIN

         <span class="comments">;	We test to see if doy was provided, otherwise we must</span>
         <span class="comments">;	calculate it.</span>

         IF doy3 THEN final_doy = doy3 + time $
         ELSE final_doy = day_of_year(year, month, day, time)
         IF keyword_set(doy) THEN return, final_doy $
         ELSE return, custom(final_doy, year, month, day, usr_month, usr_day)
      ENDELSE

   ENDIF ELSE BEGIN

      <span class="comments">;	Test to see if the object is a table:</span>

      IF (object(i) EQ 'TABLE') OR (object(i) EQ 'INDEX_TABLE') THEN BEGIN

         inform=pdspar(label,'INTERCHANGE_FORMAT')
         IF !ERR EQ -1 $
         THEN message,'ERROR - '+label+' missing required INTERCHANGE_FORMAT keyword'
         IF inform(0) EQ 'BINARY' $
         THEN message, 'ERROR - PDS table must be an ASCII table file.'

         <span class="comments">;	We must get the file pointer "^TABLE = " or "^INDEX_TABLE = "</span>

         pointer = pdspar(label,'TABLE')
         IF !ERR EQ -1 THEN filename = pdspar(label, 'INDEX_TABLE')
         IF !ERR EQ -1 $
         THEN message, 'ERROR - No pointers to table data found in ' + label

         <span class="comments">;	Find positions of double quotes surrounding filename:</span>

         leftpos = strpos(pointer(0),'"')
         IF leftpos EQ -1 $
         THEN message, 'ERROR - No filename found in pointer to image data'

         rightpos = strpos(pointer(0),'"',leftpos + 1)

         <span class="comments">;	Extract filename from inside double quotes:</span>

         filename = strmid(pointer(0), leftpos + 1, rightpos - leftpos - 1)

         <span class="comments">;	Remove leading and trailing blanks:</span>

         filename = strtrim(filename, 2)

         <span class="comments">;	Read the table and label:</span>

<span class="comments">;;A.Cardesin 13-04-2005</span>
<span class="comments">;;Modified: function name corrected'tascpds_test'-->'tascpds'</span>
         data = tascpds(filename, label, /SILENT)

         n_columns = pdspar(label, 'COLUMNS')
         IF !ERR EQ -1 $
         THEN message, 'ERROR - '+label+' missing required COLUMNS keyword' $
         ELSE n_columns = fix(n_columns(0))

         <span class="comments">;	We initialize these indexes to -1 because later we will test</span>
         <span class="comments">;	to see which ones are provided:</span>

         time_col = -1
         date_col = -1
         doy3 = 0

         FOR i = 0, n_columns DO BEGIN

            <span class="comments">;	In the structure returned by tascpds, search the column_names</span>
            <span class="comments">;	element for the keywords and assign the appropriate element of</span>
            <span class="comments">;	the structure to an array.  </span>

            col_name = data.column_names(i)

            CASE 1 OF
               col_name EQ 'START_TIME' OR col_name EQ 'OBSERVATION_TIME' OR $
               col_name EQ 'UT_TIME' OR col_name EQ 'SPACECRAFT_START_TIME': $
               BEGIN
                  time_col = i
                  times_arr = data.(i)
                  dummy_arr = times_arr
               END
               col_name EQ 'OBSERVATION_DATE' OR col_name EQ 'UT_DATE': BEGIN
                  date_col = i
                  dates_arr = data.(i)
                  dummy_arr = dates_arr
               END
               ELSE: 
            ENDCASE

         ENDFOR

         IF (time_col EQ -1) AND (date_col EQ -1) $
         THEN message, 'ERROR - Invalid or no time keyword in PDS label'

         <span class="comments">;	We use the dummy_arr to declare the final arrays:</span>

         n_el = n_elements(dummy_arr)

         jd_arr = dblarr(n_el)
         doy_arr = fltarr(n_el)
         cu_arr = fltarr(n_el)

         <span class="comments">;	Now, we will go through the date and/or time array(s) one</span>
         <span class="comments">;	element at a time and perform the necessary calculations.</span>

         FOR k = 0, n_el - 1 DO BEGIN

            <span class="comments">;	IF there is a 'time' and a separate 'date' keyword:</span>

            IF (time_col NE -1) AND (date_col NE -1) THEN BEGIN
               d_arr = date_sep(dates_arr(k))
               year = d_arr(0)
               month = d_arr(1)
               day = d_arr(2)
               doy3 = d_arr(3)
               time = time_sep(times_arr(k))

            ENDIF ELSE BEGIN

               <span class="comments">;	if there is just a 'TIME' keyword, it must contain</span>
               <span class="comments">;	both a date and time in the format, dateTtime.</span>

               IF (time_col NE -1) AND (date_col EQ -1) THEN BEGIN
                  if (!VERSION.RELEASE GT 5.2) then begin
                      sep_arr = strsplit(times_arr(k), 'T', /EXTRACT)
                  endif else begin
                     sep_arr = str_sep(times_arr(k),'T') <span class="comments">; obsolete in IDL> 5.2</span>
                  endelse
                  d_arr = date_sep(sep_arr(0))
                  year = d_arr(0)
                  month = d_arr(1)
                  day = d_arr(2)
                  doy3 = d_arr(3)
                  time = time_sep(sep_arr(1))
               ENDIF

               <span class="comments">; if there is just a 'DATE' keyword, it must contain</span>
               <span class="comments">; at least a date and maybe a time in the format, dateTtime.</span>

               IF (time_col EQ -1) AND (date_col NE -1) THEN BEGIN
                  if (!VERSION.RELEASE GT 5.2) then begin
                      sep_arr = strsplit(dates_arr(k), 'T', /EXTRACT)
                  endif else begin
                      sep_arr = str_sep(dates_arr(k),'T') <span class="comments">; obsolete in IDL>5.2</span>
                  endelse
                  d_arr = date_sep(sep_arr(0))
                  year = d_arr(0)
                  month = d_arr(1)
                  day = d_arr(2)
                  doy3 = d_arr(3)
                  IF n_elements(sep_arr) EQ 2 THEN time = time_sep(sep_arr(1))
               ENDIF

            ENDELSE

            IF keyword_set(jd) $
            THEN jd_arr(k) = jdate(year, month, day, time) $
            ELSE BEGIN

               IF doy3 THEN doy_arr(k) = doy3 + time $
               ELSE doy_arr(k) = day_of_year(year, month, day, time)

               IF not keyword_set(doy) $
               THEN cu_arr(k)=custom(doy_arr(k),year, $
                                     month,day,usr_month,usr_day)

            ENDELSE

         ENDFOR

         IF keyword_set(jd) THEN return, jd_arr
         IF keyword_set(doy) THEN return, doy_arr
         return, cu_arr

      ENDIF
   ENDELSE

ENDFOR

message, 'Could not determine type of data in PDS file'

end
</code>
    </div>
  </body>
</html>