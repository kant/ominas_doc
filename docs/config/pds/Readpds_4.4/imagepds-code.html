<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 20:36:24 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>imagepds.pro (OMINAS Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="imagepds.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; NAME: IMAGEPDS</span>
<span class="comments">; </span>
<span class="comments">; PURPOSE: To read an image array into an array variable</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE: Result = IMAGEPDS (filename, label [,/SILENT, /NOSCALE]</span>
<span class="comments">; </span>
<span class="comments">; INPUTS:</span>
<span class="comments">;     Filename: Scalar string containing the name of the PDS file to read</span>
<span class="comments">;     Label: String array containing the image header information</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;     Result: image array constructed from designated record</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT:</span>
<span class="comments">;     SILENT: suppresses any messages from the procedure</span>
<span class="comments">;     NOSCALE: does not perform scaling and offset of values, default</span>
<span class="comments">;         is to scale and offset</span>
<span class="comments">; </span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;     To read an image file IMAGE.LBL into an array, img:</span>
<span class="comments">;        IDL> label = headpds("IMAGE.LBL", /SILENT)</span>
<span class="comments">;        IDL> img = imagepds("IMAGE.LBL", label,/SILENT)</span>
<span class="comments">;     To read an image file IMAGEWIN.LBL with a window object into img:</span>
<span class="comments">;        IDL> label = headpds("IMAGEWIN.LBL", /SILENT)</span>
<span class="comments">;        IDL> img = imagepds("IMAGEWIN.LBL",/SILENT)</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;     Functions: APPLY_BITMASK, CLEAN, GET_INDEX, OBJPDS, PDSPAR,</span>
<span class="comments">;         POINTPDS, REMOVE</span>
<span class="comments">; </span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;     Adapted by John D. Koch from READFITS by Wayne Landsman,</span>
<span class="comments">;         December, 1994</span>
<span class="comments">;     </span>
<span class="comments">;     Re-written by: Puneet Khetarpal [January 25, 2005]</span>
<span class="comments">;     For a complete list of modifications, see changelog.txt file.</span>
<span class="comments">;</span>
<span class="comments">;-----------------------------------------------------------------------------</span>

<span class="comments">;- level 3 -------------------------------------------------------------------</span>

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: start and end index are viable indices for current</span>
<span class="comments">;     image; so is label; param is a PDS keyword name to be extracted</span>
<span class="comments">;     from label; required is a boolean describing whether the keyword</span>
<span class="comments">;     to be extracted is required for the image object or not.</span>
<span class="comments">; postcondition: the keyword for current image object is extracted and returned</span>
  
<a id="extract_image_keywords:source"></a>function extract_image_keywords, start_ind, end_ind, label, param, required
    <span class="comments">; intialize variables:</span>
    flag = 0      <span class="comments">; 1: found, 0: not found</span>
    <span class="comments">; determine if param value is of type string or not:</span>
    isstring = ((param eq "SAMPLE_TYPE") || $
               (strpos(param, "DISPLAY") gt -1)) ? 1 : 0  
    <span class="comments">; determine if param value if of type double or not:</span>
    isfloat = ((param eq "OFFSET") || (param eq "SCALING_FACTOR")) ? 1 : 0

    <span class="comments">; first extract all param keywords value in the label:</span>
    allvalues = pdspar(label, param, count=allcount, index=allindex)
    if (allcount gt 0) then begin
        <span class="comments">; extract all param value between start_ind and next object or</span>
        <span class="comments">; end index:</span>
        objects = pdspar(label, "OBJECT", count=objcount, index=objindex)
        pos = where (objindex gt start_ind, cnt)
        if (cnt gt 0) then begin
            greatind = objindex[pos[0]]
            ppos = where (allindex gt start_ind and allindex lt greatind, pcnt)
        endif else begin
            ppos = where(allindex gt start_ind and allindex lt end_ind, pcnt)
        endelse

        if (pcnt gt 0) then begin
            value = clean(allvalues[ppos[0]], /space)
            flag = 1
            
            <span class="comments">; convert into appropriate type:</span>
            if (isstring) then begin
                par = ['"', "'", "(", ")", ","]
                value = remove(value, par)
            endif else if (isfloat) then begin
                value = float(value)
            endif else begin
                value = long(value)
            endelse
        endif
    endif

    <span class="comments">; if not found then issue error:</span>
    if (~flag) then begin
        if (required) then begin
            print, "Error: missing required " + param + " keyword from label"
        endif
        value = "-1"
    endif

    return, value
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: value is an idl scalar obtained from the label for</span>
<span class="comments">;     current image object definition</span>
<span class="comments">; postcondition: the value is tested for whether it is of type string</span>
<span class="comments">;     or not</span>

<a id="is_string:source"></a>function is_string, value
    <span class="comments">; get size information of value:</span>
    flag = (size(value, /type) eq 7) ? 1 : 0
    return, flag
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: keywds contains all current image object definitions</span>
<span class="comments">; postcondition: all keyword values are tested for viability</span>

<a id="check_image_keywords:source"></a>function check_image_keywords, keywds, silent
    <span class="comments">; check line samples:</span>
    if (keywds.line_samples eq 0) then begin
        print, "Error: LINE_SAMPLES keyword value is 0. No data in file."
        goto, endfunction
    endif else if (keywds.line_samples lt 0) then begin
        print, "Error: Invalid LINE_SAMPLES keyword value found: " + $
            clean(string(keywds.line_samples), /space)
        goto, endfunction
    endif  

    <span class="comments">; check lines:</span>
    if (keywds.lines eq 0) then begin
        print, "Error: LINES keyword value is 0. No data in file."
        goto, endfunction
    endif else if (keywds.lines lt 0) then begin
        print, "Error: Invalid LINES keyword value found: " + $
            clean(string(keywds.lines), /space)
        goto, endfunction
    endif

    <span class="comments">; check sample bits:</span>
    bitsrange = [8, 16, 32, 64]
    pos = where (keywds.bits eq bitsrange, cnt)
    if (cnt eq 0) then begin
        print, "Error: invalid SAMPLE_BITS keyword value found: " + $
            clean(string(keywds.bits), /space) 
        goto, endfunction
    endif

    <span class="comments">; check sample type:</span>
    if (strlen(keywds.sample_type) eq 0) then begin
        print, "Error: null SAMPLE_TYPE keyword value found."
        goto, endfunction
    endif

    <span class="comments">; check sample display direction:</span>
    if (keywds.sdd eq "-1") then begin
        if (~silent) then begin
          print, "Note: SAMPLE_DISPLAY_DIRECTION keyword not found..."
          print, "  assuming default value of RIGHT."
        endif
        keywds.sdd = "RIGHT"
    endif
    ddrange = ["UP", "DOWN", "LEFT", "RIGHT"]
    pos = where (keywds.sdd eq ddrange, cnt)
    if (cnt eq 0) then begin
        print, "Error: invalid SAMPLE_DISPLAY_DIRECTION keyword: " + keywds.sdd
        print, "  assuming default value of RIGHT."
        keywds.sdd = "RIGHT"
    endif

    <span class="comments">; check line display direction:</span>
    if (keywds.ldd eq "-1") then begin
        if (~silent) then begin
          print, "Note: LINE_DISPLAY_DIRECTION keyword not found..."
          print, "  assuming default value of DOWN."
        endif
        keywds.ldd = "DOWN"
    endif
    pos = where (keywds.ldd eq ddrange, cnt)
    if (cnt eq 0) then begin
        print, "Error: invalid LINE_DISPLAY_DIRECTION keyword: " + keywds.ldd
        print, "  assuming default value of DOWN."
        keywds.ldd = "DOWN"
    endif

    return, keywds

    endfunction:
        keywds.flag = 0
        return, keywds
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: start and end index are viable indices for current</span>
<span class="comments">;     image object, and wobjects contains all the window objects</span>
<span class="comments">;     in the label</span>
<span class="comments">; postcondition: all window subobjects for current image object are returned</span>

<a id="get_subwindows:source"></a>function get_subwindows, start_ind, end_ind, wobjects
    <span class="comments">; initialize variable:</span>
    struct = {flag: 0, count:0}
    windex = wobjects.index

    <span class="comments">; find whether there exist window subobjects for start index:</span>
    pos = where (windex gt start_ind and windex lt end_ind, count)
    if (count gt 0) then begin
        struct.flag = 1
        struct.count = count
        array = wobjects.array[pos]
        index = wobjects.index[pos]
        struct = create_struct(struct, "array", array, "index", index)
    endif

    return, struct
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: start and end index are viable indices for the current</span>
<span class="comments">;     subwindow object; so is label; element contains the current</span>
<span class="comments">;     image object array</span>
<span class="comments">; postcondition: the current window subobject parameters are obtained</span>
<span class="comments">;     from label and returned in a structure</span>

<a id="obtain_current_window_params:source"></a>function obtain_current_window_params, start_ind, end_ind, label, element
    <span class="comments">; initialize keyword structure variable:</span>
    keywds = {flag: 1}
    
    <span class="comments">; get dimensions of element:</span>
    dim = size(element, /dimensions)

    <span class="comments">; extract first line:</span>
    first_line = extract_image_keywords(start_ind, end_ind, label, $
        "FIRST_LINE", 1)
    if (is_string(first_line)) then goto, endfunction

    <span class="comments">; check first line:</span>
    if (first_line le 0 || first_line gt dim[1]) then begin
        print, "Error: FIRST_LINE keyword value exceeds image: " + $
            clean(string(first_line),/space)
        goto, endfunction
    endif

    <span class="comments">; extract first line sample:</span>
    first_line_sample = extract_image_keywords(start_ind, end_ind, label, $
        "FIRST_LINE_SAMPLE", 1)
    if (is_string(first_line_sample)) then goto, endfunction

    <span class="comments">; check first line sample:</span>
    if (first_line_sample le 0 || first_line_sample gt dim[0]) then begin
        print, "Error: FIRST_LINE_SAMPLE keyword value exceeds image: " + $
            clean(string(first_line), /space)
        goto, endfunction
    endif

    <span class="comments">; extract line samples:</span>
    line_samples = extract_image_keywords(start_ind, end_ind, label, $ 
        "LINE_SAMPLES", 1)
    if (is_string(line_samples)) then goto, endfunction

    <span class="comments">; check line samples:</span>
    if (line_samples eq 0) then begin
        print, "Error: LINE_SAMPLES keyword value is 0. No data in file."
        goto, endfunction
    endif else if (line_samples lt 0) then begin
        print, "Error: Invalid LINE_SAMPLES keyword value found: " + $
            clean(string(line_samples), /space)
        goto, endfunction
    endif  

    <span class="comments">; extract lines:</span>
    lines = extract_image_keywords(start_ind, end_ind, label, "LINES", 1)
    if (is_string(lines)) then goto, endfunction

    <span class="comments">; check lines:</span>
    if (lines eq 0) then begin
        print, "Error: LINES keyword value is 0. No data in file."
        goto, endfunction
    endif else if (lines lt 0) then begin
        print, "Error: Invalid LINES keyword value found: " + $
            clean(string(lines), /space)
        goto, endfunction
    endif

    keywds = create_struct(keywds, "first_line", first_line, $
        "first_line_sample", first_line_sample, "line_samples", line_samples, $
        "lines", lines)

    return, keywds
    endfunction:
        keywds.flag = 0
        return, keywds
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: element is either a subwindow array or the image</span>
<span class="comments">;     array; keywds contains all current image object definitions.</span>
<span class="comments">; postcondition: the element array is rotated depending upon the</span>
<span class="comments">;     values of line and sample display direction keyword values</span>
 
<a id="process_display_direction:source"></a>function process_display_direction, element, keywds
    <span class="comments">; local variables:</span>
    ldd = keywds.ldd
    sdd = keywds.sdd
    saveelement = element

    <span class="comments">; process display direction:</span>
    if (sdd eq "RIGHT") then begin
        element = (ldd eq "UP") ? rotate(element, 0) : $
           (ldd eq "DOWN") ? rotate(element, 7) : -1 
    endif else if (sdd eq "LEFT") then begin
        element = (ldd eq "UP") ? rotate(element, 5) : $
           (ldd eq "DOWN") ? rotate(element, 2) : -1
    endif else if (sdd eq "UP") then begin
        element = (ldd eq "LEFT") ? rotate(element, 3) : $
           (ldd eq "RIGHT") ? rotate(elment, 4): -1
    endif else if (sdd eq "DOWN") then begin
        element = (ldd eq "LEFT") ? rotate(element, 6) : $
           (ldd eq "RIGHT") ? rotate(element, 1) : -1
    endif

    stat = size(element, /dimensions)
    if (stat[0] eq 0) then begin
        print, "Error: invalid LINE_DISPLAY_DIRECTION " + ldd + $
               " and SAMPLE_DISPLAY_DIRECTION " + sdd + " combination"
        return, saveelement
    endif

    return, element
end


<span class="comments">;- level 2 -------------------------------------------------------------------</span>

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: start and end index are viable indices; so is label</span>
<span class="comments">; postcondition: all current image parameters are extracted from label</span>

<a id="obtain_current_image_params:source"></a>function obtain_current_image_params, start_ind, end_ind, label, silent
    <span class="comments">; initialize keyword structure variable:</span>
    keywds = {flag:1}

    <span class="comments">; required keywords:</span>
    <span class="comments">; line samples:</span>
    line_samples = extract_image_keywords(start_ind, end_ind, label, $
        "LINE_SAMPLES", 1)
    if (is_string(line_samples)) then goto, endfunction

    <span class="comments">; lines:</span>
    lines = extract_image_keywords(start_ind, end_ind, label, "LINES", 1)
    if (is_string(lines)) then goto, endfunction

    <span class="comments">; bits:</span>
    bits = extract_image_keywords(start_ind, end_ind, label, "SAMPLE_BITS", 1)
    if (is_string(lines)) then goto, endfunction

    <span class="comments">; sample type:</span>
    sample_type = extract_image_keywords(start_ind, end_ind, label, $ 
        "SAMPLE_TYPE", 1)

    if (sample_type eq "-1") then goto, endfunction

    <span class="comments">; optional keywords:</span>
    <span class="comments">; sample display direction:</span>
    samp_dis_dir = extract_image_keywords(start_ind, end_ind, label, $
        "SAMPLE_DISPLAY_DIRECTION", 0)
    
    <span class="comments">; line display direction:</span>
    line_dis_dir = extract_image_keywords(start_ind, end_ind, label, $
        "LINE_DISPLAY_DIRECTION", 0)

    <span class="comments">; offset:</span>
    offset = extract_image_keywords(start_ind, end_ind, label, "OFFSET", 0)
    if (is_string(offset)) then offset = double(0.0)

    <span class="comments">; scaling factor:</span>
    scaling_factor = extract_image_keywords(start_ind, end_ind, label, $
        "SCALING_FACTOR", 0)
    if (is_string(scaling_factor)) then scaling_factor = double(1.0)

    <span class="comments">; line prefix bytes:</span>
    prefix_bytes = extract_image_keywords(start_ind, end_ind, label, $
        "LINE_PREFIX_BYTES", 0)
    if (is_string(prefix_bytes)) then prefix_bytes = long(0)

    <span class="comments">; line suffix bytes:</span>
    suffix_bytes = extract_image_keywords(start_ind, end_ind, label, $
        "LINE_SUFFIX_BYTES", 0)
    if (is_string(suffix_bytes)) then suffix_bytes = long(0) 

    keywds = create_struct(keywds, "line_samples", line_samples, "lines", $
        lines, "bits", bits, "sample_type", sample_type, "sdd", samp_dis_dir, $
        "ldd", line_dis_dir, "offset", offset, "scaling_factor", $
        scaling_factor, "prefix_bytes", prefix_bytes, "suffix_bytes", $
        suffix_bytes)

    keywds = check_image_keywords(keywds,silent)

    return, keywds
    endfunction:
        keywds.flag = 0
        return, keywds
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: sample type is a viable sample type keyword value for</span>
<span class="comments">;     current image object</span>
<span class="comments">; postcondition: the architecture for the data file is determined</span>

<a id="obtain_image_architecture:source"></a>function obtain_image_architecture, sample_type
    <span class="comments">; initialize architecture variable:</span>
    arch = "MSB"

    <span class="comments">; obtain all types of keyword values from the label:</span>
    if ((strpos(sample_type, "LSB") gt -1) || $
        (strpos(sample_type, "PC") gt -1) || $
        (strpos(sample_type, "VAX") gt -1)) then begin
        arch = "LSB"
    endif

    return, arch
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: keywds is the idl structure definition for current</span>
<span class="comments">;     image object.</span>
<span class="comments">; postcondition: an idl structure is created to read the data from the</span>
<span class="comments">;     data file</span>
 
<a id="obtain_image_structure:source"></a>function obtain_image_structure, keywds
    <span class="comments">; initialize structure:</span>
    bits = keywds.bits   <span class="comments">; temporary store bits value</span>
    type = keywds.sample_type <span class="comments">; temporary store sample_type value</span>

    <span class="comments">; get the line sample vector for image:</span>
    if (bits eq 8) then begin
        idl_type = 1
    endif else if (bits eq 16) then begin
        idl_type = (strpos(type, "UNSIGNED") gt -1) ? 12 : 2
    endif else if (bits eq 32) then begin
        if (strpos(type, "INTEGER") gt -1) then begin
            idl_type = (strpos(type, "UNSIGNED") gt -1) ? 13 : 3
        endif else begin
            idl_type = 4
        endelse
    endif else if (bits eq 64) then begin
        if (strpos(type, "INTEGER") gt -1) then begin
            idl_type = (strpos(type, "UNSIGNED") gt -1) ? 15 : 14
        endif else begin
            idl_type = 5
        endelse
    endif

    vector = make_array(keywds.line_samples, type = idl_type)

    <span class="comments">; construct the prefix byte structure:</span>
    if (keywds.prefix_bytes gt 0) then begin
        struct = {prefix:bytarr(keywds.prefix_bytes), sample:vector}
    endif else begin
        struct = {sample:vector}
    endelse

    <span class="comments">; construct the suffix byte structure:</span>
    if (keywds.suffix_bytes gt 0) then begin
        struct = create_struct(struct, "suffix", bytarr(keywds.suffix_bytes))
    endif

    <span class="comments">; now replicate the structure lines times:</span>
    main = replicate(struct, keywds.lines)

    return, main
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: pointer is an idl structure containing viable data</span>
<span class="comments">;     file name associated with current image object to be read, and</span>
<span class="comments">;     the number of bytes to skip if any; struct is the idl structure</span>
<span class="comments">;     to be read from the data file, and arch is the architecture of</span>
<span class="comments">;     the data file (LSB or MSB).</span>
<span class="comments">; postcondition: the data file is opened, the structure is read, and</span>
<span class="comments">;     returned</span>

<a id="read_image_data:source"></a>function read_image_data, pointer, struct, arch
    <span class="comments">; error protection:</span>
    on_ioerror, signal

    <span class="comments">; initialize variable and declare flag:</span>
    data_read = {flag: 1} <span class="comments">; 0: error, 1: no error</span>

    <span class="comments">; open the file to be read and apply swap endian if needed:</span>
    if (arch eq "MSB") then begin
        openr, unit, pointer.datafile, /get_lun, /swap_if_little_endian
    endif else begin
        openr, unit, pointer.datafile, /get_lun, /swap_if_big_endian
    endelse

    <span class="comments">; set the file pointer to current object to be read:</span>
    point_lun, unit, pointer.skip

    <span class="comments">; read the image object into structure:</span>
    readu, unit, struct

    <span class="comments">; close the unit and free the unit:</span>
    close, unit
    free_lun, unit
    
    data_read = create_struct(data_read, "struct", struct)

    return, data_read

    signal:
        on_ioerror, null
        print, "Error: file either corrupted or invalid parameters specified"+$
               " in label."
        data_read.flag = 0
        close, unit
        free_lun, unit
        return, data_read
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: current contains the raw image data for current image</span>
<span class="comments">;     object as read from the datafile; keywds contains all current</span>
<span class="comments">;     image object keyword values.</span>
<span class="comments">; postcondition: extracts the image array from the current structure,</span>
<span class="comments">;     converts the array values to signed integers if necessary, and</span>
<span class="comments">;     performs scaling and offset if noscale keyword is not supplied.</span>

<a id="convert_image_data:source"></a>function convert_image_data, current, label, start_ind, end_ind,keywds, noscale
    <span class="comments">; extract image from the read data:</span>
    element = current[*].sample

    <span class="comments">; convert data elements for signed bytarr objects</span>
    <span class="comments">; (IDL only supports byte values of 0-255):</span>
    pos = strpos(keywds.sample_type, "UNSIGNED")
    if ((keywds.bits eq 8) && (pos lt 0)) then begin
        element = fix(element)
        fixitlist = where (element gt 127, count)
        if (count gt 0) then begin
            element[fixitlist] = element[fixitlist] - 256
        endif
    endif  

    <span class="comments">; apply bit mask if applicable:</span>
    element = apply_bitmask(label, start_ind, end_ind, element)

    <span class="comments">; process scaling factor and offset:</span>
    if (~noscale) then begin
        if (keywds.scaling_factor ne 1.0) then begin
            element *= keywds.scaling_factor
        endif
        if (keywds.offset ne 0.0) then begin
            element += keywds.offset
        endif
    endif

    return, element
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: start_ind and end_ind are viable start and end indices</span>
<span class="comments">;     of current image object; element contains the image array</span>
<span class="comments">;     information with the converted values, and bitmask applied;</span>
<span class="comments">;     wobjects and label are viable, and imgkeywds is an idl structure</span>
<span class="comments">;     containing current image object keyword values.</span>
<span class="comments">; postcondition: all window subobjects for the current image object,</span>
<span class="comments">;     if present, are processed and returned </span>

<a id="process_windows:source"></a>function process_windows, start_ind, end_ind, element, wobjects, label, $ 
  imgkeywds, silent
    <span class="comments">; initialize structure:</span>
    windows_struct = {flag: 1}

    <span class="comments">; check existence of window subobjects and get their positions:</span>
    subwindows = get_subwindows(start_ind, end_ind, wobjects)
    if (~subwindows.flag) then goto, endfunction
    count = subwindows.count
    array = subwindows.array
    index = subwindows.index

    <span class="comments">; intialize data structure for windows objects:</span>
    if (count gt 1) then wdata = {windows: count}

    <span class="comments">; process each window subobject:</span>
    for j = 0, count - 1 do begin
        <span class="comments">; set current and next window object pointer:</span>
        cur_win = index[j]
        next_win = (j lt count - 1) ? index[j + 1] : end_ind

        <span class="comments">; obtain required keywords for current window object:</span>
        keywds = obtain_current_window_params(cur_win, next_win, label,element)
        if (~keywds.flag) then goto, endfunction

        <span class="comments">; notify to user if not silent:</span>
        if (~silent) then begin
            xtext = clean(string(keywds.line_samples), /space)
            ytext = clean(string(keywds.lines), /space)
            print, "  Now processing " + xtext + " by " + ytext + " window"
        endif

        <span class="comments">; extract the window vector from element:</span>
        x1 = keywds.first_line_sample - 1     <span class="comments">; x - top left corner of window</span>
        y1 = keywds.first_line - 1            <span class="comments">; y - top left corner of window</span>
        x2 = x1 + keywds.line_samples - 1     <span class="comments">; x - bottom right corner</span>
        y2 = y1 + keywds.lines - 1            <span class="comments">; y - bottom right corner </span>
        win_element = element(x1:x2, y1:y2)

        <span class="comments">; process display directions</span>
        win_element = process_display_direction(win_element, imgkeywds)

        <span class="comments">; store the window vector into windows data structure:</span>
        if (count gt 1) then begin
            name = array[j] + clean(string(j + 1), /space)
            wdata = create_struct(wdata, name, win_element)
        endif else begin
            wdata = create_struct("window", win_element)
        endelse
    endfor

    <span class="comments">; add entire image to window structure:</span>
    element = process_display_direction(element, imgkeywds)
    wdata = create_struct(wdata, "image", element)
    windows_struct = create_struct(windows_struct, "wdata", wdata)

    return, windows_struct

    endfunction:
        windows_struct.flag = 0
        return, windows_struct
end 

<span class="comments">;- level 1 -------------------------------------------------------------------</span>

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: filename and label are viable, and objects has at</span>
<span class="comments">;     least one image object structure, and wobjects definition is</span>
<span class="comments">;     obtained.</span>
<span class="comments">; spotcondition: all image objects are processed as defined in objects</span>
<span class="comments">;     and window structure.</span>
 
<a id="process_all_images:source"></a>function process_all_images, filename, label, objects, wobjects, silent,noscale
    <span class="comments">; initialize the image structure if more than one image:</span>
    if (objects.count gt 1) then data = {images:objects.count}

    <span class="comments">; start the loop:</span>
    for i = 0, objects.count - 1 do begin
        <span class="comments">; get current start and end index pointer:</span>
        start_ind = objects.index[i]
        end_ind = get_index(label, start_ind)
        if (end_ind eq -1) then return, -1

        <span class="comments">; obtain current image object keyword values:</span>
        keywds = obtain_current_image_params(start_ind, end_ind, label,silent)
        if (~keywds.flag) then return, -1  

        <span class="comments">; obtain file data architecture:</span>
        arch = obtain_image_architecture(keywds.sample_type)

        <span class="comments">; obtain image structure:</span>
        struct = obtain_image_structure(keywds)

        <span class="comments">; obtain pointer info:</span>
        pointer = pointpds(label, filename, objects.array[i])
        if (pointer.flag eq "-1") then return, -1

        <span class="comments">; read data:</span>
        if (~silent) then begin
            print, "Now reading " + clean(string(keywds.line_samples),/space) $
                + " by " + clean(string(keywds.lines),/space) + " image"
        endif
        data_read = read_image_data(pointer, struct, arch)        
        if (~data_read.flag) then return, -1
        current = data_read.struct

        <span class="comments">; perform data conversion if needed:</span>
        element = convert_image_data(current, label, start_ind, end_ind, $
            keywds, noscale)

        <span class="comments">; process window sub objects:</span>
        windows = process_windows(start_ind, end_ind, element, wobjects, $
             label, keywds, silent)

        <span class="comments">; save image and windows structure if applicable:</span>
        if (windows.flag) then begin
            data = (objects.count gt 1) ? create_struct(data, $
                objects.array[i], windows.wdata) : windows.wdata
        endif else begin
            element = process_display_direction(element, keywds)
            data = (objects.count gt 1) ? create_struct(data, $
                objects.array[i], element) : element
        endelse

    endfor

    return, data
end

<span class="comments">;- level 0 -------------------------------------------------------------------</span>

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: filename is a viable pds label file name, and label is</span>
<span class="comments">;     a viable pds label.</span>
<span class="comments">; postcondition: all image objects defined in label are read from</span>
<span class="comments">;     associated data file and returned.</span>
 
<a id="imagepds:source"></a>function imagepds, filename, label, SILENT = silent, NOSCALE = noscale
    <span class="comments">; error protection:</span>
    <span class="comments">;on_error, 2</span>
    on_ioerror, signal

    <span class="comments">; check for the number of parameters in function call:</span>
    if (n_params() lt 2) then begin
        print, "Syntax Error: result = IMAGEPDS (filename, label [, /SILENT" +$
               ", /NOSCALE])"
        return, -1
    endif
    silent = keyword_set(SILENT)
    noscale = keyword_set(NOSCALE)

    <span class="comments">; obtain all image and window objects from label:</span>
    objects = objpds (label, "IMAGE")
    if (objects.flag eq -1) then begin
        print, "Error: no IMAGE object found in label"
        return, -1
    endif
    wobjects = objpds(label, "WINDOW")

    <span class="comments">; process all image and window objects:</span>
    data = process_all_images(filename,label,objects,wobjects,silent,noscale)

    return, data

    signal:
        on_ioerror, null
        print, "Error reading file"
        return, -1
end
</code>
    </div>
  </body>
</html>