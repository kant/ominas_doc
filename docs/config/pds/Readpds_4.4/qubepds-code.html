<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 14:16:25 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>qubepds.pro (OMINAS Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="qubepds.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; NAME: QUBEPDS</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE: To read a 3-D image QUBE object into a 3-D IDL array.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;     Result: QUBEPDS (filename, label [,/SILENT, /NOSCALE])</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;     Filename: Scalar string containing the name of the PDS file to read</span>
<span class="comments">;     Label: the PDS label string array containing qube object definitions</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;     Result: and IDL structure containing the qube array(s).</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT:</span>
<span class="comments">;     SILENT: suppresses any message from the procedure</span>
<span class="comments">;     NOSCALE: does not perform scaling and offset of values; default</span>
<span class="comments">;         is to scale and offset</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;     Functions: APPLY_BITMASK, CLEAN, GET_INDEX, OBJPDS, PDSPAR,</span>
<span class="comments">;         POINTPDS, REMOVE</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;     Written by: Puneet Khetarpal [August, 2002]</span>
<span class="comments">;     </span>
<span class="comments">;     09 Mar 2006  A.Cardesin   Do not throw an error for Suffix_bytes NE 4 but only a warning.</span>
<span class="comments">;     </span>
<span class="comments">;     10 Feb 2007  S.Martinez   Update to read qube structure and suffix planes </span>
<span class="comments">;                               depending on the storage order.</span>
<span class="comments">;     </span>
<span class="comments">;     04 Apr 2008  S.Martinez   Corrected bug. </span>
<span class="comments">;                               Fuction obtain_item_idltype moved before obtain_qube_structure.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;     For a complete list of modifications, see changelog.txt file.</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;  - Assume qubes with 3-axes among the 6 possible axes</span>
<span class="comments">;  - All parameters are assumed to have the same variable type </span>
<span class="comments">;     inside a given suffix (the first type in the list *_SUFFIX_ITEM_TYPE)</span>
<span class="comments">;  - Corner regions are not used</span>
<span class="comments">;</span>

<span class="comments">;-----------------------------------------------------------------------------</span>

<span class="comments">;- level 3 -------------------------------------------------------------------</span>

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: start and end index are viable indices; so is label;</span>
<span class="comments">;     param is a PDS keyword to be extracted from label; required is a</span>
<span class="comments">;     boolean describing whether the keyword to be extracted is</span>
<span class="comments">;     required for the qube object or not.</span>
<span class="comments">; postcondition: the keyword for current qube is extracted and returned</span>

<a id="extract_qube_keywords:source"></a>function extract_qube_keywords, start_ind, end_ind, label, param, required
    <span class="comments">; initialize variables:</span>
    flag = 0       <span class="comments">; 1: found, 0: not found</span>

    <span class="comments">; first extract all param keywords value in the label:</span>
    allvalues = pdspar(label, param, count = allcount, index = allindex)
    if (allcount gt 0) then begin
        <span class="comments">;; extract all param value between start_ind and end_ind:</span>
        pos = where (allindex gt start_ind and allindex lt end_ind, cnt)
        if (cnt gt 0) then begin
            value = clean(allvalues[pos[0]], /space)
            flag = 1
        endif
    endif

    <span class="comments">; if not found then issue error:</span>
    if (~flag) then begin
        if (required) then begin
            print, "Error: missing required " + param + " keyword from label"
        endif
        value = "-1"
    endif

    return, value
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: keywds contains all current qube object definitions</span>
<span class="comments">; postcondition: all keyword values are tested for viability</span>

<a id="check_qube_keywords:source"></a>function check_qube_keywords, keywds
    <span class="comments">; construct new structure:</span>
    struct = {flag: 1}
    param = ['"', "(", ")", "{", "}"]

    <span class="comments">; check axes:</span>
    axes = long(clean(keywds.axes, /space))
    if (axes eq 0) then begin
        print, "Error: AXES keyword value is 0. No data in file."
        goto, endfunction
    endif else if (axes lt 1 || axes gt 6) then begin
        print, "Error: invalid AXES keyword value found: " + $
            clean(string(axes), /space)
        goto, endfunction
    endif

    <span class="comments">; check axis name:</span>
    temp = remove(clean(keywds.axis_name, /space), param)
    if (!version.release gt 5.2) then begin
        axis_name = strsplit(temp, ",", /extract)
    endif else begin
        axis_name = str_sep(temp, ",")    <span class="comments">; obsolete in idl v. > 5.2</span>
    endelse
    if (n_elements(axis_name) ne axes) then begin
        print, "Error: invalid number of AXIS_NAME values found: " + $
            clean(string(n_elements(axis_name)), /space) + " ne " + keywds.axes
        goto, endfunction
    endif

    <span class="comments">; check core items:</span>
    temp = remove(clean(keywds.core_items, /space), param)
    if (!version.release gt 5.2) then begin
        core_items = long(strsplit(temp, ",", /extract))
    endif else begin
        core_items = long(str_sep(temp, ","))   <span class="comments">; obsolete in idl v. > 5.2</span>
    endelse
    pos = where (core_items lt 1, cnt)
    if (n_elements(core_items) ne axes) then begin
        print, "Error: invalid number of CORE_ITEMS values found: " + $
            clean(string(n_elements(core_items)), /space) + " ne " +keywds.axes
        goto, endfunction
    endif
    if (cnt gt 0) then begin
        print, "Error: invalid CORE_ITEMS values found: " + $
            clean(string(core_items[pos[0]]), /space) + " (n >= 1)"
        goto, endfunction
    endif

    <span class="comments">; check core item bytes:</span>
    core_item_bytes = long(clean(keywds.core_item_bytes, /space))
    bytesrange = [1, 2, 4]
    pos = where (core_item_bytes eq bytesrange, cnt)
    if (cnt eq 0) then begin
        print, "Error: invalid CORE_ITEM_BYTES keyword value found: " + $
            keywds.core_item_bytes
        goto, endfunction
    endif

    <span class="comments">; check core item type:</span>
    core_item_type = remove(clean(keywds.core_item_type, /space), param)
    if ((strpos(core_item_type, "INTEGER") lt 0) && $
       (strpos(core_item_type, "REAL") lt 0)) then begin
        print, "Error: invalid CORE_ITEM_TYPE keyword value found: " + $
            core_item_type
        goto, endfunction
    endif

    <span class="comments">; check core base:</span>
    core_base = float(clean(keywds.core_base,/space))

    <span class="comments">; check core mulitplier:</span>
    core_multiplier = float(clean(keywds.core_multiplier, /space))

    <span class="comments">; check suffix bytes:</span>
    suffix_bytes = long(clean(keywds.suffix_bytes, /space))
    if (suffix_bytes ne 4) then begin
<span class="comments">;Modified A.Cardesin 2006Mar09</span>
<span class="comments">;Do not throw an error but only a warning and go on checking</span>
        print, "Warning: invalid SUFFIX_BYTES keyword value found: " + $
            keywds.suffix_bytes + " (must = 4)"
<span class="comments">;        goto, endfunction</span>
    endif

    <span class="comments">; check suffix items:</span>
    temp = remove(clean(keywds.suffix_items, /space), param)
    if (!version.release gt 5.2) then begin
        suffix_items = long(strsplit(temp, ',',/extract))
    endif else begin
        suffix_items = long(str_sep(temp, ','))
    endelse
    pos = where (suffix_items lt 0, cnt)
    if (cnt gt 0) then begin
        print, "Error: invalid SUFFIX_ITEMS keyword value found: " + $
            keywds.suffix_items + " (0 &lt;= n)"
        goto, endfunction
    endif

    <span class="comments">; check sample, line, band suffix item bytes:</span>
    bytesrange = [1, 2, 4, 8, 16]
    sample_suffix_item_bytes = long(clean(keywds.sample_suffix_item_bytes, /space))
    pos = where (sample_suffix_item_bytes eq bytesrange, cnt)
    if (cnt eq 0) then begin
        print, "Error: invalid SAMPLE_SUFFIX_ITEM_BYTES keyword value found: " + $
            keywds.sample_suffix_item_bytes
        goto, endfunction
    endif

    line_suffix_item_bytes = long(clean(keywds.line_suffix_item_bytes, /space))
    pos = where (line_suffix_item_bytes eq bytesrange, cnt)
    if (cnt eq 0) then begin
        print, "Error: invalid SAMPLE_SUFFIX_ITEM_BYTES keyword value found: " + $
            keywds.line_suffix_item_bytes
        goto, endfunction
    endif

    band_suffix_item_bytes = long(clean(keywds.band_suffix_item_bytes, /space))
    pos = where (band_suffix_item_bytes eq bytesrange, cnt)
    if (cnt eq 0) then begin
        print, "Error: invalid SAMPLE_SUFFIX_ITEM_BYTES keyword value found: " + $
            keywds.band_suffix_item_bytes
        goto, endfunction
    endif

    struct = create_struct(struct, "axes", axes, "axis_name", axis_name, $
        "core_items", core_items, "core_item_bytes", core_item_bytes, $
        "core_item_type", core_item_type, "core_base", core_base, $
        "core_multiplier", core_multiplier, "suffix_bytes", suffix_bytes, $
        "suffix_items", suffix_items, $
        <span class="comments">;Modified feb2007, smartinez</span>
        "sample_suffix_item_bytes",sample_suffix_item_bytes, "sample_suffix_type",keywds.sample_suffix_type, $
        "line_suffix_item_bytes",line_suffix_item_bytes, "line_suffix_type",keywds.line_suffix_type, $
	"band_suffix_item_bytes",band_suffix_item_bytes, "band_suffix_type",keywds.band_suffix_type)

    return, struct
    endfunction:
        struct.flag = 0
        return, struct
end

<span class="comments">;- level 2 -------------------------------------------------------------------</span>

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: start and end index are viable indices; so is label</span>
<span class="comments">; postcondition: all current qube parameters are extracted from label</span>

<a id="obtain_current_qube_params:source"></a>function obtain_current_qube_params, start_ind, end_ind, label
    <span class="comments">; initialize keyword structure variable:</span>
    keywds = {flag: 1}

    <span class="comments">; required keywords:</span>
    <span class="comments">; axes:</span>
    axes = extract_qube_keywords(start_ind, end_ind, label, "AXES", 1)
    if (axes eq "-1") then goto, endfunction

    <span class="comments">; axis name:</span>
    axis_name = extract_qube_keywords(start_ind, end_ind, label, "AXIS_NAME",1)
    if (axis_name eq "-1") then goto, endfunction

    <span class="comments">; core items:</span>
    core_items = extract_qube_keywords(start_ind, end_ind, label, $
        "CORE_ITEMS", 1)
    if (core_items eq "-1") then goto, endfunction

    <span class="comments">; core item bytes:</span>
    core_item_bytes = extract_qube_keywords(start_ind, end_ind, label, $
        "CORE_ITEM_BYTES", 1)
    if (core_item_bytes eq "-1") then goto, endfunction

    <span class="comments">; core item type:</span>
    core_item_type = extract_qube_keywords(start_ind, end_ind, label, $
        "CORE_ITEM_TYPE", 1)
    if (core_item_type eq "-1") then goto, endfunction

    <span class="comments">; core base:</span>
    core_base = extract_qube_keywords(start_ind, end_ind, label, "CORE_BASE",1)
    if (core_base eq "-1") then goto, endfunction

    <span class="comments">; core multiplier:</span>
    core_multiplier = extract_qube_keywords(start_ind, end_ind, label, $
        "CORE_MULTIPLIER", 1)
    if (core_multiplier eq "-1") then goto, endfunction

    <span class="comments">; suffix bytes:</span>
    suffix_bytes = extract_qube_keywords(start_ind, end_ind, label, $
        "SUFFIX_BYTES", 1)
    if (suffix_bytes eq "-1") then goto, endfunction

    <span class="comments">; suffix items:</span>
    suffix_items = extract_qube_keywords(start_ind, end_ind, label, $
        "SUFFIX_ITEMS", 1)
    if (suffix_items eq "-1") then goto, endfunction

    <span class="comments">;Modified feb2007, smartinez</span>
    <span class="comments">;Get SAMPLE, LINE, BAND suffix bytes and types if present, else suffix_bytes or "REAL"</span>
    sample_suffix_item_bytes = extract_qube_keywords(start_ind, end_ind, label, $
  		"SAMPLE_SUFFIX_ITEM_BYTES", 0)
    if (sample_suffix_item_bytes eq "-1") then sample_suffix_item_bytes = suffix_bytes
    sample_suffix_type = extract_qube_keywords(start_ind, end_ind, label, $
  		"SAMPLE_SUFFIX_ITEM_TYPE", 0)
    if (sample_suffix_type eq "-1") then sample_suffix_type = "REAL"    

    line_suffix_item_bytes = extract_qube_keywords(start_ind, end_ind, label, $
  		"LINE_SUFFIX_ITEM_BYTES", 0)
    if (line_suffix_item_bytes eq "-1") then line_suffix_item_bytes = suffix_bytes
    line_suffix_type = extract_qube_keywords(start_ind, end_ind, label, $
  		"LINE_SUFFIX_ITEM_TYPE", 0)
    if (line_suffix_type eq "-1") then line_suffix_type = "REAL"

    band_suffix_item_bytes = extract_qube_keywords(start_ind, end_ind, label, $
  		"BAND_SUFFIX_ITEM_BYTES", 0)
    if (band_suffix_item_bytes eq "-1") then band_suffix_item_bytes = suffix_bytes
    band_suffix_type = extract_qube_keywords(start_ind, end_ind, label, $
  		"BAND_SUFFIX_ITEM_TYPE", 0)
    if (band_suffix_type eq "-1") then band_suffix_type = "REAL"
  		
    <span class="comments">; add keywords values to structure:</span>
    <span class="comments">; Modified feb2007, smartinez. Added sample, line and band suffix keywords.</span>
    keywds = create_struct(keywds, "axes", axes, "axis_name", axis_name, $
        "core_items", core_items, "core_item_bytes", core_item_bytes, $
        "core_item_type", core_item_type, "core_base", core_base, $
        "core_multiplier", core_multiplier, "suffix_bytes", suffix_bytes, $
        "suffix_items", suffix_items, $
        "sample_suffix_item_bytes",sample_suffix_item_bytes, "sample_suffix_type",sample_suffix_type, $
        "line_suffix_item_bytes",line_suffix_item_bytes, "line_suffix_type",line_suffix_type, $
	"band_suffix_item_bytes",band_suffix_item_bytes, "band_suffix_type",band_suffix_type)

    <span class="comments">; clean keywords structure and convert to appropriate type:</span>
    keywds = check_qube_keywords (keywds)

    return, keywds

    endfunction:
        keywds.flag = 0
        return, keywds
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: type is a viable sample type keyword value for current qube</span>
<span class="comments">; postcondition: the architecture of the data file is returned</span>

<a id="obtain_qube_architecture:source"></a>function obtain_qube_architecture, type
    <span class="comments">; initialize variable:</span>
    arch = "MSB"

    <span class="comments">; determine if arch is "LSB":</span>
    if ((strpos(type, "LSB") gt -1) || (strpos(type, "PC") gt -1) || $
        (strpos(type, "VAX") gt -1)) then begin
        arch = "LSB"
    endif

    return, arch
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: type is the item type; bytes is the number of bytes of the item</span>
<span class="comments">; postcondition: the idl data type more suitable is returned</span>

<a id="obtain_item_idltype:source"></a>function obtain_item_idltype, type, bytes

    case bytes of
      1:  idltype = 1
      2:  idltype = (strpos(type, "UNSIGNED") gt -1) ? 12 : 2   
      4:  if (strpos(type, "INTEGER") gt -1) then begin
    idltype = (strpos(type, "UNSIGNED") gt -1) ? 13 : 3
      endif else begin
    idltype = 4
      endelse
      8:  if (strpos(type, "INTEGER") gt -1) then begin
    idltype = (strpos(type, "UNSIGNED") gt -1) ? 15 : 14
      endif else begin
    idltype = (strpos(type, "COMPLEX") gt -1) ? 6 : 5
      endelse 
      16: idltype = (strpos(type, "REAL") gt -1) ? 0 : 9   
      else: idltype = 0
    endcase

    return, idltype
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: keywds is the idl structure definition for current</span>
<span class="comments">;     qube object</span>
<span class="comments">; postcondition: an idl structure is created to read the data from the</span>
<span class="comments">;     data file</span>

<a id="obtain_qube_structure:source"></a>function obtain_qube_structure, keywds

<span class="comments">;    ; initialize structure:</span>
<span class="comments">;    bits = keywds.core_item_bytes * 8   ; temporary store bits value</span>
<span class="comments">;    type = keywds.core_item_type        ; temporary store item type value</span>
<span class="comments">;</span>
<span class="comments">;    ; get the idl type of the vector to be created:</span>
<span class="comments">;    if (bits eq 8) then begin</span>
<span class="comments">;        idl_type = 1</span>
<span class="comments">;    endif else if (bits eq 16) then begin</span>
<span class="comments">;        idl_type = (strpos(type, "UNSIGNED") gt -1) ? 12 : 2</span>
<span class="comments">;    endif else if (bits eq 32) then begin</span>
<span class="comments">;        if (strpos(type, "INTEGER") gt -1) then begin</span>
<span class="comments">;            idl_type = (strpos(type, "UNSIGNED") gt -1) ? 13 : 3</span>
<span class="comments">;        endif else begin</span>
<span class="comments">;            idl_type = 4</span>
<span class="comments">;        endelse</span>
<span class="comments">;    endif	    </span>

<span class="comments">;    ; determine which element contains the SAMPLE axis:</span>
<span class="comments">;    pos = where (keywds.axis_name eq "SAMPLE")</span>
<span class="comments">;    vector = make_array(keywds.core_items[pos[0]], type = idl_type)</span>
<span class="comments">;</span>
<span class="comments">;    ; construct the structure with sample suffix bytes if any:</span>
<span class="comments">;    if (keywds.suffix_items[pos[0]] gt 0) then begin</span>
<span class="comments">;        bytes = keywds.suffix_items[pos[0]] * keywds.suffix_bytes</span>
<span class="comments">;        sample_struct = {sample:vector, sideplane:bytarr(bytes)}</span>
<span class="comments">;    endif else begin</span>
<span class="comments">;        sample_struct = {sample:vector}</span>
<span class="comments">;    endelse</span>
<span class="comments">;</span>
<span class="comments">;    ; replicate the above structure LINES items times:</span>
<span class="comments">;    pos = where (keywds.axis_name eq "LINE")</span>
<span class="comments">;    lines_struct = replicate(sample_struct, keywds.core_items[pos[0]])</span>
<span class="comments">;</span>
<span class="comments">;    ; construct the structure with line suffix bytes if any:</span>
<span class="comments">;    if (keywds.suffix_items[pos[0]] gt 0) then begin</span>
<span class="comments">;        bytes = keywds.suffix_items[pos[0]] * 4</span>
<span class="comments">;        band_struct = {line:lines_struct, bottomplane:bytarr(bytes)}</span>
<span class="comments">;    endif else begin</span>
<span class="comments">;        band_struct = {line:lines_struct}</span>
<span class="comments">;    endelse</span>
<span class="comments">;</span>
<span class="comments">;    ; replicate the above structure BAND items times:</span>
<span class="comments">;    pos = where (keywds.axis_name eq "BAND")</span>
<span class="comments">;    main = replicate(band_struct, keywds.core_items[pos[0]])</span>
<span class="comments">;    </span>
<span class="comments">;    return, main</span>

    <span class="comments">;Modified feb2007, smartinez</span>

    <span class="comments">;Qube core item type</span>
    print, 'CORE Items: ',  keywds.core_item_type,keywds.core_item_bytes
    core_type = obtain_item_idltype(keywds.core_item_type,keywds.core_item_bytes)

    <span class="comments">;Qube storage order</span>
    if (keywds.axis_name[0] eq 'SAMPLE' and keywds.axis_name[1] eq 'LINE' $		<span class="comments">; BSQ - (SAMPLE,LINE,BAND)</span>
	and keywds.axis_name[2] eq 'BAND') then begin order = 0
    endif else if (keywds.axis_name[0] eq 'SAMPLE' and keywds.axis_name[1] eq 'BAND'$	<span class="comments">; BIL - (SAMPLE,BAND,LINE)</span>
	and keywds.axis_name[2] eq 'LINE') then begin order = 1
    endif else if (keywds.axis_name[0] eq 'BAND' and keywds.axis_name[1] eq 'SAMPLE'$	<span class="comments">; BIP - (BAND,SAMPLE,LINE)</span>
	and keywds.axis_name[2] eq 'LINE') then begin order = 2
    endif 

   print, 'Order: ',order

    <span class="comments">;Qube structure</span>

    <span class="comments">; X core dimension </span>
    X_line = Make_array(keywds.core_items[0],Type=core_type,/nozero)
    
    <span class="comments">; SX suffix items type</span>
    suffix_item_type = (order eq 2) ? keywds.band_suffix_type : keywds.sample_suffix_type
    suffix_item_bytes = (order eq 2) ? keywds.band_suffix_item_bytes : keywds.sample_suffix_item_bytes
    suffix_type = obtain_item_idltype(suffix_item_type,suffix_item_bytes)

    <span class="comments">; SX suffix plane</span>
    if (keywds.suffix_items[0] gt 0) then begin
	SX_line = Make_array(keywds.suffix_items[0],Type=suffix_type,/nozero)
        XSX_line = {X:X_line, SX:SX_line} 
    endif else XSX_line = {X:X_line}
    SX_line = 0B    

    <span class="comments">; Y core dimension, SY suffix plane</span>
    <span class="comments">; SY suffix items type</span>
    if (order eq 0) then begin
	suffix_item_type = keywds.line_suffix_type
	suffix_item_bytes = keywds.line_suffix_item_bytes
    endif else if (order eq 1) then begin
	suffix_item_type = keywds.band_suffix_type
	suffix_item_bytes = keywds.band_suffix_item_bytes
    endif else begin
	suffix_item_type = keywds.sample_suffix_type
	suffix_item_bytes = keywds.sample_suffix_item_bytes
    endelse
    suffix_type = obtain_item_idltype(suffix_item_type,suffix_item_bytes)

    <span class="comments">; Replicate (X+SX, Y times)</span>
    <span class="comments">; Add SY suffix plane with dimension (X,SY)</span>
    if (keywds.suffix_items[1] gt 0) then begin
	SY_line = reform(Make_array(keywds.core_items[0], keywds.suffix_items[1], Type=suffix_type,/nozero), $
		keywds.core_items[0], keywds.suffix_items[1])
        XY_frame = {Y:replicate(XSX_line,keywds.core_items[1]), SY:SY_line} 
    endif else  XY_frame = {Y:replicate(XSX_line,keywds.core_items[1])}
    SY_line = 0B    
    XSX_line = 0B

    <span class="comments">;Z core dimension, SZ suffix plane</span>
   
    <span class="comments">; SZ suffix items type</span>
    suffix_item_type = (order eq 0) ? keywds.band_suffix_type : keywds.line_suffix_type
    suffix_item_bytes = (order eq 0) ? keywds.band_suffix_item_bytes : keywds.line_suffix_item_bytes
    suffix_type = obtain_item_idltype(suffix_item_type,suffix_item_bytes)

    if (keywds.suffix_items[2] gt 0) then begin
	SZ_line = reform(Make_array(keywds.core_items[0], keywds.core_items[1], keywds.suffix_items[2], Type=suffix_type,/nozero), $
		keywds.core_items[0], keywds.core_items[1], keywds.suffix_items[2])
        qube = {Z:replicate(XY_frame,keywds.core_items[2]), SZ:SZ_line} 
    endif else  qube = {Z:replicate(XY_frame,keywds.core_items[2])} 
    XY_frame = 0B
    SZ_line = 0B
    
    return, qube

end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: pointer is an idl structure containing viable data</span>
<span class="comments">;     file name associated with current qube object to be read, and</span>
<span class="comments">;     the number of bytes to skip if any; struct is the idl structure</span>
<span class="comments">;     to be read from the data file, and arch is the architecture of</span>
<span class="comments">;     the data file (LSB or MSB).</span>
<span class="comments">; postcondition: the data file is opened, the structure is read, and returned</span>

<a id="read_qube_data:source"></a>function read_qube_data, pointer, struct, arch
    <span class="comments">; error protection:</span>
    on_ioerror, signal

    <span class="comments">; initialize variable and declare flag:</span>
    data_read = {flag: 1} <span class="comments">; 0: error, 1: no error</span>

    <span class="comments">; open the file to read and apply swap endian if needed:</span>
    if (arch eq "MSB") then begin
        openr, unit, pointer.datafile, /get_lun, /swap_if_little_endian
    endif else begin
        openr, unit, pointer.datafile, /get_lun, /swap_if_big_endian
    endelse

    <span class="comments">; set the file pointer to current object to be read:</span>
    point_lun, unit, pointer.skip    

    <span class="comments">; read the qube object into structure:</span>
    readu, unit, struct

    <span class="comments">; close the unit and free the unit:</span>
    close, unit
    free_lun, unit

    data_read = create_struct(data_read, "struct", struct)

    return, data_read

    signal:
       on_ioerror, null
       print, "Error: file either corrupted or invalid parameters specified" +$
           " in label."
       data_read.flag = 0
       return, data_read
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: current contains the raw qube data structure for</span>
<span class="comments">;     current qube as read from the datafile; keywds containsn all</span>
<span class="comments">;     current qube object keyword values.</span>
<span class="comments">; postcondition: extracts the qube array from the current structure,</span>
<span class="comments">;     converts the array values to signed integers if necessary, and</span>
<span class="comments">;     performs scaling and offset if noscale keyword is not supplied.</span>

<a id="convert_qube_data:source"></a>function convert_qube_data, current, label, start_ind, end_ind, keywds, noscale
    
    <span class="comments">; extract qube from the read data:</span>
    <span class="comments">;Modified smartinez, feb2007   </span>
    <span class="comments">;element = current[*].dimension1[*].dimension0</span>
    element_core = current.Z.Y.X

    <span class="comments">;Modified by P.Choganwala starts</span>
    if ((keywds.suffix_items[0] eq 0) and       $
        (keywds.suffix_items[1] eq 0) and       $
	(keywds.suffix_items[2] eq 0)) then begin
        element_suffix = 0
    endif
    if (keywds.suffix_items[2] gt 0) then begin
        element_suffix = current.SZ
    endif
    if (keywds.suffix_items[1] gt 0) then begin
        element_suffix = current.Z.SY
    endif
    if (keywds.suffix_items[0] gt 0) then begin
        element_suffix = current.Z.Y.SX
    endif
    <span class="comments">;Modified by P.Choganwala ends</span>
    
    <span class="comments">; convert data elements for signed bytarr objects</span>
    <span class="comments">; (IDL only supports byt values of 0-255):</span>
    pos = strpos(keywds.core_item_type, "UNSIGNED")
    if ((keywds.core_item_bytes eq 1) && (pos lt 0)) then begin
        element_core = fix(element_core)
        fixitlist = where (element_core gt 127, count)
        if (count gt 0) then begin
            element_core[fixitlist] -= 256
        endif
    endif

    <span class="comments">; apply bit mask if applicable:</span>
    element_core = apply_bitmask(label, start_ind, end_ind, element_core)
    element_suffix = apply_bitmask(label, start_ind, end_ind, element_suffix)

    <span class="comments">; process scaling factor and offset:</span>
    if (~noscale) then begin
        if (keywds.core_multiplier ne 1.0) then begin
            element_core *= keywds.core_multiplier
        endif
        if (keywds.core_base ne 0.0) then begin
            element_core += keywds.core_base
        endif
    endif

    element = {core:element_core, sideplane:element_suffix}
    return, element
end

<span class="comments">;- level 1 -------------------------------------------------------------------</span>

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: filename and label are viable, and objects has at</span>
<span class="comments">;     least one qube object structure.</span>
<span class="comments">; postcondition: all qube objects are processed as defined in objects struct</span>

<a id="process_all_qubes:source"></a>function process_all_qubes, filename, label, objects, silent, noscale
    <span class="comments">; initialize the qube structure if more than one qube:</span>
    if (objects.count gt 1) then data = {qubes:objects.count}

    <span class="comments">; start the loop:</span>
    for i = 0, objects.count - 1 do  begin
        <span class="comments">;; get current start and end index pointer:</span>
        start_ind = objects.index[i]
        end_ind = get_index(label, start_ind)
        if (end_ind eq -1) then return, -1

        <span class="comments">; obtain current qube object keyword values:</span>
        keywds = obtain_current_qube_params (start_ind, end_ind, label)
        if (~keywds.flag) then return, -1

        <span class="comments">; obtain file data architecture:</span>
        arch = obtain_qube_architecture(keywds.core_item_type)

        <span class="comments">; obtain qube structure:</span>

        struct = obtain_qube_structure(keywds)

        <span class="comments">; obtain pointer information:</span>
        pointer = pointpds(label, filename, objects.array[i])
        if (pointer.flag eq "-1") then return, -1

        <span class="comments">; inform user of current status:</span>
        if (~silent) then begin
            text = "Now reading "
            for j = 0, keywds.axes - 2 do begin
                text += clean(string(keywds.core_items[j]),/space) + " by "
            endfor
            text += clean(string(keywds.core_items[keywds.axes - 1]),/space)+$
                " qube array"
            
            <span class="comments">;Modified feb2007, smartinez. Added suffix dimension.</span>
	    <span class="comments">;print, text</span>
            text += ", "
            for j = 0, keywds.axes - 2 do begin
                text += clean(string(keywds.suffix_items[j]),/space) + " by "
            endfor
            text += clean(string(keywds.suffix_items[keywds.axes - 1]),/space)+ $
		" suffix items."
            print, text 
        endif

        <span class="comments">; read data:</span>
        data_read = read_qube_data(pointer, struct, arch)
        if (~data_read.flag) then return, -1
        current = data_read.struct

        <span class="comments">; perform data conversion if needed:</span>
        element = convert_qube_data(current, label, start_ind, end_ind, $
            keywds, noscale)

	<span class="comments">; add qube to structure:</span>
        data = (objects.count gt 1) ? create_struct(data, objects.array[i], $
            element) : element
    endfor

    return, data
end

<span class="comments">;- level 0 -------------------------------------------------------------------</span>

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: filename is a viable pds label file name, and label is</span>
<span class="comments">;     a viable pds label.</span>
<span class="comments">; postcondition: all qube objects defined in label are read from</span>
<span class="comments">;     associated data file and returned.</span>

<a id="qubepds:source"></a>function qubepds, filename, label, SILENT = silent, NOSCALE = noscale
    <span class="comments">; error protection:</span>
    <span class="comments">;on_error, 2</span>

    <span class="comments">; check for number of parameters in function call:</span>
    if (n_params() lt 2) then begin
        print, "Syntax Error: result = qubepds(filename, label [, /SILENT," + $
               " /NOSCALE] )"
        return, -1
    endif
    silent = keyword_set(SILENT)
    noscale = keyword_set(NOSCALE)

    <span class="comments">; obtain all qube objects from label:</span>
    objects = objpds (label, "QUBE")
    if (objects.flag eq -1) then begin
        print, "Error: no QUBE object found in label"
        return, -1
    endif

    <span class="comments">; process all qube objects:</span>
    data = process_all_qubes(filename, label, objects, silent, noscale)

    return, data
end
</code>
    </div>
  </body>
</html>