<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 20:36:29 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>tbinpds.pro (OMINAS Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="tbinpds.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; NAME: TBINPDS   [Table BINARY PDS]</span>
<span class="comments">; </span>
<span class="comments">; PURPOSE: To read a PDS binary table file into an IDL structure containing </span>
<span class="comments">;     columns of the data table as elements.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE: Result = TBINPDS (filename, label, objindex, [/SILENT])</span>
<span class="comments">; </span>
<span class="comments">; INPUTS:</span>
<span class="comments">;     Filename: Scalar string containing the name of the PDS file to read.</span>
<span class="comments">;     Label: String array containing the table header information.</span>
<span class="comments">;     Objindex: Integer specifying the starting index of teh current table</span>
<span class="comments">;         object in the label array to be read.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;     Result: Table structure constructed from designated records with fields</span>
<span class="comments">;         for each column in the table, along with a string array field </span>
<span class="comments">;         containing the name of each column.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT:</span>
<span class="comments">;     SILENT: Suppresses any messages from the procedure.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;     To read an BINARY table file TABLE.LBL into a structure "table":</span>
<span class="comments">;         IDL> label = HEADPDS ('TABLE.LBL', /SILENT)</span>
<span class="comments">;         IDL> table = TBINPDS ('TABLE.LBL', label, /SILENT)</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURES USED:</span>
<span class="comments">;     Functions: OBJPDS, GET_INDEX, CLEAN, REMOVE, STR2NUM, PDSPAR, POINTPDS</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;     Written by: John D. Koch [December 1994] (adapted from READFITS by</span>
<span class="comments">;                                               Wayne Landsman)</span>
<span class="comments">;     Re-written by: Puneet Khetarpal [19 July, 2004] </span>
<span class="comments">;     </span>
<span class="comments">;     Modifications: Parin Choganwala [27 April, 2008]</span>
<span class="comments">;		     In OBTAIN_TBIN_REQ increased range of columns,rows,row_bytes</span>
<span class="comments">;		     data type by using ULONG and LONG64	   </span>
<span class="comments">;     </span>
<span class="comments">;     S. Martinez [2 February, 2009]. OBTAIN_TBIN_ITEMS modified, the number of</span>
<span class="comments">;        elements was wrong (named 'count' in the structure).</span>
<span class="comments">;      </span>
<span class="comments">;     S. Martinez [11 February, 2009]. ROW_SUFFIX/PREFIX_BYTES data type changed to </span>
<span class="comments">;        unsigned long 64. Range of previous data type exceeded.</span>
<span class="comments">;                        </span>
<span class="comments">;     S. Martinez [12 January, 2010]. Endianess not correctly handled. Modified </span>
<span class="comments">;        tbinpds to reverse byte order if MSB architecture and little-endian </span>
<span class="comments">;        machine or LSB architecture and big-endian machine.</span>
<span class="comments">;</span>
<span class="comments">;     S. Martinez [05 July, 2010]. Updated to handle CONTAINER/BIT_COLUMN objects.</span>
<span class="comments">;        Functions OBTAIN_TBIN_CONTAINERS, OBTAIN_TBIN_BIT_COLUMNS,</span>
<span class="comments">;                  PROCESS_TBIN_BIT_COLUMNS and FORMAT_COLUMN added to this file.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;     To view a complete list of modifications made to this routine, </span>
<span class="comments">;     please see changelog.txt file.</span>
<span class="comments">;</span>
<span class="comments">;  </span>
<span class="comments">;-----------------------------------------------------------------------------</span>

<span class="comments">;- level 2 -------------------------------------------------------------------</span>

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: the name variable is a viable required keyword scalar string,</span>
<span class="comments">;     label is a viable PDS label string array, and start and end_ind are</span>
<span class="comments">;     viable integers pointing at the start and end of the current table</span>
<span class="comments">;     object being processed.</span>
<span class="comments">; postcondition: extracts the "name" keyword from the label, stores it in a </span>
<span class="comments">;     structure, and returns to the main block.</span>

<a id="OBTAIN_KEYWORD:source"></a>function OBTAIN_KEYWORD, name, label, start_ind, end_ind
   <span class="comments">; initialize keyword structure:</span>
   struct = create_struct("flag",1)

   <span class="comments">; obtain keyword parameters:</span>
   val = PDSPAR (label, name, COUNT=count, INDEX=index)    <span class="comments">; external routine</span>

   <span class="comments">; if no viable params found, then issue error:</span>
   if (!ERR EQ -1) then begin
       print, "Error: missing required " + name + " keyword(s)."
       GOTO, ENDFUN
   endif

   <span class="comments">; extract the indices where keyword index is between start_ind and end_ind:</span>
   pos = where (index GT start_ind AND index LT end_ind)

   <span class="comments">; if none found then return flag as -1:</span>
   if (pos[0] EQ -1) then GOTO, ENDFUN

   <span class="comments">; store the viable values, indices, and count for "name" keyword:</span>
   val = val[pos]
   index = index[pos]
   count = n_elements(val)

   <span class="comments">; place the stored params in the structure:</span>
   struct = create_struct(struct,"val",val,"count",count,"index",index)
   return, struct

   ENDFUN:
      struct.flag = -1
      return, struct
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: name is a structure containing all names param for current</span>
<span class="comments">;     table object, label is a viable PDS label string array, and start_ind</span>
<span class="comments">;     and end_ind are integer pointers to start and end of current object.</span>
<span class="comments">; postcondition: the table name is searched through all the name values and</span>
<span class="comments">;     then removed from the structure, the count is decremented by one, and</span>
<span class="comments">;     the index value is also removed from the corresponding structure field.</span>

<a id="REMOVE_TBIN_NAME:source"></a>function REMOVE_TBIN_NAME, name, label, start_ind, end_ind
    <span class="comments">; first obtain COLUMN object indices for current table object:</span>
    column = OBJPDS(label, "COLUMN")                      <span class="comments">; external routine</span>
    pos = where (column.index GT start_ind AND column.index LT end_ind)
    column.index = column.index[pos]

    <span class="comments">; check to see if the first name index is less than the first column</span>
    <span class="comments">; index value. If found then there exists a table name, and is removed:</span>
    if (name.index[0] LT column.index[0]) then begin
        temp = name.val[1:name.count - 1]
        name.val = ''
        name.val = temp
        
        temp = name.index[1:name.count - 1]
        name.index = ''
        name.index = temp
        
        name.count = name.count - 1
    endif

    <span class="comments">; clean up name array values, and removed unwanted characters:</span>
    param = ['"', "'", "(", ")"]
    for j = 0, name.count-1 do begin
        name.val[j] = CLEAN (name.val[j])                 <span class="comments">; external routine</span>
        name.val[j] = REMOVE (name.val[j], param)         <span class="comments">; external routine</span>
    endfor

    return, name
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: data_type is a structure containing the required keyword</span>
<span class="comments">;     params for DATA_TYPE keyword.</span>
<span class="comments">; postcondition: the architecture of the data file is determined.</span>

<a id="OBTAIN_TBIN_ARCH:source"></a>function OBTAIN_TBIN_ARCH, data_type
    <span class="comments">; intitialize variables:</span>
    arch = "MSB"

    for j = 0, data_type.count - 1 do begin
        type = data_type.val[j]
        <span class="comments">; check the existence of little endian data type:</span>
        if ((strpos(type, "LSB") gt -1) || (strpos(type, "PC") gt -1) || $
            (strpos(type, "VAX") gt -1)) then begin
            arch = "LSB"
        endif
    endfor

    return, arch
end


<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: data_type is a structure containing the required keyword </span>
<span class="comments">;     params for DATA_TYPE keyword.</span>
<span class="comments">; postcondition: the data type keyword values are cleaned.</span>

<a id="SEPARATE_TBIN_DATA_TYPE:source"></a>function SEPARATE_TBIN_DATA_TYPE, data_type
    <span class="comments">; set the param variable:</span>
    param = ['"', "'", ")", "("]

    <span class="comments">; start the loop to go through each data_type value array:</span>
    for j = 0, data_type.count - 1 do begin
        <span class="comments">; first clean data_type:</span>
        data_type.val[j] = CLEAN (data_type.val[j], /SPACE)  <span class="comments">; external routine</span>
        data_type.val[j] = REMOVE (data_type.val[j], param)  <span class="comments">; external routine</span>
    endfor

    return, data_type
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: keywds contains all required keyword values in a structure,</span>
<span class="comments">;     items contains all item keyword values, curr_ind and next_ind are </span>
<span class="comments">;     integer pointers to current and next column object being processed, and</span>
<span class="comments">;     curpos is an integer containing the current cursor position being</span>
<span class="comments">;     processed in the record.</span>
<span class="comments">; postcondition: the routine tests whether there are any table items for</span>
<span class="comments">;     current column object, and if found, then populates the necessary</span>
<span class="comments">;     item structure for current column object and returns to main block.</span>
<span class="comments">;     If no table items are found, then simply extracts the number of</span>
<span class="comments">;     bytes for current object and returns it as a bytarr.</span>

<a id="PROCESS_TBIN_ITEMS:source"></a>function PROCESS_TBIN_ITEMS, keywds, items, curpos, curr_ind, next_ind
    <span class="comments">; first determine whether there exist ITEMS for current COLUMN:</span>
    if (items.flag EQ -1) then begin
        ipos = -1
    endif else begin
        ipos = where (items.items.index GT curr_ind AND items.items.index LT $
                  next_ind)
    endelse

    <span class="comments">; if items not present then extract the number of bytes for current object:</span>
    if (ipos[0] EQ -1) then begin
        <span class="comments">; determine the index for current bytes values to be assigned:</span>
        pos = where (keywds.bytes.index GT curr_ind AND $
                     keywds.bytes.index LT next_ind)
        element = bytarr(long(keywds.bytes.val[pos[0]]))

        <span class="comments">; increment the cursor position by current bytes:</span>
        curpos = curpos + long(keywds.bytes.val[pos[0]])
    endif else begin
        <span class="comments">; if items are present, then create a secondary element bytarr </span>
        <span class="comments">; for each item, and start a temp cursor position for this column:</span>
        item_bytes = long(items.bytes.val[ipos[0]])
        element = bytarr(item_bytes)
        temppos = item_bytes

        <span class="comments">; check for offset keyword values. if offset is 0 then simply</span>
        <span class="comments">; set the item element structure to be element, else construct</span>
        <span class="comments">; a bytarr for offset buffer to be read, increment temppos, and</span>
        <span class="comments">; add the offset buffer to item element structure along with element:</span>
        if (items.offset.count EQ 0) then begin
            item_offset = 0
        endif else begin
            item_offset = long(items.offset.val[ipos[0]])
        endelse
        if (item_offset EQ 0) then begin
            item_elem = create_struct("element", element)
        endif else begin
            offtemp = bytarr(item_offset)
            temppos = temppos + item_offset
            item_elem = create_struct("element", element, "offtemp", offtemp)
        endelse

        <span class="comments">; now replicate the item element structure number of items - 1 times.</span>
        <span class="comments">; it is being replicated items - 1 times because of the offset buffer.</span>
        <span class="comments">; when there is an offset, the offset bytes do not carry after the</span>
        <span class="comments">; last item, so the item_elem structure constructed earlier would be</span>
        <span class="comments">; incorrect:</span>
        <span class="comments">;</span>
        <span class="comments">; 1/13/2010 : Some datasets use ITEMS = 1. Add logical branch to</span>
        <span class="comments">; handle this special case. If ITEMS = 1, we simply store item_elem</span>
        <span class="comments">; to element, and avoid the creation of special temporary elements.</span>
        num_items = long(items.items.val[ipos[0]])

        if num_items gt 1 then begin
            item_elem = replicate(item_elem, num_items - 1)

            <span class="comments">; multiply temppos by the number of items - 1:</span>
            temppos = temppos * (num_items - 1)
        
            <span class="comments">; create a temporary structure to hold last array element, and</span>
            <span class="comments">; increment temppos by item_bytes:</span>
            temp_struct = create_struct("element", element)
            temppos = temppos + item_bytes

            <span class="comments">; populate the column structure to act as the element to be read:</span>
            element = create_struct("item_elem", item_elem, "last", temp_struct)
        endif else begin
            element = create_struct("item_elem", item_elem)
        endelse
        <span class="comments">; finally increment main cursor position by temppos value:</span>
        curpos = curpos + temppos
    endelse

    <span class="comments">; add cursor position and element into column object structure:</span>
    object_struct = create_struct("curpos", curpos, "data", element)

    return, object_struct
end

<span class="comments">;- level 1 -------------------------------------------------------------------</span>

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: label is a viable PDS label string array, start_ind is the</span>
<span class="comments">;     index specifying the start of the current object, and end index its</span>
<span class="comments">;     end. Label must contain a valid BINARY table with INTERCHANGE format</span>
<span class="comments">;     keyword.</span>
<span class="comments">; postcondition: returns a boolean (1 or -1) depending on whether it finds</span>
<span class="comments">;     a BINARY interchange format keyword, or not.</span>

<a id="TBIN_INTERFORM:source"></a>function TBIN_INTERFORM, label, start_ind, end_ind
    <span class="comments">; obtain all INTERCHANGE_FORMAT keyword values from label:</span>
    interform = PDSPAR (label, "INTERCHANGE_FORMAT", INDEX=int_ind)

    <span class="comments">; check whether there exist any interchange format keywords:</span>
    if (!ERR EQ -1) then begin
        print, "Error: missing required INTERCHANGE_FORMAT keyword"
        return, -1
    endif else begin
        <span class="comments">; obtain the indices of interchange format array object, where</span>
        <span class="comments">; they are between start and end index:</span>
        interpos = where (int_ind GT start_ind AND int_ind LT end_ind)

        <span class="comments">; extract the interform values:</span>
        interform = interform[interpos[0]]
        interform = interform[0]

        <span class="comments">; remove all white space, and remove the '"' chars if found:</span>
        interform = CLEAN(interform,/SPACE)            <span class="comments">; external routine</span>
        interform = REMOVE(interform, '"')             <span class="comments">; external routine</span>

        <span class="comments">; if interchange format value is binary, then return -1 with error:</span>
        if (interform EQ "ASCII") then begin
            print, "Error: This is ascii table file; try TASCPDS."
            return, -1
        endif
    endelse
    <span class="comments">; if all goes well, then return 1:</span>
    return, 1
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: label is a viable PDS label string array, and start_ind and</span>
<span class="comments">;     end_ind are valid integers specifying the start and end of the </span>
<span class="comments">;     current table object as index pointers in the string array.</span>
<span class="comments">; postcondition: extracts required keywords for table object in the label.</span>

<a id="OBTAIN_TBIN_REQ:source"></a>function OBTAIN_TBIN_REQ, label, start_ind, end_ind
    <span class="comments">; initialize keyword structure:</span>
    keywds = create_struct("flag",1)

    <span class="comments">; obtain table object definitions for current object:</span>
    <span class="comments">; extract the keyword structure from subroutine, and check whether</span>
    <span class="comments">; there are any params for the keyword, if not then return to main block</span>
    <span class="comments">; else store the value</span>

    <span class="comments">; first obtain number of COLUMNS:</span>
    columns_num = OBTAIN_KEYWORD("COLUMNS", label, start_ind, end_ind)
    if (columns_num.flag EQ -1) then GOTO, ENDFUN
    columns = fix(columns_num.val[0])

    <span class="comments">;Modified by parin Apr,2008 starts</span>
    <span class="comments">; obtain ROW_BYTES keyword:</span>
    row_bytes = OBTAIN_KEYWORD("ROW_BYTES",label, start_ind, end_ind)
    if (row_bytes.flag EQ -1) then GOTO, ENDFUN
    row_bytes = ulong(row_bytes.val[0])

    <span class="comments">; obtain ROWS keyword:</span>
    rows = OBTAIN_KEYWORD("ROWS", label, start_ind, end_ind)
    if (rows.flag EQ -1) then GOTO, ENDFUN
    rows = ulong(rows.val[0])

    <span class="comments">; check whether either columns, rows or row_bytes equal 0:</span>
    if ((columns le 0) or (rows le 0) or (row_bytes le 0)) then begin
        row_bytes = ulong64(row_bytes)
        rows = ulong64(rows)
        if ((columns le 0) or (rows le 0) or (row_bytes le 0)) then begin
        	print, "Error: ROWS OR ROW_BYTES or COLUMNS &lt;= 0. No data read."
        	GOTO, ENDFUN
         endif
    endif
    <span class="comments">;Modified by parin Apr, 2008 ends</span>

    <span class="comments">; obtain information for each column object:</span>

    <span class="comments">; obtain NAME keyword:</span>
    name = OBTAIN_KEYWORD("NAME",label,start_ind,end_ind)
    if (name.flag EQ -1) then GOTO, ENDFUN
    
    <span class="comments">;; Modified by smartinez</span>
    bit_column_objects = objpds(label, "BIT_COLUMN")
    if (bit_column_objects.flag ne -1) then begin
      bit_ind = 0ULL
      bit_start_ind = bit_column_objects.index[0]
      bit_end_ind = get_index(label,bit_column_objects.index[0])
    
      tmp_ind = 0L
      tmp_val = strarr(name.count)
      tmp_index = lonarr(name.count)
      for i=0,name.count-1 do begin
      
        if (name.index[i] gt bit_start_ind and name.index[i] lt bit_end_ind) then begin
          bit_ind++
          columns--
          if (bit_ind lt n_elements(bit_column_objects.index)) then begin
            bit_start_ind = bit_column_objects.index[bit_ind]
            bit_end_ind = get_index(label,bit_column_objects.index[bit_ind])
          endif
          continue
        endif

        tmp_val[tmp_ind] = name.val[i] 
        tmp_index[tmp_ind] = name.index[i] 
        tmp_ind++
      
      endfor
      tmp_name = create_struct('flag',name.flag,'count',tmp_ind,'val',tmp_val[0:tmp_ind-1],'index',tmp_index[0:tmp_ind-1])
      name = tmp_name
    endif
    <span class="comments">;; End of smartinez modification</span>


    <span class="comments">; remove table name from name structure if present:</span>
    name = REMOVE_TBIN_NAME(name, label, start_ind, end_ind)

    <span class="comments">; obtain DATA_TYPE keyword, then clean, separate, and extract it:</span>
    data_type = OBTAIN_KEYWORD("DATA_TYPE", label, start_ind, end_ind)
    if (data_type.flag EQ -1) then GOTO, ENDFUN

    <span class="comments">; obtain data file architecture and separate data type:</span>
    arch = OBTAIN_TBIN_ARCH(data_type)
    data_type = SEPARATE_TBIN_DATA_TYPE(data_type)  <span class="comments">; subroutine</span>

    <span class="comments">; obtain BYTES keyword:</span>
    bytes = OBTAIN_KEYWORD("BYTES",label, start_ind, end_ind)
    if (bytes.flag EQ -1) then GOTO, ENDFUN

    <span class="comments">; obtain START_BYTE keyword, and subtract 1 for IDL variable indexing:</span>
    start_byte = OBTAIN_KEYWORD("START_BYTE",label, start_ind, end_ind)
    if (start_byte.flag EQ -1) then GOTO, ENDFUN
    start_byte.val = long(start_byte.val) - 1

    <span class="comments">; store values into the keyword structure:</span>
    keywds = create_struct(keywds, "columns",columns,"row_bytes",row_bytes, $
                           "rows",rows,"name",name,"data_type",data_type, $
                           "bytes",bytes,"start_byte",start_byte, "arch",arch)

    return, keywds

    ENDFUN:
       keywds.flag = -1
       return, keywds
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: label is a viable PDS label string array, start_ind and end_ind</span>
<span class="comments">;     are integer pointers to start and end of current table in label.</span>
<span class="comments">; postcondition: obtains the optional table keywords from the label, and </span>
<span class="comments">;     returns them in a structure.</span>

<a id="OBTAIN_TBIN_OPT:source"></a>function OBTAIN_TBIN_OPT, label, start_ind, end_ind
    <span class="comments">; initialize structure:</span>
    keywds = create_struct("flag", 1, "prefix", 0ULL, "suffix", 0ULL)

    <span class="comments">; obtain ROW_PREFIX_BYTES keyword:</span>
    rowprefix = PDSPAR (label, "ROW_PREFIX_BYTES", COUNT=pcount, INDEX=pindex)
    if (!ERR GT -1) then begin
        pos = where (pindex GT start_ind AND pindex LT end_ind)
        if (pos[0] GT -1) then begin
            keywds.prefix = ulong64(rowprefix[pos[0]])
            if (keywds.prefix LT 0) then begin
                print, "Error: invalid ROW_PREFIX_BYTES (" + $
                       CLEAN(string(keywds.prefix), /SPACE) + ")."
                GOTO, ENDFUN
            endif
        endif
    endif

    <span class="comments">; obtain ROW_SUFFIX_BYTES keyword:</span>
    rowsuffix = PDSPAR (label, "ROW_SUFFIX_BYTES", COUNT=scount, INDEX=sindex)
    if (!ERR GT -1) then begin
        pos = where (sindex GT start_ind AND sindex LT end_ind)
        if (pos[0] GT -1) then begin
            keywds.suffix = ulong64(rowsuffix[pos[0]])
            if (keywds.suffix LT 0) then begin
                print, "Error: invalid ROW_SUFFIX_BYTES (" + $
                       CLEAN(string(keywds.suffix), /SPACE) + ")."
                GOTO, ENDFUN
            endif
        endif
    endif

    return, keywds

    ENDFUN:
        keywds.flag = -1
        return, keywds
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: label is viable PDS label string array, req_keywds is a </span>
<span class="comments">;     structure containing required table object keywords, and start and </span>
<span class="comments">;     end_ind are viable integer pointers to start and end of the current</span>
<span class="comments">;     table object.</span>
<span class="comments">; postcondition: Extracts table items keyword params from label and returns</span>
<span class="comments">;     to main block as a structure.</span>

<a id="OBTAIN_TBIN_ITEMS:source"></a>function OBTAIN_TBIN_ITEMS, label, req_keywds, start_ind, end_ind
    <span class="comments">; initialize items keyword structure:</span>
    keywds = create_struct("flag", 1, "flag2", 1)

    <span class="comments">; obtain necessary ITEM keyword values:</span>
    <span class="comments">; first obtain ITEMS keyword values:</span>
    items = PDSPAR (label, "ITEMS", COUNT=items_count, INDEX=items_index)
    if (!ERR EQ -1) then begin
        GOTO, ENDFUN
    endif

    <span class="comments">; extract values of items between start_ind and end_ind, and store:</span>
    pos = where (items_index GT start_ind AND items_index LT end_ind)
    if (pos[0] EQ -1) then GOTO, ENDFUN
    items = create_struct("val",items[pos],"count",n_elements(items[pos]), $
                          "index",items_index[pos])

    <span class="comments">; now we know that there are columns with ITEMS keyword in current table</span>
    <span class="comments">; object, so extract the other item keyword values:</span>

    <span class="comments">; obtain ITEM_BYTES keyword values:</span>
    bytes = PDSPAR (label, "ITEM_BYTES", COUNT=byte_count, INDEX=byte_index)
    if (!ERR EQ -1) then begin
        print, "Error: missing required ITEM_BYTES keyword for items column."
        keywds.flag2 = -1
        GOTO, ENDFUN
    endif
    pos = where (byte_index GT start_ind AND byte_index LT end_ind)
    if (pos[0] EQ -1) then begin
        print, "Error: missing required ITEM_BYTES keyword for current table"
        keywds.flag2 = -1
        GOTO, ENDFUN
    endif
    bytes = create_struct("val", bytes[pos], "count", n_elements(bytes[pos]), $
                          "index", byte_index[pos])

    <span class="comments">; initialize a temp structure to hold default values:</span>
    temp = create_struct("val",0,"count",0,"index",0)

    <span class="comments">; obtain ITEM_OFFSET keyword values, if present:</span>
    offset = PDSPAR (label, "ITEM_OFFSET", COUNT=off_count, INDEX=off_index)

    <span class="comments">; if there exist ITEM_OFFSET keywords, then obtain ones between</span>
    <span class="comments">; start and end_ind else set it to temp structure:</span>
    if (!ERR NE -1) then begin
        pos = where (off_index GT start_ind AND off_index LT end_ind)
        if (pos[0] EQ -1) then begin
            offset = temp
        endif else begin
            offset = create_struct("val", offset[pos], "count", $
                                   n_elements(offset[pos]),"index",off_index[pos])

            <span class="comments">; since the offset values in the PDS label are given as the </span>
            <span class="comments">; number of bytes from the beginning of a one item to the</span>
            <span class="comments">; beginning of next, therefore, the offset that we are concerned</span>
            <span class="comments">; with is the difference between the end of one item and the</span>
            <span class="comments">; beginning of next:</span>
            offset.val = long(offset.val) - long(bytes.val)
            FOR i=0,N_ELEMENTS(offset.val)-1 DO $
              if (offset.val[i] LT 0) then begin
                  print, "Error: invalid ITEM_OFFSET value, must be >=ITEM_BYTES"
                  keywds.flag2 = -1
                  GOTO, ENDFUN
              endif
        endelse
    endif else offset = temp

    <span class="comments">; store info into a structure:</span>
    keywds = create_struct(keywds, "items", items, "bytes",bytes,"offset", $
                           offset)
    return, keywds 

    ENDFUN:
        keywds.flag = -1
        return, keywds
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: label is viable PDS label string array, req_keywds is a </span>
<span class="comments">;     structure containing required table object keywords, and start and </span>
<span class="comments">;     end_ind are viable integer pointers to start and end of the current</span>
<span class="comments">;     table object.</span>
<span class="comments">; postcondition: Extracts table container keyword params from label and returns</span>
<span class="comments">;     to main block as a structure.</span>

<a id="OBTAIN_TBIN_CONTAINERS:source"></a>function OBTAIN_TBIN_CONTAINERS, label, req_keywds, start_ind, end_ind
  <span class="comments">; initialize items keyword structure:</span>
  keywds = create_struct("flag", 1, "flag2",1)
  
  container = objpds(label, "CONTAINER")
  if (container.flag eq -1) then goto,endfun
  
  container_info = replicate(create_struct('name','','start_byte',0ULL,'bytes',0ULL,'repetitions',0ULL,'description','',$
                                           'start_index',0ULL,'end_index',0ULL,'columns',0ULL),n_elements(container.index))
  
  for i=0,n_elements(container.index)-1 do begin
    container_info[i].start_index = container.index[i]
    container_info[i].end_index = get_index(label,container.index[i])
    
    column = objpds(label[container_info[i].start_index:container_info[i].end_index],"COLUMN")
    container_info[i].columns = column.count
    end_header = container_info[i].start_index + column.index[0]
    
    name = obtain_keyword("NAME",label, container_info[i].start_index, end_header)    
    repetitions = obtain_keyword("REPETITIONS",label, container_info[i].start_index, end_header)
    bytes = obtain_keyword("BYTES",label, container_info[i].start_index, end_header)
    start_byte = obtain_keyword("START_BYTE",label, container_info[i].start_index, end_header)
    if (name.flag eq 0 || repetitions.flag eq 0 || bytes.flag eq 0 || start_byte.flag eq 0) then begin
      print, "Error: missing required keyword in CONTAINER object: NAME, REPETITIONS, BYTES or START_BYTE"
      keywds.flag2 = -1
      goto, endfun
    endif
    
    container_info[i].name = name.val[0]
    container_info[i].repetitions = repetitions.val[0]
    container_info[i].bytes = bytes.val[0]
    container_info[i].start_byte = start_byte.val[0]
  endfor

  <span class="comments">; store info into a structure:</span>
  keywds = create_struct(keywds, "name", container_info.name, "bytes",container_info.bytes,"repetitions",container_info.repetitions,"start_byte",container_info.start_byte,$
                         "start_index",container_info.start_index,"end_index",container_info.end_index,"columns",container_info.columns,"count",n_elements(container_info.name))
  return, keywds 

  endfun:
    keywds.flag = -1
    return, keywds
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: label is viable PDS label string array, data contains the</span>
<span class="comments">;     data as read not taking into account bit_column splitting, req_keywds </span>
<span class="comments">;     contains all required keyword values in a structure,</span>
<span class="comments">;     bit_columns contains all bit_column keyword values, </span>
<span class="comments">; postcondition: the routine tests whether there are any table bit_column for</span>
<span class="comments">;     current column object, and if found, then replaces the current column</span>
<span class="comments">;     for bit_column structure for current column object and returns </span>
<span class="comments">;     to main block.</span>

<a id="PROCESS_TBIN_BIT_COLUMNS:source"></a>function PROCESS_TBIN_BIT_COLUMNS, data, label, req_keywds, bit_columns
  
  columns = bit_columns.column_index(uniq(bit_columns.column_index))
  column_index = ulonarr(n_elements(columns))
  
  for i=0,n_elements(columns)-1 do begin
    end_index = get_index(label,columns[i])
    name = req_keywds.name.val(where(req_keywds.name.index gt columns[i] and req_keywds.name.index lt end_index))
    column_index[i] = where(data.names eq name[0])   
  endfor
  
  tmp_ind = 0ULL
  names = tag_names(data)
  for i=0,n_elements(names)-1 do begin
  
    pos = where(i ne column_index,count)
    
    <span class="comments">;; Add columns with bit_columns</span>
    if (count eq 0) then begin
      
      index = where(bit_columns.column_index eq columns[tmp_ind])
      for j=0,n_elements(index)-1 do begin
    
        bit_column_index = index[j]
        bit_name = "BIT_COLUMN" + CLEAN(string(j+1),/SPACE)
      
        data_type = size(data.(column_index[tmp_ind]),/TYPE)
        if (data_type eq 1) then data_size = 1 $ <span class="comments">;; BYTE</span>
        else if (data_type eq 2 or data_type eq 12) then data_size = 2 $ <span class="comments">;; INT,UINT</span>
        else if (data_type eq 3 or data_type eq 4 or data_type eq 13) then data_size = 4 $ <span class="comments">;; LONG,ULONG,FLOAT</span>
        else if (data_type eq 5 or data_type eq 14 or data_type eq 15) then data_size = 8 <span class="comments">;; LONG64,ULONG64,DOUBLE</span>
        
        bit_mask = (2B^bit_columns.bits(bit_column_index)) - 1
        bit_shift = 8B*data_size - (bit_columns.bits(bit_column_index) + bit_columns.start_bit(bit_column_index) - 1)
        bit_mask = ishft(bit_mask,bit_shift)
        
        tmp_column = byte(ishft(data.(column_index[tmp_ind]) and bit_mask,-1B*bit_shift))
        bit_column_struct = (n_elements(bit_column_struct) eq 0) ? create_struct(bit_name,tmp_column) : create_struct(bit_column_struct,bit_name,tmp_column)
      
      endfor
   
      final_data = (n_elements(final_data) eq 0) ? create_struct(names[i],bit_column_struct) : create_struct(final_data,names[i],bit_column_struct)
      tmp_ind++
      
    <span class="comments">;; Add columns without bit_column</span>
    endif else final_data = (n_elements(final_data) eq 0) ? create_struct(names[i],data.(i)) : create_struct(final_data,names[i],data.(i))
  endfor

  return, final_data
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: label is viable PDS label string array, req_keywds is a </span>
<span class="comments">;     structure containing required table object keywords, and start and </span>
<span class="comments">;     end_ind are viable integer pointers to start and end of the current</span>
<span class="comments">;     table object.</span>
<span class="comments">; postcondition: Extracts table bit_column keyword params from label and returns</span>
<span class="comments">;     to main block as a structure.</span>

<a id="OBTAIN_TBIN_BIT_COLUMNS:source"></a>function OBTAIN_TBIN_BIT_COLUMNS, label, req_keywds, start_ind, end_ind
  <span class="comments">; initialize items keyword structure:</span>
  keywds = create_struct("flag", 1, "flag2",1)
  
  <span class="comments">;;</span>
  <span class="comments">;; Column info</span>
  column_objects = objpds(label, "COLUMN")
  column_start_ind = ULONG(column_objects.index)
  column_end_ind = ULONARR(n_elements(column_start_ind))
  for i=0,n_elements(column_start_ind)-1 do begin
    column_end_ind[i] = ULONG(get_index(label,column_objects.index[i]))
  endfor
  
  bit_columns = objpds(label, "BIT_COLUMN")
  if (bit_columns.flag eq -1) then goto,endfun
  
  bit_columns_info = replicate(create_struct('name','','bit_data_type','','start_bit',0B,'bits',0B,'items',0B,'item_bits',0B,$
                                           'item_offset',0B,'start_index',0ULL,'end_index',0ULL,'column_index',0UL),n_elements(bit_columns.index))
  
  for i=0,n_elements(bit_columns.index)-1 do begin
    bit_columns_info[i].start_index = bit_columns.index[i]
    bit_columns_info[i].end_index = get_index(label,bit_columns.index[i])
      
    name = obtain_keyword("NAME",label, bit_columns_info[i].start_index, bit_columns_info[i].end_index)    
    bit_data_type = obtain_keyword("BIT_DATA_TYPE",label, bit_columns_info[i].start_index, bit_columns_info[i].end_index)   
    start_bit = obtain_keyword("START_BIT",label, bit_columns_info[i].start_index, bit_columns_info[i].end_index)   
    bits = obtain_keyword("BITS",label, bit_columns_info[i].start_index, bit_columns_info[i].end_index)    
    if (name.flag eq 0 || bit_data_type.flag eq 0 || start_bit.flag eq 0 || (bits.flag eq 0) ) then begin
      print, "Error: missing required keyword in BIT_COLUMN object: NAME, BIT_DATA_TYPE, START_BIT or BITS"
      keywds.flag2 = -1
      goto, endfun
    endif
    
    bit_columns_info[i].name = name.val[0]
    bit_columns_info[i].bit_data_type = bit_data_type.val[0]
    bit_columns_info[i].start_bit = start_bit.val[0]
    bit_columns_info[i].bits = bits.val[0]
    
    pos = where(bit_columns_info[i].start_index gt column_start_ind and bit_columns_info[i].start_index lt column_end_ind)
    bit_columns_info[i].column_index = column_start_ind(pos[0])
    
  endfor

  <span class="comments">; store info into a structure:</span>
  keywds = create_struct(keywds, "name", bit_columns_info.name, "bit_data_type",bit_columns_info.bit_data_type,"start_bit",bit_columns_info.start_bit,$
                                 "bits",bit_columns_info.bits,$
                                 "start_index",bit_columns_info.start_index,"end_index",bit_columns_info.end_index,'column_index',bit_columns_info.column_index,$
                                 'count',n_elements(bit_columns_info.name))
  return, keywds 

  endfun:
    keywds.flag = -1
    return, keywds
end




<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: keywds contains required keywords for current table object,</span>
<span class="comments">;     items contains items keywords for current table object, label is a </span>
<span class="comments">;     viable PDS label string array, start_ind and end_ind are integer</span>
<span class="comments">;     pointers to start and end of current table object</span>
<span class="comments">; postcondition: creates a structure to be read from the data file and returns</span>
<span class="comments">;     it to the main block.</span>

<a id="CREATE_TBIN_STRUCT:source"></a>function CREATE_TBIN_STRUCT, keywds, opt, items, containers, label, start_ind, end_ind
    <span class="comments">; initialize variables:</span>
    curpos = 0            <span class="comments">; cursor position</span>
    complete_set = create_struct("flag", 1)      <span class="comments">; structure to be returned</span>
    data_set = 0          <span class="comments">; data structure set</span>

    <span class="comments">; create structure for row prefix bytes if any:</span>
    if (opt.prefix GT 0) then begin
        data_set = create_struct("prefix", bytarr(opt.prefix))
    endif


    <span class="comments">;; No CONTAINER objects in label</span>
    if (containers.flag eq -1) then begin

    <span class="comments">; start the loop:</span>
    for j = 0, keywds.columns - 1 do begin
        <span class="comments">; set current and next COLUMN object index pointers:</span>
        curr_ind = keywds.name.index[j]
        if (j EQ keywds.columns - 1) then begin
            next_ind = end_ind
        endif else begin
            next_ind = keywds.name.index[j+1]
        endelse

        <span class="comments">; name of current column:</span>
        name = "COLUMN" + CLEAN(string(j+1),/SPACE)     <span class="comments">; external routine</span>
        <span class="comments">; extract start byte value for current column:</span>
        start_byte = long(keywds.start_byte.val[j])

        <span class="comments">; the temp buffer to be read is: difference between start_byte of</span>
        <span class="comments">; current column and last curpos:</span>
        buffer_length = start_byte - curpos
        if (buffer_length LT 0) then begin
            print, "Error: inconsistent START_BYTE and BYTES specification" + $
                   " in COLUMNS " + CLEAN(string(j),/SPACE) + " and " + $
                   CLEAN(string(j+1), /SPACE) + "."
            GOTO, ENDFUN
        endif else if (buffer_length EQ 0) then begin
            temp = -1            
        endif else begin
            temp = bytarr (buffer_length)
            curpos = start_byte
        endelse

        <span class="comments">; process item objects for current COLUMN object:</span>
        element = PROCESS_TBIN_ITEMS(keywds, items, curpos,curr_ind,next_ind)

        <span class="comments">; create column structure:</span>
        if (temp[0] EQ -1) then begin
            col_struct = create_struct ("element", element.data)
        endif else begin
            col_struct = create_struct ("temp", temp, "element", element.data)
        endelse

        <span class="comments">; construct structure to be read:</span>
        if (size(data_set, /TYPE) NE 8) then begin
            data_set = create_struct(name, col_struct)
        endif else begin
            data_set = create_struct(data_set, name, col_struct)
        endelse
    endfor

    <span class="comments">; set additional buffer array at end of record:</span>
    <span class="comments">; if cursor position &lt; rb then take the difference between 78 and curpos</span>
    <span class="comments">; and create a temporary buffer to be read at the end of each record.</span>
    <span class="comments">; if cursor position > rb then issue error, and exit routine:</span>
    if (keywds.row_bytes GT curpos) then begin
        diff = keywds.row_bytes - curpos
        data_set = create_struct(data_set, "temp", bytarr(diff))
    endif else if (keywds.row_bytes LT curpos) then begin
        print, "Error: Invalid START_BYTE or BYTES specification in label."
        GOTO, ENDFUN
    endif


    <span class="comments">;; CONTAINER objects in label</span>
    endif else begin 
    
      container_index = 0
      
      columns = objpds(label, "COLUMN")
      pos = where(columns.index gt start_ind and columns.index lt end_ind)
      columns.count = n_elements(pos)
      columns.array[0:columns.count-1] = columns.array(pos)
      columns.index[0:columns.count-1] = columns.index(pos)
      columns_end_index = uintarr(columns.count)   
      for i=0,columns.count-1 do columns_end_index[i] = get_index(label,columns.index[i])
      
      <span class="comments">;; start the loop for columns</span>
      for j = 0, columns.count - 1 do begin
      
        <span class="comments">; set current and next COLUMN object index pointers:</span>
        curr_ind = columns.index[j]
        next_ind = columns_end_index[j]
        
        <span class="comments">;; Check if column belongs to container object</span>
        container_flag = 0
        if (container_index lt containers.count) then begin
          if (curr_ind gt containers.start_index[container_index] and next_ind lt containers.end_index[container_index]) then container_flag = 1 $
          else container_flag = 0
        endif
        
        if (container_flag eq 0) then begin
        
          <span class="comments">; name of current column:</span>
          name = "COLUMN" + CLEAN(string(j+1),/SPACE)     <span class="comments">; external routine</span>
        
          <span class="comments">; extract start byte value for current column:</span>
          <span class="comments">; determine the index for current start_byte values to be assigned:</span>
          pos = where (long(keywds.start_byte.index) GT curr_ind AND long(keywds.start_byte.index) LT next_ind)
          start_byte = long(keywds.start_byte.val[pos(0)])
        
          <span class="comments">; the temp buffer to be read is: difference between start_byte of</span>
          <span class="comments">; current column and last curpos:</span>
          buffer_length = start_byte - curpos
          if (buffer_length LT 0) then begin
              print, "Error: inconsistent START_BYTE and BYTES specification" + $
                   " in COLUMNS " + CLEAN(string(j),/SPACE) + " and " + $
                   CLEAN(string(j+1), /SPACE) + "."
              GOTO, ENDFUN
          endif else if (buffer_length EQ 0) then begin
            temp = -1            
          endif else begin
            temp = bytarr (buffer_length)
            curpos = start_byte
          endelse

          <span class="comments">; process item objects for current COLUMN object:</span>
          element = PROCESS_TBIN_ITEMS(keywds, items, curpos,curr_ind,next_ind)

          <span class="comments">; create column structure:</span>
          if (temp[0] EQ -1) then begin
            col_struct = create_struct ("element", element.data)
          endif else begin
            col_struct = create_struct ("temp", temp, "element", element.data)
          endelse

          <span class="comments">; construct structure to be read:</span>
          if (size(data_set, /TYPE) NE 8) then begin
            data_set = create_struct(name, col_struct)
          endif else begin
            data_set = create_struct(data_set, name, col_struct)
          endelse
          
        endif else begin
        
          <span class="comments">; name of current column:</span>
          container_name = "CONTAINER" + CLEAN(string(container_index+1),/SPACE)     <span class="comments">; external routine</span>
          container_struct = 0
          container_curpos = 0
        
          for k=0,containers.columns[container_index]-1 do begin
        
            <span class="comments">; set current and next COLUMN object index pointers:</span>
            curr_ind = columns.index[j]
            next_ind = columns_end_index[j]
        
          <span class="comments">; name of current column:</span>
          name = "COLUMN" + CLEAN(string(j+1),/SPACE)     <span class="comments">; external routine</span>
        
          <span class="comments">; extract start byte value for current column:</span>
          <span class="comments">; determine the index for current start_byte values to be assigned:</span>
          pos = where (long(keywds.start_byte.index) GT curr_ind AND long(keywds.start_byte.index) LT next_ind)
          start_byte = long(keywds.start_byte.val[pos(0)])
        
          <span class="comments">; the temp buffer to be read is: difference between start_byte of</span>
          <span class="comments">; current column and last curpos:</span>
          buffer_length = start_byte - container_curpos
          if (buffer_length LT 0) then begin
              print, "Error: inconsistent START_BYTE and BYTES specification" + $
                   " in COLUMNS " + CLEAN(string(j),/SPACE) + " and " + $
                   CLEAN(string(j+1), /SPACE) + "."
              GOTO, ENDFUN
          endif else if (buffer_length EQ 0) then begin
            temp = -1            
          endif else begin
            temp = bytarr (buffer_length)
            curpos = start_byte
          endelse

          <span class="comments">;process item objects for current COLUMN object:</span>
          element = PROCESS_TBIN_ITEMS(keywds, items, container_curpos,curr_ind,next_ind)

          <span class="comments">; create column structure:</span>
          if (temp[0] EQ -1) then begin
            col_struct = create_struct ("element", element.data)
          endif else begin
            col_struct = create_struct ("temp", temp, "element", element.data)
          endelse

          <span class="comments">; construct structure to be read:</span>
          if (size(container_struct, /TYPE) NE 8) then container_struct = create_struct(name, col_struct) $
          else container_struct = create_struct(container_struct, name, col_struct)
        
          if (k ne containers.columns[container_index]-1) then j++
        endfor
       
        container_struct_aux = replicate(container_struct,containers.repetitions[container_index])        
        curpos = container_curpos*containers.repetitions[container_index] + curpos
        container_index++
        
        <span class="comments">; construct structure to be read:</span>
        if (size(data_set, /TYPE) NE 8) then begin
          data_set = create_struct(container_name, container_struct_aux)
        endif else begin
          data_set = create_struct(data_set, container_name, container_struct_aux)
        endelse
       
       endelse   
          
    endfor

    <span class="comments">; set additional buffer array at end of record:</span>
    <span class="comments">; if cursor position &lt; rb then take the difference between 78 and curpos</span>
    <span class="comments">; and create a temporary buffer to be read at the end of each record.</span>
    <span class="comments">; if cursor position > rb then issue error, and exit routine:</span>
    if (keywds.row_bytes GT curpos) then begin
        diff = keywds.row_bytes - curpos
        data_set = create_struct(data_set, "temp", bytarr(diff))
    endif else if (keywds.row_bytes LT curpos) then begin
        print, "Error: Invalid START_BYTE or BYTES specification in label."
        GOTO, ENDFUN
    endif      
    
    endelse
    

    if (opt.suffix GT 0) then begin
        data_set = create_struct(data_set, "suffix", bytarr(opt.suffix))
    endif

    <span class="comments">; replicate data structure ROWS times:</span>
    data_set = replicate (data_set, keywds.rows)

    <span class="comments">; construct the complete data structure:</span>
    complete_set = create_struct (complete_set, "data_set", data_set)

    return, complete_set

    ENDFUN:
        complete_set.flag = -1
        return, complete_set
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: pointer is a structure containing viable pointer information</span>
<span class="comments">;     for current table object, data_struct contains the data structure to</span>
<span class="comments">;     be read from file, keywds contains all the required keyword info, and </span>
<span class="comments">;     silent is set to either 0 or 1 depending on the function specification.</span>
<span class="comments">; postcondition: this subroutine reads the data from the pointer datafile</span>
<span class="comments">;     and returns the data structure.</span>
<span class="comments">;</span>

<a id="READ_TBIN_DATA:source"></a>function READ_TBIN_DATA, pointer, data_struct, keywds, silent
    <span class="comments">; error protection:</span>
    on_ioerror, SIGNAL

    <span class="comments">; construct data_set structure:</span>
    data_set = create_struct("flag", 1)

    <span class="comments">; first inform user of status:</span>
    if (silent EQ 0) then begin
        text = CLEAN(string(keywds.columns), /SPACE) + " Columns and " + $
               CLEAN(string(keywds.rows), /SPACE) + " Rows" <span class="comments">; external routine</span>
        print, "Now reading table with " + text
    endif

    <span class="comments">; open the file:</span>
    if (keywds.arch eq "MSB") then begin
        openr, unit, pointer.datafile, /get_lun, /swap_if_little_endian
    endif else begin 
        openr, unit, pointer.datafile, /get_lun, /swap_if_big_endian
    endelse

    <span class="comments">; now read data after setting the file pointer to skip:</span>
    point_lun, unit, pointer.skip
    readu, unit, data_struct
    close, unit
    free_lun, unit
    data_set = create_struct(data_set, "data", data_struct)

    return, data_set

    SIGNAL:
        on_ioerror, NULL
        print, "Error: File either corrupted or bad PDS label."
        data_set.flag = -1
        close, unit
        free_lun,unit
        return, data_set
end


<a id="FORMAT_COLUMN:source"></a>function FORMAT_COLUMN, element, keywds, items, repetitions, rows, type, index1, index2

  stat = size(element, /TYPE)
  
  <span class="comments">; check to see if current column is a structure:</span>
  if (stat EQ 8) then begin
    <span class="comments">; determine item bytes for current column:</span>
    if (index1 EQ keywds.columns - 1) then begin
      bytes = items.bytes.val[items.bytes.count - 1]
      items_count = items.items.val[items.bytes.count - 1]
    endif else begin
      pos = where (items.bytes.index GT keywds.bytes.index[index1])
      bytes = items.bytes.val[pos[0]]
      items_count = items.items.val[pos[0]]
    endelse

    <span class="comments">; perform conversion of the element into arrays using routine:</span>
    stat = size(element.item_elem.element)
    
    if (repetitions eq 0) then begin
      if (items_count eq 2) then begin
        combo = bytarr(stat[1], 2, stat[2])
        combo[*, 0, *] = element.item_elem.element
        combo[*, 1, *] = element.last.element
        temp = BTABVECT2(combo, type, rows, bytes)
      endif else begin
        
        if float(strtrim(items_count,1)) ne 1 then begin
            combo = bytarr(stat[1], stat[2] + 1, stat[3])
            combo[*, 0:stat[2] - 1, *] = element.item_elem.element
            combo[*, stat[2], *] = element.last.element
        endif else begin
            combo = bytarr(stat[1], stat[2], stat[3])
            combo = element.item_elem.element
        endelse
        temp = BTABVECT2(combo, type, rows, bytes)
      endelse

    endif else begin
      combo = bytarr(repetitions, stat[2] + 1, stat[3], stat[4])
      combo[*,0:stat[2]-1,*,*] = element.item_elem.element
      combo[*,stat[2],*,*] = element.last.element
      
      temp = BTABVECT2(combo, type, rows, bytes, repetitions)
    endelse
  endif else begin
    bytes = keywds.bytes.val[index2]
    temp = (repetitions eq 0) ? BTABVECT2(element, type, rows, bytes) : BTABVECT2(element, type, rows, bytes, repetitions)  <span class="comments">; external routine</span>
  endelse

  return, temp
end


<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: keywds contains the required keyword params, data contains</span>
<span class="comments">;     the data as read from the file in a structure format.</span>
<span class="comments">; poscondition: the data structure is parsed and all the column data is </span>
<span class="comments">;     extracted, organized into arrays, and returned as a structure.</span>
<a id="ORGANIZE_TBIN_DATA:source"></a>function ORGANIZE_TBIN_DATA, keywds, items, data
    <span class="comments">; initialize data structures:</span>
    data_set = create_struct("flag", 1)
    name_val = keywds.name.val[0:keywds.name.count-1]
    data_struct = create_struct("names", name_val)
    rows = keywds.rows

    <span class="comments">;; Check if container object</span>
    names = tag_names(data)
    pos = where(strmid(names,0,9) eq "CONTAINER",count)
    if (count eq 0) then begin

    <span class="comments">; go through each column and convert data structure into array:</span>
    for i = 0, keywds.columns - 1 do begin
        <span class="comments">; get the column title and data type:</span>
        title = "column" + CLEAN(i + 1,/SPACE)
        type = keywds.data_type.val[i]

        <span class="comments">; obtain the ith tag's element and store it as temp element, and </span>
        <span class="comments">; determine the type of object element is, i.e., a structure, array:</span>
        if (size(data.(0), /TYPE) NE 8) then element = data.(i+1).element $
        else element = data.(i).element
        stat = size(element, /TYPE)

        temp = FORMAT_COLUMN(element, keywds, items, 0, rows, type, i, i)
            
        <span class="comments">; if conversion not successful then return to main block with flag:</span>
        if (temp.flag EQ -1) then begin
            GOTO, ENDFUN 
        endif

        <span class="comments">; add to data structure:</span>
        data_struct = create_struct(data_struct, title, temp.vector)
    endfor
    
    endif else begin
    
      column_ind = 0ULL
      total_ind = 0ULL
      
      <span class="comments">; go through each column and convert data structure into array:</span>
      for i = 0, n_elements(names)-1 do begin
      
        if (strmid(names[i],0,9) eq "CONTAINER") then begin
          container_content = tag_names(data.(i))
          stat = size(data.(i))
          repetitions = stat[1] <span class="comments">;; repetitions</span>
          total_ind++
          
          container_struct = 0
          for j=0,n_elements(container_content)-1 do begin
          
            title = "column" + CLEAN(column_ind + 1,/SPACE)
            type = keywds.data_type.val[column_ind]
            element = data.(i).(j).element
          
            temp = FORMAT_COLUMN(element, keywds, items, repetitions, rows, type, i, total_ind)
            if (temp.flag EQ -1) then goto, endfun <span class="comments">; if conversion not successful then return to main block with flag</span>
            
            <span class="comments">; add to data structure:</span>
            container_struct =  (size(container_struct, /TYPE) NE 8) ? create_struct(title, temp.vector) : create_struct(container_struct, title, temp.vector)
          
            column_ind++
            total_ind++
          
          endfor
        
          data_struct = create_struct(data_struct,names[i],container_struct)
        
        endif else begin  
          
          title = "column" + CLEAN(column_ind + 1,/SPACE)
          type = keywds.data_type.val[column_ind]
          
          <span class="comments">; obtain the ith tag's element and store it as temp element, and </span>
          <span class="comments">; determine the type of object element is, i.e., a structure, array:</span>
          if (size(data.(0), /TYPE) NE 8) then element = data.(i+1).element else element = data.(i).element
          
          temp = FORMAT_COLUMN(element, keywds, items, 0, rows, type, i, total_ind)
          if (temp.flag EQ -1) then goto, endfun <span class="comments">; if conversion not successful then return to main block with flag</span>

          <span class="comments">; add to data structure:</span>
          data_struct = create_struct(data_struct, title, temp.vector)
          
          column_ind++
          total_ind++
        endelse
    
      endfor
    
    endelse

    data_set = create_struct(data_set, "data", data_struct)
    return, data_set

    ENDFUN:
       data_set.flag = -1
       return, data_set
end

<span class="comments">;- level 0 -------------------------------------------------------------------</span>

<a id="TBINPDS:source"></a>function TBINPDS, fname, label, objindex, SILENT=silent
    <span class="comments">; error protection:</span>
    <span class="comments">;ON_ERROR, 2</span>

    <span class="comments">; check for number of parameters in function call:</span>
    if (n_params() LT 3) then begin
        print, "Syntax: Result = TBINPDS (filename,label,objindex[,/SILENT])"
        return, -1
    endif

    <span class="comments">; check for silent keyword:</span>
    silent = keyword_set(SILENT)

    <span class="comments">; obtain viable objects for label:</span>
    objects = OBJPDS(label, "ALL")                         <span class="comments">; external routine</span>
    if (objects.flag EQ -1) then begin
        print, "Error: No viable TABLE objects found in label."
        return, -1
    endif

    <span class="comments">; match the indices of all viable objects against objindex:</span>
    objpos = where (objindex EQ objects.index)

    <span class="comments">; if a match is found, then store the name of that object, else </span>
    <span class="comments">; indicate the specification of invalid objindex:</span>
    if (objpos[0] NE -1) then begin
        objects.array = objects.array[objpos[0]]
        objectname = objects.array[0]
    endif else begin
        print, "Error: Invalid objindex specified."
        return, -1
    endelse

    <span class="comments">; set start and end object pointers for current table object:</span>
    start_ind = objindex
    end_ind = GET_INDEX(label, start_ind)                  <span class="comments">; external routine</span>
    if (end_ind EQ -1) then begin
        return, -1
    endif

    <span class="comments">; check for valid interchange format using subroutine:</span>
    if (TBIN_INTERFORM(label, start_ind, end_ind) EQ -1) then begin
        return, -1
    endif

    <span class="comments">; obtain required keywords for the current object:</span>
    req_keywds = OBTAIN_TBIN_REQ(label, start_ind, end_ind)   <span class="comments">; subroutine</span>
    if (req_keywds.flag EQ -1) then begin
        return, -1
    endif

    <span class="comments">; obtain optional keywords for current object:</span>
    opt_keywds = OBTAIN_TBIN_OPT(label, start_ind, end_ind)    <span class="comments">; subroutine</span>
    if (opt_keywds.flag EQ -1) then begin
        return, -1
    endif

    <span class="comments">; obtain items keywords for the column objects using subroutine:</span>
    items = OBTAIN_TBIN_ITEMS(label, req_keywds, start_ind, end_ind)
    if (items.flag2 EQ -1) then begin
        return, -1
    endif

    <span class="comments">; obtain CONTAINER objects for the column objects using subroutine:</span>
    containers = OBTAIN_TBIN_CONTAINERS(label, req_keywds, start_ind, end_ind)
    if (containers.flag2 EQ -1) then begin
        return, -1
    endif
   
   <span class="comments">; obtain BIT_COLUMN objects for the column objects using subroutine:</span>
    bit_columns = OBTAIN_TBIN_BIT_COLUMNS(label, req_keywds, start_ind, end_ind)
    if (bit_columns.flag2 EQ -1) then begin
        return, -1
    endif
   
    <span class="comments">; check consistency of COLUMN objects and COLUMNS keyword</span>
    <span class="comments">; note: only when no CONTAINER/BIT_COLUMN objects are present, and no ITEM keywords used</span>
    <span class="comments">;       because it is not clear how to count the number of columns in those cases</span>
    if (containers.flag EQ -1 and bit_columns.flag EQ -1 and items.flag EQ -1) then begin
      column_objects = objpds(label, "COLUMN")
      pos = where(column_objects.index gt start_ind and column_objects.index lt end_ind,count)
      if (count ne req_keywds.columns) then $
        print,'Warning: COLUMNS keyword value not consistent with number of COLUMN objects.'
    endif
   
    <span class="comments">; obtain pointer information for table object:</span>
    pointer = POINTPDS (label, fname, objectname)          <span class="comments">; external routine</span>
    if (pointer.flag EQ -1) then begin
        return, -1
    endif        

    <span class="comments">; create data structure to be read:</span>
    complete_set = CREATE_TBIN_STRUCT(req_keywds, opt_keywds, items, containers, label, $
                                       start_ind, end_ind)    <span class="comments">; subroutine</span>
    if (complete_set.flag EQ -1) then begin
        return, -1
    endif else begin
        data_struct = complete_set.data_set
    endelse
    
    <span class="comments">; read data structure from file using subroutine:</span>
    data_set = READ_TBIN_DATA(pointer, data_struct, req_keywds, silent)
    if (data_set.flag EQ -1) then begin
        return, -1
    endif

    data = data_set.data
    
    <span class="comments">; separate data into columns and convert into appropriate type:</span>
    data_set = ORGANIZE_TBIN_DATA(req_keywds, items, data) <span class="comments">; subroutine</span>
    if (data_set.flag EQ 1) then begin
        data = data_set.data
    endif else begin
        return, -1
    endelse

    <span class="comments">;; Reverse byte order if:</span>
    <span class="comments">;;   - MSB architecture and little-endian machine</span>
    <span class="comments">;;   - LSB architecture and big-endian machine</span>
    if (req_keywds.arch eq "MSB") then data = swap_endian(data,/swap_if_little_endian) $
    else data = swap_endian(data,/swap_if_big_endian)
    
    <span class="comments">;;</span>
    <span class="comments">;; Process BIT_COLUMN objects if present and add to current structure</span>
    if (bit_columns.flag EQ -1) then return, data 
    data = PROCESS_TBIN_BIT_COLUMNS(data, label, req_keywds, bit_columns)
    
    return, data
end
</code>
    </div>
  </body>
</html>