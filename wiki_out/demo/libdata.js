/* Index used for searching */
/*
   Fields used:
     url, name, type, filename, authors, routine name, comments, parameters,
     categories, and attributes
*/
title = "OMINAS API Documentation";
subtitle = "Generated by IDLdoc";
libdata = new Array();
libdataItem = 0;



libdata[libdataItem++] = new Array("./doc_demo.html", "doc_demo.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "doc_demo.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./jupiter_example.html", "jupiter_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "jupiter_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./mosaic_example.html", "mosaic_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "mosaic_example.pro", "", "", " MOSAIC EXAMPLE     This example requires the following kernel files, which are    included in the demo's data directory: <span class= code-output > $CAS_SPICE_CK/001103_001105ra.bc</span> <span class= code-output > $CAS_SPICE_CK/001105_001108.bc</span> <span class= code-output > $CAS_SPICE_CK/001026_001029ra.bc</span> <span class= code-output > $CAS_SPICE_CK/001029_001031ra.bc</span>    This example file demonstrates how to construct a mosaic using OMINAS.    This example file can be executed from the UNIX command line using:   	  idl mosaic.example     or from within IDL using:   	  @mosaic.example     After the example stops, later code samples in this file may be executed by    pasting them onto the IDL command line.   Navigate on limbs automatically     pg_farfit finds the limb to within a few pixels.  In reality, you would    want to refine the pointing by scanning for the limb and performing a    least-squares fit, but for the purposes of clarity in this example, the    inital fit will do.  See jup_cassini.example and dione.example for examples    of least-squares fits to image features.   Correct photometry     Here, a crude photometric correction is performed for the purposes    of this example.     In addition to the corrected images, the output descriptors, dd_pht,    will contain the photometric angles in their user data arrays with    the names 'EMM', 'INC' and 'PHASE'.   Project maps     Note that all map projections use the same map descriptor.     Also, aux=['EMM'] is used with pg_map to direct it to reproject    the emmision angle array that was produced and stored in the data descriptor    by pg_photom.  That array will be needed by pg_mosaic.   Introducing wind profiles   Use the commented commands instead to include a zonal wind profile in  the projection.   Construct the mosaic     The combination function 'emm' combines the maps    using wighting proprtional to emm^x, where emm is the emmision    cosine.  It also imposes a minimum emmision cosine, emm0.  Note    that the emission angles were computed by pg_photom and    reprojected by pg_map, as directed by the 'aux' keyword.   Save the mosaic and map info     To read the mosaic and projection info: <span class= code-output > dd = dat_read('./data/test.msc', mosaic, label)</span> <span class= code-output > md = pg_get_maps(dd)</span>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./radar_example.html", "radar_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "radar_example.pro", "Paulo Penteado   ", "", "", "", "          -1", "  This script demonstrated reading a Cassini RADAR SAR image and projecting it   onto an orthographical map for display.    The data file, BIFQI22N068_D045_T003S01_V02.IMG, must first be   downloaded from PDS&lt;http://pds-imaging.jpl.nasa.gov/data/cassini/cassini_orbiter/CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP&gt;,   then unzipped (the zip file is 202MB).    Setup: The instrument detectors, translators and transforms must contain the   RADAR definitions, as is included in demo/data/instrument_detectors.tab,   demo/data/translators.tab, and demo/data/transforms.tab. Since the RADAR   data is in PDS format, the PDS detector and io functions must also be set up   in the corresponding tables, as is in config/tab/filetype_detectors.tab   and config/tab/io.tab.    There is no need for SPICE/Icy for this example. It can be run just by doing: <span class= code-output > img='~/radar/BIFQI22N068_D045_T003S01_V02.IMG'</span> <span class= code-output > .run radar_example</span>   from the demo directory. Note that you have to set the variable img to the   location of your data file.   ");
  

libdata[libdataItem++] = new Array("./saturn_example.html", "saturn_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "saturn_example.pro", "", "", " Saturn Example    	 This example file uses Saturn and its rings to show various   	 capabilities of the software.  This includes fitting the   	 limb and rings simultaneously, hiding the limb and/or rings wrt   	 other objects in the field of view, plotting radial and longitudinal   	 sectors on the ring and mapping the saturn cloud tops.    	 This example file can be executed from the UNIX command line using: <span class= code-output >	  idl ominas saturn.example</span>   	 or from within IDL using: <span class= code-output >	  @saturn.example</span>   	 After the example stops, later code samples in this file may be executed by   	 pasting them onto the IDL command line.   Image read and display  	  	This first section uses dat_read to read in the image.  The image file    c3440346.gem is a Voyager VICAR format file where the image has had    the camera distortions removed with the VICAR program GEOMA.  dat_read    reads the image portion (im) and the image label (label) and its output    is a data descriptor (dd).  ctmod is called to reserve several colors    in the case of an 8-bit display.  tvim is called to display the image    (im) at 1/2 size in a new window with the y coordinate as top-down.  	For Example: <span class= code-output >    dd = dat_read('data/c3440346.gem', im, label)</span> <span class= code-output >  ctmod, top=top</span> <span class= code-output >  tvim, im, zoom=0.5, /order, /new, top=top</span> 	Blah blah    Obtaining the descriptors    	This section obtains the camera descriptor (cd), the planet descriptor   	(pd) and the ring descriptor (rd) for use by the software.  In this   	example, the various elements of these descriptors are overridden with   	values that causes the software not to try to read these values from   	a detached header or through a translator that would access the data   	from the default source.    	Change override to zero to read the data through the translators using   	the Voyager SEDR instead (assuming you have installed the SEDR data   	files, which are not provided in the default installation).     This example, commented out, shows how two objects can be included in   one planet descriptor.   Filling the generic descriptor    	This line fills a  generic  descriptor.  This is a convenience   	feature where in several descriptors are grouped into a structure that   	can be passed to functions in one piece.    	cd - camera descriptor part   	gbx - globe descriptor part   	dkx - disk descriptor part   Calculating the limb, ring and planet center   Determining the plot characteristics    This section uses pg_limb to calculate the limb point structure (limb_ptd)   containing the limb points, the ring point structure (ring_ptd) and also   the planet center (center_ptd) using the routine pg_center.  It uses the   generic descriptor (gd) to pass the camera, planet and ring descriptors   to these routines.  It also uses pg_hide to remove (/rm) points from the   ring (/disk) from the limb points and then again to remove the ring points   covered by the planet (/globe).  It then groups each of these into   object_ptd for plotting.  The colors, psyms, psizes and plables variables   are defined for the plot.  The center is drawn in the default color   (!p.color), the limb is in yellow (ctyellow) and the inner and outer ring   are in red (ctred).  Here you can see that each ring is treated as two   objects (inner and outer) when defining plot characteristics.  With an   8-bit display, these color routines return the values that were previously   reserved in the color table with ctmod; with a 24-bit display, these   routines return the true color values for these colors.  nlimb stores the   number of points in the limb_ptd structure, nring, the number of points in   the ring point structure.  In plabels, the limb and ring's name is not   plotted since it would be plotted at the center of the object.   Drawing the limb, ring and planet center  	   This section draws the objects in the object structure (center, limb  and ring) with the colors and plot symbols and labels defined earlier.  Notice how the limb and ring curves cut off at the points of intersection  between the objects.   Draw planet and ring latitude/longitude grid  	     This sections calculates a latitude/longitude grid for the planet and a   	radius/longitude grid for the rings.  By default it draws 12 latitude   	and 12 longitude grid lines.  The longitude grid lines circle the body   	and so on a map they will appear as 24 grid lines.  The ring radius grid   	uses four grid lines by default between the inner and outer ring radius.   	It uses pg_hide to set as not visible the points on the grid behind the   	planet and ring for both objects.  It then uses pg_draw to draw the   	planet grid points in blue (ctblue) and the ring grid points in purple   	(ctpurple).  Here is where the example then stops.   Manually repointing the geometry    This pasteable section first clears the screen of the plotted points   by redisplaying the image with tvim.  It then calls pg_drag to allow   the user to use the cursor to drag the pointing, and with it the limb,   ring and planet center.  To move the pointing with pg_drag, use the left   mouse button and translate the pointing in x,y.  Use the middle mouse   button to rotate the pointing about an axis (in this case, the axis of   rotation is set as the planet center (center_ptd[0]).  When the   desired pointing is set, the right mouse button accepts it.  pg_drag   returns the delta x,y amount dragged (dxy) as well as the rotation   angle (dtheta).  pg_repoint uses the dxy and dtheta to update the   camera descriptor (cd, passed by gd).  The limb and center is then   recalculated, the image redisplayed to clear the objects drawn, and   then pg_draw is called to replot.   Scanning the edge to find the limb and using it to calculate the pointing    This section calls pg_cvscan to scan the image around the predicted   limb position and the ring edge position (within width of 80 pixels) and   find the points of highest correlation with a given edge model for each   object (edge_model_nav_limb = limb model used in the VICAR program NAV   and edge_model_nav_ring = ring model from NAV) and zeropoint offset in   the given model (lzero).  These points are then plotted.   Thresholding using correlation coefficient    This section (optional) calls pg_threshold to remove points with lower   correlation coefficients.  The /relative flag means that the minimum   and maximum thresholds are taken as a fraction to the maximum value   in the array.  Notice here again that the ring is treated as two   objects.   Removing regions of bad points    This section (optional) calls pg_select to remove points within a   polygonal region as defined by the cursor.  Click the left mouse   button to mark a point and move the mouse to the next point and   click.  Use the middle mouse button to erase a point and the right   mouse button to end the region.  pg_trim removes the points in the   just defined region.  The scan points are then replotted.   Repeat these statements for each region a user wants to remove.   Fitting the pointing to the scanned points    This section calls pg_cvscan_coeff to determine the linear least-squares   coefficients for a fit to the image coordinate translation and rotation   which matches the computed curve to the scanned curve. It then calls   pg_fit to do the fit with the calculated coefficients to calculate the   correction in translation (dxy) and rotation (dtheta).  It calls   pg_cvchisq to get the chi square of the fit.  Then calls pg_repoint to   update the pointing. Recalculates the limb and center and replots.   The determination of the curves and their subsequent fit can be   iterated on.   Defining a ring sector for a plot    To plot a ring radius vs. intensity or longitude vs. intensity, the   user must first define the limits of the ring sector.  Here it is   done in one of two ways, the first is to define the longitude (lon)   and radius (rad) limits in an array.  The second method is to use   the cursor to sweep out a ring sector, pg_ring_sector is called to   do this.  To use the mouse, click in one corner of your desired sector   and move the cursor to the opposite corner.  In this example,   counterclockwise is the direction of increasing longitude.  The chosen   sector is then calculated using pg_profile_ring with the /outline   keyword.  This outline is then drawn with pg_draw.   Plotting ring sector plots    		Below is the code for four different types of plots using pg_profile_ring.   		Radial (default) and longitudinal (/azimuthal), interpolated (default)   		and binned (/bin).  There is an oversamp keyword which defines the amount   		to oversample (vs. 1 pixel).  In the case of a longitudinal bin scan,   		pixelization can cause some bins to contain very low numbers or none at   		all.  In this example oversamp=0.3 to cause the plot to have larger bins   		to help alleviate this problem.  The calculated profile is then plotted   		in a new window.   Draw planet and ring latitude/longitude grid    This sections calculates a latitude/longitude grid for each planet and a   radius/longitude grid for the rings.  By default it draws 12 latitude   and 12 longitude grid lines.  The longitude grid lines circle the body   and so on a map they will appear as 24 grid lines.  The ring radius grid   uses four grid lines by default between the inner and outer ring radius.   It uses pg_hide to set as not visible the points on the grid behind the   planet and ring for both objects.  It then uses pg_draw to draw the   grid points in blue (ctblue).  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./stars_example.html", "stars_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "stars_example.pro", "", "", " Star fitting example   Note: One optional image in this example requires the voyager SEDR  files, which is not supplied in the default installation.   This example requires a star catalog. The options are: UCAC4, UCACT,  TYCHO2, SAO, and GSC2. To learn more about where to obtain these  catalogs, please see the documentation for the star catalog translators,  strcat_ucac4_input, strcat_ucact_input, strcat_tycho2_input,  strcat_sao_input, and strcat_gsc2_input.   In this script, the star fitting capabilities of OMINAS will be demonstrated.   This example file can be executed from the UNIX command line using: <span class= code-output >idl stars.example</span>  or from within IDL using: <span class= code-output >@stars.example</span>  After the example stops, later code samples in this file may be executed by  pasting them onto the IDL command line.   Image read and display   This first section uses dat_read to read in the image. There are several  available image files to use for the preocessing:   	c1138223.gem: Voyager VICAR format file where the image has had  	the camera distortions removed with the VICAR program GEOMA.   	N1456251768_1.IMG: Cassini ISS-NA image, obtained from the PDS imaging  	node.   dat_read reads the image portion (im) and the image label (label) and its  output is a data descriptor (dd). tvim is called to display the image (im)  at 3/4 size in a new window with the y coordinate as top-down.   Note: Users with a 24-bit display, you may want to do the device command  'pseudo=8' so that xloadct can be used to contrast enhance the image.   Code: <span class= code-output >;dd = dat_read('data/c1138223.gem', im, label)           ; VICAR format file</span> <span class= code-output >dd = dat_read('data/N1456251768_1.IMG', im, label)       ; Cas ISS-NA image</span> <span class= code-output >tvim, im, zoom=0.75, /order</span>   Filling the descriptors   This section fills the camera descriptor (cd), the planet descriptor  (pd) and the ring descriptor (rd) for use by the software.   In this example, if the Voyager image is chosen, the default translators  are skipped to use a SEDR update from a VICAR program called NAV instead  of using the normal SEDR the regular translator would return.   If the Cassini image is chosen, this option will be ignored.   Code: <span class= code-output >; Voyager descriptor-generating code</span> <span class= code-output >;cd = pg_get_cameras(dd, 'sedr_source=NAV')</span> <span class= code-output >;pd = pg_get_planets(dd, od=cd, 'sedr_source=NAV')</span> <span class= code-output >;rd = pg_get_rings(dd, pd=pd, od=cd, 'sedr_source=NAV')</span> <span class= code-output >; Cassini descriptor-generating code</span> <span class= code-output >cd = pg_get_cameras(dd)</span> <span class= code-output >pd = pg_get_planets(dd, od=cd)</span> <span class= code-output >rd = pg_get_rings(dd, pd=pd, od=cd)</span>   Filling the generic descriptor   This line fills a  generic  descriptor, which is a standard IDL struct.  Generic descriptors are a convenient notation for several descriptors to  be grouped into a structure that can be passed to functions in one piece.   The components of the generic descriptor are: <span class= code-output >cd - camera descriptor part</span> <span class= code-output >gbx - globe descriptor part</span> <span class= code-output >dkx - disk descriptor part</span>  Code: <span class= code-output >gd = {cd:cd, gbx:pd, dkx:rd}</span>   Filling the star descriptor   This line fills a star descriptor by reading the star catalog using  pg_get_stars. pg_get_stars calls back-end functions to read the  translator table. Therefore, for a specific instrument (for instance,  both ISS-NA and ISS-WA), the star catalog should be specified. The  translators.tab for this demo (in data/translators.tab) should contain  a line with the star catalog to be used: <span class= code-output > -   strcat_tycho2_input     -       /j2000    # or /b1950 if desired</span>  This line specifies that the tycho2 catalog should be used, and all  coordinates should be for the j2000 epoch. Likewise, such a line should  be included in the translator for any mission to be processed.   NOTES:   If the keyword 'tr_override' is specified, only the specified   translator is called instead of whatever star catalog   translators are listed in the translators table.    The translator keyword 'faint' selects only stars with magnitudes   brighter than 14.  The keyword, 'bright' may be used place an upper   bound on the brightness.    /no_sort suppresses the default behavior of returning only   the first object found with any given name.  That operation can be   very time consuming when a large number of objects are returned   by the translators.  In the first case, we have specified that only one   translator will be called, and we know that it will not return   duplicate objects.   Code: <span class= code-output >;sd = pg_get_stars(dd, od=cd, /no_sort, tr_ov='strcat_gsc2_input', 'faint=8')</span> <span class= code-output >sd = pg_get_stars(dd, od=cd, 'faint=14')</span>   Calculating the star centers   The star centers are calculated using pg_center. bx is an output  keyword which contains the body descriptor, in this case it is an  array of star descriptors. Each star descriptor describes the  data for one star.   pg_hide is called to remove (/rm) any star points covered by the  planet (/globe). Although there is no planet in the Cassini image,  this technique should be used to hide star points in general, were  there to be a limb_ptd.   Determining the plot characteristics   The star elements are chosen to be red, with a symbol type of *  (code 2), a font size of 2, and labels corresponding to the name of  each star. Stars can have either catalog names or common names.   Code: <span class= code-output >star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, /rm, /globe</span> <span class= code-output >n_stars=n_elements(sd)</span> <span class= code-output >color = ctred()</span> <span class= code-output >psym = 6</span> <span class= code-output >csizes = 2</span> <span class= code-output >plabels = cor_name(sd)</span>   Drawing the star centers   This section draws the stars in the star_ptd with the colors, plot  symbols, font size, and labels defined earlier.   In this particular example, the planet does not appear in the image.   Code: <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=plabels, csi=csizes</span>   Drawing the stellar spectral types   This pasteable section uses the stellar library function str_sp to return  spectral types of the stars and uses them instead of the star names. If  the spectral type is not available for the catalog, then no information  will be plotted in the labels.   Code: <span class= code-output >tvim, im</span> <span class= code-output >spt=str_sp(sd)</span> <span class= code-output >psyms_str=make_array(n_stars,val=6)</span> <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=spt, csi=csizes</span>   Drawing stellar magnitudes   This pasteable section uses the stellar library function str_get_mag to get  visual magnitudes of the stars and uses them instead of the star names.   Code: <span class= code-output >tvim, im</span> <span class= code-output >sm = str_get_mag(sd)</span> <span class= code-output >smag = string(sm, format='(f4.1)')</span> <span class= code-output >psyms_str=make_array(n_stars,val=6)</span> <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=smag, csi=csizes</span>   Manually repointing the geometry   This pasteable section first clears the screen of the plotted points  by redisplaying the image with tvim.  It then calls pg_drag to allow  the user to use the cursor to drag the pointing, and with it the stars.  To move the pointing with pg_drag, use the left mouse button and  translate the pointing in x,y.  Use the middle mouse button to rotate  the pointing about an axis (in this case, the axis of rotation is set  as the optic axis of the image (star_ptd) which is defined using the  routine pnt_create_descrptors with the points being the camera optic  axis as returned by the camera library routine cam_oaxis.  When the  desired pointing is set, the right mouse button accepts it.  pg_drag  returns the delta x,y amount dragged (dxy) as well as the rotation  angle (dtheta).  pg_repoint uses the dxy and dtheta to update the  camera descriptor (cd, passed by gd).  The limb, ring and star points  are then recalculated, the image redisplayed to clear the objects drawn,  and then pg_draw is called to replot.   Code: <span class= code-output >optic_ptd = pnt_create_descriptors(points=cam_oaxis(cd))</span> <span class= code-output >tvim, im</span> <span class= code-output >dxy = pg_drag(star_ptd, dtheta=dtheta, axis=optic_ptd, symbol=6)  ; square</span> <span class= code-output >pg_repoint, dxy, dtheta, axis=optic_ptd, gd=gd</span> <span class= code-output >star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, /rm, /globe</span> <span class= code-output >tvim, im</span> <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=plabels</span>   Scanning to find the stars and using it to calculate the pointing   This section calls pg_ptscan to scan the image around the predicted  star positions (within width of 40 pixels) and find the pixels with  the highest correlation with a given edge model (example uses the  default gaussian) for each star.  These points are then plotted.   Code: <span class= code-output >ptscan_ptd = pg_ptscan(dd, star_ptd, edge=30, width=40)</span> <span class= code-output >pg_draw, ptscan_ptd, psym=1, col=ctyellow()</span>   Thresholding using correlation coefficient   This section (optional) calls pg_threshold to remove points with lower  correlation coefficients.  This example only keeps stars with a  correlation coefficient above 0.6.  Notice that each object can have  its own min and max value.   Code: <span class= code-output >pg_threshold, ptscan_ptd, min=make_array(n_stars,val=0.6), $</span> <span class= code-output >                          max=make_array(n_stars,val=1.0)</span> <span class= code-output >tvim, im</span> <span class= code-output >pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span> <span class= code-output >pg_draw, ptscan_ptd, psym=1, col=ctyellow()</span>   Removing regions of bad points   This section (optional) calls pg_select to remove points within a  polygonal region as defined by the cursor.  Click the left mouse  button to mark a point and move the mouse to the next point and  click.  Use the middle mouse button to erase a point and the right  mouse button to end the region.  pg_trim removes the points in the  just defined region.  The scan points are then replotted.  Repeat these statements for each region a user wants to remove.   Code: <span class= code-output >region=pg_select(dd)</span> <span class= code-output >pg_trim, dd, ptscan_ptd, region</span> <span class= code-output >tvim, im</span> <span class= code-output >pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span> <span class= code-output >pg_draw, ptscan_ptd, psym=1, col=ctyellow()</span>   Fitting the pointing to the found stars   This section calls pg_ptscan_coeff to determine the linear  least-squares coefficients for a fit to the image coordinate translation  and rotation which matches the computed positions to the scanned  positions. It then calls pg_fit to do the fit with the calculated  coefficients to calculate the correction in translation (dxy) and  rotation (dtheta).  It calls pg_ptchisq to get the chi square of the  fit.  It then calls pg_repoint to update the pointing.  Recalculates  the limb, rings and stars and replots.   Code: <span class= code-output >optic_ptd = pnt_create_descriptors(points=cam_oaxis(cd))</span> <span class= code-output >ptscan_cf = pg_ptscan_coeff(ptscan_ptd, axis=optic_ptd)</span> <span class= code-output >dxy = pg_fit([ptscan_cf], dtheta=dtheta)</span> <span class= code-output >chisq = pg_chisq(dxy, dtheta, ptscan_ptd, axis=optic_ptd[0])</span> <span class= code-output >covar = pg_covariance([ptscan_cf])</span> <span class= code-output >print, dxy, dtheta*180./!pi, chisq, covar</span> <span class= code-output >pg_repoint, dxy, dtheta, axis=optic_ptd, gd=gd</span> <span class= code-output >star_ptd = pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, /rm, /globe</span> <span class= code-output >tvim, im</span> <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=plabels</span>   Output the new state   This section (optional) shows how you can save your output: any changes  to the image data into a new file and the new pointing into a detached  header.   Code: <span class= code-output >pg_put_cameras, dd, gd=gd</span> <span class= code-output >dat_write, 'data/c1138223_nv.gem', dd</span>  ", "", "          -1", "");
  

