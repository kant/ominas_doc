<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Thu Aug 18 11:37:52 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>dat_write.pro (OMINAS API Documentation)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="dat_write.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	dat_write</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Writes a data file of arbitrary format.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/SYS</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	dat_write, filespec, dd</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;  INPUT:</span>
<span class="comments">;	filespec:	Array of strings giving file specifications for</span>
<span class="comments">;			file to write.</span>
<span class="comments">;</span>
<span class="comments">;	dd:		Array of data descriptors.</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;  INPUT:</span>
<span class="comments">;	filetype:	Overrides data descriptor filetype (and thus the </span>
<span class="comments">;			output function).</span>
<span class="comments">;</span>
<span class="comments">;	output_fn:	Overrides data descriptor output function.</span>
<span class="comments">;</span>
<span class="comments">;	verbose:	If set, message are enabled.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; RETURN: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;	dat_write expands all file specifications and attempts to write a</span>
<span class="comments">;	file corresponding to each given data descriptor.  An error results</span>
<span class="comments">;	if the filespec expands to a different number of files than the number</span>
<span class="comments">;	of given data descriptors. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; STATUS:</span>
<span class="comments">;	Complete</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;	dat_read</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 7/1998</span>
<span class="comments">; 	Adapted by:	Spitale, 5/2016</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="dat_write:source"></a>pro dat_write, filespec, dd, nodata=nodata, $
		  filetype=_filetype, $
		  output_fn=_output_fn, $
                  verbose=verbose
@core.include

<span class="comments">; on_error, 1</span>
 _dd = cor_dereference(dd)

 <span class="comments">;------------------------------</span>
 <span class="comments">; expand filespec</span>
 <span class="comments">;------------------------------</span>
<span class="comments">; filenames = findfile1(filespec)</span>
 filenames = ''
 for i=0, n_elements(filespec)-1 do $
  begin
   ff = file_search(filespec[i])
   if(ff[0] NE '') then filenames = append_array(filenames, ff) $
   else filenames = append_array(filenames, filespec[i])
  end

 n_files = n_elements(filenames)
 ndd = n_elements(_dd)

 <span class="comments">;--------------------------------------------------------------------</span>
 <span class="comments">; test for multiple dd per file.  If detected, then all data arrays</span>
 <span class="comments">; are sent to the first filename; the output routine must support</span>
 <span class="comments">; this mechanism</span>
 <span class="comments">;--------------------------------------------------------------------</span>
 multi = 1
 if(n_files EQ ndd) then multi = 0
 if(multi) then filenames = filenames[0]

 <span class="comments">;========================================</span>
 <span class="comments">; write each file</span>
 <span class="comments">;========================================</span>
 for i=0, ndd-1 do $
  begin
   filename = filenames[0]
   if(NOT multi) then filename = filenames[i]

   <span class="comments">;------------------------------</span>
   <span class="comments">; get filetype</span>
   <span class="comments">;------------------------------</span>
   if(keyword_set(_filetype)) then filetype = _filetype $
   else filetype = _dd[i].filetype
   if(filetype EQ '') then nv_message, $
                                    'Filetype unavailable.', name='dat_write'

   <span class="comments">;------------------------------</span>
   <span class="comments">; get name of output routine</span>
   <span class="comments">;------------------------------</span>
   if(keyword_set(_output_fn)) then output_fn = _output_fn $
   else dat_lookup_io, filetype, input_fn, output_fn
   if(NOT keyword_set(output_fn)) then output_fn = _dd[i].output_fn

   if(output_fn EQ '') then $
        nv_message, 'No output function available.', name='dat_write'

   <span class="comments">;---------------------</span>
   <span class="comments">; write the file</span>
   <span class="comments">;---------------------</span>
   header = ''
   if(ptr_valid(_dd[i].header_dap)) then $
                                 header = data_archive_get(_dd[i].header_dap)
   data = data_archive_get(_dd[i].data_dap)

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; first transform the data if necessary</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - -</span>
   data = dat_transform_output(_dd[i], data, header, silent=silent)

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; write data</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - -</span>
   udata = cor_udata(dd[i])

   write = 1
   if(NOT multi) then $
    begin
     data_out = data 
     header_out = header 
     udata_out = udata
    end $
   else $
    begin
<span class="comments">; the output functions are not set up to handle multiple elements, so </span>
<span class="comments">; this crashes...</span>
     data_out = append_array(data_out, nv_ptr_new(data))
     header_out = append_array(header_out, nv_ptr_new(header))
     udata_out = append_array(udata_out, nv_ptr_new(udata))
     if(i NE ndd-1) then write = 0
    end

   if(write) then $
    begin
     if(keyword_set(verbose)) then print, 'Writing ' + filename + '.'
     call_procedure, output_fn, filename, nodata=nodata, $
                                       data_out, header_out, udata_out
    end

  end

 if(multi) then nv_ptr_free, [data_out, header_out, udata_out]

end
<span class="comments">;===========================================================================</span>
</code>
    </div>
  </body>
</html>