<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Thu Aug 18 11:37:49 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>dat_data.pro (OMINAS API Documentation)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="dat_data.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	dat_data</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Returns the data array associated with a data descriptor.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/SYS</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	data = dat_data(dd)</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;  INPUT:</span>
<span class="comments">;	dd:	Data descriptor.</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;  INPUT: </span>
<span class="comments">;	abscissa: If set, the abscissa array is returned instead of the data </span>
<span class="comments">;		  array.</span>
<span class="comments">;</span>
<span class="comments">;	samples:  Sampling indices.  If set, only these data elements are</span>
<span class="comments">;		  returned.  May be 1D or the same number of dimensions as</span>
<span class="comments">;		  the data array.   </span>
<span class="comments">;</span>
<span class="comments">;	nd:       If set, the samples input is taken to be an ND coordinate</span>
<span class="comments">;	          rather than a 1D subscript.  dat_data can normally tell</span>
<span class="comments">;	          the difference automatically, but there is an ambiguity</span>
<span class="comments">;	          if a single ND point is requested.  In that case, dat_data</span>
<span class="comments">;	          interprets that as an array of 1D subscripts, unless /nd</span>
<span class="comments">;	          is set.</span>
<span class="comments">;</span>
<span class="comments">;	true:     If set, the actual data array is returned, even if there is</span>
<span class="comments">;	          a sampling function.</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; RETURN:</span>
<span class="comments">;	The data array associated with the data descriptor.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; STATUS:</span>
<span class="comments">;	Complete</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;	dat_set_data</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 2/1998</span>
<span class="comments">; 	Adapted by:	Spitale, 5/2016</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="dat_data:source"></a>function dat_data, dd, samples=_samples, offset=offset, $
                  nd=nd, true=true, noevent=noevent, abscissa=_abscissa
@core.include
 nv_notify, dd, type = 1, noevent=noevent
 _dd = cor_dereference(dd)

 sampled = 0
 if(NOT keyword_set(offset)) then offset = 0

 <span class="comments">;-------------------------------------------------------------------------</span>
 <span class="comments">; If there is a sampling function, but no samples are given, then </span>
 <span class="comments">; generate sampling for the entire data array.  This way the sampling</span>
 <span class="comments">; function always gets called and a sensible result is obtained.</span>
 <span class="comments">;-------------------------------------------------------------------------</span>
 full_array = 0
 if(keyword_set(_dd.sampling_fn) $
        AND (NOT keyword_set(_samples)) $
               AND NOT keyword_set(true)) then $
   begin
    _samples = gridgen(*_dd.dim_p) 
    full_array = 1
   end


 <span class="comments">;-------------------------------------------------------------------------</span>
 <span class="comments">; sampling</span>
 <span class="comments">;-------------------------------------------------------------------------</span>
 if(keyword_set(_samples)) then $
  begin
   <span class="comments">; - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; call sampling function</span>
   <span class="comments">; - - - - - - - - - - - - - - - - -</span>
   samples = _samples
   if(keyword_set(_dd.sampling_fn)) then $
      samples = call_function(_dd.sampling_fn, dd, samples, $
                                                     dat_sampling_data(_dd))

   <span class="comments">; - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; convert samples to 1D</span>
   <span class="comments">; - - - - - - - - - - - - - - - - -</span>
   samples = round(samples)
   sdim = size(samples, /dim)
   if((n_elements(sdim) NE 1) OR keyword_set(nd)) then $
                                 samples = nd_to_w(*(_dd.dim_p), samples)
  end
 if(keyword_set(samples)) then samples = samples + offset


 <span class="comments">;-------------------------------------------------------------------------</span>
 <span class="comments">; Load data array if necessary. </span>
 <span class="comments">;  Need to add sampling to this call to allow sampling portions of huge</span>
 <span class="comments">;  files.  The problem is that we need to know whether to reload a data </span>
 <span class="comments">;  array that has previously been subsampled.</span>
 <span class="comments">;-------------------------------------------------------------------------</span>
 if(NOT data_archive_defined(_dd.data_dap, _dd.dap_index)) then $
                                      dat_load_data, dd, sample=samples
 _dd = cor_dereference(dd)

 <span class="comments">;-------------------------------------------------------------------------</span>
 <span class="comments">; Compression</span>
 <span class="comments">;-------------------------------------------------------------------------</span>
 if(NOT keyword_set(_dd.compress)) then $
  begin
   data = data_archive_get(_dd.data_dap, _dd.dap_index, samples=samples)
   abscissa = data_archive_get(_dd.abscissa_dap, _dd.dap_index, samples=samples)
   if(keyword_set(data)) then sampled = 1
  end $
 else $
  begin
   data = data_archive_get(_dd.data_dap, _dd.dap_index)
   data = call_function('dat_uncompress_data_' + _dd.compress, _dd, data, abscissa=abscissa)
  end


 <span class="comments">;-------------------------------------------------------------------------</span>
 <span class="comments">; Sample if not already sampled</span>
 <span class="comments">;-------------------------------------------------------------------------</span>
 if(defined(samples)) then $
  begin
   if(NOT sampled) then $
    begin
     data = data[samples]
     if(keyword_set(abscissa)) then abscissa = abscissa[samples]
    end

   w = where(samples EQ -1)
   if(w[0] NE -1) then samples[w] = 0
  end


 <span class="comments">;-------------------------------------------------------------------------</span>
 <span class="comments">; If possible, reorganize to the proper dimensions.  This is not possible</span>
 <span class="comments">; if the data array is being subsampled.</span>
 <span class="comments">;-------------------------------------------------------------------------</span>
 if(full_array) then $
  begin
   data = reform(data, *_dd.dim_p, /over)
   if(keyword_set(abscissa)) then abscissa = reform(abscissa, *_dd.dim_p, /over)
  end


 <span class="comments">;-------------------------------------------------------------------------</span>
 <span class="comments">; compute data ranges -- not accurate if data array is being subsampled</span>
 <span class="comments">;-------------------------------------------------------------------------</span>
 max = max(data)
 min = min(data)

 if(max GT _dd.max) then _dd.max = max
 if(min LT _dd.min) then _dd.min = min

 cor_rereference, dd, _dd

 <span class="comments">;-------------------------------------------------------------------------</span>
 <span class="comments">; get abscissa</span>
 <span class="comments">;-------------------------------------------------------------------------</span>
 if(keyword_set(abscissa)) then _abscissa = abscissa $
 else $
  begin
   if(keyword_set(samples)) then _abscissa = samples $
   else _abscissa = lindgen(*_dd.dim_p)
  end

 return, data
end
<span class="comments">;===========================================================================</span>



</code>
    </div>
  </body>
</html>