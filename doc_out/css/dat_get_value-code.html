<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Thu Aug 18 11:37:49 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>dat_get_value.pro (OMINAS API Documentation)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="dat_get_value.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	dat_get_value</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Calls input translators, supplying the given keyword, and builds </span>
<span class="comments">;	a list of returned descriptors.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/SYS</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	xds = dat_get_value(dd, keyword)</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;  INPUT:</span>
<span class="comments">;	dd:		Data descriptors.  Must all have the same instrument </span>
<span class="comments">;			string.</span>
<span class="comments">;</span>
<span class="comments">;	keyword:	Keyword to pass to translators, describing the</span>
<span class="comments">;			requested quantity.</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;  INPUT: </span>
<span class="comments">;	trs:		Transient argument string.</span>
<span class="comments">;</span>
<span class="comments">;	tr_disable:	If set, dat_get_value returns without performing </span>
<span class="comments">;			any action.</span>
<span class="comments">;</span>
<span class="comments">;	tr_override:	Comma-delimited list of translators to use instead</span>
<span class="comments">;			of those stored in dd.</span>
<span class="comments">;</span>
<span class="comments">;	tr_first:	If set, dat_get_value returns after the first</span>
<span class="comments">;			successful translator.</span>
<span class="comments">;</span>
<span class="comments">;	tr_nosort:	By default, output descriptors are sorted to remove</span>
<span class="comments">;			those with duplicate names, retaining only the first</span>
<span class="comments">;			descriptor of a given name for each input data </span>
<span class="comments">;			descriptor.  /tr_nosort disables this action.</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: </span>
<span class="comments">;	status:		0 if at least one translator call was successful, </span>
<span class="comments">;			-1 otherwise.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; RETURN: </span>
<span class="comments">;	Array of descriptors returned from all successful translator calls.</span>
<span class="comments">;	Descriptors are returned in the same order that the corresponding </span>
<span class="comments">;	translators were called.  Each translator may produce multiple </span>
<span class="comments">;	descriptors.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; STATUS:</span>
<span class="comments">;	Complete</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale</span>
<span class="comments">; 	Adapted by:	Spitale, 5/2016</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>
<a id="dat_get_value:source"></a>function dat_get_value, dd, keyword, status=status, trs=trs, $
@nv_trs_keywords_include.pro
@nv_trs_keywords1_include.pro
                             end_keywords
@core.include

<span class="comments">; on_error, 1</span>
 _dd = cor_dereference(dd)
 ndd = n_elements(dd)

 status = -1
 xds = 0

 if(keyword_set(tr_disable)) then return, 0

 <span class="comments">;--------------------------------------------</span>
 <span class="comments">; record any transient keyvals</span>
 <span class="comments">;--------------------------------------------</span>
 _dd[0] = dat_add_transient_keyvals(_dd[0], trs)

 <span class="comments">;--------------------------------------------</span>
 <span class="comments">; build translators list</span>
 <span class="comments">;--------------------------------------------</span>
 if(NOT keyword_set(tr_override)) then $
  begin
   if(NOT ptr_valid(_dd[0].input_translators_p)) then $
    begin
     nv_message, /con, name='dat_get_value', $
	    'No input translator available for '+keyword+'.'
     return, 0
    end
   translators = *_dd[0].input_translators_p
  end $
 else translators = $
	   nv_match(*_dd[0].input_translators_p, str_nsplit(tr_override, ','))
 n = n_elements(translators)


 <span class="comments">;----------------------------------------------------------------</span>
 <span class="comments">; call all translators, building a list of returned values</span>
 <span class="comments">;----------------------------------------------------------------</span>
 n_total = 0
 nmax = 0
 chunk_n = 20

 for i=0, n-1 do $
  begin
   _dd.last_translator = [i,0]#make_array(ndd, val=1)
   cor_rereference, dd, _dd
   xd = call_function(translators[i], dd, keyword, values=xds, stat=stat, $
@nv_trs_keywords_include.pro
@nv_trs_keywords1_include.pro
		    end_keywords)

   <span class="comments">;--------------------------------------</span>
   <span class="comments">; add values to list</span>
   <span class="comments">;--------------------------------------</span>
   if(stat EQ 0) then $
    begin
     xds = append_array(xds, xd)
     if(keyword_set(tr_first)) then i=n
    end
  end
 nxds = n_elements(xds)

 <span class="comments">;----------------------------------------------------------------</span>
 <span class="comments">; sort xds</span>
 <span class="comments">;----------------------------------------------------------------</span>
 result = 0
 if(keyword_set(xds)) then begin
   status = 0
   if(NOT keyword_set(tr_nosort)) then begin
    for i=0, ndd-1 do begin
      w = where(cor_assoc_xd(xds) EQ dd[i])
      nw = n_elements(w)
      if(w[0] NE -1) then begin
        names = cor_name(xds[w])
        ss = sort(names)
        uu = uniq(names[ss])

        ii = lindgen(nxds)
        ii = ii[w[ss[uu]]]
        ii = ii[sort(ii)]

        result = append_array(result, xds[ii])
      endif
    endfor
   endif else result = xds
 endif

 return, result
end
<span class="comments">;===========================================================================</span>
</code>
    </div>
  </body>
</html>