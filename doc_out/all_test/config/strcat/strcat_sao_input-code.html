<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 11:10:22 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>strcat_sao_input.pro (OMINAS API Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="strcat_sao_input.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;===============================================================================</span>
<span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; Input translator for SAO star catalog.</span>
<span class="comments">;</span>
<span class="comments">; Usage</span>
<span class="comments">; =====</span>
<span class="comments">; This routine is called via `dat_get_value`, which is used to read the</span>
<span class="comments">; translator table. In particular, the specific translator for the scene</span>
<span class="comments">; to be processed should contain the following line::</span>
<span class="comments">;</span>
<span class="comments">;      -   strcat_sao_input     -       /j2000    # or /b1950 if desired</span>
<span class="comments">; </span>
<span class="comments">; For the star catalog translator system to work properly, only one type</span>
<span class="comments">; of catalog may be used at a time for a particular instrument.</span>
<span class="comments">;</span>
<span class="comments">;	The version of the SAO catalog which is expected by this translator is</span>
<span class="comments">; the 1984 binary catalog format used by NAV. The star catalog file,</span>
<span class="comments">; sao_idl.str, must be kept in the location of the path_sao variable,</span>
<span class="comments">; which uses the NV_SAO_DATA environment variable by default.</span>
<span class="comments">;	</span>
<span class="comments">; In the file, the data is grouped into 18 segments of 10 degrees each.</span>
<span class="comments">; Each star has a data record of 36 bytes.  RA (radians), RAMu (pm in </span>
<span class="comments">; sec time/year), DEC (radians), DECMu (pm in sec arc/year), Visual </span>
<span class="comments">; Magnitude, 13-byte Name and 3-byte Spectral type. The first 4 records</span>
<span class="comments">; of the output catalog are 18 sets of pointers to the records for the </span>
<span class="comments">; start and end of each segment. The real values (RA, RAMu, DEC, DECMu </span>
<span class="comments">; and Mag) are in XDR.  The pointer integers are in network byte order.</span>
<span class="comments">;</span>
<span class="comments">; The catalog uses the b1950 epoch, but all coordinates can be precessed</span>
<span class="comments">; to J2000 by using the /j2000 keyword.</span>
<span class="comments">;</span>
<span class="comments">; Restrictions</span>
<span class="comments">; ============</span>
<span class="comments">; Since the distance to stars are not given in the SAO catalog, the</span>
<span class="comments">; position vector magnitude is set as 10 parsec and the luminosity</span>
<span class="comments">; is calculated from the visual magnitude and the 10 parsec distance.</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;       Written by:     Vance Haemmerle,  5/1998</span>
<span class="comments">;</span>
<span class="comments">;	      Modified:                         1/1999</span>
<span class="comments">;</span>
<span class="comments">;       Modified:       Tiscareno,        7/2000</span>
<span class="comments">;</span>
<span class="comments">;       Modified:       Haemmerle,       12/2000</span>
<span class="comments">;</span>
<span class="comments">;       Modified:       Spitale,          9/2001</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;===============================================================================</span>

<span class="comments">;===============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; :Private:</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;-</span>
<span class="comments">;===============================================================================</span>
<a id="sao_get_regions:source"></a>function sao_get_regions, ra1, ra2, dec1, dec2, path_sao=path_sao
 return, file_test(path_sao + 'sao_idl.str') ? path_sao + 'sao_idl.str' : path_sao + 'sao.dat'	<span class="comments">; there's only one sao "region"</span>
end
<span class="comments">;===============================================================================</span>




<span class="comments">;===============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; :Private:</span>
<span class="comments">; :Hidden:</span>
<span class="comments">; Ingests a set of records from the SAO star catalog and generates star</span>
<span class="comments">; descriptors for each star within a specified scene.</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;   array of star descriptors</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;   dd : in, required, type="data descriptor"</span>
<span class="comments">;      data descriptor</span>
<span class="comments">;   filename : in, required, type=string</span>
<span class="comments">;      name of index file, or regions file</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;   cam_vel : in, optional, type=double</span>
<span class="comments">;      camera velocity from scene data, used to correct for stellar</span>
<span class="comments">;      aberration</span>
<span class="comments">;   b1950 : in, optional, type=string</span>
<span class="comments">;      if set, coordinates are output wrt b1950</span>
<span class="comments">;   ra1 : in, required, type=double</span>
<span class="comments">;      lower bound in right ascension of scene</span>
<span class="comments">;   ra2 : in, required, type=double</span>
<span class="comments">;      upper bound in right ascension of scene</span>
<span class="comments">;   dec1 : in, required, type=double</span>
<span class="comments">;      lower bound in declination of scene</span>
<span class="comments">;   dec2 : in, required, type=double</span>
<span class="comments">;      upper bound in declination of scene</span>
<span class="comments">;   faint : in, optional, type=double</span>
<span class="comments">;      stars with magnitudes fainter than this will not be returned</span>
<span class="comments">;   bright : in, optional, type=double</span>
<span class="comments">;      stars with magnitudes brighter than this will not be returned</span>
<span class="comments">;   nbright : in, optional, type=double</span>
<span class="comments">;      if set, selects only the n brightest stars</span>
<span class="comments">;   noaberr : in, optional, type=string</span>
<span class="comments">;      if set, stellar aberration will not be calculated</span>
<span class="comments">;   names : in, optional, type="string array"</span>
<span class="comments">;      if set, will return only the stars with the expected names</span>
<span class="comments">;   mag : out, required, type=double</span>
<span class="comments">;      magnitude of returned stars</span>
<span class="comments">;   jtime : in, optional, type=double</span>
<span class="comments">;      Years since 1950 (the epoch of catalog) for precession</span>
<span class="comments">;      and proper motion correction. If not given, it is taken</span>
<span class="comments">;      from the object descriptor bod_time, which is assumed to</span>
<span class="comments">;      be seconds past 2000, unless keyword /b1950 is set</span>
<span class="comments">;-</span>
<span class="comments">;===============================================================================</span>
<a id="sao_get_stars:source"></a>function sao_get_stars, filename, cam_vel=cam_vel, $
         b1950=b1950, ra1=ra1, ra2=ra2, dec1=dec1, dec2=dec2, $
         faint=faint, bright=bright, nbright=nbright, $
         noaberr=noaberr, names=names, mag=mag, jtime=jtime

 ra1 = ra1 * !dpi/180d
 ra2 = ra2 * !dpi/180d
 dec1 = dec1 * !dpi/180d
 dec2 = dec2 * !dpi/180d

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Open file</span>
 <span class="comments">;---------------------------------------------------------</span>
 openr, unit, filename, /get_lun
 record = assoc(unit,{sao_record})
 pointer = assoc(unit,lonarr(9))

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Get segment pointers</span>
 <span class="comments">;---------------------------------------------------------</span>
 ptr = lonarr(36)
 ptr=[pointer[0],pointer[1],pointer[2],pointer[3]]
 byteorder, ptr, /ntohl

<span class="comments">;print, ptr</span>

<span class="comments">; find segments</span>
 start_segment = 17 - fix((dec2*!RADEG+90.)/10)
 end_segment = 17 - fix((dec1*!RADEG+90.)/10)

<span class="comments">;print, 'Search segments from ',start_segment,' to ',end_segment</span>

 first_segment = 1
 for i = start_segment, end_segment DO $
  begin
   start_record = ptr(2*i)
   end_record = ptr(2*i+1)

<span class="comments">;print, 'Whole segment is ',start_record,' to ',end_record</span>

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Search within segment to find RA limits</span>
 <span class="comments">;---------------------------------------------------------</span>
<span class="comments">; *** need to use strcat_radec_regions (see strcat_tycho2_input) ***</span>
   if(end_record-start_record GT 100) then $
   begin
    ra_ptr = ptr(2*i) + lindgen(37)*((ptr(2*i+1)-ptr(2*i))/36)
    ra_ptr[36] = ptr(2*i+1)
    ra_test = fltarr(37)
    for j = 0, 36 do $
     begin
      _star = record[ra_ptr[j]]
      ra_test[j] = _star.RA
     end
    byteorder, ra_test, /XDRTOF

    index = where(ra_test LE ra1,count)
    start_record = ra_ptr[0]
    if(count NE 0) then start_record = ra_ptr[count-1]

    end_record = ra_ptr[36]
    index = where(ra_test GE ra2,count)
    if(count NE 0) then end_record = ra_ptr[37-count]
   end

<span class="comments">;print, 'Search records from ',start_record,' to ',end_record</span>

   _star = replicate({sao_record},end_record-start_record+1)
   for j = start_record, end_record do _star[j-start_record] = record[j]

<span class="comments">;print,'star contains',n_elements(_star),' stars'</span>

   _RA = _star[*].RA
   byteorder, _RA, /XDRTOF
   index = where(_RA LE ra2 AND _RA GE ra1, ra_count)
   if(ra_count NE 0) then _star = _star(index)

<span class="comments">;print, 'After RA test, star contains',n_elements(_star),' stars'</span>

   dec_count = 0
   if(ra_count NE 0) then $
    begin
     _DEC = _star[*].DEC
     byteorder, _DEC, /XDRTOF
     index = where(_DEC LE dec2 AND _DEC GE dec1, dec_count)
     if(dec_count NE 0) then _star = _star(index)
    end

<span class="comments">;print, 'After DEC test, star contains',n_elements(_star),' stars'</span>

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; select within magnitude limits</span>
 <span class="comments">;---------------------------------------------------------</span>
 if(keyword__set(faint)) then $
  begin
   status = -1
   _Mag = _star.mag
   byteorder, _Mag, /XDRTOF
   w = where(_Mag LE faint)
   if(w[0] NE -1) then star = _star[w]
   if(NOT keyword__set(star)) then return, ''
   _star = star
   status = 0
  end

 if(keyword__set(bright)) then $
  begin
   status = -1
   _Mag = _star.mag
   byteorder, _Mag, /XDRTOF
   w = where(_Mag GE bright)
   if(w[0] NE -1) then star1 = _star[w]
   if(NOT keyword__set(star1)) then return, ''
   _star = star1
   status = 0
  end


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Unpack the _star array</span>
 <span class="comments">;---------------------------------------------------------</span>
   if(dec_count NE 0) then $
    begin
     _RA = _star.RA
     _DEC = _star.DEC
     _DECpm = _star.DECpm
     _RApm = _star.RApm
     _Mag = _star.mag
     _Name = STRING(_star.Name)
     _Sp = STRING(_star.sp)
     byteorder, _RA, /XDRTOF
     byteorder, _DEC, /XDRTOF
     byteorder, _RApm, /XDRTOF
     byteorder, _DECpm, /XDRTOF
     byteorder, _Mag, /XDRTOF

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Apply proper motion to star (JTIME = years past 1950.0)</span>
 <span class="comments">;---------------------------------------------------------</span>
     _RA = _RA + (double(_RApm)*JTIME/240.D0)*!DTOR 
     _DEC = _DEC + (double(_DECpm)*JTIME/3600.D0)*!DTOR

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Correct for stellar aberration if camera velocity</span>
 <span class="comments">; is available</span>
 <span class="comments">;---------------------------------------------------------</span>
     if keyword__set(cam_vel) then $
      str_aberr_radec, _RA, _DEC, cam_vel, _RA, _DEC 
   end

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Print out data</span>
 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; print, _Name, _RA, _DEC, Mag, ' ',_Sp</span>
 <span class="comments">; if(n_elements(_Name) NE 0) then $</span>
 <span class="comments">;  print, _Name</span>

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Build arrays</span>
 <span class="comments">;---------------------------------------------------------</span>
    if(dec_count NE 0) then $
    begin
     if(first_segment EQ 1) then $
      begin
       first_segment = 0
       RA = _RA
       DEC = _DEC
       Mag = _Mag
       Name = _Name
       Sp = _Sp
      end $
     else $
      begin
       RA = [RA,_RA]
       DEC = [DEC,_DEC]
       Mag = [Mag,_Mag]
       Name = [Name,_Name]
       Sp = [Sp,_Sp]
      end
     end

   end <span class="comments">;segment end</span>

 Name = 'SAO ' + Name


 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Select named stars</span>
 <span class="comments">;---------------------------------------------------------</span>
 if(keyword__set(names)) then $
  begin
   status = -1
   w = where(names EQ Name)
   if(w[0] NE -1) then star = _star[w]
   if(NOT keyword__set(star)) then return, ''
   _star = star
   status = 0
  end

 close, unit
 free_lun, unit
 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Fill star descriptors</span>
 <span class="comments">;---------------------------------------------------------</span>

 n = n_elements(Name)

 print, 'Total of ',n,' stars'
 status = -1
 if(n EQ 0) then return, ''
 status = 0

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Calculate "dummy" properties</span>
 <span class="comments">;---------------------------------------------------------</span>

 orient = make_array(3,3,n)
 _orient = [ [1d,0d,0d], [0d,1d,0d], [0d,0d,1d] ]
 for j = 0 , n-1 do orient[*,*,j] = _orient
 avel = make_array(1,3,n,value=0d)
 vel = make_array(1,3,n,value=0d)
<span class="comments">; time = make_array(n,value=(bod_time(ods[0])))</span>
 time = make_array(n,value=0d)
 radii = make_array(3,n,value=1d)
 lora = make_array(n, value=0d)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Calculate position vector, use distance as 10 parsec </span>
 <span class="comments">; to have apparent magnitude = absolute magnitude</span>
 <span class="comments">;---------------------------------------------------------</span>

 dist = 3.085678d+17 <span class="comments">; 10pc in meters</span>
 pos = make_array(3,n,value=0d)
 pos[0,*] = cos(RA)*cos(DEC)*dist
 pos[1,*] = sin(RA)*cos(DEC)*dist
 pos[2,*] = sin(DEC)*dist

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Precess B1950 to J2000 if wanted</span>
 <span class="comments">;---------------------------------------------------------</span>

 if(keyword__set(j2000)) then pos = transpose(b1950_to_j2000(transpose(pos)))
 pos = reform(pos,1,3,n)

 <span class="comments">;---------------------------------------------------------</span>
 <span class="comments">; Calculate "luminosity" from visual Magnitude</span>
 <span class="comments">; Use Sun as model, though this is wrong for other stars</span>
 <span class="comments">; but since we don't know A (space absorption) and may</span>
 <span class="comments">; only sometimes know Spectral type... what the heck</span>
 <span class="comments">; use formula Mv = 4.83 - 2.5*log(L/Lsun) and since</span>
 <span class="comments">; distance is 10pc mv = Mv</span>
 <span class="comments">;---------------------------------------------------------</span>
 Lsun = const_get('Lsun')
 lum = Lsun * 10.d^( (4.83d0-double(Mag))/2.5d )

 _sd = str_create_descriptors( n, $
        gd=make_array(n, val=dd), $
        name=name, $
        orient=orient, $
        avel=avel, $
        pos=pos, $
        vel=vel, $
        time=time, $
        radii=radii, $
        lora=lora, $
        lum=lum, $
        sp=sp )

 return, _sd
end
<span class="comments">;===============================================================================</span>




<span class="comments">;===============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; :Private:</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;-</span>
<span class="comments">;===============================================================================</span>
<a id="strcat_sao_input:source"></a>function strcat_sao_input, dd, keyword, n_obj=n_obj, dim=dim, values=values, status=status, $
@nv_trs_keywords_include.pro
@nv_trs_keywords1_include.pro
	end_keywords

 return, strcat_input('sao', dd, keyword, n_obj=n_obj, dim=dim, values=values, status=status, $
@nv_trs_keywords_include.pro
@nv_trs_keywords1_include.pro
	end_keywords )

end
<span class="comments">;==========================================================================</span>
</code>
    </div>
  </body>
</html>