<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 11:10:06 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>readspreadsheet.pro (OMINAS API Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="readspreadsheet.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; $Id: readspreadsheet.pro,v 1.2 2007/04/27 16:31:45 santam Exp $</span>
<span class="comments">;</span>
<span class="comments">; Copyright (c) ESA/ESTEC/SCI-SB</span>
<span class="comments">;   Use as is</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;      READSPREADSHEET</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;      This function reads data in PDS Spreadsheet object.</span>
<span class="comments">;</span>
<span class="comments">;      This function is meant to be integrated into the READPDS package</span>
<span class="comments">;      from the PDS Small Bodies Node to add spreadsheet support.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;      Scientific Data Extraction Routines</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;      Result = READSPREADSHEET(filename, label, objindex [,SILENT] [,PRINT_TIME])</span>
<span class="comments">;</span>
<span class="comments">;      Note: this routine is intended to be called from the READPDS.PRO routine</span>
<span class="comments">;      (see examples below)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;      Filename: Scalar string containing the name of the PDS file to read.</span>
<span class="comments">;      Label: String array containing the spreadsheet label information.</span>
<span class="comments">;      Objindex: Integer specifying the starting index of the current object</span>
<span class="comments">;         in the label array to be read.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;      Result: Spreadsheet structure containing records for each field in the object,</span>
<span class="comments">;      along with a string array NAMES with the names of all the fields.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT:</span>
<span class="comments">;      SILENT: Suppresses any messages from the procedure.</span>
<span class="comments">;      PRINT_TIME: Prints processing times for each of the Fields</span>
<span class="comments">;</span>
<span class="comments">; EXTERNAL FUNCTIONS USED:</span>
<span class="comments">;      SBNIDL ReadPDS Package: OBJPDS, GET_INDEX, CLEAN, REMOVE, STR2NUM, PDSPAR, POINTPDS</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;      (1) Preprocess object definition parameters</span>
<span class="comments">;      (2) Create data structure to be read</span>
<span class="comments">;      (3) Read data structure from file using subroutine</span>
<span class="comments">;      (4) Re-organize data structures into arrays</span>
<span class="comments">;      (5) Return Data</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;      Fields with missing values (e.g. 2,1,,,4,5,,7,,,) are converted to ZERO</span>
<span class="comments">;      This should be corrected in a later version. Possible using NaN (!values.f_nan)</span>
<span class="comments">;</span>
<span class="comments">; TEST STATUS</span>
<span class="comments">;      This routine has been tested on SUN/SPARC/SOLARIS2.9 and WINDOWS XP with IDL6.1</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLES:</span>
<span class="comments">;      This routine is intended to be called from the READPDS.PRO routine</span>
<span class="comments">;      To read a PDS file TEST.LBL into an IDL spreadsheet structure, spr:</span>
<span class="comments">;        IDL> spr = READPDS ("TEST.LBL",/SILENT)</span>
<span class="comments">;        IDL> help, /STRUCTURE, spr</span>
<span class="comments">;               OBJECTS      INT       1</span>
<span class="comments">;               SPREADSHEET  STRUCT    -> &lt;Anonymous> Array[1]</span>
<span class="comments">;        IDL> help, /STRUCTURE, spr.(1)</span>
<span class="comments">;               NAMES           STRING    Array[8]</span>
<span class="comments">;               FIELD1           TYPE     Array[...]</span>
<span class="comments">;               FIELD2           TYPE     Array[...]</span>
<span class="comments">;                ...</span>
<span class="comments">;               FIELDN           TYPE     Array[...]</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written by: A.Cardesin (ESA/ESTEC), 2006Feb (based on TASCPDS by P.Khetarpal)</span>
<span class="comments">;-</span>

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; (1.3.1) obtain keyword from spreadsheet object</span>
<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: the KWname variable is a viable required keyword scalar string,</span>
<span class="comments">;     label is a viable PDS label string array, and start and end_ind are</span>
<span class="comments">;     viable integers pointing at the start and end of the current spreadsheet</span>
<span class="comments">;     object being processed. objname is the name of the current object</span>
<span class="comments">; postcondition: extracts the "KWname" keyword from the label, stores it in a</span>
<span class="comments">;     structure, and returns to the main block.</span>

<a id="obtain_Spreadsheet_keyword:source"></a>function obtain_Spreadsheet_keyword, KWname, label, start_ind, end_ind, objname
   <span class="comments">; initialize keyword structure:</span>
   struct = create_struct("flag",1)

   <span class="comments">; obtain keyword parameters:</span>
   val = pdspar (label, KWname, count=count, index=index)    <span class="comments">; external routine</span>

   <span class="comments">; if no viable params found, then issue error:</span>
   if (count eq 0) then begin
       print, "Error in object " + objname + $
       " : missing required " + KWname + " keyword(s) for SPREADSHEET object."
       goto, endfun
   endif

   <span class="comments">; extract the indices where keyword index is between start_ind and end_ind:</span>
   pos = where (index gt start_ind and index lt end_ind, cnt)

   <span class="comments">; if none found then return flag as -1:</span>
   if (cnt eq 0) then goto, endfun

   <span class="comments">; store the viable values, indices, and count for "name" keyword:</span>
   val = val[pos]
   index = index[pos]
   count = n_elements(val)

   <span class="comments">; place the stored params in the structure:</span>
   struct = create_struct(struct,"val",val,"count",count,"index",index)
   return, struct

   endfun:
      struct.flag = -1
      return, struct
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; (1.3.2) remove SpreadSheet name from name structure if present</span>
<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: name is a structure containing all names param for current</span>
<span class="comments">;     Spreadsheet object, label is a viable PDS label string array, and start_ind</span>
<span class="comments">;     and end_ind are integer pointers to start and end of current object.</span>
<span class="comments">; postcondition: the SpreadSheet name is searched through all the name values and</span>
<span class="comments">;     then removed from the structure, the count is decremented by one, and</span>
<span class="comments">;     the index value is also removed from the corresponding structure field.</span>
<span class="comments">;</span>

<a id="remove_SpreadSheet_name:source"></a>function remove_SpreadSheet_name, name, label, start_ind, end_ind
    <span class="comments">; first obtain COLUMN object indices for current SpreadSheet object:</span>
    field = objpds(label, "FIELD")                      <span class="comments">; external routine</span>
    pos = where (field.index gt start_ind and field.index lt end_ind)
    field.index = field.index[pos]

    <span class="comments">; check to see if the first name index is less than the first field</span>
    <span class="comments">; index value. If found then there exists a spreadsheet name, and is removed:</span>
    if (name.index[0] lt field.index[0]) then begin
        name.val = name.val[1:name.count - 1]
        name.index = name.index[1:name.count - 1]
        name.count = name.count - 1
    endif

    <span class="comments">; clean up name array values, and removed unwanted characters:</span>
    param = ['"', "'", "(", ")"]
    for j = 0, name.count-1 do begin
        name.val[j] = clean (name.val[j])                 <span class="comments">; external routine</span>
        name.val[j] = remove (name.val[j], param)         <span class="comments">; external routine</span>
    endfor

    return, name
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; (1.3.3) obtain data architecture and clean data type</span>
<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: data_type is a structure containing the required keyword</span>
<span class="comments">;     params for DATA_TYPE keyword.</span>
<span class="comments">; postcondition: the data type keyword values are cleaned, and the values after</span>
<span class="comments">;     the first '_' character are extracted, if present.</span>
<span class="comments">;</span>

<a id="clean_SpreadSheet_data_type:source"></a>function clean_SpreadSheet_data_type, data_type
    <span class="comments">; set the param variable:</span>
    param = ['"', "'", ")", "("]

    <span class="comments">; start the loop to go through each data_type value array:</span>
    for j = 0, data_type.count - 1 do begin
        <span class="comments">; first clean data_type:</span>
        data_type.val[j] = clean (data_type.val[j], /space)  <span class="comments">; external routine</span>
        data_type.val[j] = remove (data_type.val[j], param)  <span class="comments">; external routine</span>

        <span class="comments">; extract the second component of value if '_' present:</span>
        temp = strsplit(data_type.val[j], '_', /extract)

        if (n_elements(temp) eq 3) then begin
            data_type.val[j] = temp[1] + '_' + temp[2]
        endif else if (n_elements(temp) gt 1) then begin
            data_type.val[j] = temp[1]
        endif
    endfor

    return, data_type
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; (1.3) Obtain required keywords for the current object</span>
<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: label is a viable PDS label string array, and start_ind and</span>
<span class="comments">;     end_ind are valid integers specifying the start and end of the</span>
<span class="comments">;     current spreadsheet object as index pointers in the string array.</span>
<span class="comments">;     objname is the name of the current object</span>
<span class="comments">; postcondition: extracts required keywords for spreadsheet object in the label.</span>
<span class="comments">; procedure:</span>
<span class="comments">;     (1.3.1) obtain spreadsheet object definitions for current object</span>
<span class="comments">;     (1.3.2) remove SpreadSheet name from name structure if present</span>
<span class="comments">;     (1.3.3) obtain data architecture and clean data type</span>
<span class="comments">;     (1.3.4) return structure with the keywords and their values</span>


<a id="obtain_SpreadSheet_req:source"></a>function obtain_SpreadSheet_req, label, start_ind, end_ind, objname
    <span class="comments">; initialize keyword structure:</span>
    keywds = create_struct("flag",1)

    <span class="comments">; (1.3.1) obtain spreadsheet object definitions for current object:</span>
    <span class="comments">; extract the keyword structure from subroutine, and check whether</span>
    <span class="comments">; there are any params for the keyword, if not then return to main block</span>
    <span class="comments">; else store the value</span>

    <span class="comments">; first obtain number of FIELDS:</span>
    fields_num = obtain_spreadsheet_keyword("FIELDS", label, start_ind, end_ind, objname)
    if (fields_num.flag eq -1) then goto, endfun
    fields = fix(fields_num.val[0])

    <span class="comments">; obtain ROW_BYTES keyword:</span>
    row_bytes = obtain_spreadsheet_keyword("ROW_BYTES",label, start_ind, end_ind, objname)
    if (row_bytes.flag eq -1) then goto, endfun
    row_bytes = long(row_bytes.val[0])

    <span class="comments">; obtain ROWS keyword:</span>
    rows = obtain_spreadsheet_keyword("ROWS", label, start_ind, end_ind, objname)
    if (rows.flag eq -1) then goto, endfun
    rows = long(rows.val[0])

    <span class="comments">; obtain FIELD_DELIMITER keyword:</span>
    field_delimiter = obtain_spreadsheet_keyword("FIELD_DELIMITER", label, start_ind, $
                                                                    end_ind, objname)
    if (field_delimiter.flag eq -1) then goto, endfun
    if n_elements(field_delimiter.val) EQ 1 then $
     field_delimiter = strtrim(field_delimiter.val[0],2) $
    else begin
     print, "Error in object "+ objname +": FIELD_DELIMITER is not well defined."
     goto, endfun
    endelse

    <span class="comments">; check whether either fields, rows or row_bytes equal 0:</span>
    if (fields * rows * row_bytes le 0) then begin
        print, "Error in object "+ objname +": ROWS or ROW_BYTES or FIELDS &lt;= 0."
        goto, endfun
    endif

    <span class="comments">; obtain information for each FIELD object:</span>

    <span class="comments">; obtain NAME keyword:</span>
    name = obtain_spreadsheet_keyword("NAME", label, start_ind, end_ind, objname)
    if (name.flag eq -1) then goto, endfun

    <span class="comments">; obtain DATA_TYPE keyword, then clean, separate, and extract it:</span>
    data_type = obtain_spreadsheet_keyword("DATA_TYPE", label, start_ind, end_ind, objname)
    if (data_type.flag eq -1) then goto, endfun

    <span class="comments">; obtain BYTES keyword:</span>
    bytes = obtain_spreadsheet_keyword ("BYTES", label, start_ind, end_ind, objname)
    if (bytes.flag eq -1) then goto, endfun
    <span class="comments">;check that bytes is positive</span>
    void = where (bytes.val le 0, count)
    if (count gt 0) then begin
        print, "Error in object "+ objname +": BYTES &lt;= 0."
        goto, endfun
    endif

    <span class="comments">;</span>
    <span class="comments">; (1.3.2) remove SpreadSheet name from name structure if present:</span>
    <span class="comments">;</span>
    name = remove_SpreadSheet_name(name, label, start_ind, end_ind)

    <span class="comments">;</span>
    <span class="comments">; (1.3.3) obtain data architecture and clean data type:</span>
    <span class="comments">;</span>
    data_type = clean_SpreadSheet_data_type(data_type)

    <span class="comments">;</span>
    <span class="comments">; (1.3.4) return structure with the keywords and their values</span>
    <span class="comments">;</span>
    keywds = create_struct(keywds, "fields",fields,"row_bytes",row_bytes, $
                           "rows",rows,"field_delimiter",field_delimiter, $
                           "name",name,"data_type",data_type,"bytes",bytes)
    return, keywds

    endfun:
       keywds.flag = -1
       return, keywds
end


<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; (1.4) Obtain items keywords for the field objects using subroutine</span>
<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: label is viable PDS label string array, req_keywds is a</span>
<span class="comments">;     structure containing required spread object keywords, and start and</span>
<span class="comments">;     end_ind are viable integer pointers to start and end of the current</span>
<span class="comments">;     spreadsheet object. objname is the name of the current object read</span>
<span class="comments">; postcondition: Extracts spreadsheet items keyword params from label and returns</span>
<span class="comments">;     to main block as a structure.</span>
<span class="comments">;     flag=-1: no items found   flag2=-1: items found, ITEM_BYTES missing or erroneous</span>
<span class="comments">; procedure:</span>
<span class="comments">;     (1.4.1) obtain necessary ITEM keyword values</span>
<span class="comments">;     (1.4.2) extract values of items between start_ind and end_ind, and store</span>
<span class="comments">;     (1.4.3) obtain ITEM_BYTES keyword values</span>
<span class="comments">;     (1.4.4) Return structure with the keywords</span>

<a id="obtain_spreadsheet_items:source"></a>function obtain_spreadsheet_items, label, req_keywds, start_ind, end_ind, objname
    <span class="comments">; initialize items keyword structure:</span>
    keywds = create_struct("flag", 1, "flag2", 1)

    <span class="comments">;</span>
    <span class="comments">; (1.4.1) obtain necessary ITEM keyword values:</span>
    <span class="comments">;</span>
    items = pdspar (label, "ITEMS", count=items_count, index=items_index)
    if (items_count eq 0) then begin
        goto, endfun
    endif

    <span class="comments">;</span>
    <span class="comments">; (1.4.2) extract values of items between start_ind and end_ind, and store:</span>
    <span class="comments">;</span>
    pos = where (items_index gt start_ind and items_index lt end_ind, cnt)
    if (cnt eq 0) then goto, endfun
    if (items[pos] le 0) then begin
        print, "Error in object "+ objname +": ITEMS cannot be &lt;= 0."
        keywds.flag2 = -1
        goto, endfun
    endif

    items = create_struct("val",items[pos],"count",n_elements(items), $
                          "index",items_index[pos])

    <span class="comments">; now we know that there are fields with ITEMS keyword in current</span>
    <span class="comments">; spreadsheet object, so extract the other item keyword values:</span>

    <span class="comments">;</span>
    <span class="comments">; (1.4.3) obtain ITEM_BYTES keyword values:</span>
    <span class="comments">;</span>
    bytes = pdspar (label, "ITEM_BYTES", count=byte_count, index=byte_index)
    if (byte_count eq 0) then begin
        print, "Error in object "+ objname +": missing required ITEM_BYTES keyword."
        keywds.flag2 = -1
        goto, endfun
    endif
    pos = where (byte_index gt start_ind and byte_index lt end_ind, cnt)
    if (cnt eq 0) then begin
        print, "Error in object "+ objname +": missing required ITEM_BYTES keyword."
        keywds.flag2 = -1
        goto, endfun
    endif
    if (bytes[pos] le 0) then begin
        print, "Error in object "+ objname +": ITEM_BYTES cannot be &lt;= 0."
        keywds.flag2 = -1
        goto, endfun
    endif

    bytes = create_struct("val", bytes[pos], "count", n_elements(bytes), $
                          "index", byte_index[pos])

    <span class="comments">;</span>
    <span class="comments">; (1.4.4) Return structure with the keywords</span>
    <span class="comments">;</span>

    <span class="comments">; store info into a structure:</span>
    keywds = create_struct(keywds, "items",items, "bytes",bytes)
    return, keywds

    endfun:
        keywds.flag = -1
        return, keywds
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; (2.1.2) process item objects for current FIELD object</span>
<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: keywds contains all required keyword values in a structure,</span>
<span class="comments">;     items contains all item keyword values, curr_ind and next_ind are</span>
<span class="comments">;     integer pointers to current and next field object being processed, and</span>
<span class="comments">; postcondition: the routine tests whether there are any items defined for</span>
<span class="comments">;     current field object, and if found, then populates the necessary</span>
<span class="comments">;     item structure for current field object and returns to main block.</span>
<span class="comments">;     If no items are found, returns a single element null string''.</span>
<span class="comments">; procedure:</span>
<span class="comments">;   (2.1.2.1) determine whether there exist ITEMS for current FIELD:</span>
<span class="comments">;   (2.1.2.2) if items not present then create a one-element field (null string)</span>
<span class="comments">;   (2.1.2.3) if items are present, check keywords and create a field with n elements</span>
<span class="comments">;   (2.1.2.4) return data into field object structure</span>
<span class="comments">;</span>

<a id="process_field_items:source"></a>function process_field_items, keywds, items, curr_ind, next_ind, objname

    object_struct = create_struct("flag", 1)      <span class="comments">; structure to be returned</span>

    <span class="comments">;</span>
    <span class="comments">; (2.1.2.1) determine whether there exist ITEMS for current FIELD:</span>
	<span class="comments">;</span>
    if (items.flag eq -1) then begin
        ipos = -1
    endif else begin
        ipos = where (items.items.index gt curr_ind and items.items.index lt $
                  next_ind)
    endelse

    <span class="comments">;</span>
    <span class="comments">; (2.1.2.2) if items not present then create a one-element field (null string)</span>
    <span class="comments">;</span>
    if (ipos[0] eq -1) then begin

        field = ''

    endif else begin
    <span class="comments">;</span>
    <span class="comments">; (2.1.2.3) if items are present, check keywords and create a field with num_items elements</span>
    <span class="comments">;</span>
    num_items  = long(items.items.val[ipos[0]])
    if num_items lt 1 then begin
        print, "Error in object "+objname+": keyword ITEMS must be greater that 0"
        goto, endfun
    endif

    item_bytes = long(items.bytes.val[ipos[0]])
    if item_bytes lt 1 then begin
        print, "Error in object "+objname+": keyword ITEM_BYTES must be greater that 0"
        goto, endfun
    endif

    <span class="comments">; Create a field with num_items elements</span>
    field = strarr(num_items)

    endelse

    <span class="comments">;</span>
    <span class="comments">; (2.1.2.4) return data into field object structure:</span>
    <span class="comments">;</span>
    object_struct = create_struct(object_struct, "data",field)
    return, object_struct

    endfun:
        object_struct.flag = -1
        return, object_struct
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; (2.1.3) Create field structure with the correct data type</span>
<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: element is a n dimensional string array</span>
<span class="comments">; postcondition: element is converted into an n dimensional array of type</span>
<span class="comments">;     "type", and returned to main block.</span>
<span class="comments">;</span>

<a id="convert_spreadsheet_element:source"></a>function convert_spreadsheet_element, element, type
    <span class="comments">; error protection:</span>
    on_ioerror, error_case

    <span class="comments">; depending on the case of the type assign each element to its own</span>
    <span class="comments">; element conversion type:</span>
    data = create_struct("flag",1)
    stat = size(element)

    case type of
               "CHARACTER": break <span class="comments">; it is already a string</span>
                    "TIME": break <span class="comments">; it is already a string</span>
                    "DATE": break <span class="comments">; it is already a string</span>
                    "REAL": element = double(element)
                 "INTEGER": element = long(element)
        "UNSIGNED_INTEGER": element = long(element)
                   "FLOAT": element = float(element)
                  "DOUBLE": element = double(element)
                    "BYTE": element = byte(long(element))
                 "BOOLEAN": element = long(element)
                     "N/A": <span class="comments">; no conversion performed, spare column</span>
                      else: begin
                                print, "Error: " + type + $
                                       " is not a recognized data type!"
                                data.flag = -1
                                return, data
                            end
    endcase

    data = create_struct(data, "element",element)
    return, data

    error_case:
        on_ioerror, null
        print, "WARNING: bad DATA_TYPE definition. Data will be treated as string"
        data = create_struct(data, "element", element)
        return, data
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; (2) Create data structure to be read:</span>
<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: keywds contains required keywords for current spreadsheet object,</span>
<span class="comments">;     label is a viable PDS label string array, start_ind and end_ind are integer</span>
<span class="comments">;     pointers to start and end of current spreadsheet object, objname is the name</span>
<span class="comments">;     of the current object</span>
<span class="comments">; postcondition: creates a structure to be read from the data file and returns</span>
<span class="comments">;     to the main block.</span>
<span class="comments">; procedure:</span>
<span class="comments">;   (2.1) LOOP: for each FIELD object</span>
<span class="comments">;    (2.1.1) Set current and next FIELD object index pointers</span>
<span class="comments">;    (2.1.2) process item objects for current FIELD object</span>
<span class="comments">;    (2.1.3) Create field structure with the correct data type</span>
<span class="comments">;    (2.1.4) Add to current row structure</span>
<span class="comments">;   (2.2) Return the complete data structure, replicating row_struct ROWS times</span>
<span class="comments">;</span>

<a id="create_spreadsheet_struct:source"></a>function create_spreadsheet_struct, keywds, items, label, start_ind, end_ind, objname
    <span class="comments">; initialize variables:</span>
    complete_set = create_struct("flag", 1)      <span class="comments">; structure to be returned</span>
    row_struct = 0          <span class="comments">; structure of a row of data</span>

    <span class="comments">;</span>
    <span class="comments">; (2.1) LOOP: for each FIELD object</span>
    <span class="comments">;</span>
    for j = 0, keywds.fields - 1 do begin

        <span class="comments">;</span>
        <span class="comments">; (2.1.1) Set current and next FIELD object index pointers:</span>
        <span class="comments">;</span>
        curr_ind = keywds.name.index[j]
        if (j eq keywds.fields - 1) then begin
            next_ind = end_ind
        endif else begin
            next_ind = keywds.name.index[j+1]
        endelse

        <span class="comments">; name of current field: FIELDi</span>
        name = "FIELD" + clean(string(j+1),/space)     <span class="comments">; external routine</span>

    	<span class="comments">;</span>
        <span class="comments">; (2.1.2) process items for current FIELD object:</span>
        <span class="comments">;</span>
        element = process_field_items (keywds, items, curr_ind,next_ind,objname)
        if element.flag eq -1 then goto, endfun

        <span class="comments">;</span>
        <span class="comments">; (2.1.3) Create field structure with the correct data type</span>
        <span class="comments">;</span>

        <span class="comments">;type of current field</span>
        type = keywds.data_type.val[j]

        <span class="comments">;convert current field to the specified type</span>
        temp_field = convert_spreadsheet_element(element.data, type)  <span class="comments">; subroutine</span>
        <span class="comments">; if conversion not successful then return to main block with flag:</span>
        if (temp_field.flag eq -1) then begin
           print, "Error converting data in field ", strtrim(j+1,2)
           goto, endfun
        endif

	<span class="comments">; create field structure</span>
        field_struct = create_struct ("element", temp_field.element)

        <span class="comments">;</span>
        <span class="comments">; (2.1.4) Add to current row structure</span>
        <span class="comments">;</span>
        if (size(row_struct,/TNAME) eq 'STRUCT') then begin
            row_struct = create_struct(row_struct, name, field_struct)
        endif else begin
            row_struct = create_struct(name, field_struct)
        endelse
    endfor

    <span class="comments">;</span>
    <span class="comments">; (2.2) Return the complete data structure, replicating row_struct ROWS times</span>
    <span class="comments">;</span>
    complete_set = create_struct (complete_set, "data_set", replicate (row_struct, keywds.rows))

    return, complete_set

    endfun:
        complete_set.flag = -1
        return, complete_set
end

<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; (3) Read spreadsheet data structure from file</span>
<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: pointer is a structure containing viable pointer information</span>
<span class="comments">;     for current spreadsheet object, data_struct contains the data structure to</span>
<span class="comments">;     be read from file, keywds contains all the required keyword info, and</span>
<span class="comments">;     silent is set to either 0 or 1 depending on the function specification.</span>
<span class="comments">; postcondition: this subroutine reads the data from the pointer datafile</span>
<span class="comments">;     and returns the data structure.</span>
<span class="comments">; procedure:</span>
<span class="comments">;   (3.1) construct data_set structure</span>
<span class="comments">;   (3.2) open file and read data after setting the file pointer to skip</span>
<span class="comments">;   (3.3) Find field separator (as defined in the keyword FIELD_DELIMITER)</span>
<span class="comments">;   (3.4) LOOP: read each line, separate fields and put them into the structure</span>
<span class="comments">;   (3.5) Close and return structure</span>

<a id="read_spreadsheet_data:source"></a>function read_spreadsheet_data, pointer, data_struct, keywds, silent
    <span class="comments">; error protection:</span>
    on_ioerror, signal

    <span class="comments">;</span>
    <span class="comments">; (3.1) construct data_set structure:</span>
    <span class="comments">;</span>
    data_set = create_struct("flag", 1)

    <span class="comments">; first inform user of status:</span>
    if (silent eq 0) then begin
        text = clean(string(keywds.fields), /space) + " Fields and " + $
               clean(string(keywds.rows), /space) + " Rows" <span class="comments">; external routine</span>
        print, "Now reading Spreadsheet with " + text
    endif

    <span class="comments">;</span>
    <span class="comments">; (3.2) open file and read data after setting the file pointer to skip:</span>
    <span class="comments">;</span>
    openr, unit, pointer.datafile, /get_lun
    point_lun, unit, pointer.skip

    <span class="comments">;</span>
    <span class="comments">; (3.3) Find field separator (as defined in the keyword FIELD_DELIMITER)</span>
    <span class="comments">;</span>
    case strjoin(strsplit(keywds.field_delimiter,'"',/EXTRACT)) of

       "COMMA"       : separator = ','
       "SEMICOLON"   : separator = ';'
       "VERTICAL_BAR": separator = '|'
       "TAB"         : separator = string(BYTE(9)) <span class="comments">;TAB character (ascii 9)</span>
       else: begin
               print, "Error in spreadsheet object definition: " + $
                      "Field separator: " + keywds.field_delimiter + " is not valid."
               goto, signal
               end
    endcase


    <span class="comments">;</span>
    <span class="comments">; (3.4) LOOP: read each line, separate fields and put them into the structure</span>
    <span class="comments">;</span>

    textline = ''

    <span class="comments">; Instead of reading the whole structure at once,</span>
    <span class="comments">; I will read line by line and fill the structure myself</span>
    for i=0L,long(keywds.rows)-1 do begin

        readf, unit, textline

        <span class="comments">; separate fields</span>
        asciifields = strsplit(textline, separator, /EXTRACT, $
                              COUNT=count, /PRESERVE_NULL )

        <span class="comments">; I treat missing values as ZERO.</span>
        <span class="comments">; This should be corrected in the future to use NaN</span>
        indx = where(asciifields EQ '', count)
        if count gt 0 then $
            asciifields[indx] = '0'

        <span class="comments">; read each line into the data_struct</span>
        <span class="comments">; I use tempstruct as I cannot index a structure while reading</span>
        tempstruct = data_struct[i]
        reads, asciifields, tempstruct
        data_struct[i] = tempstruct

    endfor   <span class="comments">; ENDLOOP</span>

    <span class="comments">;</span>
    <span class="comments">; (3.5) Close and return structure</span>
    <span class="comments">;</span>
    close, unit
    free_lun, unit
    data_set = create_struct(data_set, "data", data_struct)

    return, data_set

    signal:
        on_ioerror, null
        print, "Error: Bad Fields/Items Definition or bad data. Cannot read."
        data_set.flag = -1
        return, data_set
end


<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; (4) Re-organize data structures into arrays</span>
<span class="comments">;-----------------------------------------------------------------------------</span>
<span class="comments">; precondition: keywds contains the required keyword params, data contains</span>
<span class="comments">;     the data as read from the file in a structure format, print_time is a flag</span>
<span class="comments">; poscondition: the data structure is parsed and all the field data is</span>
<span class="comments">;     extracted, organized into arrays, and returned as a structure.</span>
<span class="comments">;     If print_time is active the time consumed in each loop is printed</span>
<span class="comments">; procedure:</span>
<span class="comments">;   (4.1) initialize data structures: flag, names and rows</span>
<span class="comments">;   (4.2) LOOP: go through each field and re-organise data structures into arrays</span>
<span class="comments">;   (4.3) Create structure and return</span>

<a id="organize_spreadsheet_data:source"></a>function organize_spreadsheet_data, keywds, data, print_time

    <span class="comments">; Init time to print if PRINT_TIME mode is active</span>
    startTime = systime(1)

    <span class="comments">;</span>
    <span class="comments">; (4.1) initialize data structures: flag, names and rows</span>
    <span class="comments">;</span>
    data_set = create_struct("flag", 1)
    name_val = keywds.name.val[0:keywds.name.count-1]
    data_struct = create_struct("names", name_val)
    rows = keywds.rows

    <span class="comments">;</span>
    <span class="comments">; (4.2) LOOP: go through each field and re-organise data structures into arrays:</span>
    <span class="comments">;</span>
    for i = 0, keywds.fields - 1 do begin

        <span class="comments">; set the field title</span>
        title = "field" + clean(i + 1,/space)

	<span class="comments">; check if a field has items or not</span>
        if (size(data.(0), /tname) eq 'STRUCT') then begin
            data_struct = create_struct(data_struct, title, data.(i).element)
        endif else begin
            data_struct = create_struct(data_struct, title, data.(i+1).element)
        endelse

  	<span class="comments">; print time if PRINT_TIME mode is active</span>
    	if PRINT_TIME then begin
            iTime=sysTime(1)
            print, "Field ", strtrim(string(i+1),2),$
                   " converted in ", iTime - startTime," seconds."
            startTime = iTime
            empty
        endif

    endfor     <span class="comments">; ENDLOOP</span>

    <span class="comments">;</span>
    <span class="comments">; (4.3) Create structure and return</span>
    <span class="comments">;</span>
    data_set = create_struct(data_set, "data", data_struct)

    return, data_set

    endfun:
       data_set.flag = -1
       return, data_set
end


<span class="comments">;==========================================================================</span>
<span class="comments">; MAIN FUNCTION</span>
<span class="comments">;==========================================================================</span>
<span class="comments">;(1) Preprocess object definition parameters</span>
<span class="comments">;   (1.1) obtain viable objects for label</span>
<span class="comments">;   (1.2) Set start/end indices for all viable objects</span>
<span class="comments">;   (1.3) Obtain required keywords for the current object</span>
<span class="comments">;     (1.3.1) obtain spreadsheet object definitions for current object</span>
<span class="comments">;     (1.3.2) remove SpreadSheet name from name structure if present</span>
<span class="comments">;     (1.3.3) obtain data architecture and clean data type</span>
<span class="comments">;     (1.3.4) return structure with the keywords and their values</span>
<span class="comments">;   (1.4) Obtain items keywords for the field objects using subroutine</span>
<span class="comments">;     (1.4.1) obtain necessary ITEM keyword values</span>
<span class="comments">;     (1.4.2) extract values of items between start_ind and end_ind, and store</span>
<span class="comments">;     (1.4.3) obtain ITEM_BYTES keyword values</span>
<span class="comments">;     (1.4.4) Return structure with the keywords</span>
<span class="comments">;   (1.5) Obtain pointer information for spreadsheet object</span>
<span class="comments">;</span>
<span class="comments">;(2) Create data structure to be read</span>
<span class="comments">;   (2.1) LOOP: for each FIELD object</span>
<span class="comments">;     (2.1.1) Set current and next FIELD object index pointers</span>
<span class="comments">;     (2.1.2) process item objects for current FIELD object</span>
<span class="comments">;       (2.1.2.1) determine whether there exist ITEMS for current FIELD:</span>
<span class="comments">;       (2.1.2.2) if items not present then create a one-element field (null string)</span>
<span class="comments">;       (2.1.2.3) if items are present, check keywords and create a field with n elements</span>
<span class="comments">;       (2.1.2.4) return data into field object structure</span>
<span class="comments">;    (2.1.3) construct structure to be read</span>
<span class="comments">;   (2.2) replicate data structure ROWS times</span>
<span class="comments">;   (2.3) construct the complete data structure</span>
<span class="comments">;</span>
<span class="comments">;(3) Read data structure from file using subroutine</span>
<span class="comments">;   (3.1) construct data_set structure</span>
<span class="comments">;   (3.2) open file and read data after setting the file pointer to skip</span>
<span class="comments">;   (3.3) Find field separator (as defined in the keyword FIELD_DELIMITER)</span>
<span class="comments">;   (3.4) LOOP: read each line, separate fields and put them into the structure</span>
<span class="comments">;   (3.5) Close and return structure</span>
<span class="comments">;</span>
<span class="comments">;(4) Re-organize data structures into arrays</span>
<span class="comments">;   (4.1) initialize data structures: flag, names and rows</span>
<span class="comments">;   (4.2) LOOP: go through each field and re-organise data structures into arrays</span>
<span class="comments">;   (4.3) Create structure and return</span>
<span class="comments">;</span>
<span class="comments">;(5) Return Data</span>

FUNCTION READSPREADSHEET, filename, label, objindex, SILENT=silent, PRINT_TIME=print_time

    <span class="comments">; check for keywords</span>
    silent     = keyword_set(SILENT)
    print_time = keyword_set(PRINT_TIME)

    <span class="comments">; Init Time to print process timing in PRINT_TIME mode</span>
    initTime=systime(1)

    <span class="comments">; error protection:</span>
    <span class="comments">;on_error, 2</span>

    <span class="comments">; check for number of parameters in function call:</span>
    if (n_params() lt 3) then begin
        print, "Syntax: result = readspreadsheet (filename,label,objindex[,/SILENT])"
        return, -1
    endif

<span class="comments">;;</span>
<span class="comments">;; (1) Preprocess object definition parameters</span>
<span class="comments">;;</span>
    <span class="comments">;</span>
    <span class="comments">; (1.1) obtain viable objects for label:</span>
    <span class="comments">;</span>
    objects = objpds(label, "ALL")                         <span class="comments">; external routine</span>
    if (objects.flag eq -1) then begin
        print, "Error: No viable SPREADSHEET objects found in label."
        return, -1
    endif

    <span class="comments">;</span>
    <span class="comments">; (1.2) Set start/end indices for all viable objects</span>
    <span class="comments">;</span>

    <span class="comments">; match the indices of all viable objects against objindex:</span>
    objpos = where (objindex eq objects.index)

    <span class="comments">; if a match is found, then store the name of that object, else</span>
    <span class="comments">; indicate the specification of invalid objindex:</span>
    if (objpos[0] ne -1) then begin
        objects.array = objects.array[objpos[0]]
        objectname = objects.array[0]
    endif else begin
        print, "Error: Invalid objindex specified: " + $
             clean(string(objects.index[objpos[0]]), /space)
        return, -1
    endelse

    <span class="comments">; set start and end object pointers for current spreadsheet object:</span>
    start_ind = objindex
    end_ind = get_index(label, start_ind)                  <span class="comments">; external routine</span>
    if (end_ind eq -1) then return, -1

    <span class="comments">;</span>
    <span class="comments">; (1.3) Obtain required keywords for the current object:</span>
    <span class="comments">;</span>
    req_keywds = obtain_spreadsheet_req(label, start_ind, end_ind, objectname) <span class="comments">; subroutine</span>
    if (req_keywds.flag eq -1) then return, -1

    <span class="comments">;</span>
    <span class="comments">; (1.4) Obtain items keywords for the field objects using subroutine:</span>
    <span class="comments">;</span>
    items = obtain_spreadsheet_items(label, req_keywds, $      <span class="comments">; subroutine</span>
    				     start_ind, end_ind, objectname)
    if (items.flag2 eq -1) then return, -1

    <span class="comments">;</span>
    <span class="comments">; (1.5) Obtain pointer information for spreadsheet object:</span>
    <span class="comments">;</span>
    pointer = pointpds (label, filename, objectname)          <span class="comments">; external routine</span>
    if (pointer.flag EQ -1) then return, -1

<span class="comments">;;</span>
<span class="comments">;; (2) Create data structure to be read:</span>
<span class="comments">;;</span>
    complete_set = create_spreadsheet_struct (req_keywds, items, $ <span class="comments">; subroutine</span>
                                        label, start_ind, end_ind, objectname)
    if (complete_set.flag eq -1) then begin
        return, -1
    endif else begin
        data_struct = complete_set.data_set
    endelse

    <span class="comments">; print time if PRINT_TIME mode is active</span>
    IF PRINT_TIME THEN BEGIN
    	preprocessTime=systime(1)
	print, "Preprocessing time :", preprocessTime-initTime, " seconds"
	empty
    ENDIF

<span class="comments">;;</span>
<span class="comments">;; (3) Read data structure from file using subroutine:</span>
<span class="comments">;;</span>
    data_set = read_spreadsheet_data (pointer, data_struct, req_keywds, silent)
    if (data_set.flag eq -1) then return, -1

    data = data_set.data

    <span class="comments">; print time if PRINT_TIME mode is active</span>
    IF PRINT_TIME THEN BEGIN
	readTime=systime(1)
	print, "Reading time :", readTime-preprocessTime, " seconds"
	print, "Spreadsheet has been read."
	print, "Re-organising data structure..."
    ENDIF

<span class="comments">;;</span>
<span class="comments">;; (4) Re-organize data inside the structure</span>
<span class="comments">;;</span>
    data_set = organize_spreadsheet_data (req_keywds, data, print_time)          <span class="comments">; subroutine</span>
    if (data_set.flag eq 1) then begin
        data = data_set.data
    endif else begin
        return, -1
    endelse

    <span class="comments">; print time if PRINT_TIME mode is active</span>
    IF PRINT_TIME THEN BEGIN
	convertTime=systime(1)
	print, "Re-organization time :", convertTime-readTime, " seconds"
	print, "Total time :", convertTime-initTime, " seconds"
    ENDIF

<span class="comments">;;</span>
<span class="comments">;; (5) Return Data</span>
<span class="comments">;;</span>
    return, data
END
</code>
    </div>
  </body>
</html>