<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Thu Oct 13 10:41:45 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>jupiter_example.pro (OMINAS API Documentation)</title>

    

    <script type="text/javascript" src="idldoc-resources/js/jquery.js"></script>
    <script type="text/javascript" src="idldoc-resources/js/copybutton.js"></script>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="jupiter_example.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">

    <div class="header">
      <h1>OMINAS API Documentation</h1>
      <h2>Generated by IDLdoc</h2>
    </div>
    
    
    <table class="navbar smaller" summary="Navigation header" cellspacing="0">
      <tr>
        <td >
          <a href="overview.html">Overview</a>
        </td>
    
        <td >
          Directory
        </td>
    
        <td class="selected">File</td>
    
        
        <td >
          <a href="jupiter_example-code.html" title="Chromocoded source">Source</a> <a href="jupiter_example.pro" title=".pro file"><img src="idldoc-resources/attach.png" alt="[attach.png]" align="top"/></a>
        </td>
        
    
        <td >Etc</td>
    
        <td >
          <a href="categories.html">Categories</a>
        </td>
    
        <td >
          <a href="search.html">Search</a>
        </td>
    
        
        <td >
          <a href="idldoc-index.html">Index</a>
        </td>
        
    
        
        <td >
          <a href="idldoc-warnings.html">Warnings</a>
        </td>
        
    
        <td >
          <a href="idldoc-help.html">Help</a>
        </td>
    
        <td class="flexible">
          Developer documentation
        </td>
      </tr>
    </table>
    
    
    
    <p class="localnavbar smallest"><a href="" target="_top">single page</a> | <a href="index.html" target="_top">use frames</a> &nbsp;&nbsp;&nbsp; summary &nbsp;&nbsp;&nbsp; class &nbsp;&nbsp;&nbsp; fields &nbsp;&nbsp;&nbsp; <a href="#routine-details">routine details</a> &nbsp;&nbsp;&nbsp; <a href="#attributes">file attributes</a></p>
    
    
    
    
    
    
    
    
    

    <div class="content">
      <h2 class="directory">./</h2>
      <h1 class="basename">jupiter_example.pro<span class="file-attributes"></span></h1>
      

      <span class="file_attribute small">batch file</span>
      
      
      <br/>

      
      <div id="file_comments">
        <div class="small "><h2> JUPITER EXAMPLE</h2>

<p>   Edited by Mark Moretto
</p>

<p>   June 2016
</p>

<p>    This example file uses an image of Jupiter, its rings, and satellites to
    demonstrate various capabilities of the OMINAS software.  This includes
    fitting the limb and rings simultaneously, hiding the limb and/or rings wrt
    other objects in the field of view, plotting radial and longitudinal
    sectors on the ring and generating map projections.
</p>

<p>    This example file can be executed from the UNIX command line using:
<div><div><code class="listing"><span class="code-output">idl jupiter.example</span>
</code></div></div>    or from within IDL using:
<div><div><code class="listing"><span class="code-output">@jupiter.example</span>
</code></div></div>    After the example stops, later code samples in this file may be executed by
    pasting them onto the IDL command line.
</p>

<h2> Read and display image</h2>

<p> <img src="jupiter_load.jpeg"/>
</p>

<p>   This first section uses dat_read to read in the image and then displays
   the image using tvim.
</p>

<p>   dat_read reads the image portion (im) and the label (label) and returns a
   data descriptor (dd) containing the image and label and information obtained
   through OMINAS' configuration tables.  If a file exists in the same directory
   and with the same name as the image, except with the extension ".dh",
   then it is assumed to be a detached header and it is read as well.
</p>

<p>   The files w1352097259.1 and n1352037683.2 are Cassini wide- and narrow-
   angle frames of Jupiter.  2000r.img and 2100r.img are Galileo SSI
   images of Ganymede.
</p>

<p>   ctmod is called to reserve several colors in the case of an 8-bit display.
</p>

<p>   tvim is called to display the image (im) in a new window with the y
   coordinate as top-down:
<div><div><code class="listing"><span class="code-output"> file = 'data/N1350122987_2.IMG'</span>
<span class="code-output"> dd = dat_read(file, im, label, /silent)</span>
<span class="code-output"> ctmod, top=top</span>
<span class="code-output"> tvim, im, zoom=0.75, /order, /new, top=top</span>
</code></div></div></p>

<h2> Obtain descriptors</h2>

<p>   This section obtains the camera descriptor (cd), planet descriptors
   (pd), ring descriptors (rd), and the sun descriptor (sund) for
   use with subsequent commands:
<div><div><code class="listing"><span class="code-output"> cd = pg_get_cameras(dd)</span>
<span class="code-output"> pd = pg_get_planets(dd, od=cd)</span>
<span class="code-output"> rd = pg_get_rings(dd, pd=pd, od=cd)</span>
<span class="code-output"> sund = pg_get_stars(dd, od=cd, name='SUN')</span>
</code></div></div></p>

<h3> NOTES</h3>

<p>   Because the detached header translator dh_std_input appears before
   the Cassini Spice input translator in the default translators table, the
   descriptors are taken from the detached header if it exists.  If it doesn't
   exist, then they are obtained through the SPICE kernels.
</p>

<p>   The commented lines shows how translator keywords can be passed to
   override the keywords given in the translators table.
</p>

<p>   The keyword 'name' could be used in pg_get_planets to select only Jupiter
   and the Galilean satellites.  By default, every body that's relevant to
   the mission and can be found in the kernel list is returned.  Also, the
   SPICE translator organizes the pd array such that pd[0] gives the
   primary target of the observation, if one exists.
</p>

<p>   The keyword 'name' is used in pg_get_stars to select only the Sun.
   Otherwise, star catalog stars would also be returned.  Note, however,
   that the star catalog is still searched because it does appear in the
   translators table.
</p>

<h2> Create a generic descriptor</h2>

<p>   This line creates a "generic" descriptor.  This is a convenience
   feature wherein several descriptors are grouped into a structure that
   can be passed to functions in one piece.  The field names of a generic
   descriptor must follow the convention described in pg_description.txt:
<div><div><code class="listing"><span class="code-output"> gd = {cd:cd, gbx:pd, dkx:rd, sund:sund}</span>
</code></div></div>   cd - camera descriptor part
</p>

<p>   gbx - globe descriptor part
</p>

<p>   dkx - disk descriptor part
</p>

<p>   sund - sun descriptor part
</p>

<h2> Compute geometric features</h2>

<p>   These commands compute the limb of each planet, the edges of the Jovian ring
   system, and terminators on each planet:
<div><div><code class="listing"><span class="code-output"> limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, /rm, /disk</span>
<span class="code-output">           pg_hide, limb_ptd, /limb, gd=gd, od=sund</span>
<span class="code-output"> ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, /globe</span>
<span class="code-output"> term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, /limb</span>

<span class="code-output"> center_ptd = pg_center(gd=gd, bx=pd)</span>
<span class="code-output"> center_o=pnt_points(center_ptd[0])    ;get the center of Jupiter from the points object</span>
<span class="code-output"> print, center_o                       ;display the center of Jupiter</span>
<span class="code-output"> object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</span>
</code></div></div>   Note that terminators are computed
   using pg_limb by specifying the sun as the observer instead of the camera.
</p>

<h2> Set plot parameters</h2>

<p>   The colors, psyms, psizes and plables variables
   are defined for the plot.  The center is drawn in the default color
   (!p.color), the limb is in yellow (ctyellow) and the inner and outer ring
   are in red (ctred).  Here you can see that each ring is treated as two
   objects (inner and outer) when defining plot characteristics.  With an
   8-bit display, these color routines return the values that were previously
   reserved in the color table with ctmod; with a 24-bit display, these
   routines return the true color values for these colors.  nlimb stores the
   number of points in the limb_ptd structure, nring, the number of points in
   the ring point structure.  In plabels, the limb and ring's name is not
   plotted since it would be plotted at the center of the object:
<div><div><code class="listing"><span class="code-output"> ncent=n_elements(center_ptd)</span>
<span class="code-output"> nlimb=n_elements(limb_ptd)</span>
<span class="code-output"> nring=n_elements(ring_ptd)</span>
<span class="code-output"> nterm=n_elements(term_ptd)</span>
<span class="code-output"> colors=[make_array(n_elements(pd),value=!p.color), $</span>
<span class="code-output">         make_array(n_elements(pd),value=ctyellow()), $</span>
<span class="code-output">         make_array(2*n_elements(rd),value=ctred()), $</span>
<span class="code-output">         make_array(nterm,value=ctgreen())]</span>
<span class="code-output"> psyms=[make_array(n_elements(pd),value=1), $</span>
<span class="code-output">         make_array(n_elements(pd),value=3), $</span>
<span class="code-output">         make_array(2*n_elements(rd),value=3), $</span>
<span class="code-output">         make_array(nterm,value=3)]</span>
<span class="code-output"> psizes=1.0</span>
<span class="code-output"> csizes=0.75</span>
<span class="code-output"> plabels=[cor_name(pd), $</span>
<span class="code-output">         make_array(n_elements(pd),value=''), $</span>
<span class="code-output">         make_array(2*n_elements(rd),value=''), $</span>
<span class="code-output">         make_array(nterm,value='')]</span>
</code></div></div></p>

<h2> Draw the limb, ring and planet center</h2>

<p> <img src="jupiter_limb_initial.jpeg"/>
</p>

<p> This section draws the objects in the object array (center, limb, ring,
 and terminator) with the colors and plot symbols and labels defined earlier:
<div><div><code class="listing"><span class="code-output">   pg_draw, object_ptd, col=colors, psy=psyms, psi=psizes, csi=csizes, pl=plabels</span>
</code></div></div></p>

<h2> First-cut Automatic repointing</h2>

<p> Refine the pointing of the spacecraft by using pg_farfit, which searches
 the whole image for a pattern matching the edges calculated using the
 descriptors:
<div><div><code class="listing"><span class="code-output">   edge_ptd = pg_edges(dd, edge=10)                ; Scan image for edges.</span>
<span class="code-output">   pg_draw, edge_ptd</span>
<span class="code-output">   dxy = pg_farfit(dd, edge_ptd, [limb_ptd[0]])    ; Try to correlate scanned edges with the computed limb.</span>
<span class="code-output">   pg_repoint, dxy, 0d, axis=center_ptd[0], gd=gd  ; Change the pointing.</span>
<span class="code-output">   tvim, im</span>
<span class="code-output">   pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>

<span class="code-output">   center_ptd = pg_center(gd=gd, bx=pd)</span>
<span class="code-output">   print, 'after automatic repointing, the center was shifted by:', pnt_points(center_ptd[0])-center_o, 'pixels'</span>

</code></div></div></p>

<h2> Manually repoint the geometry</h2>

<p>   This pasteable section first clears the screen of the plotted points
   by redisplaying the image with tvim.  It then calls pg_drag to allow
   the user to use the cursor to drag the pointing, and with it the limb,
   ring and planet center.  To move the pointing with pg_drag, use the left
   mouse button and translate the pointing in x,y.  Use the middle mouse
   button to rotate the pointing about an axis (in this case, the axis of
   rotation is set as the planet center (center_ptd[0]).  When the
   desired pointing is set, the right mouse button accepts it.  pg_drag
   returns the delta x,y amount dragged (dxy) as well as the rotation
   angle (dtheta).  pg_repoint uses the dxy and dtheta to update the
   camera descriptor (cd, passed by gd).  The limb and center is then
   recalculated, the image redisplayed to clear the objects drawn, and
   then pg_draw is called to replot:
<div><div><code class="listing"><span class="code-output"> tvim, im</span>
<span class="code-output"> dxy = pg_drag(object_ptd, dtheta=dtheta, axis=center_ptd[0])    ;Do the reponting</span>
<span class="code-output"> pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd              ;Modify the general descriptor</span>

<span class="code-output"> ;Recalculate the geometry and redisplay the image with the new overlays</span>

<span class="code-output"> limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, /rm, /disk</span>
<span class="code-output">        pg_hide, limb_ptd, /limb, gd=gd, od=sund</span>
<span class="code-output"> ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, /globe</span>
<span class="code-output"> center_ptd = pg_center(gd=gd, bx=pd)</span>
<span class="code-output"> term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, /limb</span>
<span class="code-output"> object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</span>

<span class="code-output"> tvim, im</span>
<span class="code-output"> pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>
</code></div></div></p>

<h2> Scan the edge to find the limb and use it to correct the pointing using least-squares.</h2>

<p>   This section calls pg_cvscan to scan the image around the predicted
   limb position and the ring edge position (within width of 80 pixels) and
   find the points of highest correlation with a given edge model for each
   object (edge_model_nav_limb = limb model used in the VICAR program NAV
   and edge_model_nav_ring = ring model from NAV) and zeropoint offset in
   the given model (lzero).  These points are then plotted:
<div><div><code class="listing"><span class="code-output"> cvscan_ptd=pg_cvscan(dd, gd=gd, [limb_ptd[0]], edge=30, width=80, $</span>
<span class="code-output">     model=[make_array(nlimb,val=ptr_new(edge_model_nav_limb(zero=lzero)))], $</span>
<span class="code-output">     mzero=[make_array(nlimb,val=lzero)] )</span>

<span class="code-output"> ; cvscan_ptd=pg_cvscan(dd, [limb_ptd], edge=30, width=20, $</span>
<span class="code-output"> ;    model=[make_array(nlimb,val=ptr_new(edge_model_atan(10,5, zero=lzero)))], $</span>
<span class="code-output"> ;    mzero=[make_array(nlimb,val=lzero)] )</span>

<span class="code-output"> tvim, im</span>
<span class="code-output"> pg_draw, cvscan_ptd</span>
</code></div></div>   The commented command might be more appropriate for images in which
   the planet disk is quite small.  In that case, we use a different edge
   model (because the nav model cannot be scaled) and we scan a much
   narrower region.
</p>

<h2> Threshold on correlation coefficient</h2>

<p>   This section calls pg_threshold to remove points with
   unacceptable correlation coefficients.  The /relative flag means that
   the minimum and maximum thresholds are taken as a fraction of the maximum
   correlation coefficient for each set of points. In this case we use a minimun
   correlation coefficent of 0.81 and a maximum of 1.0:
<div><div><code class="listing"><span class="code-output"> pg_threshold, cvscan_ptd, min=0.81, max=1.0, /rel</span>
<span class="code-output"> tvim, im</span>
<span class="code-output"> pg_draw, cvscan_ptd</span>
</code></div></div></p>

<h2> Removing regions of bad scan points</h2>

<p>   This pasteable section calls pg_select to remove points within a
   polygonal region as defined by the cursor.  Click the left mouse
   button to mark a point and move the mouse to the next point and
   click.  Use the middle mouse button to erase a point and the right
   mouse button to end the region.  pg_trim removes the points in the
   just defined region.  The scan points are then replotted.
   Repeat these statements for each region a user wants to remove:
<div><div><code class="listing"><span class="code-output"> region = pg_select(dd)</span>
<span class="code-output"> pg_trim, dd, cvscan_ptd, region</span>
<span class="code-output"> tvim, im</span>
<span class="code-output"> pg_draw, cvscan_ptd</span>
</code></div></div></p>

<h2> Fit the pointing to the scanned points using least squares</h2>

<p>   This section calls pg_cvscan_coeff to determine the linear least-squares
   coefficients for a fit to the image coordinate translation and rotation
   that matches the computed curve to the scanned curve. It then calls
   pg_fit to do the fit with the calculated coefficients to calculate the
   correction in translation (dxy) and rotation (dtheta).  It calls
   pg_cvchisq to get the chi square of the fit.  Then calls pg_repoint to
   update the pointing. Recalculates the limb and center and replots.
   The determination of the curves and their subsequent fit can be
   iterated on.
</p>

<p>   Note that, as shown, dx, dy, and dtheta are fit.  To fix any of these
   parameters use the 'fix' keyword to pg_cvscan_coeff.  For example
   with 'fix=2', dtheta will be zero:
<div><div><code class="listing"><span class="code-output"> fix = [2]</span>
<span class="code-output"> cvscan_cf = pg_cvscan_coeff(cvscan_ptd, axis=center_ptd[0], fix=fix)</span>
<span class="code-output"> dxy = pg_fit([cvscan_cf], dtheta=dtheta)</span>
<span class="code-output"> chisq = pg_chisq(dxy, dtheta, cvscan_ptd, axis=center_ptd[0], fix=fix)</span>
<span class="code-output"> covar = pg_covariance([cvscan_cf])</span>
<span class="code-output"> print, dxy, dtheta*180./!pi, chisq, covar</span>
<span class="code-output"> pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd</span>

<span class="code-output"> limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, /rm, /disk</span>
<span class="code-output">         pg_hide, limb_ptd, /limb, gd=gd, od=sund</span>
<span class="code-output"> ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, /globe</span>
<span class="code-output"> center_ptd = pg_center(gd=gd, bx=pd)</span>
<span class="code-output"> term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, /limb</span>
<span class="code-output"> object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</span>

<span class="code-output"> tvim, im</span>
<span class="code-output"> pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>
</code></div></div></p>

<h2> Draw planet and ring latitude/longitude grid</h2>

<p> <img src="jupiter_lat_lon.jpeg"/>
</p>

<p>   This sections calculates a latitude/longitude grid for each planet and a
   radius/longitude grid for the rings.  By default it draws 12 latitude
   and 12 longitude grid lines.  The longitude grid lines circle the body
   and so on a map they will appear as 24 grid lines.  The ring radius grid
   uses four grid lines by default between the inner and outer ring radius.
   It uses pg_hide to set as not visible the points on the grid behind the
   planet and ring for both objects.  It then uses pg_draw to draw the
   grid points in blue (ctblue):
<div><div><code class="listing"><span class="code-output"> grid_ptd = pg_grid(gd=gd, lat=lat, lon=lon)</span>
<span class="code-output"> pg_hide, grid_ptd, cd=cd, gbx=pd, /limb</span>
<span class="code-output"> pg_hide, grid_ptd, cd=cd, gbx=pd, od=sund, /limb</span>
<span class="code-output"> pg_hide, grid_ptd, gd=gd, /disk</span>
<span class="code-output"> pg_draw, grid_ptd, color=ctblue()</span>

<span class="code-output"> plat_ptd = pg_grid(gd=gd, slon=!dpi/2d, lat=lat, nlon=0)</span>
<span class="code-output"> pg_hide, plat_ptd[0], cd=cd, gbx=pd[0], /limb</span>
<span class="code-output"> pg_draw, plat_ptd[0], psym=3, plabel=strtrim(round(lat*180d/!dpi),2), /label_p</span>

<span class="code-output"> plon_ptd = pg_grid(gd=gd, slat=0d, lon=lon, nlat=0)</span>
<span class="code-output"> pg_hide, plon_ptd[0], cd=cd, gbx=pd[0], /limb</span>
<span class="code-output"> pg_draw, plon_ptd[0], psym=3, plabel=strtrim(round(lon*180d/!dpi),2), /label_p</span>

<span class="code-output"> dgrid_ptd=pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, /globe</span>
<span class="code-output"> pg_draw, dgrid_ptd, color=ctpurple()</span>
</code></div></div></p>

<h2> Generate map projections</h2>

<p>   This section defines a map descriptor for a simple cylindrical projection
   using pg_get_maps.  It then calls pg_map to create a map projection and
   uses tvim to display it in a new window.  Four different map descriptors
   are demonstrated.
</p>

<p>   We also call pg_grid to calculate a latitude/longitude grid on the map and
   then pg_draw to draw the grid in green. For convenience, define a new generic descriptor.
   Note that the map descriptor is used for the cd field. Call pg_limb to calculate the limb
   on the map and then pg_draw to draw the grid in purple.
</p>

<h3> Mercator</h3>

<p>   Map descriptor:
<div><div><code class="listing"><span class="code-output"> md = pg_get_maps(/over, bx=pd[0], $</span>
<span class="code-output">   type='MERCATOR', $</span>
<span class="code-output">   ;type='MOLLWEIDE', $</span>
<span class="code-output">   fn_data=ptr_new(), $</span>
<span class="code-output">   size=[800,400] $</span>
<span class="code-output">   )</span>

</code></div></div> <img src="jupiter_mercator.jpeg"/>
</p>

<h3> Stereographic</h3>

<p>   Map descriptor:
<div><div><code class="listing"><span class="code-output"> md = pg_get_maps(/over, bx=pd[0], $</span>
<span class="code-output">   type='STEREOGRAPHIC', $</span>
<span class="code-output">   fn_data=ptr_new(), $</span>
<span class="code-output">   scale=0.5, $</span>
<span class="code-output">   size=[800,800], $</span>
<span class="code-output">   center=[!dpi/2d,0d] $</span>
<span class="code-output">   )</span>

</code></div></div> <img src="jupiter_stereographic.jpeg"/>
</p>

<h3> Orthographic</h3>

<p>   Map descriptor:
<div><div><code class="listing"><span class="code-output"> md = pg_get_maps(/over, bx=pd[0], $</span>
<span class="code-output">   type='ORTHOGRAPHIC', $</span>
<span class="code-output">   fn_data=ptr_new(), $</span>
<span class="code-output">   size=[800,800], $</span>
<span class="code-output">   center=[!dpi/6d,!dpi] $</span>
<span class="code-output">   ;center=[!dpi/2d,0] $  ; north polar</span>
<span class="code-output">   ;center=[-!dpi/2d,0] $ ; south polar</span>
<span class="code-output">   )</span>

</code></div></div> <img src="jupiter_orthographic.jpeg"/>
</p>

<h3> Rectangular</h3>

<p>   Map descriptor:
<div><div><code class="listing"><span class="code-output"> md = pg_get_maps(/over, bx=pd[0], $</span>
<span class="code-output">   type='RECTANGULAR', $</span>
<span class="code-output">   /graphic,  $</span>
<span class="code-output">   fn_data=ptr_new(), $</span>
<span class="code-output">   scale=1.0, $</span>
<span class="code-output">   ;center=[0d,!dpi],$</span>
<span class="code-output">   size=[800,400] $</span>
<span class="code-output">   )</span>

</code></div></div> <img src="jupiter_rectangular.jpeg"/>
</p>

<p></p>

<h3> Projecting the maps</h3>

<p>   Use the pg_map and the map descriptor to project the image onto a map.
   Certain regions, such as rings, could be excluded from the projection
   and ounds on the map can be set, if desired:
<div><div><code class="listing"><span class="code-output"> ;to set projection bounds...</span>
<span class="code-output"> ;bounds = [-30,30,-180,180]*!dpi/180d</span>

<span class="code-output"> map = 0</span>
<span class="code-output"> dd_map = pg_map(dd, md=md, gd=gd, bx=pd[0], map=map, bounds=bounds)</span>

<span class="code-output"> ; to exclude areas covered by rings...</span>
<span class="code-output"> ;dd_map = pg_map(dd, md=md, gd=gd, bx=pd[0], gbx=pd[0], $</span>
<span class="code-output"> ;          hide_fn='pm_hide_ring', hide_data_p=ptr_new(rd), map=map, bounds=bounds)</span>

<span class="code-output"> tvim, /new, map</span>
</code></div></div>   Call pg_grid to calculate a latitude/longitude grid on the map and
   then pg_draw to draw the grid in green.
</p>

<p>   For convenience, define a new generic descriptor.  Note that the map
   descriptor is used for the cd field:
<div><div><code class="listing"><span class="code-output"> gdm={cd:md, od:cd, gbx:cor_select(pd,'JUPITER'), dkx:rd}</span>

<span class="code-output"> map_grid_ptd = pg_grid(gd=gdm, lat=lat, lon=lon)</span>
<span class="code-output"> plat_ptd = pg_grid(gd=gdm, slon=!dpi/2d, lat=lat, nlon=0)</span>
<span class="code-output"> plon_ptd = pg_grid(gd=gdm, slat=0d, lon=lon, nlat=0)</span>

<span class="code-output"> pg_draw, map_grid_ptd, col=ctgreen()</span>
<span class="code-output"> pg_draw, plat_ptd, psym=7, plabel=strmid(strtrim(lat*180d/!dpi,2),0,3), /label_p</span>
<span class="code-output"> pg_draw, plon_ptd, psym=7, plabel=strmid(strtrim(lon*180d/!dpi,2),0,3), /label_p</span>
</code></div></div>   Call pg_limb to calculate the limb on the map and then pg_draw to
   draw the grid in purple:
<div><div><code class="listing"><span class="code-output"> map_limb_ptd = pg_limb(gd=gdm)</span>
<span class="code-output"> pg_draw, map_limb_ptd, col=ctred()</span>

<span class="code-output"> map_term_ptd = pg_limb(gd=gdm, od=sund)</span>
<span class="code-output"> pg_draw, map_term_ptd, col=ctyellow()</span>
</code></div></div></p>

<h2> Reproject the previous map</h2>

<p>   A map can be reprojected using a second map descriptor
   and the original map descriptor as the camera descriptor:
<div><div><code class="listing"><span class="code-output"> md1 = pg_get_maps(/over, bx=pd[0], $</span>
<span class="code-output">   type='ORTHOGRAPHIC', $</span>
<span class="code-output">   ;type='STEREOGRAPHIC', $</span>
<span class="code-output">   fn_data=ptr_new(), $</span>
<span class="code-output">   size=[800,800], $</span>
<span class="code-output">   center=[!dpi/6d,!dpi] $</span>
<span class="code-output">   )</span>

<span class="code-output"> map=0</span>
<span class="code-output"> dd_map1 = pg_map(dd_map, md=md1, cd=md, map=map1, bounds=bounds)</span>
<span class="code-output"> tvim, /new, map1</span>

</code></div></div> <img src="jupiter_rectangular_to_ortho.jpeg"/>
</p>

<p></p>

<h2> Output the new state</h2>

<p>   This section shows how you can save your output.
</p>

<h3> Output descriptors</h3>

<p>   These commands write the descriptor information out through the
   translators.  The exact behavior is translator-dependent.  The detached
   header translator just modifies the detached header (stored in the data
   descriptor).  The SPICE output translator writes a C-kernel if a file
   name is specified using the ck_out translator keyword (as in the commented
   line):
<div><div><code class="listing"><span class="code-output"> pg_put_rings, dd, od=gd.cd, rd=rd</span>
<span class="code-output"> pg_put_planets, dd, od=gd.cd, pd=pd</span>
<span class="code-output"> pg_put_cameras, dd, gd=gd</span>
<span class="code-output"> ; cor_set_udata, cd, 'CK_COMMENT', 'This is a comment.'</span>
<span class="code-output"> ; pg_put_cameras, dd, gd=gd, 'ck_out=./test.bc'</span>
<span class="code-output"> ; print, spice_daf_comment('./test.bc')</span>
<span class="code-output"> pg_put_stars, dd, sd=sund, od=gd.cd</span>

</code></div></div></p>

<h3> Write image file and header</h3>

<p>   dat_write writes the image file from the data descriptor.  The detached header
   is also written into a file with the same name as the image file except with
   the extension '.dh'.  If this file does not already exist, it is created:
<div><div><code class="listing"><span class="code-output"> split_filename, file, dir, name</span>
<span class="code-output"> dat_write, './data/' + name, dd</span>
</code></div></div></p>

<h3> Write map file and header</h3>

<p>   pg_put_maps causes the detached header translator to generate a new detached
   header and write the map descriptor into it.
</p>

<p>   As above, dat_write writes the map image file and the detached header. Notice
   that the filetype is given explicitly because the data descriptor was not
   created by dat_read, which would have detected the filetype:
<div><div><code class="listing"><span class="code-output"> pg_put_maps, dd_map, md=md</span>

<span class="code-output"> split_filename, file, dir, name</span>
<span class="code-output"> dat_write, './data/' + name + '.map', dd_map, filetype = 'VICAR'</span>
</code></div></div>   To read the new map file, use dat_read just as the image file was read at the
   beginning of this example script.  To read the map descriptor from the
   detached header, use:
<div><div><code class="listing"><span class="code-output"> md = pg_get_maps(dd_map)</span>
</code></div></div></p>

</div>
      </div>
      

      

      

      

      

      

      

      

      

      

      <div id="attributes">
        <h2>File attributes</h2>

        <table class="attribute small" summary="File attributes">
          <tr>
            <td class="name">Modification date:</td>
            <td>Tue Oct 11 10:03:12 2016</td>
          </tr>

          <tr>
            <td class="name">Lines:</td>
            <td>152</td>
          </tr>

          
          <tr>
            <td class="name">Docformat:</td>
            <td>rst rst</td>
          </tr>
          
        </table>
      </div>

      
    </div>

    <div class="footer">
    
      <table class="smaller" summary="footer">
        <tr>
          <td class="left">Produced by IDLdoc 3.6.1 on Thu Oct 13 10:41:45 2016</td>
          <td class="right"><a target="_top" href="http://github.com/mgalloy/idldoc">IDLdoc project information</a></td>
        </tr>
      </table>
    
    </div>
  </body>
</html>